'use strict';
var Zq = Object.create;
var Yl = Object.defineProperty;
var Qq = Object.getOwnPropertyDescriptor;
var eB = Object.getOwnPropertyNames;
var tB = Object.getPrototypeOf,
  iB = Object.prototype.hasOwnProperty;
var te = (t, e) => () => (t && (e = t((t = 0))), e);
var P = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports),
  Ft = (t, e) => {
    for (var i in e) Yl(t, i, { get: e[i], enumerable: !0 });
  },
  lS = (t, e, i, n) => {
    if ((e && typeof e == 'object') || typeof e == 'function')
      for (let r of eB(e))
        !iB.call(t, r) && r !== i && Yl(t, r, { get: () => e[r], enumerable: !(n = Qq(e, r)) || n.enumerable });
    return t;
  };
var je = (t, e, i) => (
    (i = t != null ? Zq(tB(t)) : {}),
    lS(e || !t || !t.__esModule ? Yl(i, 'default', { value: t, enumerable: !0 }) : i, t)
  ),
  Ke = (t) => lS(Yl({}, '__esModule', { value: !0 }), t);
function Fr() {
  return (
    process.env.CI === 'true' ||
    process.env.TF_BUILD === 'true' ||
    process.env.GITHUB_ACTIONS === 'true' ||
    process.env.BUILDKITE === 'true' ||
    process.env.CIRCLECI === 'true' ||
    process.env.CIRRUS_CI === 'true' ||
    process.env.TRAVIS === 'true' ||
    !!process.env['bamboo.buildKey'] ||
    !!process.env.CODEBUILD_BUILD_ID ||
    !!process.env.GITLAB_CI ||
    !!process.env.HEROKU_TEST_RUN_ID ||
    !!process.env.BUILD_ID ||
    !!process.env.BUILD_BUILDID ||
    !!process.env.TEAMCITY_VERSION
  );
}
var Jl = te(() => {
  'use strict';
});
var hS = P((Hne, Am) => {
  'use strict';
  var nB = require('fs'),
    pS = require('path'),
    rB = require('os');
  function fS(t) {
    console.log(`[dotenv][DEBUG] ${t}`);
  }
  var sB = `
`,
    oB = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/,
    aB = /\\n/g,
    cB = /\r\n|\n|\r/;
  function dS(t, e) {
    let i = !!(e && e.debug),
      n = {};
    return (
      t
        .toString()
        .split(cB)
        .forEach(function (r, s) {
          let o = r.match(oB);
          if (o != null) {
            let c = o[1],
              u = o[2] || '',
              l = u.length - 1,
              p = u[0] === '"' && u[l] === '"';
            (u[0] === "'" && u[l] === "'") || p
              ? ((u = u.substring(1, l)), p && (u = u.replace(aB, sB)))
              : (u = u.trim()),
              (n[c] = u);
          } else i && fS(`did not match key and value when parsing line ${s + 1}: ${r}`);
        }),
      n
    );
  }
  function uB(t) {
    return t[0] === '~' ? pS.join(rB.homedir(), t.slice(1)) : t;
  }
  function lB(t) {
    let e = pS.resolve(process.cwd(), '.env'),
      i = 'utf8',
      n = !1;
    t && (t.path != null && (e = uB(t.path)), t.encoding != null && (i = t.encoding), t.debug != null && (n = !0));
    try {
      let r = dS(nB.readFileSync(e, { encoding: i }), { debug: n });
      return (
        Object.keys(r).forEach(function (s) {
          Object.prototype.hasOwnProperty.call(process.env, s)
            ? n && fS(`"${s}" is already defined in \`process.env\` and will not be overwritten`)
            : (process.env[s] = r[s]);
        }),
        { parsed: r }
      );
    } catch (r) {
      return { error: r };
    }
  }
  Am.exports.config = lB;
  Am.exports.parse = dS;
});
var mS = P((Nc, Im) => {
  'use strict';
  (function (t, e) {
    typeof Nc == 'object' && typeof Im == 'object'
      ? (Im.exports = e(require('child_process'), require('crypto')))
      : typeof define == 'function' && define.amd
      ? define(['child_process', 'crypto'], e)
      : typeof Nc == 'object'
      ? (Nc['electron-machine-id'] = e(require('child_process'), require('crypto')))
      : (t['electron-machine-id'] = e(t.child_process, t.crypto));
  })(Nc, function (t, e) {
    return (function (i) {
      function n(s) {
        if (r[s]) return r[s].exports;
        var o = (r[s] = { exports: {}, id: s, loaded: !1 });
        return i[s].call(o.exports, o, o.exports, n), (o.loaded = !0), o.exports;
      }
      var r = {};
      return (n.m = i), (n.c = r), (n.p = ''), n(0);
    })([
      function (i, n, r) {
        i.exports = r(34);
      },
      function (i, n, r) {
        var s = r(29)('wks'),
          o = r(33),
          c = r(2).Symbol,
          u = typeof c == 'function',
          l = (i.exports = function (p) {
            return s[p] || (s[p] = (u && c[p]) || (u ? c : o)('Symbol.' + p));
          });
        l.store = s;
      },
      function (i, n) {
        var r = (i.exports =
          typeof window < 'u' && window.Math == Math
            ? window
            : typeof self < 'u' && self.Math == Math
            ? self
            : Function('return this')());
        typeof __g == 'number' && (__g = r);
      },
      function (i, n, r) {
        var s = r(9);
        i.exports = function (o) {
          if (!s(o)) throw TypeError(o + ' is not an object!');
          return o;
        };
      },
      function (i, n, r) {
        i.exports = !r(24)(function () {
          return (
            Object.defineProperty({}, 'a', {
              get: function () {
                return 7;
              },
            }).a != 7
          );
        });
      },
      function (i, n, r) {
        var s = r(12),
          o = r(17);
        i.exports = r(4)
          ? function (c, u, l) {
              return s.f(c, u, o(1, l));
            }
          : function (c, u, l) {
              return (c[u] = l), c;
            };
      },
      function (i, n) {
        var r = (i.exports = { version: '2.4.0' });
        typeof __e == 'number' && (__e = r);
      },
      function (i, n, r) {
        var s = r(14);
        i.exports = function (o, c, u) {
          if ((s(o), c === void 0)) return o;
          switch (u) {
            case 1:
              return function (l) {
                return o.call(c, l);
              };
            case 2:
              return function (l, p) {
                return o.call(c, l, p);
              };
            case 3:
              return function (l, p, d) {
                return o.call(c, l, p, d);
              };
          }
          return function () {
            return o.apply(c, arguments);
          };
        };
      },
      function (i, n) {
        var r = {}.hasOwnProperty;
        i.exports = function (s, o) {
          return r.call(s, o);
        };
      },
      function (i, n) {
        i.exports = function (r) {
          return typeof r == 'object' ? r !== null : typeof r == 'function';
        };
      },
      function (i, n) {
        i.exports = {};
      },
      function (i, n) {
        var r = {}.toString;
        i.exports = function (s) {
          return r.call(s).slice(8, -1);
        };
      },
      function (i, n, r) {
        var s = r(3),
          o = r(26),
          c = r(32),
          u = Object.defineProperty;
        n.f = r(4)
          ? Object.defineProperty
          : function (l, p, d) {
              if ((s(l), (p = c(p, !0)), s(d), o))
                try {
                  return u(l, p, d);
                } catch {}
              if ('get' in d || 'set' in d) throw TypeError('Accessors not supported!');
              return 'value' in d && (l[p] = d.value), l;
            };
      },
      function (i, n, r) {
        var s = r(42),
          o = r(15);
        i.exports = function (c) {
          return s(o(c));
        };
      },
      function (i, n) {
        i.exports = function (r) {
          if (typeof r != 'function') throw TypeError(r + ' is not a function!');
          return r;
        };
      },
      function (i, n) {
        i.exports = function (r) {
          if (r == null) throw TypeError("Can't call method on  " + r);
          return r;
        };
      },
      function (i, n, r) {
        var s = r(9),
          o = r(2).document,
          c = s(o) && s(o.createElement);
        i.exports = function (u) {
          return c ? o.createElement(u) : {};
        };
      },
      function (i, n) {
        i.exports = function (r, s) {
          return { enumerable: !(1 & r), configurable: !(2 & r), writable: !(4 & r), value: s };
        };
      },
      function (i, n, r) {
        var s = r(12).f,
          o = r(8),
          c = r(1)('toStringTag');
        i.exports = function (u, l, p) {
          u && !o((u = p ? u : u.prototype), c) && s(u, c, { configurable: !0, value: l });
        };
      },
      function (i, n, r) {
        var s = r(29)('keys'),
          o = r(33);
        i.exports = function (c) {
          return s[c] || (s[c] = o(c));
        };
      },
      function (i, n) {
        var r = Math.ceil,
          s = Math.floor;
        i.exports = function (o) {
          return isNaN((o = +o)) ? 0 : (o > 0 ? s : r)(o);
        };
      },
      function (i, n, r) {
        var s = r(11),
          o = r(1)('toStringTag'),
          c =
            s(
              (function () {
                return arguments;
              })()
            ) == 'Arguments',
          u = function (l, p) {
            try {
              return l[p];
            } catch {}
          };
        i.exports = function (l) {
          var p, d, x;
          return l === void 0
            ? 'Undefined'
            : l === null
            ? 'Null'
            : typeof (d = u((p = Object(l)), o)) == 'string'
            ? d
            : c
            ? s(p)
            : (x = s(p)) == 'Object' && typeof p.callee == 'function'
            ? 'Arguments'
            : x;
        };
      },
      function (i, n) {
        i.exports =
          'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
      },
      function (i, n, r) {
        var s = r(2),
          o = r(6),
          c = r(7),
          u = r(5),
          l = 'prototype',
          p = function (d, x, b) {
            var g,
              y,
              h,
              v = d & p.F,
              C = d & p.G,
              _ = d & p.S,
              m = d & p.P,
              O = d & p.B,
              N = d & p.W,
              D = C ? o : o[x] || (o[x] = {}),
              z = D[l],
              H = C ? s : _ ? s[x] : (s[x] || {})[l];
            C && (b = x);
            for (g in b)
              (y = !v && H && H[g] !== void 0),
                (y && g in D) ||
                  ((h = y ? H[g] : b[g]),
                  (D[g] =
                    C && typeof H[g] != 'function'
                      ? b[g]
                      : O && y
                      ? c(h, s)
                      : N && H[g] == h
                      ? (function (F) {
                          var ne = function (pe, le, V) {
                            if (this instanceof F) {
                              switch (arguments.length) {
                                case 0:
                                  return new F();
                                case 1:
                                  return new F(pe);
                                case 2:
                                  return new F(pe, le);
                              }
                              return new F(pe, le, V);
                            }
                            return F.apply(this, arguments);
                          };
                          return (ne[l] = F[l]), ne;
                        })(h)
                      : m && typeof h == 'function'
                      ? c(Function.call, h)
                      : h),
                  m && (((D.virtual || (D.virtual = {}))[g] = h), d & p.R && z && !z[g] && u(z, g, h)));
          };
        (p.F = 1), (p.G = 2), (p.S = 4), (p.P = 8), (p.B = 16), (p.W = 32), (p.U = 64), (p.R = 128), (i.exports = p);
      },
      function (i, n) {
        i.exports = function (r) {
          try {
            return !!r();
          } catch {
            return !0;
          }
        };
      },
      function (i, n, r) {
        i.exports = r(2).document && document.documentElement;
      },
      function (i, n, r) {
        i.exports =
          !r(4) &&
          !r(24)(function () {
            return (
              Object.defineProperty(r(16)('div'), 'a', {
                get: function () {
                  return 7;
                },
              }).a != 7
            );
          });
      },
      function (i, n, r) {
        'use strict';
        var s = r(28),
          o = r(23),
          c = r(57),
          u = r(5),
          l = r(8),
          p = r(10),
          d = r(45),
          x = r(18),
          b = r(52),
          g = r(1)('iterator'),
          y = !([].keys && 'next' in [].keys()),
          h = '@@iterator',
          v = 'keys',
          C = 'values',
          _ = function () {
            return this;
          };
        i.exports = function (m, O, N, D, z, H, F) {
          d(N, O, D);
          var ne,
            pe,
            le,
            V = function (oe) {
              if (!y && oe in B) return B[oe];
              switch (oe) {
                case v:
                  return function () {
                    return new N(this, oe);
                  };
                case C:
                  return function () {
                    return new N(this, oe);
                  };
              }
              return function () {
                return new N(this, oe);
              };
            },
            W = O + ' Iterator',
            K = z == C,
            q = !1,
            B = m.prototype,
            ee = B[g] || B[h] || (z && B[z]),
            xe = ee || V(z),
            de = z ? (K ? V('entries') : xe) : void 0,
            Z = (O == 'Array' && B.entries) || ee;
          if (
            (Z && ((le = b(Z.call(new m()))), le !== Object.prototype && (x(le, W, !0), s || l(le, g) || u(le, g, _))),
            K &&
              ee &&
              ee.name !== C &&
              ((q = !0),
              (xe = function () {
                return ee.call(this);
              })),
            (s && !F) || (!y && !q && B[g]) || u(B, g, xe),
            (p[O] = xe),
            (p[W] = _),
            z)
          )
            if (((ne = { values: K ? xe : V(C), keys: H ? xe : V(v), entries: de }), F))
              for (pe in ne) pe in B || c(B, pe, ne[pe]);
            else o(o.P + o.F * (y || q), O, ne);
          return ne;
        };
      },
      function (i, n) {
        i.exports = !0;
      },
      function (i, n, r) {
        var s = r(2),
          o = '__core-js_shared__',
          c = s[o] || (s[o] = {});
        i.exports = function (u) {
          return c[u] || (c[u] = {});
        };
      },
      function (i, n, r) {
        var s,
          o,
          c,
          u = r(7),
          l = r(41),
          p = r(25),
          d = r(16),
          x = r(2),
          b = x.process,
          g = x.setImmediate,
          y = x.clearImmediate,
          h = x.MessageChannel,
          v = 0,
          C = {},
          _ = 'onreadystatechange',
          m = function () {
            var N = +this;
            if (C.hasOwnProperty(N)) {
              var D = C[N];
              delete C[N], D();
            }
          },
          O = function (N) {
            m.call(N.data);
          };
        (g && y) ||
          ((g = function (N) {
            for (var D = [], z = 1; arguments.length > z; ) D.push(arguments[z++]);
            return (
              (C[++v] = function () {
                l(typeof N == 'function' ? N : Function(N), D);
              }),
              s(v),
              v
            );
          }),
          (y = function (N) {
            delete C[N];
          }),
          r(11)(b) == 'process'
            ? (s = function (N) {
                b.nextTick(u(m, N, 1));
              })
            : h
            ? ((o = new h()), (c = o.port2), (o.port1.onmessage = O), (s = u(c.postMessage, c, 1)))
            : x.addEventListener && typeof postMessage == 'function' && !x.importScripts
            ? ((s = function (N) {
                x.postMessage(N + '', '*');
              }),
              x.addEventListener('message', O, !1))
            : (s =
                _ in d('script')
                  ? function (N) {
                      p.appendChild(d('script'))[_] = function () {
                        p.removeChild(this), m.call(N);
                      };
                    }
                  : function (N) {
                      setTimeout(u(m, N, 1), 0);
                    })),
          (i.exports = { set: g, clear: y });
      },
      function (i, n, r) {
        var s = r(20),
          o = Math.min;
        i.exports = function (c) {
          return c > 0 ? o(s(c), 9007199254740991) : 0;
        };
      },
      function (i, n, r) {
        var s = r(9);
        i.exports = function (o, c) {
          if (!s(o)) return o;
          var u, l;
          if (
            (c && typeof (u = o.toString) == 'function' && !s((l = u.call(o)))) ||
            (typeof (u = o.valueOf) == 'function' && !s((l = u.call(o)))) ||
            (!c && typeof (u = o.toString) == 'function' && !s((l = u.call(o))))
          )
            return l;
          throw TypeError("Can't convert object to primitive value");
        };
      },
      function (i, n) {
        var r = 0,
          s = Math.random();
        i.exports = function (o) {
          return 'Symbol('.concat(o === void 0 ? '' : o, ')_', (++r + s).toString(36));
        };
      },
      function (i, n, r) {
        'use strict';
        function s(_) {
          return _ && _.__esModule ? _ : { default: _ };
        }
        function o() {
          return process.platform !== 'win32'
            ? ''
            : process.arch === 'ia32' && process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')
            ? 'mixed'
            : 'native';
        }
        function c(_) {
          return (0, g.createHash)('sha256').update(_).digest('hex');
        }
        function u(_) {
          switch (h) {
            case 'darwin':
              return _.split('IOPlatformUUID')[1]
                .split(
                  `
`
                )[0]
                .replace(/\=|\s+|\"/gi, '')
                .toLowerCase();
            case 'win32':
              return _.toString()
                .split('REG_SZ')[1]
                .replace(/\r+|\n+|\s+/gi, '')
                .toLowerCase();
            case 'linux':
              return _.toString()
                .replace(/\r+|\n+|\s+/gi, '')
                .toLowerCase();
            case 'freebsd':
              return _.toString()
                .replace(/\r+|\n+|\s+/gi, '')
                .toLowerCase();
            default:
              throw new Error('Unsupported platform: ' + process.platform);
          }
        }
        function l(_) {
          var m = u((0, b.execSync)(C[h]).toString());
          return _ ? m : c(m);
        }
        function p(_) {
          return new x.default(function (m, O) {
            return (0, b.exec)(C[h], {}, function (N, D, z) {
              if (N) return O(new Error('Error while obtaining machine id: ' + N.stack));
              var H = u(D.toString());
              return m(_ ? H : c(H));
            });
          });
        }
        Object.defineProperty(n, '__esModule', { value: !0 });
        var d = r(35),
          x = s(d);
        (n.machineIdSync = l), (n.machineId = p);
        var b = r(70),
          g = r(71),
          y = process,
          h = y.platform,
          v = { native: '%windir%\\System32', mixed: '%windir%\\sysnative\\cmd.exe /c %windir%\\System32' },
          C = {
            darwin: 'ioreg -rd1 -c IOPlatformExpertDevice',
            win32: v[o()] + '\\REG.exe QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid',
            linux: '( cat /var/lib/dbus/machine-id /etc/machine-id 2> /dev/null || hostname ) | head -n 1 || :',
            freebsd: 'kenv -q smbios.system.uuid || sysctl -n kern.hostuuid',
          };
      },
      function (i, n, r) {
        i.exports = { default: r(36), __esModule: !0 };
      },
      function (i, n, r) {
        r(66), r(68), r(69), r(67), (i.exports = r(6).Promise);
      },
      function (i, n) {
        i.exports = function () {};
      },
      function (i, n) {
        i.exports = function (r, s, o, c) {
          if (!(r instanceof s) || (c !== void 0 && c in r)) throw TypeError(o + ': incorrect invocation!');
          return r;
        };
      },
      function (i, n, r) {
        var s = r(13),
          o = r(31),
          c = r(62);
        i.exports = function (u) {
          return function (l, p, d) {
            var x,
              b = s(l),
              g = o(b.length),
              y = c(d, g);
            if (u && p != p) {
              for (; g > y; ) if (((x = b[y++]), x != x)) return !0;
            } else for (; g > y; y++) if ((u || y in b) && b[y] === p) return u || y || 0;
            return !u && -1;
          };
        };
      },
      function (i, b, r) {
        var s = r(7),
          o = r(44),
          c = r(43),
          u = r(3),
          l = r(31),
          p = r(64),
          d = {},
          x = {},
          b = (i.exports = function (g, y, h, v, C) {
            var _,
              m,
              O,
              N,
              D = C
                ? function () {
                    return g;
                  }
                : p(g),
              z = s(h, v, y ? 2 : 1),
              H = 0;
            if (typeof D != 'function') throw TypeError(g + ' is not iterable!');
            if (c(D)) {
              for (_ = l(g.length); _ > H; H++)
                if (((N = y ? z(u((m = g[H]))[0], m[1]) : z(g[H])), N === d || N === x)) return N;
            } else
              for (O = D.call(g); !(m = O.next()).done; ) if (((N = o(O, z, m.value, y)), N === d || N === x)) return N;
          });
        (b.BREAK = d), (b.RETURN = x);
      },
      function (i, n) {
        i.exports = function (r, s, o) {
          var c = o === void 0;
          switch (s.length) {
            case 0:
              return c ? r() : r.call(o);
            case 1:
              return c ? r(s[0]) : r.call(o, s[0]);
            case 2:
              return c ? r(s[0], s[1]) : r.call(o, s[0], s[1]);
            case 3:
              return c ? r(s[0], s[1], s[2]) : r.call(o, s[0], s[1], s[2]);
            case 4:
              return c ? r(s[0], s[1], s[2], s[3]) : r.call(o, s[0], s[1], s[2], s[3]);
          }
          return r.apply(o, s);
        };
      },
      function (i, n, r) {
        var s = r(11);
        i.exports = Object('z').propertyIsEnumerable(0)
          ? Object
          : function (o) {
              return s(o) == 'String' ? o.split('') : Object(o);
            };
      },
      function (i, n, r) {
        var s = r(10),
          o = r(1)('iterator'),
          c = Array.prototype;
        i.exports = function (u) {
          return u !== void 0 && (s.Array === u || c[o] === u);
        };
      },
      function (i, n, r) {
        var s = r(3);
        i.exports = function (o, c, u, l) {
          try {
            return l ? c(s(u)[0], u[1]) : c(u);
          } catch (d) {
            var p = o.return;
            throw (p !== void 0 && s(p.call(o)), d);
          }
        };
      },
      function (i, n, r) {
        'use strict';
        var s = r(49),
          o = r(17),
          c = r(18),
          u = {};
        r(5)(u, r(1)('iterator'), function () {
          return this;
        }),
          (i.exports = function (l, p, d) {
            (l.prototype = s(u, { next: o(1, d) })), c(l, p + ' Iterator');
          });
      },
      function (i, n, r) {
        var s = r(1)('iterator'),
          o = !1;
        try {
          var c = [7][s]();
          (c.return = function () {
            o = !0;
          }),
            Array.from(c, function () {
              throw 2;
            });
        } catch {}
        i.exports = function (u, l) {
          if (!l && !o) return !1;
          var p = !1;
          try {
            var d = [7],
              x = d[s]();
            (x.next = function () {
              return { done: (p = !0) };
            }),
              (d[s] = function () {
                return x;
              }),
              u(d);
          } catch {}
          return p;
        };
      },
      function (i, n) {
        i.exports = function (r, s) {
          return { value: s, done: !!r };
        };
      },
      function (i, n, r) {
        var s = r(2),
          o = r(30).set,
          c = s.MutationObserver || s.WebKitMutationObserver,
          u = s.process,
          l = s.Promise,
          p = r(11)(u) == 'process';
        i.exports = function () {
          var d,
            x,
            b,
            g = function () {
              var C, _;
              for (p && (C = u.domain) && C.exit(); d; ) {
                (_ = d.fn), (d = d.next);
                try {
                  _();
                } catch (m) {
                  throw (d ? b() : (x = void 0), m);
                }
              }
              (x = void 0), C && C.enter();
            };
          if (p)
            b = function () {
              u.nextTick(g);
            };
          else if (c) {
            var y = !0,
              h = document.createTextNode('');
            new c(g).observe(h, { characterData: !0 }),
              (b = function () {
                h.data = y = !y;
              });
          } else if (l && l.resolve) {
            var v = l.resolve();
            b = function () {
              v.then(g);
            };
          } else
            b = function () {
              o.call(s, g);
            };
          return function (C) {
            var _ = { fn: C, next: void 0 };
            x && (x.next = _), d || ((d = _), b()), (x = _);
          };
        };
      },
      function (i, n, r) {
        var s = r(3),
          o = r(50),
          c = r(22),
          u = r(19)('IE_PROTO'),
          l = function () {},
          p = 'prototype',
          d = function () {
            var x,
              b = r(16)('iframe'),
              g = c.length,
              y = '>';
            for (
              b.style.display = 'none',
                r(25).appendChild(b),
                b.src = 'javascript:',
                x = b.contentWindow.document,
                x.open(),
                x.write('<script>document.F=Object</script' + y),
                x.close(),
                d = x.F;
              g--;

            )
              delete d[p][c[g]];
            return d();
          };
        i.exports =
          Object.create ||
          function (x, b) {
            var g;
            return (
              x !== null ? ((l[p] = s(x)), (g = new l()), (l[p] = null), (g[u] = x)) : (g = d()),
              b === void 0 ? g : o(g, b)
            );
          };
      },
      function (i, n, r) {
        var s = r(12),
          o = r(3),
          c = r(54);
        i.exports = r(4)
          ? Object.defineProperties
          : function (u, l) {
              o(u);
              for (var p, d = c(l), x = d.length, b = 0; x > b; ) s.f(u, (p = d[b++]), l[p]);
              return u;
            };
      },
      function (i, n, r) {
        var s = r(55),
          o = r(17),
          c = r(13),
          u = r(32),
          l = r(8),
          p = r(26),
          d = Object.getOwnPropertyDescriptor;
        n.f = r(4)
          ? d
          : function (x, b) {
              if (((x = c(x)), (b = u(b, !0)), p))
                try {
                  return d(x, b);
                } catch {}
              if (l(x, b)) return o(!s.f.call(x, b), x[b]);
            };
      },
      function (i, n, r) {
        var s = r(8),
          o = r(63),
          c = r(19)('IE_PROTO'),
          u = Object.prototype;
        i.exports =
          Object.getPrototypeOf ||
          function (l) {
            return (
              (l = o(l)),
              s(l, c)
                ? l[c]
                : typeof l.constructor == 'function' && l instanceof l.constructor
                ? l.constructor.prototype
                : l instanceof Object
                ? u
                : null
            );
          };
      },
      function (i, n, r) {
        var s = r(8),
          o = r(13),
          c = r(39)(!1),
          u = r(19)('IE_PROTO');
        i.exports = function (l, p) {
          var d,
            x = o(l),
            b = 0,
            g = [];
          for (d in x) d != u && s(x, d) && g.push(d);
          for (; p.length > b; ) s(x, (d = p[b++])) && (~c(g, d) || g.push(d));
          return g;
        };
      },
      function (i, n, r) {
        var s = r(53),
          o = r(22);
        i.exports =
          Object.keys ||
          function (c) {
            return s(c, o);
          };
      },
      function (i, n) {
        n.f = {}.propertyIsEnumerable;
      },
      function (i, n, r) {
        var s = r(5);
        i.exports = function (o, c, u) {
          for (var l in c) u && o[l] ? (o[l] = c[l]) : s(o, l, c[l]);
          return o;
        };
      },
      function (i, n, r) {
        i.exports = r(5);
      },
      function (i, n, r) {
        var s = r(9),
          o = r(3),
          c = function (u, l) {
            if ((o(u), !s(l) && l !== null)) throw TypeError(l + ": can't set as prototype!");
          };
        i.exports = {
          set:
            Object.setPrototypeOf ||
            ('__proto__' in {}
              ? (function (u, l, p) {
                  try {
                    (p = r(7)(Function.call, r(51).f(Object.prototype, '__proto__').set, 2)),
                      p(u, []),
                      (l = !(u instanceof Array));
                  } catch {
                    l = !0;
                  }
                  return function (d, x) {
                    return c(d, x), l ? (d.__proto__ = x) : p(d, x), d;
                  };
                })({}, !1)
              : void 0),
          check: c,
        };
      },
      function (i, n, r) {
        'use strict';
        var s = r(2),
          o = r(6),
          c = r(12),
          u = r(4),
          l = r(1)('species');
        i.exports = function (p) {
          var d = typeof o[p] == 'function' ? o[p] : s[p];
          u &&
            d &&
            !d[l] &&
            c.f(d, l, {
              configurable: !0,
              get: function () {
                return this;
              },
            });
        };
      },
      function (i, n, r) {
        var s = r(3),
          o = r(14),
          c = r(1)('species');
        i.exports = function (u, l) {
          var p,
            d = s(u).constructor;
          return d === void 0 || (p = s(d)[c]) == null ? l : o(p);
        };
      },
      function (i, n, r) {
        var s = r(20),
          o = r(15);
        i.exports = function (c) {
          return function (u, l) {
            var p,
              d,
              x = String(o(u)),
              b = s(l),
              g = x.length;
            return b < 0 || b >= g
              ? c
                ? ''
                : void 0
              : ((p = x.charCodeAt(b)),
                p < 55296 || p > 56319 || b + 1 === g || (d = x.charCodeAt(b + 1)) < 56320 || d > 57343
                  ? c
                    ? x.charAt(b)
                    : p
                  : c
                  ? x.slice(b, b + 2)
                  : ((p - 55296) << 10) + (d - 56320) + 65536);
          };
        };
      },
      function (i, n, r) {
        var s = r(20),
          o = Math.max,
          c = Math.min;
        i.exports = function (u, l) {
          return (u = s(u)), u < 0 ? o(u + l, 0) : c(u, l);
        };
      },
      function (i, n, r) {
        var s = r(15);
        i.exports = function (o) {
          return Object(s(o));
        };
      },
      function (i, n, r) {
        var s = r(21),
          o = r(1)('iterator'),
          c = r(10);
        i.exports = r(6).getIteratorMethod = function (u) {
          if (u != null) return u[o] || u['@@iterator'] || c[s(u)];
        };
      },
      function (i, n, r) {
        'use strict';
        var s = r(37),
          o = r(47),
          c = r(10),
          u = r(13);
        (i.exports = r(27)(
          Array,
          'Array',
          function (l, p) {
            (this._t = u(l)), (this._i = 0), (this._k = p);
          },
          function () {
            var l = this._t,
              p = this._k,
              d = this._i++;
            return !l || d >= l.length
              ? ((this._t = void 0), o(1))
              : p == 'keys'
              ? o(0, d)
              : p == 'values'
              ? o(0, l[d])
              : o(0, [d, l[d]]);
          },
          'values'
        )),
          (c.Arguments = c.Array),
          s('keys'),
          s('values'),
          s('entries');
      },
      function (i, n) {},
      function (i, n, r) {
        'use strict';
        var s,
          o,
          c,
          u = r(28),
          l = r(2),
          p = r(7),
          d = r(21),
          x = r(23),
          b = r(9),
          g = (r(3), r(14)),
          y = r(38),
          h = r(40),
          v = (r(58).set, r(60)),
          C = r(30).set,
          _ = r(48)(),
          m = 'Promise',
          O = l.TypeError,
          D = l.process,
          N = l[m],
          D = l.process,
          z = d(D) == 'process',
          H = function () {},
          F = !!(function () {
            try {
              var Z = N.resolve(1),
                oe = ((Z.constructor = {})[r(1)('species')] = function (I) {
                  I(H, H);
                });
              return (z || typeof PromiseRejectionEvent == 'function') && Z.then(H) instanceof oe;
            } catch {}
          })(),
          ne = function (Z, oe) {
            return Z === oe || (Z === N && oe === c);
          },
          pe = function (Z) {
            var oe;
            return !(!b(Z) || typeof (oe = Z.then) != 'function') && oe;
          },
          le = function (Z) {
            return ne(N, Z) ? new V(Z) : new o(Z);
          },
          V = (o = function (Z) {
            var oe, I;
            (this.promise = new Z(function (X, Q) {
              if (oe !== void 0 || I !== void 0) throw O('Bad Promise constructor');
              (oe = X), (I = Q);
            })),
              (this.resolve = g(oe)),
              (this.reject = g(I));
          }),
          W = function (Z) {
            try {
              Z();
            } catch (oe) {
              return { error: oe };
            }
          },
          K = function (Z, oe) {
            if (!Z._n) {
              Z._n = !0;
              var I = Z._c;
              _(function () {
                for (
                  var X = Z._v,
                    Q = Z._s == 1,
                    ae = 0,
                    ce = function (ye) {
                      var ve,
                        Ce,
                        Oe = Q ? ye.ok : ye.fail,
                        ke = ye.resolve,
                        ze = ye.reject,
                        R = ye.domain;
                      try {
                        Oe
                          ? (Q || (Z._h == 2 && ee(Z), (Z._h = 1)),
                            Oe === !0 ? (ve = X) : (R && R.enter(), (ve = Oe(X)), R && R.exit()),
                            ve === ye.promise
                              ? ze(O('Promise-chain cycle'))
                              : (Ce = pe(ve))
                              ? Ce.call(ve, ke, ze)
                              : ke(ve))
                          : ze(X);
                      } catch (w) {
                        ze(w);
                      }
                    };
                  I.length > ae;

                )
                  ce(I[ae++]);
                (Z._c = []), (Z._n = !1), oe && !Z._h && q(Z);
              });
            }
          },
          q = function (Z) {
            C.call(l, function () {
              var oe,
                I,
                X,
                Q = Z._v;
              if (
                (B(Z) &&
                  ((oe = W(function () {
                    z
                      ? D.emit('unhandledRejection', Q, Z)
                      : (I = l.onunhandledrejection)
                      ? I({ promise: Z, reason: Q })
                      : (X = l.console) && X.error && X.error('Unhandled promise rejection', Q);
                  })),
                  (Z._h = z || B(Z) ? 2 : 1)),
                (Z._a = void 0),
                oe)
              )
                throw oe.error;
            });
          },
          B = function (Z) {
            if (Z._h == 1) return !1;
            for (var oe, I = Z._a || Z._c, X = 0; I.length > X; )
              if (((oe = I[X++]), oe.fail || !B(oe.promise))) return !1;
            return !0;
          },
          ee = function (Z) {
            C.call(l, function () {
              var oe;
              z ? D.emit('rejectionHandled', Z) : (oe = l.onrejectionhandled) && oe({ promise: Z, reason: Z._v });
            });
          },
          xe = function (Z) {
            var oe = this;
            oe._d ||
              ((oe._d = !0), (oe = oe._w || oe), (oe._v = Z), (oe._s = 2), oe._a || (oe._a = oe._c.slice()), K(oe, !0));
          },
          de = function (Z) {
            var oe,
              I = this;
            if (!I._d) {
              (I._d = !0), (I = I._w || I);
              try {
                if (I === Z) throw O("Promise can't be resolved itself");
                (oe = pe(Z))
                  ? _(function () {
                      var X = { _w: I, _d: !1 };
                      try {
                        oe.call(Z, p(de, X, 1), p(xe, X, 1));
                      } catch (Q) {
                        xe.call(X, Q);
                      }
                    })
                  : ((I._v = Z), (I._s = 1), K(I, !1));
              } catch (X) {
                xe.call({ _w: I, _d: !1 }, X);
              }
            }
          };
        F ||
          ((N = function (Z) {
            y(this, N, m, '_h'), g(Z), s.call(this);
            try {
              Z(p(de, this, 1), p(xe, this, 1));
            } catch (oe) {
              xe.call(this, oe);
            }
          }),
          (s = function (Z) {
            (this._c = []),
              (this._a = void 0),
              (this._s = 0),
              (this._d = !1),
              (this._v = void 0),
              (this._h = 0),
              (this._n = !1);
          }),
          (s.prototype = r(56)(N.prototype, {
            then: function (Z, oe) {
              var I = le(v(this, N));
              return (
                (I.ok = typeof Z != 'function' || Z),
                (I.fail = typeof oe == 'function' && oe),
                (I.domain = z ? D.domain : void 0),
                this._c.push(I),
                this._a && this._a.push(I),
                this._s && K(this, !1),
                I.promise
              );
            },
            catch: function (Z) {
              return this.then(void 0, Z);
            },
          })),
          (V = function () {
            var Z = new s();
            (this.promise = Z), (this.resolve = p(de, Z, 1)), (this.reject = p(xe, Z, 1));
          })),
          x(x.G + x.W + x.F * !F, { Promise: N }),
          r(18)(N, m),
          r(59)(m),
          (c = r(6)[m]),
          x(x.S + x.F * !F, m, {
            reject: function (Z) {
              var oe = le(this),
                I = oe.reject;
              return I(Z), oe.promise;
            },
          }),
          x(x.S + x.F * (u || !F), m, {
            resolve: function (Z) {
              if (Z instanceof N && ne(Z.constructor, this)) return Z;
              var oe = le(this),
                I = oe.resolve;
              return I(Z), oe.promise;
            },
          }),
          x(
            x.S +
              x.F *
                !(
                  F &&
                  r(46)(function (Z) {
                    N.all(Z).catch(H);
                  })
                ),
            m,
            {
              all: function (Z) {
                var oe = this,
                  I = le(oe),
                  X = I.resolve,
                  Q = I.reject,
                  ae = W(function () {
                    var ce = [],
                      ye = 0,
                      ve = 1;
                    h(Z, !1, function (Ce) {
                      var Oe = ye++,
                        ke = !1;
                      ce.push(void 0),
                        ve++,
                        oe.resolve(Ce).then(function (ze) {
                          ke || ((ke = !0), (ce[Oe] = ze), --ve || X(ce));
                        }, Q);
                    }),
                      --ve || X(ce);
                  });
                return ae && Q(ae.error), I.promise;
              },
              race: function (Z) {
                var oe = this,
                  I = le(oe),
                  X = I.reject,
                  Q = W(function () {
                    h(Z, !1, function (ae) {
                      oe.resolve(ae).then(I.resolve, X);
                    });
                  });
                return Q && X(Q.error), I.promise;
              },
            }
          );
      },
      function (i, n, r) {
        'use strict';
        var s = r(61)(!0);
        r(27)(
          String,
          'String',
          function (o) {
            (this._t = String(o)), (this._i = 0);
          },
          function () {
            var o,
              c = this._t,
              u = this._i;
            return u >= c.length
              ? { value: void 0, done: !0 }
              : ((o = s(c, u)), (this._i += o.length), { value: o, done: !1 });
          }
        );
      },
      function (i, n, r) {
        r(65);
        for (
          var s = r(2),
            o = r(5),
            c = r(10),
            u = r(1)('toStringTag'),
            l = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'],
            p = 0;
          p < 5;
          p++
        ) {
          var d = l[p],
            x = s[d],
            b = x && x.prototype;
          b && !b[u] && o(b, u, d), (c[d] = c.Array);
        }
      },
      function (i, n) {
        i.exports = require('child_process');
      },
      function (i, n) {
        i.exports = require('crypto');
      },
    ]);
  });
});
var gS = {};
Ft(gS, { configureLightClientRequire: () => pB, lightClientRequire: () => He });
function He(t) {
  let e;
  try {
    e = JSON.parse(process.env.NX_CLOUD_LIGHT_CLIENT_RESOLUTION_PATHS);
  } catch {
    e = [];
  }
  if (e.length === 0)
    throw new Error('Light client require must have paths configured with `configureLightClientRequire`.');
  let i;
  try {
    i = require.resolve(t, { paths: e });
  } catch (n) {
    throw (
      (process.env.NX_VERBOSE_LOGGING === 'true' &&
        console.error(
          `Was not able to require.resolve module ${t} from the following paths: ${e}. This may be expected.`
        ),
      n)
    );
  }
  try {
    return require(i);
  } catch (n) {
    throw (
      (process.env.NX_VERBOSE_LOGGING === 'true' &&
        console.error(`Was not able require module ${t} from path ${i}. This may be expected. `),
      n)
    );
  }
}
function pB(t) {
  process.env.NX_CLOUD_LIGHT_CLIENT_RESOLUTION_PATHS = JSON.stringify(t);
}
var Pc = te(() => {
  'use strict';
});
var Ae = P((Us) => {
  'use strict';
  Pc();
  try {
    try {
      let { output: t } = He('nx/src/utils/output'),
        e;
      try {
        e = He('nx/src/utils/app-root').workspaceRoot;
      } catch {
        e = He('nx/src/utils/workspace-root').workspaceRoot;
      }
      (Us.workspaceRoot = e), (Us.output = t);
    } catch {
      let { output: e } = He('@nrwl/workspace/src/utilities/output'),
        { appRootPath: i } = He('@nrwl/tao/src/utils/app-root');
      (Us.workspaceRoot = i), (Us.output = e);
    }
  } catch {
    let e = (i) => {
      var r;
      let n = i.bodyLines
        ? (r = i.bodyLines) == null
          ? void 0
          : r.join(`
`)
        : '';
      return `${i.title}

${n}`;
    };
    (Us.output = {
      log: (i) => console.log(e(i)),
      note: (i) => console.info(e(i)),
      error: (i) => console.error(e(i)),
      warn: (i) => console.warn(e(i)),
      success: (i) => console.log(e(i)),
      addVerticalSeparator: () => '',
      addNewline: () =>
        console.log(`
`),
      logCommand: (i) => console.log(i),
    }),
      (Us.workspaceRoot = process.cwd());
  }
});
function Zt(t) {
  return !!t;
}
function ES() {
  return process.env.NX_INVOKED_BY_RUNNER === 'true' || process.env.NX_CLOUD === 'false';
}
function Qt() {
  try {
    return (0, Nm.execSync)('git rev-parse HEAD', { stdio: 'pipe' }).toString().trim();
  } catch {
    return;
  }
}
function ep() {
  try {
    return (0, Nm.execSync)('git rev-parse --symbolic-full-name HEAD', { stdio: 'pipe' }).toString().trim();
  } catch {
    return;
  }
}
function mB() {
  try {
    let t = (0, Pm.readFileSync)((0, Zl.join)(hB, 'nx-cloud.env'));
    return fB.parse(t);
  } catch {
    return {};
  }
}
function gB() {
  let t = mB();
  (Zn =
    process.env.NX_CLOUD_AUTH_TOKEN ||
    process.env.NX_CLOUD_ACCESS_TOKEN ||
    t.NX_CLOUD_AUTH_TOKEN ||
    t.NX_CLOUD_ACCESS_TOKEN),
    (Fi = process.env.NX_CLOUD_ENCRYPTION_KEY || t.NX_CLOUD_ENCRYPTION_KEY),
    (ie = process.env.NX_VERBOSE_LOGGING === 'true' || t.NX_VERBOSE_LOGGING === 'true'),
    (ji = process.env.NX_CLOUD_NO_TIMEOUTS === 'true' || t.NX_CLOUD_NO_TIMEOUTS === 'true'),
    (Dm = process.env.NX_CLOUD_CONTRIBUTOR_TESTING === 'true' || t.NX_CLOUD_CONTRIBUTOR_TESTING === 'true');
}
function At() {
  return _S();
}
function _S() {
  return process.env.NX_CI_EXECUTION_ID !== void 0
    ? process.env.NX_CI_EXECUTION_ID
    : process.env.NX_RUN_GROUP !== void 0
    ? process.env.NX_RUN_GROUP
    : process.env.CIRCLECI !== void 0 && process.env.CIRCLE_WORKFLOW_ID
    ? process.env.CIRCLE_WORKFLOW_ID
    : process.env.TRAVIS_BUILD_ID !== void 0
    ? process.env.TRAVIS_BUILD_ID
    : process.env.GITHUB_ACTIONS && process.env.GITHUB_RUN_ID
    ? `${process.env.GITHUB_RUN_ID}-${process.env.GITHUB_RUN_ATTEMPT}`
    : process.env.BUILD_BUILDID
    ? process.env.BUILD_BUILDID
    : process.env.BITBUCKET_BUILD_NUMBER !== void 0
    ? process.env.BITBUCKET_BUILD_NUMBER
    : process.env.VERCEL_GIT_COMMIT_SHA !== void 0
    ? process.env.VERCEL_GIT_COMMIT_SHA
    : process.env.CI_PIPELINE_ID
    ? process.env.CI_PIPELINE_ID
    : process.env.BUILD_TAG
    ? process.env.BUILD_TAG
    : null;
}
function kt() {
  return process.env.NX_CI_EXECUTION_ENV ?? '';
}
function Ct() {
  if (process.env.NX_RUN_GROUP !== void 0) return process.env.NX_RUN_GROUP;
  let t = _S();
  return t ? (kt() ? `${t}-${kt()}` : t) : Qt();
}
function It() {
  if (process.env.NX_BRANCH !== void 0) return process.env.NX_BRANCH;
  if (process.env.CIRCLECI !== void 0) {
    if (process.env.CIRCLE_PR_NUMBER !== void 0) return process.env.CIRCLE_PR_NUMBER;
    if (process.env.CIRCLE_PULL_REQUEST !== void 0) {
      let t = process.env.CIRCLE_PULL_REQUEST.split('/');
      return t[t.length - 1];
    } else if (process.env.CIRCLE_BRANCH !== void 0) return process.env.CIRCLE_BRANCH;
  }
  if (process.env.TRAVIS_PULL_REQUEST !== void 0) return process.env.TRAVIS_PULL_REQUEST;
  if (process.env.GITHUB_ACTIONS) {
    if (process.env.GITHUB_REF) {
      let t = process.env.GITHUB_REF.match(/refs\/pull\/(\d+)\/merge/);
      if (t) return t[1];
    }
    return process.env.GITHUB_HEAD_REF
      ? process.env.GITHUB_HEAD_REF
      : process.env.GITHUB_REF_NAME
      ? process.env.GITHUB_REF_NAME
      : '';
  }
  return process.env.BITBUCKET_PR_ID !== void 0
    ? process.env.BITBUCKET_PR_ID
    : process.env.BITBUCKET_BRANCH !== void 0
    ? process.env.BITBUCKET_BRANCH
    : process.env.BUILD_SOURCEBRANCHNAME !== void 0
    ? process.env.BUILD_SOURCEBRANCHNAME
    : process.env.VERCEL_GIT_COMMIT_REF !== void 0
    ? process.env.VERCEL_GIT_COMMIT_REF
    : process.env.CI_MERGE_REQUEST_IID
    ? process.env.CI_MERGE_REQUEST_IID
    : process.env.CI_COMMIT_BRANCH
    ? process.env.CI_COMMIT_BRANCH
    : process.env.GIT_BRANCH
    ? process.env.GIT_BRANCH
    : null;
}
function Hs() {
  let t = require('os'),
    e = (0, yS.createHash)('md5');
  return (
    e.update(dB()),
    {
      machineId: e.digest('base64'),
      platform: t.platform(),
      version: t.version ? t.version() : '',
      cpuCores: t.cpus().length,
    }
  );
}
function wi() {
  let t = (0, Zl.parse)(process.argv[1]).name,
    e = `${process.argv.slice(2).join(' ')}`;
  return `${t} ${e}`;
}
function Fm() {
  let t = JSON.parse((0, Pm.readFileSync)('package.json').toString());
  return { ...(t.dependencies || {}), ...(t.devDependencies || {}) }.nx.trim().match(xB);
}
function SS(t) {
  let e = bB(),
    i = {};
  return (
    t == 'auto'
      ? (i = e)
      : t &&
        t
          .split(',')
          .map((n) => n.trim())
          .forEach((n) => {
            e[n] && (i[n] = e[n]);
          }),
    Object.keys(e)
      .filter((n) => n.startsWith('NX_'))
      .forEach((n) => {
        i[n] = e[n];
      }),
    ie && (xS.note({ title: 'Environment variables passed to cloud:', bodyLines: Object.keys(i) }), xS.addNewline()),
    i
  );
}
function bB() {
  let t = {};
  for (let e of Object.keys(process.env)) e != null && !yB.includes(e) && process.env[e] && (t[e] = process.env[e]);
  return t;
}
function CS() {
  let t = Fm(),
    e = +t[1],
    i = t[2] ? +t[2] : 9999;
  return e >= 19 && i >= 7;
}
function TS() {
  return RS;
}
function OS(t) {
  RS = t;
}
var Nm,
  yS,
  Pm,
  Zl,
  fB,
  dB,
  xS,
  hB,
  $o,
  Wo,
  Ko,
  qs,
  bS,
  Bs,
  jr,
  Lc,
  Lm,
  Ql,
  vS,
  wS,
  Zn,
  Fi,
  ie,
  ji,
  Dm,
  xB,
  yB,
  Dc,
  RS,
  Le = te(() => {
    'use strict';
    (Nm = require('child_process')), (yS = require('crypto')), (Pm = require('fs')), (Zl = require('path'));
    Jl();
    (fB = hS()),
      ({ machineIdSync: dB } = mS()),
      ({ output: xS, workspaceRoot: hB } = Ae()),
      ($o = 9999999),
      (Wo = process.env.NX_CLOUD_AGENT_TIMEOUT_MS ? Number(process.env.NX_CLOUD_AGENT_TIMEOUT_MS) : 36e5),
      (Ko = process.env.NX_CLOUD_ORCHESTRATOR_TIMEOUT_MS ? Number(process.env.NX_CLOUD_ORCHESTRATOR_TIMEOUT_MS) : 36e5),
      (qs = 1e3 * 1e3 * 1e4),
      (bS = process.env.NX_CLOUD_UNLIMITED_OUTPUT === 'true'),
      (Bs = 1e3 * 1e3 * 300),
      (jr = 166),
      (Lc = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT
        ? Number(process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT)
        : null),
      (Lm = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE != 'false'),
      (Ql = process.env.NX_CLOUD_NUMBER_OF_RETRIES ? Number(process.env.NX_CLOUD_NUMBER_OF_RETRIES) : Fr() ? 10 : 1),
      (vS = process.env.NX_NO_CLOUD === 'true'),
      (wS = process.env.NX_CLOUD_RETRY_FLAKY_TASKS !== 'false');
    gB();
    xB = /(0|[1-9]\d*)(?:\.(0|[1-9]\d*))(?:\.(0|[1-9]\d*))?(?:-.*)?/;
    yB = [
      'PWD',
      'HOME',
      'SHELL',
      'LOGNAME',
      'UID',
      'HOSTNAME',
      'MAIL',
      'EDITOR',
      'LANG',
      'TEMP',
      'PATH',
      'TERM',
      'USER',
      'COMMAND_MODE',
      'TMPDIR',
      'TERMINAL_EMULATOR',
      'TERM_SESSION_ID',
      'OLDPWD',
      'MANPATH',
      'PAGER',
      'LESS',
      'LSCOLORS',
      'PNPM_HOME',
      'ZSH',
      'GOPATH',
      'GOROOT',
      'NVM_DIR',
      'NVM_BIN',
      'NVM_INC',
    ];
    Dc = 'nxCloudCriticalErrorMessage';
  });
var PS = P((Wne, NS) => {
  'use strict';
  var { hasOwnProperty: jm } = Object.prototype,
    Mm = (t, e = {}) => {
      typeof e == 'string' && (e = { section: e }),
        (e.align = e.align === !0),
        (e.newline = e.newline === !0),
        (e.sort = e.sort === !0),
        (e.whitespace = e.whitespace === !0 || e.align === !0),
        (e.platform = e.platform || (typeof process < 'u' && process.platform)),
        (e.bracketedArray = e.bracketedArray !== !1);
      let i =
          e.platform === 'win32'
            ? `\r
`
            : `
`,
        n = e.whitespace ? ' = ' : '=',
        r = [],
        s = e.sort ? Object.keys(t).sort() : Object.keys(t),
        o = 0;
      e.align &&
        (o = Qn(
          s
            .filter((l) => t[l] === null || Array.isArray(t[l]) || typeof t[l] != 'object')
            .map((l) => (Array.isArray(t[l]) ? `${l}[]` : l))
            .concat([''])
            .reduce((l, p) => (Qn(l).length >= Qn(p).length ? l : p))
        ).length);
      let c = '',
        u = e.bracketedArray ? '[]' : '';
      for (let l of s) {
        let p = t[l];
        if (p && Array.isArray(p)) for (let d of p) c += Qn(`${l}${u}`).padEnd(o, ' ') + n + Qn(d) + i;
        else p && typeof p == 'object' ? r.push(l) : (c += Qn(l).padEnd(o, ' ') + n + Qn(p) + i);
      }
      e.section && c.length && (c = '[' + Qn(e.section) + ']' + (e.newline ? i + i : i) + c);
      for (let l of r) {
        let p = AS(l, '.').join('\\.'),
          d = (e.section ? e.section + '.' : '') + p,
          x = Mm(t[l], { ...e, section: d });
        c.length && x.length && (c += i), (c += x);
      }
      return c;
    };
  function AS(t, e) {
    var i = 0,
      n = 0,
      r = 0,
      s = [];
    do
      if (((r = t.indexOf(e, i)), r !== -1)) {
        if (((i = r + e.length), r > 0 && t[r - 1] === '\\')) continue;
        s.push(t.slice(n, r)), (n = r + e.length);
      }
    while (r !== -1);
    return s.push(t.slice(n)), s;
  }
  var kS = (t, e = {}) => {
      e.bracketedArray = e.bracketedArray !== !1;
      let i = Object.create(null),
        n = i,
        r = null,
        s = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i,
        o = t.split(/[\r\n]+/g),
        c = {};
      for (let l of o) {
        if (!l || l.match(/^\s*[;#]/) || l.match(/^\s*$/)) continue;
        let p = l.match(s);
        if (!p) continue;
        if (p[1] !== void 0) {
          if (((r = tp(p[1])), r === '__proto__')) {
            n = Object.create(null);
            continue;
          }
          n = i[r] = i[r] || Object.create(null);
          continue;
        }
        let d = tp(p[2]),
          x;
        e.bracketedArray
          ? (x = d.length > 2 && d.slice(-2) === '[]')
          : ((c[d] = ((c == null ? void 0 : c[d]) || 0) + 1), (x = c[d] > 1));
        let b = x && d.endsWith('[]') ? d.slice(0, -2) : d;
        if (b === '__proto__') continue;
        let g = p[3] ? tp(p[4]) : !0,
          y = g === 'true' || g === 'false' || g === 'null' ? JSON.parse(g) : g;
        x && (jm.call(n, b) ? Array.isArray(n[b]) || (n[b] = [n[b]]) : (n[b] = [])),
          Array.isArray(n[b]) ? n[b].push(y) : (n[b] = y);
      }
      let u = [];
      for (let l of Object.keys(i)) {
        if (!jm.call(i, l) || typeof i[l] != 'object' || Array.isArray(i[l])) continue;
        let p = AS(l, '.');
        n = i;
        let d = p.pop(),
          x = d.replace(/\\\./g, '.');
        for (let b of p)
          b !== '__proto__' &&
            ((!jm.call(n, b) || typeof n[b] != 'object') && (n[b] = Object.create(null)), (n = n[b]));
        (n === i && x === d) || ((n[x] = i[l]), u.push(l));
      }
      for (let l of u) delete i[l];
      return i;
    },
    IS = (t) => (t.startsWith('"') && t.endsWith('"')) || (t.startsWith("'") && t.endsWith("'")),
    Qn = (t) =>
      typeof t != 'string' || t.match(/[=\r\n]/) || t.match(/^\[/) || (t.length > 1 && IS(t)) || t !== t.trim()
        ? JSON.stringify(t)
        : t.split(';').join('\\;').split('#').join('\\#'),
    tp = (t) => {
      if (((t = (t || '').trim()), IS(t))) {
        t.charAt(0) === "'" && (t = t.slice(1, -1));
        try {
          t = JSON.parse(t);
        } catch {}
      } else {
        let e = !1,
          i = '';
        for (let n = 0, r = t.length; n < r; n++) {
          let s = t.charAt(n);
          if (e) '\\;#'.indexOf(s) !== -1 ? (i += s) : (i += '\\' + s), (e = !1);
          else {
            if (';#'.indexOf(s) !== -1) break;
            s === '\\' ? (e = !0) : (i += s);
          }
        }
        return e && (i += '\\'), i.trim();
      }
      return t;
    };
  NS.exports = { parse: kS, decode: kS, stringify: Mm, encode: Mm, safe: Qn, unsafe: tp };
});
function Gs(t, { whitespace: e = !0, trailingCommas: i = !1 } = {}) {
  if (typeof t != 'string')
    throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof t}\``);
  let n = e ? wB : vB,
    r = !1,
    s = !1,
    o = 0,
    c = '',
    u = '',
    l = -1;
  for (let p = 0; p < t.length; p++) {
    let d = t[p],
      x = t[p + 1];
    if ((!s && d === '"' && (EB(t, p) || (r = !r)), !r))
      if (!s && d + x === '//') (c += t.slice(o, p)), (o = p), (s = Um), p++;
      else if (
        s === Um &&
        d + x ===
          `\r
`
      ) {
        p++, (s = !1), (c += n(t, o, p)), (o = p);
        continue;
      } else if (
        s === Um &&
        d ===
          `
`
      )
        (s = !1), (c += n(t, o, p)), (o = p);
      else if (!s && d + x === '/*') {
        (c += t.slice(o, p)), (o = p), (s = LS), p++;
        continue;
      } else if (s === LS && d + x === '*/') {
        p++, (s = !1), (c += n(t, o, p + 1)), (o = p + 1);
        continue;
      } else
        i &&
          !s &&
          (l !== -1
            ? d === '}' || d === ']'
              ? ((c += t.slice(o, p)), (u += n(c, 0, 1) + c.slice(1)), (c = ''), (o = p), (l = -1))
              : d !== ' ' &&
                d !== '	' &&
                d !== '\r' &&
                d !==
                  `
` &&
                ((c += t.slice(o, p)), (o = p), (l = -1))
            : d === ',' && ((u += c + t.slice(o, p)), (c = ''), (o = p), (l = p)));
  }
  return u + c + (s ? n(t.slice(o)) : t.slice(o));
}
var Um,
  LS,
  vB,
  wB,
  EB,
  ip = te(() => {
    'use strict';
    (Um = Symbol('singleComment')),
      (LS = Symbol('multiComment')),
      (vB = () => ''),
      (wB = (t, e, i) => t.slice(e, i).replace(/\S/g, ' ')),
      (EB = (t, e) => {
        let i = e - 1,
          n = 0;
        for (; t[i] === '\\'; ) (i -= 1), (n += 1);
        return !!(n % 2);
      });
  });
function vt(t) {
  var r, s;
  let e = JSON.parse(Gs((0, DS.readFileSync)(`${_B}/nx.json`).toString(), { trailingCommas: !0 })),
    i = {},
    n = [];
  for (let o in e.targetDefaults) e.targetDefaults[o].cache && n.push(o);
  return (
    e.nxCloudAccessToken && (i.accessToken ?? (i.accessToken = e.nxCloudAccessToken)),
    e.nxCloudId && (i.nxCloudId ?? (i.nxCloudId = e.nxCloudId)),
    e.nxCloudUrl && (i.url ?? (i.url = e.nxCloudUrl)),
    e.nxCloudEncryptionKey && (i.encryptionKey = e.nxCloudEncryptionKey),
    e.parallel && (i.parallel ?? (i.parallel = e.parallel)),
    e.cacheDirectory && (i.cacheDirectory ?? (i.cacheDirectory = e.cacheDirectory)),
    n.length && (i.cacheableOperations ?? (i.cacheableOperations = n)),
    {
      nxJson: e,
      nxCloudOptions: {
        ...i,
        ...((s = (r = e.tasksRunnerOptions) == null ? void 0 : r[t]) == null ? void 0 : s.options),
      },
    }
  );
}
var DS,
  _B,
  $i = te(() => {
    'use strict';
    DS = require('fs');
    ip();
    ({ workspaceRoot: _B } = Ae());
  });
var Mi,
  np,
  jc,
  dn,
  qm,
  Fc,
  Xo,
  Bm,
  In,
  Mc = te(() => {
    'use strict';
    (Mi = require('fs')), (np = je(PS())), (jc = je(require('os'))), (dn = je(require('path')));
    Le();
    $i();
    ({ output: qm } = Ae()),
      (Fc = 'nxcloud'),
      (Xo = 'nxcloud.ini'),
      (Bm = `.${Xo}`),
      (In = class {
        constructor(e, i = !1) {
          (this.nxCloudUrl = e ?? this.setNxCloudUrl()),
            (this.configFilePath = this.findExistingNxCloudConfig() ?? this.getDefaultConfigPath()),
            (this.data = this.load(i) ?? {});
        }
        setNxCloudUrl() {
          try {
            let { nxJson: e, nxCloudOptions: i } = vt('default');
            return i.url ?? 'https://cloud.nx.app';
          } catch {}
          return 'https://cloud.nx.app';
        }
        getNxCloudUrl() {
          return this.nxCloudUrl;
        }
        findExistingNxCloudConfig() {
          if (process.platform === 'win32') {
            let e = dn.default.join(jc.homedir(), Bm);
            if ((0, Mi.existsSync)(e)) return e;
            if (process.env.LOCALAPPDATA) {
              let i = dn.default.join(process.env.LOCALAPPDATA, Fc, Xo);
              if ((0, Mi.existsSync)(i)) return i;
            }
          } else {
            if (process.env.XDG_CONFIG_HOME) {
              let r = dn.default.join(process.env.XDG_CONFIG_HOME, Fc, Xo);
              if ((0, Mi.existsSync)(r)) return r;
            }
            let e = jc.homedir(),
              i = dn.default.join(e, Bm);
            if ((0, Mi.existsSync)(i)) return i;
            let n = dn.default.join(e, '.config', Fc, Xo);
            if ((0, Mi.existsSync)(n)) return n;
          }
          return null;
        }
        getDefaultConfigPath() {
          return process.platform == 'win32'
            ? process.env.LOCALAPPDATA
              ? dn.default.join(process.env.LOCALAPPDATA, Fc, Xo)
              : dn.default.join(jc.homedir(), Bm)
            : dn.default.join(jc.homedir(), '.config', Fc, Xo);
        }
        load(e) {
          let i = this.configFilePath;
          if ((0, Mi.existsSync)(i)) {
            let n = (0, Mi.readFileSync)(i, 'utf-8');
            return (0, np.parse)(n);
          } else
            return (
              e &&
                (qm.note({
                  title:
                    'Could not find an existing nx-cloud global configuration file to save your personal access token.',
                  bodyLines: [
                    `A new .nxcloudrc will be generated in the ${dn.default.dirname(this.configFilePath)} directory.`,
                  ],
                }),
                (this.data = {}),
                this.save()),
              {}
            );
        }
        save() {
          let e = (0, np.stringify)(this.data);
          (0, Mi.mkdirSync)(dn.default.dirname(this.configFilePath), { recursive: !0 }),
            (0, Mi.writeFileSync)(this.configFilePath, e, 'utf-8');
        }
        getPersonalAccessTokenFromNxCloudUrl(e = this.nxCloudUrl) {
          var i;
          return ((i = this.data[e]) == null ? void 0 : i.personalAccessToken) || null;
        }
        deletePersonalAccessTokenFromNxCloudUrl(e) {
          let i = Object.entries(this.data).find(([n, r]) => n === e);
          if (i) {
            let n = i[0];
            delete this.data[i[0]],
              this.save(),
              ie && qm.success({ title: `Deleted personal access token from ${this.configFilePath} for ${n}` });
          }
        }
        setPersonalAccessToken(e) {
          (this.data[this.nxCloudUrl] = { personalAccessToken: e }),
            this.save(),
            ie &&
              qm.success({ title: `Saved new personal access token to ${this.configFilePath} for ${this.nxCloudUrl}` });
        }
        getAllSectionNxCloudUrls() {
          return Object.keys(this.data);
        }
      });
  });
function Yo(t) {
  let e = CB() ? '   ' : '';
  RB()
    ? (process.stdout.write(`${e}${Hm(t)}`), Nn.addNewline(), Nn.addNewline())
    : TB()
    ? (Nn.addNewline(), process.stdout.write(`${e}${Hm(t)}`), Nn.addNewline(), Nn.addNewline())
    : (process.stdout.write(`${e}${Hm(t)}`), Nn.addNewline(), Nn.addNewline());
}
function CB() {
  try {
    let t = JSON.parse((0, FS.readFileSync)('package.json').toString()),
      i = { ...(t.dependencies || {}), ...(t.devDependencies || {}) }.nx.trim().match(SB),
      n = +i[1];
    if (n < 18) return !0;
    if (n > 18) return !1;
    let r = i[2] ? +i[2] : 9999,
      s = i[3] ? +i[3] : 9999;
    return r === 0 && s < 5;
  } catch {
    return !1;
  }
}
function RB() {
  try {
    return He('nx/src/tasks-runner/life-cycles/dynamic-run-many-terminal-output-life-cycle'), !0;
  } catch {
    try {
      return He('@nrwl/workspace/src/tasks-runner/life-cycles/dynamic-run-many-terminal-output-life-cycle'), !0;
    } catch {
      return !1;
    }
  }
}
function Hm(t) {
  let e;
  if (typeof Nn.dim == 'function') return Nn.dim(t);
  try {
    return Nn.colors.gray(t);
  } catch {
    return t;
  }
}
function TB() {
  return process.argv.indexOf('run-many') === -1 && process.argv.indexOf('affected') === -1;
}
function jS(t) {
  let e = t.trim();
  return e.endsWith('.') ? e : `${e}.`;
}
var FS,
  Nn,
  SB,
  Uc = te(() => {
    'use strict';
    FS = require('fs');
    Pc();
    ({ output: Nn } = Ae());
    SB = /(0|[1-9]\d*)(?:\.(0|[1-9]\d*))(?:\.(0|[1-9]\d*))?(?:-.*)?/;
  });
function wt(t) {
  return new Promise((e) => {
    setTimeout(() => e(null), t);
  });
}
var Pn = te(() => {
  'use strict';
});
var qS = P((nre, US) => {
  'use strict';
  var MS = require('stream').Stream,
    OB = require('util');
  US.exports = hn;
  function hn() {
    (this.source = null),
      (this.dataSize = 0),
      (this.maxDataSize = 1024 * 1024),
      (this.pauseStream = !0),
      (this._maxDataSizeExceeded = !1),
      (this._released = !1),
      (this._bufferedEvents = []);
  }
  OB.inherits(hn, MS);
  hn.create = function (t, e) {
    var i = new this();
    e = e || {};
    for (var n in e) i[n] = e[n];
    i.source = t;
    var r = t.emit;
    return (
      (t.emit = function () {
        return i._handleEmit(arguments), r.apply(t, arguments);
      }),
      t.on('error', function () {}),
      i.pauseStream && t.pause(),
      i
    );
  };
  Object.defineProperty(hn.prototype, 'readable', {
    configurable: !0,
    enumerable: !0,
    get: function () {
      return this.source.readable;
    },
  });
  hn.prototype.setEncoding = function () {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  hn.prototype.resume = function () {
    this._released || this.release(), this.source.resume();
  };
  hn.prototype.pause = function () {
    this.source.pause();
  };
  hn.prototype.release = function () {
    (this._released = !0),
      this._bufferedEvents.forEach(
        function (t) {
          this.emit.apply(this, t);
        }.bind(this)
      ),
      (this._bufferedEvents = []);
  };
  hn.prototype.pipe = function () {
    var t = MS.prototype.pipe.apply(this, arguments);
    return this.resume(), t;
  };
  hn.prototype._handleEmit = function (t) {
    if (this._released) {
      this.emit.apply(this, t);
      return;
    }
    t[0] === 'data' && ((this.dataSize += t[1].length), this._checkIfMaxDataSizeExceeded()),
      this._bufferedEvents.push(t);
  };
  hn.prototype._checkIfMaxDataSizeExceeded = function () {
    if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
      this._maxDataSizeExceeded = !0;
      var t = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
      this.emit('error', new Error(t));
    }
  };
});
var zS = P((rre, GS) => {
  'use strict';
  var kB = require('util'),
    HS = require('stream').Stream,
    BS = qS();
  GS.exports = Et;
  function Et() {
    (this.writable = !1),
      (this.readable = !0),
      (this.dataSize = 0),
      (this.maxDataSize = 2 * 1024 * 1024),
      (this.pauseStreams = !0),
      (this._released = !1),
      (this._streams = []),
      (this._currentStream = null),
      (this._insideLoop = !1),
      (this._pendingNext = !1);
  }
  kB.inherits(Et, HS);
  Et.create = function (t) {
    var e = new this();
    t = t || {};
    for (var i in t) e[i] = t[i];
    return e;
  };
  Et.isStreamLike = function (t) {
    return (
      typeof t != 'function' &&
      typeof t != 'string' &&
      typeof t != 'boolean' &&
      typeof t != 'number' &&
      !Buffer.isBuffer(t)
    );
  };
  Et.prototype.append = function (t) {
    var e = Et.isStreamLike(t);
    if (e) {
      if (!(t instanceof BS)) {
        var i = BS.create(t, { maxDataSize: 1 / 0, pauseStream: this.pauseStreams });
        t.on('data', this._checkDataSize.bind(this)), (t = i);
      }
      this._handleErrors(t), this.pauseStreams && t.pause();
    }
    return this._streams.push(t), this;
  };
  Et.prototype.pipe = function (t, e) {
    return HS.prototype.pipe.call(this, t, e), this.resume(), t;
  };
  Et.prototype._getNext = function () {
    if (((this._currentStream = null), this._insideLoop)) {
      this._pendingNext = !0;
      return;
    }
    this._insideLoop = !0;
    try {
      do (this._pendingNext = !1), this._realGetNext();
      while (this._pendingNext);
    } finally {
      this._insideLoop = !1;
    }
  };
  Et.prototype._realGetNext = function () {
    var t = this._streams.shift();
    if (typeof t > 'u') {
      this.end();
      return;
    }
    if (typeof t != 'function') {
      this._pipeNext(t);
      return;
    }
    var e = t;
    e(
      function (i) {
        var n = Et.isStreamLike(i);
        n && (i.on('data', this._checkDataSize.bind(this)), this._handleErrors(i)), this._pipeNext(i);
      }.bind(this)
    );
  };
  Et.prototype._pipeNext = function (t) {
    this._currentStream = t;
    var e = Et.isStreamLike(t);
    if (e) {
      t.on('end', this._getNext.bind(this)), t.pipe(this, { end: !1 });
      return;
    }
    var i = t;
    this.write(i), this._getNext();
  };
  Et.prototype._handleErrors = function (t) {
    var e = this;
    t.on('error', function (i) {
      e._emitError(i);
    });
  };
  Et.prototype.write = function (t) {
    this.emit('data', t);
  };
  Et.prototype.pause = function () {
    this.pauseStreams &&
      (this.pauseStreams &&
        this._currentStream &&
        typeof this._currentStream.pause == 'function' &&
        this._currentStream.pause(),
      this.emit('pause'));
  };
  Et.prototype.resume = function () {
    this._released || ((this._released = !0), (this.writable = !0), this._getNext()),
      this.pauseStreams &&
        this._currentStream &&
        typeof this._currentStream.resume == 'function' &&
        this._currentStream.resume(),
      this.emit('resume');
  };
  Et.prototype.end = function () {
    this._reset(), this.emit('end');
  };
  Et.prototype.destroy = function () {
    this._reset(), this.emit('close');
  };
  Et.prototype._reset = function () {
    (this.writable = !1), (this._streams = []), (this._currentStream = null);
  };
  Et.prototype._checkDataSize = function () {
    if ((this._updateDataSize(), !(this.dataSize <= this.maxDataSize))) {
      var t = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
      this._emitError(new Error(t));
    }
  };
  Et.prototype._updateDataSize = function () {
    this.dataSize = 0;
    var t = this;
    this._streams.forEach(function (e) {
      e.dataSize && (t.dataSize += e.dataSize);
    }),
      this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize);
  };
  Et.prototype._emitError = function (t) {
    this._reset(), this.emit('error', t);
  };
});
var VS = P((sre, AB) => {
  AB.exports = {
    'application/1d-interleaved-parityfec': { source: 'iana' },
    'application/3gpdash-qoe-report+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/3gpp-ims+xml': { source: 'iana', compressible: !0 },
    'application/3gpphal+json': { source: 'iana', compressible: !0 },
    'application/3gpphalforms+json': { source: 'iana', compressible: !0 },
    'application/a2l': { source: 'iana' },
    'application/ace+cbor': { source: 'iana' },
    'application/activemessage': { source: 'iana' },
    'application/activity+json': { source: 'iana', compressible: !0 },
    'application/alto-costmap+json': { source: 'iana', compressible: !0 },
    'application/alto-costmapfilter+json': { source: 'iana', compressible: !0 },
    'application/alto-directory+json': { source: 'iana', compressible: !0 },
    'application/alto-endpointcost+json': { source: 'iana', compressible: !0 },
    'application/alto-endpointcostparams+json': { source: 'iana', compressible: !0 },
    'application/alto-endpointprop+json': { source: 'iana', compressible: !0 },
    'application/alto-endpointpropparams+json': { source: 'iana', compressible: !0 },
    'application/alto-error+json': { source: 'iana', compressible: !0 },
    'application/alto-networkmap+json': { source: 'iana', compressible: !0 },
    'application/alto-networkmapfilter+json': { source: 'iana', compressible: !0 },
    'application/alto-updatestreamcontrol+json': { source: 'iana', compressible: !0 },
    'application/alto-updatestreamparams+json': { source: 'iana', compressible: !0 },
    'application/aml': { source: 'iana' },
    'application/andrew-inset': { source: 'iana', extensions: ['ez'] },
    'application/applefile': { source: 'iana' },
    'application/applixware': { source: 'apache', extensions: ['aw'] },
    'application/at+jwt': { source: 'iana' },
    'application/atf': { source: 'iana' },
    'application/atfx': { source: 'iana' },
    'application/atom+xml': { source: 'iana', compressible: !0, extensions: ['atom'] },
    'application/atomcat+xml': { source: 'iana', compressible: !0, extensions: ['atomcat'] },
    'application/atomdeleted+xml': { source: 'iana', compressible: !0, extensions: ['atomdeleted'] },
    'application/atomicmail': { source: 'iana' },
    'application/atomsvc+xml': { source: 'iana', compressible: !0, extensions: ['atomsvc'] },
    'application/atsc-dwd+xml': { source: 'iana', compressible: !0, extensions: ['dwd'] },
    'application/atsc-dynamic-event-message': { source: 'iana' },
    'application/atsc-held+xml': { source: 'iana', compressible: !0, extensions: ['held'] },
    'application/atsc-rdt+json': { source: 'iana', compressible: !0 },
    'application/atsc-rsat+xml': { source: 'iana', compressible: !0, extensions: ['rsat'] },
    'application/atxml': { source: 'iana' },
    'application/auth-policy+xml': { source: 'iana', compressible: !0 },
    'application/bacnet-xdd+zip': { source: 'iana', compressible: !1 },
    'application/batch-smtp': { source: 'iana' },
    'application/bdoc': { compressible: !1, extensions: ['bdoc'] },
    'application/beep+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/calendar+json': { source: 'iana', compressible: !0 },
    'application/calendar+xml': { source: 'iana', compressible: !0, extensions: ['xcs'] },
    'application/call-completion': { source: 'iana' },
    'application/cals-1840': { source: 'iana' },
    'application/captive+json': { source: 'iana', compressible: !0 },
    'application/cbor': { source: 'iana' },
    'application/cbor-seq': { source: 'iana' },
    'application/cccex': { source: 'iana' },
    'application/ccmp+xml': { source: 'iana', compressible: !0 },
    'application/ccxml+xml': { source: 'iana', compressible: !0, extensions: ['ccxml'] },
    'application/cdfx+xml': { source: 'iana', compressible: !0, extensions: ['cdfx'] },
    'application/cdmi-capability': { source: 'iana', extensions: ['cdmia'] },
    'application/cdmi-container': { source: 'iana', extensions: ['cdmic'] },
    'application/cdmi-domain': { source: 'iana', extensions: ['cdmid'] },
    'application/cdmi-object': { source: 'iana', extensions: ['cdmio'] },
    'application/cdmi-queue': { source: 'iana', extensions: ['cdmiq'] },
    'application/cdni': { source: 'iana' },
    'application/cea': { source: 'iana' },
    'application/cea-2018+xml': { source: 'iana', compressible: !0 },
    'application/cellml+xml': { source: 'iana', compressible: !0 },
    'application/cfw': { source: 'iana' },
    'application/city+json': { source: 'iana', compressible: !0 },
    'application/clr': { source: 'iana' },
    'application/clue+xml': { source: 'iana', compressible: !0 },
    'application/clue_info+xml': { source: 'iana', compressible: !0 },
    'application/cms': { source: 'iana' },
    'application/cnrp+xml': { source: 'iana', compressible: !0 },
    'application/coap-group+json': { source: 'iana', compressible: !0 },
    'application/coap-payload': { source: 'iana' },
    'application/commonground': { source: 'iana' },
    'application/conference-info+xml': { source: 'iana', compressible: !0 },
    'application/cose': { source: 'iana' },
    'application/cose-key': { source: 'iana' },
    'application/cose-key-set': { source: 'iana' },
    'application/cpl+xml': { source: 'iana', compressible: !0, extensions: ['cpl'] },
    'application/csrattrs': { source: 'iana' },
    'application/csta+xml': { source: 'iana', compressible: !0 },
    'application/cstadata+xml': { source: 'iana', compressible: !0 },
    'application/csvm+json': { source: 'iana', compressible: !0 },
    'application/cu-seeme': { source: 'apache', extensions: ['cu'] },
    'application/cwt': { source: 'iana' },
    'application/cybercash': { source: 'iana' },
    'application/dart': { compressible: !0 },
    'application/dash+xml': { source: 'iana', compressible: !0, extensions: ['mpd'] },
    'application/dash-patch+xml': { source: 'iana', compressible: !0, extensions: ['mpp'] },
    'application/dashdelta': { source: 'iana' },
    'application/davmount+xml': { source: 'iana', compressible: !0, extensions: ['davmount'] },
    'application/dca-rft': { source: 'iana' },
    'application/dcd': { source: 'iana' },
    'application/dec-dx': { source: 'iana' },
    'application/dialog-info+xml': { source: 'iana', compressible: !0 },
    'application/dicom': { source: 'iana' },
    'application/dicom+json': { source: 'iana', compressible: !0 },
    'application/dicom+xml': { source: 'iana', compressible: !0 },
    'application/dii': { source: 'iana' },
    'application/dit': { source: 'iana' },
    'application/dns': { source: 'iana' },
    'application/dns+json': { source: 'iana', compressible: !0 },
    'application/dns-message': { source: 'iana' },
    'application/docbook+xml': { source: 'apache', compressible: !0, extensions: ['dbk'] },
    'application/dots+cbor': { source: 'iana' },
    'application/dskpp+xml': { source: 'iana', compressible: !0 },
    'application/dssc+der': { source: 'iana', extensions: ['dssc'] },
    'application/dssc+xml': { source: 'iana', compressible: !0, extensions: ['xdssc'] },
    'application/dvcs': { source: 'iana' },
    'application/ecmascript': { source: 'iana', compressible: !0, extensions: ['es', 'ecma'] },
    'application/edi-consent': { source: 'iana' },
    'application/edi-x12': { source: 'iana', compressible: !1 },
    'application/edifact': { source: 'iana', compressible: !1 },
    'application/efi': { source: 'iana' },
    'application/elm+json': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/elm+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.cap+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/emergencycalldata.comment+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.control+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.deviceinfo+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.ecall.msd': { source: 'iana' },
    'application/emergencycalldata.providerinfo+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.serviceinfo+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.subscriberinfo+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.veds+xml': { source: 'iana', compressible: !0 },
    'application/emma+xml': { source: 'iana', compressible: !0, extensions: ['emma'] },
    'application/emotionml+xml': { source: 'iana', compressible: !0, extensions: ['emotionml'] },
    'application/encaprtp': { source: 'iana' },
    'application/epp+xml': { source: 'iana', compressible: !0 },
    'application/epub+zip': { source: 'iana', compressible: !1, extensions: ['epub'] },
    'application/eshop': { source: 'iana' },
    'application/exi': { source: 'iana', extensions: ['exi'] },
    'application/expect-ct-report+json': { source: 'iana', compressible: !0 },
    'application/express': { source: 'iana', extensions: ['exp'] },
    'application/fastinfoset': { source: 'iana' },
    'application/fastsoap': { source: 'iana' },
    'application/fdt+xml': { source: 'iana', compressible: !0, extensions: ['fdt'] },
    'application/fhir+json': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/fhir+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/fido.trusted-apps+json': { compressible: !0 },
    'application/fits': { source: 'iana' },
    'application/flexfec': { source: 'iana' },
    'application/font-sfnt': { source: 'iana' },
    'application/font-tdpfr': { source: 'iana', extensions: ['pfr'] },
    'application/font-woff': { source: 'iana', compressible: !1 },
    'application/framework-attributes+xml': { source: 'iana', compressible: !0 },
    'application/geo+json': { source: 'iana', compressible: !0, extensions: ['geojson'] },
    'application/geo+json-seq': { source: 'iana' },
    'application/geopackage+sqlite3': { source: 'iana' },
    'application/geoxacml+xml': { source: 'iana', compressible: !0 },
    'application/gltf-buffer': { source: 'iana' },
    'application/gml+xml': { source: 'iana', compressible: !0, extensions: ['gml'] },
    'application/gpx+xml': { source: 'apache', compressible: !0, extensions: ['gpx'] },
    'application/gxf': { source: 'apache', extensions: ['gxf'] },
    'application/gzip': { source: 'iana', compressible: !1, extensions: ['gz'] },
    'application/h224': { source: 'iana' },
    'application/held+xml': { source: 'iana', compressible: !0 },
    'application/hjson': { extensions: ['hjson'] },
    'application/http': { source: 'iana' },
    'application/hyperstudio': { source: 'iana', extensions: ['stk'] },
    'application/ibe-key-request+xml': { source: 'iana', compressible: !0 },
    'application/ibe-pkg-reply+xml': { source: 'iana', compressible: !0 },
    'application/ibe-pp-data': { source: 'iana' },
    'application/iges': { source: 'iana' },
    'application/im-iscomposing+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/index': { source: 'iana' },
    'application/index.cmd': { source: 'iana' },
    'application/index.obj': { source: 'iana' },
    'application/index.response': { source: 'iana' },
    'application/index.vnd': { source: 'iana' },
    'application/inkml+xml': { source: 'iana', compressible: !0, extensions: ['ink', 'inkml'] },
    'application/iotp': { source: 'iana' },
    'application/ipfix': { source: 'iana', extensions: ['ipfix'] },
    'application/ipp': { source: 'iana' },
    'application/isup': { source: 'iana' },
    'application/its+xml': { source: 'iana', compressible: !0, extensions: ['its'] },
    'application/java-archive': { source: 'apache', compressible: !1, extensions: ['jar', 'war', 'ear'] },
    'application/java-serialized-object': { source: 'apache', compressible: !1, extensions: ['ser'] },
    'application/java-vm': { source: 'apache', compressible: !1, extensions: ['class'] },
    'application/javascript': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['js', 'mjs'] },
    'application/jf2feed+json': { source: 'iana', compressible: !0 },
    'application/jose': { source: 'iana' },
    'application/jose+json': { source: 'iana', compressible: !0 },
    'application/jrd+json': { source: 'iana', compressible: !0 },
    'application/jscalendar+json': { source: 'iana', compressible: !0 },
    'application/json': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['json', 'map'] },
    'application/json-patch+json': { source: 'iana', compressible: !0 },
    'application/json-seq': { source: 'iana' },
    'application/json5': { extensions: ['json5'] },
    'application/jsonml+json': { source: 'apache', compressible: !0, extensions: ['jsonml'] },
    'application/jwk+json': { source: 'iana', compressible: !0 },
    'application/jwk-set+json': { source: 'iana', compressible: !0 },
    'application/jwt': { source: 'iana' },
    'application/kpml-request+xml': { source: 'iana', compressible: !0 },
    'application/kpml-response+xml': { source: 'iana', compressible: !0 },
    'application/ld+json': { source: 'iana', compressible: !0, extensions: ['jsonld'] },
    'application/lgr+xml': { source: 'iana', compressible: !0, extensions: ['lgr'] },
    'application/link-format': { source: 'iana' },
    'application/load-control+xml': { source: 'iana', compressible: !0 },
    'application/lost+xml': { source: 'iana', compressible: !0, extensions: ['lostxml'] },
    'application/lostsync+xml': { source: 'iana', compressible: !0 },
    'application/lpf+zip': { source: 'iana', compressible: !1 },
    'application/lxf': { source: 'iana' },
    'application/mac-binhex40': { source: 'iana', extensions: ['hqx'] },
    'application/mac-compactpro': { source: 'apache', extensions: ['cpt'] },
    'application/macwriteii': { source: 'iana' },
    'application/mads+xml': { source: 'iana', compressible: !0, extensions: ['mads'] },
    'application/manifest+json': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['webmanifest'] },
    'application/marc': { source: 'iana', extensions: ['mrc'] },
    'application/marcxml+xml': { source: 'iana', compressible: !0, extensions: ['mrcx'] },
    'application/mathematica': { source: 'iana', extensions: ['ma', 'nb', 'mb'] },
    'application/mathml+xml': { source: 'iana', compressible: !0, extensions: ['mathml'] },
    'application/mathml-content+xml': { source: 'iana', compressible: !0 },
    'application/mathml-presentation+xml': { source: 'iana', compressible: !0 },
    'application/mbms-associated-procedure-description+xml': { source: 'iana', compressible: !0 },
    'application/mbms-deregister+xml': { source: 'iana', compressible: !0 },
    'application/mbms-envelope+xml': { source: 'iana', compressible: !0 },
    'application/mbms-msk+xml': { source: 'iana', compressible: !0 },
    'application/mbms-msk-response+xml': { source: 'iana', compressible: !0 },
    'application/mbms-protection-description+xml': { source: 'iana', compressible: !0 },
    'application/mbms-reception-report+xml': { source: 'iana', compressible: !0 },
    'application/mbms-register+xml': { source: 'iana', compressible: !0 },
    'application/mbms-register-response+xml': { source: 'iana', compressible: !0 },
    'application/mbms-schedule+xml': { source: 'iana', compressible: !0 },
    'application/mbms-user-service-description+xml': { source: 'iana', compressible: !0 },
    'application/mbox': { source: 'iana', extensions: ['mbox'] },
    'application/media-policy-dataset+xml': { source: 'iana', compressible: !0, extensions: ['mpf'] },
    'application/media_control+xml': { source: 'iana', compressible: !0 },
    'application/mediaservercontrol+xml': { source: 'iana', compressible: !0, extensions: ['mscml'] },
    'application/merge-patch+json': { source: 'iana', compressible: !0 },
    'application/metalink+xml': { source: 'apache', compressible: !0, extensions: ['metalink'] },
    'application/metalink4+xml': { source: 'iana', compressible: !0, extensions: ['meta4'] },
    'application/mets+xml': { source: 'iana', compressible: !0, extensions: ['mets'] },
    'application/mf4': { source: 'iana' },
    'application/mikey': { source: 'iana' },
    'application/mipc': { source: 'iana' },
    'application/missing-blocks+cbor-seq': { source: 'iana' },
    'application/mmt-aei+xml': { source: 'iana', compressible: !0, extensions: ['maei'] },
    'application/mmt-usd+xml': { source: 'iana', compressible: !0, extensions: ['musd'] },
    'application/mods+xml': { source: 'iana', compressible: !0, extensions: ['mods'] },
    'application/moss-keys': { source: 'iana' },
    'application/moss-signature': { source: 'iana' },
    'application/mosskey-data': { source: 'iana' },
    'application/mosskey-request': { source: 'iana' },
    'application/mp21': { source: 'iana', extensions: ['m21', 'mp21'] },
    'application/mp4': { source: 'iana', extensions: ['mp4s', 'm4p'] },
    'application/mpeg4-generic': { source: 'iana' },
    'application/mpeg4-iod': { source: 'iana' },
    'application/mpeg4-iod-xmt': { source: 'iana' },
    'application/mrb-consumer+xml': { source: 'iana', compressible: !0 },
    'application/mrb-publish+xml': { source: 'iana', compressible: !0 },
    'application/msc-ivr+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/msc-mixer+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/msword': { source: 'iana', compressible: !1, extensions: ['doc', 'dot'] },
    'application/mud+json': { source: 'iana', compressible: !0 },
    'application/multipart-core': { source: 'iana' },
    'application/mxf': { source: 'iana', extensions: ['mxf'] },
    'application/n-quads': { source: 'iana', extensions: ['nq'] },
    'application/n-triples': { source: 'iana', extensions: ['nt'] },
    'application/nasdata': { source: 'iana' },
    'application/news-checkgroups': { source: 'iana', charset: 'US-ASCII' },
    'application/news-groupinfo': { source: 'iana', charset: 'US-ASCII' },
    'application/news-transmission': { source: 'iana' },
    'application/nlsml+xml': { source: 'iana', compressible: !0 },
    'application/node': { source: 'iana', extensions: ['cjs'] },
    'application/nss': { source: 'iana' },
    'application/oauth-authz-req+jwt': { source: 'iana' },
    'application/oblivious-dns-message': { source: 'iana' },
    'application/ocsp-request': { source: 'iana' },
    'application/ocsp-response': { source: 'iana' },
    'application/octet-stream': {
      source: 'iana',
      compressible: !1,
      extensions: [
        'bin',
        'dms',
        'lrf',
        'mar',
        'so',
        'dist',
        'distz',
        'pkg',
        'bpk',
        'dump',
        'elc',
        'deploy',
        'exe',
        'dll',
        'deb',
        'dmg',
        'iso',
        'img',
        'msi',
        'msp',
        'msm',
        'buffer',
      ],
    },
    'application/oda': { source: 'iana', extensions: ['oda'] },
    'application/odm+xml': { source: 'iana', compressible: !0 },
    'application/odx': { source: 'iana' },
    'application/oebps-package+xml': { source: 'iana', compressible: !0, extensions: ['opf'] },
    'application/ogg': { source: 'iana', compressible: !1, extensions: ['ogx'] },
    'application/omdoc+xml': { source: 'apache', compressible: !0, extensions: ['omdoc'] },
    'application/onenote': { source: 'apache', extensions: ['onetoc', 'onetoc2', 'onetmp', 'onepkg'] },
    'application/opc-nodeset+xml': { source: 'iana', compressible: !0 },
    'application/oscore': { source: 'iana' },
    'application/oxps': { source: 'iana', extensions: ['oxps'] },
    'application/p21': { source: 'iana' },
    'application/p21+zip': { source: 'iana', compressible: !1 },
    'application/p2p-overlay+xml': { source: 'iana', compressible: !0, extensions: ['relo'] },
    'application/parityfec': { source: 'iana' },
    'application/passport': { source: 'iana' },
    'application/patch-ops-error+xml': { source: 'iana', compressible: !0, extensions: ['xer'] },
    'application/pdf': { source: 'iana', compressible: !1, extensions: ['pdf'] },
    'application/pdx': { source: 'iana' },
    'application/pem-certificate-chain': { source: 'iana' },
    'application/pgp-encrypted': { source: 'iana', compressible: !1, extensions: ['pgp'] },
    'application/pgp-keys': { source: 'iana', extensions: ['asc'] },
    'application/pgp-signature': { source: 'iana', extensions: ['asc', 'sig'] },
    'application/pics-rules': { source: 'apache', extensions: ['prf'] },
    'application/pidf+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/pidf-diff+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/pkcs10': { source: 'iana', extensions: ['p10'] },
    'application/pkcs12': { source: 'iana' },
    'application/pkcs7-mime': { source: 'iana', extensions: ['p7m', 'p7c'] },
    'application/pkcs7-signature': { source: 'iana', extensions: ['p7s'] },
    'application/pkcs8': { source: 'iana', extensions: ['p8'] },
    'application/pkcs8-encrypted': { source: 'iana' },
    'application/pkix-attr-cert': { source: 'iana', extensions: ['ac'] },
    'application/pkix-cert': { source: 'iana', extensions: ['cer'] },
    'application/pkix-crl': { source: 'iana', extensions: ['crl'] },
    'application/pkix-pkipath': { source: 'iana', extensions: ['pkipath'] },
    'application/pkixcmp': { source: 'iana', extensions: ['pki'] },
    'application/pls+xml': { source: 'iana', compressible: !0, extensions: ['pls'] },
    'application/poc-settings+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/postscript': { source: 'iana', compressible: !0, extensions: ['ai', 'eps', 'ps'] },
    'application/ppsp-tracker+json': { source: 'iana', compressible: !0 },
    'application/problem+json': { source: 'iana', compressible: !0 },
    'application/problem+xml': { source: 'iana', compressible: !0 },
    'application/provenance+xml': { source: 'iana', compressible: !0, extensions: ['provx'] },
    'application/prs.alvestrand.titrax-sheet': { source: 'iana' },
    'application/prs.cww': { source: 'iana', extensions: ['cww'] },
    'application/prs.cyn': { source: 'iana', charset: '7-BIT' },
    'application/prs.hpub+zip': { source: 'iana', compressible: !1 },
    'application/prs.nprend': { source: 'iana' },
    'application/prs.plucker': { source: 'iana' },
    'application/prs.rdf-xml-crypt': { source: 'iana' },
    'application/prs.xsf+xml': { source: 'iana', compressible: !0 },
    'application/pskc+xml': { source: 'iana', compressible: !0, extensions: ['pskcxml'] },
    'application/pvd+json': { source: 'iana', compressible: !0 },
    'application/qsig': { source: 'iana' },
    'application/raml+yaml': { compressible: !0, extensions: ['raml'] },
    'application/raptorfec': { source: 'iana' },
    'application/rdap+json': { source: 'iana', compressible: !0 },
    'application/rdf+xml': { source: 'iana', compressible: !0, extensions: ['rdf', 'owl'] },
    'application/reginfo+xml': { source: 'iana', compressible: !0, extensions: ['rif'] },
    'application/relax-ng-compact-syntax': { source: 'iana', extensions: ['rnc'] },
    'application/remote-printing': { source: 'iana' },
    'application/reputon+json': { source: 'iana', compressible: !0 },
    'application/resource-lists+xml': { source: 'iana', compressible: !0, extensions: ['rl'] },
    'application/resource-lists-diff+xml': { source: 'iana', compressible: !0, extensions: ['rld'] },
    'application/rfc+xml': { source: 'iana', compressible: !0 },
    'application/riscos': { source: 'iana' },
    'application/rlmi+xml': { source: 'iana', compressible: !0 },
    'application/rls-services+xml': { source: 'iana', compressible: !0, extensions: ['rs'] },
    'application/route-apd+xml': { source: 'iana', compressible: !0, extensions: ['rapd'] },
    'application/route-s-tsid+xml': { source: 'iana', compressible: !0, extensions: ['sls'] },
    'application/route-usd+xml': { source: 'iana', compressible: !0, extensions: ['rusd'] },
    'application/rpki-ghostbusters': { source: 'iana', extensions: ['gbr'] },
    'application/rpki-manifest': { source: 'iana', extensions: ['mft'] },
    'application/rpki-publication': { source: 'iana' },
    'application/rpki-roa': { source: 'iana', extensions: ['roa'] },
    'application/rpki-updown': { source: 'iana' },
    'application/rsd+xml': { source: 'apache', compressible: !0, extensions: ['rsd'] },
    'application/rss+xml': { source: 'apache', compressible: !0, extensions: ['rss'] },
    'application/rtf': { source: 'iana', compressible: !0, extensions: ['rtf'] },
    'application/rtploopback': { source: 'iana' },
    'application/rtx': { source: 'iana' },
    'application/samlassertion+xml': { source: 'iana', compressible: !0 },
    'application/samlmetadata+xml': { source: 'iana', compressible: !0 },
    'application/sarif+json': { source: 'iana', compressible: !0 },
    'application/sarif-external-properties+json': { source: 'iana', compressible: !0 },
    'application/sbe': { source: 'iana' },
    'application/sbml+xml': { source: 'iana', compressible: !0, extensions: ['sbml'] },
    'application/scaip+xml': { source: 'iana', compressible: !0 },
    'application/scim+json': { source: 'iana', compressible: !0 },
    'application/scvp-cv-request': { source: 'iana', extensions: ['scq'] },
    'application/scvp-cv-response': { source: 'iana', extensions: ['scs'] },
    'application/scvp-vp-request': { source: 'iana', extensions: ['spq'] },
    'application/scvp-vp-response': { source: 'iana', extensions: ['spp'] },
    'application/sdp': { source: 'iana', extensions: ['sdp'] },
    'application/secevent+jwt': { source: 'iana' },
    'application/senml+cbor': { source: 'iana' },
    'application/senml+json': { source: 'iana', compressible: !0 },
    'application/senml+xml': { source: 'iana', compressible: !0, extensions: ['senmlx'] },
    'application/senml-etch+cbor': { source: 'iana' },
    'application/senml-etch+json': { source: 'iana', compressible: !0 },
    'application/senml-exi': { source: 'iana' },
    'application/sensml+cbor': { source: 'iana' },
    'application/sensml+json': { source: 'iana', compressible: !0 },
    'application/sensml+xml': { source: 'iana', compressible: !0, extensions: ['sensmlx'] },
    'application/sensml-exi': { source: 'iana' },
    'application/sep+xml': { source: 'iana', compressible: !0 },
    'application/sep-exi': { source: 'iana' },
    'application/session-info': { source: 'iana' },
    'application/set-payment': { source: 'iana' },
    'application/set-payment-initiation': { source: 'iana', extensions: ['setpay'] },
    'application/set-registration': { source: 'iana' },
    'application/set-registration-initiation': { source: 'iana', extensions: ['setreg'] },
    'application/sgml': { source: 'iana' },
    'application/sgml-open-catalog': { source: 'iana' },
    'application/shf+xml': { source: 'iana', compressible: !0, extensions: ['shf'] },
    'application/sieve': { source: 'iana', extensions: ['siv', 'sieve'] },
    'application/simple-filter+xml': { source: 'iana', compressible: !0 },
    'application/simple-message-summary': { source: 'iana' },
    'application/simplesymbolcontainer': { source: 'iana' },
    'application/sipc': { source: 'iana' },
    'application/slate': { source: 'iana' },
    'application/smil': { source: 'iana' },
    'application/smil+xml': { source: 'iana', compressible: !0, extensions: ['smi', 'smil'] },
    'application/smpte336m': { source: 'iana' },
    'application/soap+fastinfoset': { source: 'iana' },
    'application/soap+xml': { source: 'iana', compressible: !0 },
    'application/sparql-query': { source: 'iana', extensions: ['rq'] },
    'application/sparql-results+xml': { source: 'iana', compressible: !0, extensions: ['srx'] },
    'application/spdx+json': { source: 'iana', compressible: !0 },
    'application/spirits-event+xml': { source: 'iana', compressible: !0 },
    'application/sql': { source: 'iana' },
    'application/srgs': { source: 'iana', extensions: ['gram'] },
    'application/srgs+xml': { source: 'iana', compressible: !0, extensions: ['grxml'] },
    'application/sru+xml': { source: 'iana', compressible: !0, extensions: ['sru'] },
    'application/ssdl+xml': { source: 'apache', compressible: !0, extensions: ['ssdl'] },
    'application/ssml+xml': { source: 'iana', compressible: !0, extensions: ['ssml'] },
    'application/stix+json': { source: 'iana', compressible: !0 },
    'application/swid+xml': { source: 'iana', compressible: !0, extensions: ['swidtag'] },
    'application/tamp-apex-update': { source: 'iana' },
    'application/tamp-apex-update-confirm': { source: 'iana' },
    'application/tamp-community-update': { source: 'iana' },
    'application/tamp-community-update-confirm': { source: 'iana' },
    'application/tamp-error': { source: 'iana' },
    'application/tamp-sequence-adjust': { source: 'iana' },
    'application/tamp-sequence-adjust-confirm': { source: 'iana' },
    'application/tamp-status-query': { source: 'iana' },
    'application/tamp-status-response': { source: 'iana' },
    'application/tamp-update': { source: 'iana' },
    'application/tamp-update-confirm': { source: 'iana' },
    'application/tar': { compressible: !0 },
    'application/taxii+json': { source: 'iana', compressible: !0 },
    'application/td+json': { source: 'iana', compressible: !0 },
    'application/tei+xml': { source: 'iana', compressible: !0, extensions: ['tei', 'teicorpus'] },
    'application/tetra_isi': { source: 'iana' },
    'application/thraud+xml': { source: 'iana', compressible: !0, extensions: ['tfi'] },
    'application/timestamp-query': { source: 'iana' },
    'application/timestamp-reply': { source: 'iana' },
    'application/timestamped-data': { source: 'iana', extensions: ['tsd'] },
    'application/tlsrpt+gzip': { source: 'iana' },
    'application/tlsrpt+json': { source: 'iana', compressible: !0 },
    'application/tnauthlist': { source: 'iana' },
    'application/token-introspection+jwt': { source: 'iana' },
    'application/toml': { compressible: !0, extensions: ['toml'] },
    'application/trickle-ice-sdpfrag': { source: 'iana' },
    'application/trig': { source: 'iana', extensions: ['trig'] },
    'application/ttml+xml': { source: 'iana', compressible: !0, extensions: ['ttml'] },
    'application/tve-trigger': { source: 'iana' },
    'application/tzif': { source: 'iana' },
    'application/tzif-leap': { source: 'iana' },
    'application/ubjson': { compressible: !1, extensions: ['ubj'] },
    'application/ulpfec': { source: 'iana' },
    'application/urc-grpsheet+xml': { source: 'iana', compressible: !0 },
    'application/urc-ressheet+xml': { source: 'iana', compressible: !0, extensions: ['rsheet'] },
    'application/urc-targetdesc+xml': { source: 'iana', compressible: !0, extensions: ['td'] },
    'application/urc-uisocketdesc+xml': { source: 'iana', compressible: !0 },
    'application/vcard+json': { source: 'iana', compressible: !0 },
    'application/vcard+xml': { source: 'iana', compressible: !0 },
    'application/vemmi': { source: 'iana' },
    'application/vividence.scriptfile': { source: 'apache' },
    'application/vnd.1000minds.decision-model+xml': { source: 'iana', compressible: !0, extensions: ['1km'] },
    'application/vnd.3gpp-prose+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp-prose-pc3ch+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp-v2x-local-service-information': { source: 'iana' },
    'application/vnd.3gpp.5gnas': { source: 'iana' },
    'application/vnd.3gpp.access-transfer-events+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.bsf+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.gmop+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.gtpc': { source: 'iana' },
    'application/vnd.3gpp.interworking-data': { source: 'iana' },
    'application/vnd.3gpp.lpp': { source: 'iana' },
    'application/vnd.3gpp.mc-signalling-ear': { source: 'iana' },
    'application/vnd.3gpp.mcdata-affiliation-command+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcdata-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcdata-payload': { source: 'iana' },
    'application/vnd.3gpp.mcdata-service-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcdata-signalling': { source: 'iana' },
    'application/vnd.3gpp.mcdata-ue-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcdata-user-profile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-affiliation-command+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-floor-request+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-location-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-mbms-usage-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-service-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-signed+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-ue-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-ue-init-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-user-profile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-affiliation-command+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-affiliation-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-location-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-mbms-usage-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-service-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-transmission-request+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-ue-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-user-profile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mid-call+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.ngap': { source: 'iana' },
    'application/vnd.3gpp.pfcp': { source: 'iana' },
    'application/vnd.3gpp.pic-bw-large': { source: 'iana', extensions: ['plb'] },
    'application/vnd.3gpp.pic-bw-small': { source: 'iana', extensions: ['psb'] },
    'application/vnd.3gpp.pic-bw-var': { source: 'iana', extensions: ['pvb'] },
    'application/vnd.3gpp.s1ap': { source: 'iana' },
    'application/vnd.3gpp.sms': { source: 'iana' },
    'application/vnd.3gpp.sms+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.srvcc-ext+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.srvcc-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.state-and-event-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.ussd+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp2.bcmcsinfo+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp2.sms': { source: 'iana' },
    'application/vnd.3gpp2.tcap': { source: 'iana', extensions: ['tcap'] },
    'application/vnd.3lightssoftware.imagescal': { source: 'iana' },
    'application/vnd.3m.post-it-notes': { source: 'iana', extensions: ['pwn'] },
    'application/vnd.accpac.simply.aso': { source: 'iana', extensions: ['aso'] },
    'application/vnd.accpac.simply.imp': { source: 'iana', extensions: ['imp'] },
    'application/vnd.acucobol': { source: 'iana', extensions: ['acu'] },
    'application/vnd.acucorp': { source: 'iana', extensions: ['atc', 'acutc'] },
    'application/vnd.adobe.air-application-installer-package+zip': {
      source: 'apache',
      compressible: !1,
      extensions: ['air'],
    },
    'application/vnd.adobe.flash.movie': { source: 'iana' },
    'application/vnd.adobe.formscentral.fcdt': { source: 'iana', extensions: ['fcdt'] },
    'application/vnd.adobe.fxp': { source: 'iana', extensions: ['fxp', 'fxpl'] },
    'application/vnd.adobe.partial-upload': { source: 'iana' },
    'application/vnd.adobe.xdp+xml': { source: 'iana', compressible: !0, extensions: ['xdp'] },
    'application/vnd.adobe.xfdf': { source: 'iana', extensions: ['xfdf'] },
    'application/vnd.aether.imp': { source: 'iana' },
    'application/vnd.afpc.afplinedata': { source: 'iana' },
    'application/vnd.afpc.afplinedata-pagedef': { source: 'iana' },
    'application/vnd.afpc.cmoca-cmresource': { source: 'iana' },
    'application/vnd.afpc.foca-charset': { source: 'iana' },
    'application/vnd.afpc.foca-codedfont': { source: 'iana' },
    'application/vnd.afpc.foca-codepage': { source: 'iana' },
    'application/vnd.afpc.modca': { source: 'iana' },
    'application/vnd.afpc.modca-cmtable': { source: 'iana' },
    'application/vnd.afpc.modca-formdef': { source: 'iana' },
    'application/vnd.afpc.modca-mediummap': { source: 'iana' },
    'application/vnd.afpc.modca-objectcontainer': { source: 'iana' },
    'application/vnd.afpc.modca-overlay': { source: 'iana' },
    'application/vnd.afpc.modca-pagesegment': { source: 'iana' },
    'application/vnd.age': { source: 'iana', extensions: ['age'] },
    'application/vnd.ah-barcode': { source: 'iana' },
    'application/vnd.ahead.space': { source: 'iana', extensions: ['ahead'] },
    'application/vnd.airzip.filesecure.azf': { source: 'iana', extensions: ['azf'] },
    'application/vnd.airzip.filesecure.azs': { source: 'iana', extensions: ['azs'] },
    'application/vnd.amadeus+json': { source: 'iana', compressible: !0 },
    'application/vnd.amazon.ebook': { source: 'apache', extensions: ['azw'] },
    'application/vnd.amazon.mobi8-ebook': { source: 'iana' },
    'application/vnd.americandynamics.acc': { source: 'iana', extensions: ['acc'] },
    'application/vnd.amiga.ami': { source: 'iana', extensions: ['ami'] },
    'application/vnd.amundsen.maze+xml': { source: 'iana', compressible: !0 },
    'application/vnd.android.ota': { source: 'iana' },
    'application/vnd.android.package-archive': { source: 'apache', compressible: !1, extensions: ['apk'] },
    'application/vnd.anki': { source: 'iana' },
    'application/vnd.anser-web-certificate-issue-initiation': { source: 'iana', extensions: ['cii'] },
    'application/vnd.anser-web-funds-transfer-initiation': { source: 'apache', extensions: ['fti'] },
    'application/vnd.antix.game-component': { source: 'iana', extensions: ['atx'] },
    'application/vnd.apache.arrow.file': { source: 'iana' },
    'application/vnd.apache.arrow.stream': { source: 'iana' },
    'application/vnd.apache.thrift.binary': { source: 'iana' },
    'application/vnd.apache.thrift.compact': { source: 'iana' },
    'application/vnd.apache.thrift.json': { source: 'iana' },
    'application/vnd.api+json': { source: 'iana', compressible: !0 },
    'application/vnd.aplextor.warrp+json': { source: 'iana', compressible: !0 },
    'application/vnd.apothekende.reservation+json': { source: 'iana', compressible: !0 },
    'application/vnd.apple.installer+xml': { source: 'iana', compressible: !0, extensions: ['mpkg'] },
    'application/vnd.apple.keynote': { source: 'iana', extensions: ['key'] },
    'application/vnd.apple.mpegurl': { source: 'iana', extensions: ['m3u8'] },
    'application/vnd.apple.numbers': { source: 'iana', extensions: ['numbers'] },
    'application/vnd.apple.pages': { source: 'iana', extensions: ['pages'] },
    'application/vnd.apple.pkpass': { compressible: !1, extensions: ['pkpass'] },
    'application/vnd.arastra.swi': { source: 'iana' },
    'application/vnd.aristanetworks.swi': { source: 'iana', extensions: ['swi'] },
    'application/vnd.artisan+json': { source: 'iana', compressible: !0 },
    'application/vnd.artsquare': { source: 'iana' },
    'application/vnd.astraea-software.iota': { source: 'iana', extensions: ['iota'] },
    'application/vnd.audiograph': { source: 'iana', extensions: ['aep'] },
    'application/vnd.autopackage': { source: 'iana' },
    'application/vnd.avalon+json': { source: 'iana', compressible: !0 },
    'application/vnd.avistar+xml': { source: 'iana', compressible: !0 },
    'application/vnd.balsamiq.bmml+xml': { source: 'iana', compressible: !0, extensions: ['bmml'] },
    'application/vnd.balsamiq.bmpr': { source: 'iana' },
    'application/vnd.banana-accounting': { source: 'iana' },
    'application/vnd.bbf.usp.error': { source: 'iana' },
    'application/vnd.bbf.usp.msg': { source: 'iana' },
    'application/vnd.bbf.usp.msg+json': { source: 'iana', compressible: !0 },
    'application/vnd.bekitzur-stech+json': { source: 'iana', compressible: !0 },
    'application/vnd.bint.med-content': { source: 'iana' },
    'application/vnd.biopax.rdf+xml': { source: 'iana', compressible: !0 },
    'application/vnd.blink-idb-value-wrapper': { source: 'iana' },
    'application/vnd.blueice.multipass': { source: 'iana', extensions: ['mpm'] },
    'application/vnd.bluetooth.ep.oob': { source: 'iana' },
    'application/vnd.bluetooth.le.oob': { source: 'iana' },
    'application/vnd.bmi': { source: 'iana', extensions: ['bmi'] },
    'application/vnd.bpf': { source: 'iana' },
    'application/vnd.bpf3': { source: 'iana' },
    'application/vnd.businessobjects': { source: 'iana', extensions: ['rep'] },
    'application/vnd.byu.uapi+json': { source: 'iana', compressible: !0 },
    'application/vnd.cab-jscript': { source: 'iana' },
    'application/vnd.canon-cpdl': { source: 'iana' },
    'application/vnd.canon-lips': { source: 'iana' },
    'application/vnd.capasystems-pg+json': { source: 'iana', compressible: !0 },
    'application/vnd.cendio.thinlinc.clientconf': { source: 'iana' },
    'application/vnd.century-systems.tcp_stream': { source: 'iana' },
    'application/vnd.chemdraw+xml': { source: 'iana', compressible: !0, extensions: ['cdxml'] },
    'application/vnd.chess-pgn': { source: 'iana' },
    'application/vnd.chipnuts.karaoke-mmd': { source: 'iana', extensions: ['mmd'] },
    'application/vnd.ciedi': { source: 'iana' },
    'application/vnd.cinderella': { source: 'iana', extensions: ['cdy'] },
    'application/vnd.cirpack.isdn-ext': { source: 'iana' },
    'application/vnd.citationstyles.style+xml': { source: 'iana', compressible: !0, extensions: ['csl'] },
    'application/vnd.claymore': { source: 'iana', extensions: ['cla'] },
    'application/vnd.cloanto.rp9': { source: 'iana', extensions: ['rp9'] },
    'application/vnd.clonk.c4group': { source: 'iana', extensions: ['c4g', 'c4d', 'c4f', 'c4p', 'c4u'] },
    'application/vnd.cluetrust.cartomobile-config': { source: 'iana', extensions: ['c11amc'] },
    'application/vnd.cluetrust.cartomobile-config-pkg': { source: 'iana', extensions: ['c11amz'] },
    'application/vnd.coffeescript': { source: 'iana' },
    'application/vnd.collabio.xodocuments.document': { source: 'iana' },
    'application/vnd.collabio.xodocuments.document-template': { source: 'iana' },
    'application/vnd.collabio.xodocuments.presentation': { source: 'iana' },
    'application/vnd.collabio.xodocuments.presentation-template': { source: 'iana' },
    'application/vnd.collabio.xodocuments.spreadsheet': { source: 'iana' },
    'application/vnd.collabio.xodocuments.spreadsheet-template': { source: 'iana' },
    'application/vnd.collection+json': { source: 'iana', compressible: !0 },
    'application/vnd.collection.doc+json': { source: 'iana', compressible: !0 },
    'application/vnd.collection.next+json': { source: 'iana', compressible: !0 },
    'application/vnd.comicbook+zip': { source: 'iana', compressible: !1 },
    'application/vnd.comicbook-rar': { source: 'iana' },
    'application/vnd.commerce-battelle': { source: 'iana' },
    'application/vnd.commonspace': { source: 'iana', extensions: ['csp'] },
    'application/vnd.contact.cmsg': { source: 'iana', extensions: ['cdbcmsg'] },
    'application/vnd.coreos.ignition+json': { source: 'iana', compressible: !0 },
    'application/vnd.cosmocaller': { source: 'iana', extensions: ['cmc'] },
    'application/vnd.crick.clicker': { source: 'iana', extensions: ['clkx'] },
    'application/vnd.crick.clicker.keyboard': { source: 'iana', extensions: ['clkk'] },
    'application/vnd.crick.clicker.palette': { source: 'iana', extensions: ['clkp'] },
    'application/vnd.crick.clicker.template': { source: 'iana', extensions: ['clkt'] },
    'application/vnd.crick.clicker.wordbank': { source: 'iana', extensions: ['clkw'] },
    'application/vnd.criticaltools.wbs+xml': { source: 'iana', compressible: !0, extensions: ['wbs'] },
    'application/vnd.cryptii.pipe+json': { source: 'iana', compressible: !0 },
    'application/vnd.crypto-shade-file': { source: 'iana' },
    'application/vnd.cryptomator.encrypted': { source: 'iana' },
    'application/vnd.cryptomator.vault': { source: 'iana' },
    'application/vnd.ctc-posml': { source: 'iana', extensions: ['pml'] },
    'application/vnd.ctct.ws+xml': { source: 'iana', compressible: !0 },
    'application/vnd.cups-pdf': { source: 'iana' },
    'application/vnd.cups-postscript': { source: 'iana' },
    'application/vnd.cups-ppd': { source: 'iana', extensions: ['ppd'] },
    'application/vnd.cups-raster': { source: 'iana' },
    'application/vnd.cups-raw': { source: 'iana' },
    'application/vnd.curl': { source: 'iana' },
    'application/vnd.curl.car': { source: 'apache', extensions: ['car'] },
    'application/vnd.curl.pcurl': { source: 'apache', extensions: ['pcurl'] },
    'application/vnd.cyan.dean.root+xml': { source: 'iana', compressible: !0 },
    'application/vnd.cybank': { source: 'iana' },
    'application/vnd.cyclonedx+json': { source: 'iana', compressible: !0 },
    'application/vnd.cyclonedx+xml': { source: 'iana', compressible: !0 },
    'application/vnd.d2l.coursepackage1p0+zip': { source: 'iana', compressible: !1 },
    'application/vnd.d3m-dataset': { source: 'iana' },
    'application/vnd.d3m-problem': { source: 'iana' },
    'application/vnd.dart': { source: 'iana', compressible: !0, extensions: ['dart'] },
    'application/vnd.data-vision.rdz': { source: 'iana', extensions: ['rdz'] },
    'application/vnd.datapackage+json': { source: 'iana', compressible: !0 },
    'application/vnd.dataresource+json': { source: 'iana', compressible: !0 },
    'application/vnd.dbf': { source: 'iana', extensions: ['dbf'] },
    'application/vnd.debian.binary-package': { source: 'iana' },
    'application/vnd.dece.data': { source: 'iana', extensions: ['uvf', 'uvvf', 'uvd', 'uvvd'] },
    'application/vnd.dece.ttml+xml': { source: 'iana', compressible: !0, extensions: ['uvt', 'uvvt'] },
    'application/vnd.dece.unspecified': { source: 'iana', extensions: ['uvx', 'uvvx'] },
    'application/vnd.dece.zip': { source: 'iana', extensions: ['uvz', 'uvvz'] },
    'application/vnd.denovo.fcselayout-link': { source: 'iana', extensions: ['fe_launch'] },
    'application/vnd.desmume.movie': { source: 'iana' },
    'application/vnd.dir-bi.plate-dl-nosuffix': { source: 'iana' },
    'application/vnd.dm.delegation+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dna': { source: 'iana', extensions: ['dna'] },
    'application/vnd.document+json': { source: 'iana', compressible: !0 },
    'application/vnd.dolby.mlp': { source: 'apache', extensions: ['mlp'] },
    'application/vnd.dolby.mobile.1': { source: 'iana' },
    'application/vnd.dolby.mobile.2': { source: 'iana' },
    'application/vnd.doremir.scorecloud-binary-document': { source: 'iana' },
    'application/vnd.dpgraph': { source: 'iana', extensions: ['dpg'] },
    'application/vnd.dreamfactory': { source: 'iana', extensions: ['dfac'] },
    'application/vnd.drive+json': { source: 'iana', compressible: !0 },
    'application/vnd.ds-keypoint': { source: 'apache', extensions: ['kpxx'] },
    'application/vnd.dtg.local': { source: 'iana' },
    'application/vnd.dtg.local.flash': { source: 'iana' },
    'application/vnd.dtg.local.html': { source: 'iana' },
    'application/vnd.dvb.ait': { source: 'iana', extensions: ['ait'] },
    'application/vnd.dvb.dvbisl+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.dvbj': { source: 'iana' },
    'application/vnd.dvb.esgcontainer': { source: 'iana' },
    'application/vnd.dvb.ipdcdftnotifaccess': { source: 'iana' },
    'application/vnd.dvb.ipdcesgaccess': { source: 'iana' },
    'application/vnd.dvb.ipdcesgaccess2': { source: 'iana' },
    'application/vnd.dvb.ipdcesgpdd': { source: 'iana' },
    'application/vnd.dvb.ipdcroaming': { source: 'iana' },
    'application/vnd.dvb.iptv.alfec-base': { source: 'iana' },
    'application/vnd.dvb.iptv.alfec-enhancement': { source: 'iana' },
    'application/vnd.dvb.notif-aggregate-root+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-container+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-generic+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-ia-msglist+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-ia-registration-request+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-ia-registration-response+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-init+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.pfr': { source: 'iana' },
    'application/vnd.dvb.service': { source: 'iana', extensions: ['svc'] },
    'application/vnd.dxr': { source: 'iana' },
    'application/vnd.dynageo': { source: 'iana', extensions: ['geo'] },
    'application/vnd.dzr': { source: 'iana' },
    'application/vnd.easykaraoke.cdgdownload': { source: 'iana' },
    'application/vnd.ecdis-update': { source: 'iana' },
    'application/vnd.ecip.rlp': { source: 'iana' },
    'application/vnd.eclipse.ditto+json': { source: 'iana', compressible: !0 },
    'application/vnd.ecowin.chart': { source: 'iana', extensions: ['mag'] },
    'application/vnd.ecowin.filerequest': { source: 'iana' },
    'application/vnd.ecowin.fileupdate': { source: 'iana' },
    'application/vnd.ecowin.series': { source: 'iana' },
    'application/vnd.ecowin.seriesrequest': { source: 'iana' },
    'application/vnd.ecowin.seriesupdate': { source: 'iana' },
    'application/vnd.efi.img': { source: 'iana' },
    'application/vnd.efi.iso': { source: 'iana' },
    'application/vnd.emclient.accessrequest+xml': { source: 'iana', compressible: !0 },
    'application/vnd.enliven': { source: 'iana', extensions: ['nml'] },
    'application/vnd.enphase.envoy': { source: 'iana' },
    'application/vnd.eprints.data+xml': { source: 'iana', compressible: !0 },
    'application/vnd.epson.esf': { source: 'iana', extensions: ['esf'] },
    'application/vnd.epson.msf': { source: 'iana', extensions: ['msf'] },
    'application/vnd.epson.quickanime': { source: 'iana', extensions: ['qam'] },
    'application/vnd.epson.salt': { source: 'iana', extensions: ['slt'] },
    'application/vnd.epson.ssf': { source: 'iana', extensions: ['ssf'] },
    'application/vnd.ericsson.quickcall': { source: 'iana' },
    'application/vnd.espass-espass+zip': { source: 'iana', compressible: !1 },
    'application/vnd.eszigno3+xml': { source: 'iana', compressible: !0, extensions: ['es3', 'et3'] },
    'application/vnd.etsi.aoc+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.asic-e+zip': { source: 'iana', compressible: !1 },
    'application/vnd.etsi.asic-s+zip': { source: 'iana', compressible: !1 },
    'application/vnd.etsi.cug+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvcommand+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvdiscovery+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvprofile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvsad-bc+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvsad-cod+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvsad-npvr+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvservice+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvsync+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvueprofile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.mcid+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.mheg5': { source: 'iana' },
    'application/vnd.etsi.overload-control-policy-dataset+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.pstn+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.sci+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.simservs+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.timestamp-token': { source: 'iana' },
    'application/vnd.etsi.tsl+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.tsl.der': { source: 'iana' },
    'application/vnd.eu.kasparian.car+json': { source: 'iana', compressible: !0 },
    'application/vnd.eudora.data': { source: 'iana' },
    'application/vnd.evolv.ecig.profile': { source: 'iana' },
    'application/vnd.evolv.ecig.settings': { source: 'iana' },
    'application/vnd.evolv.ecig.theme': { source: 'iana' },
    'application/vnd.exstream-empower+zip': { source: 'iana', compressible: !1 },
    'application/vnd.exstream-package': { source: 'iana' },
    'application/vnd.ezpix-album': { source: 'iana', extensions: ['ez2'] },
    'application/vnd.ezpix-package': { source: 'iana', extensions: ['ez3'] },
    'application/vnd.f-secure.mobile': { source: 'iana' },
    'application/vnd.familysearch.gedcom+zip': { source: 'iana', compressible: !1 },
    'application/vnd.fastcopy-disk-image': { source: 'iana' },
    'application/vnd.fdf': { source: 'iana', extensions: ['fdf'] },
    'application/vnd.fdsn.mseed': { source: 'iana', extensions: ['mseed'] },
    'application/vnd.fdsn.seed': { source: 'iana', extensions: ['seed', 'dataless'] },
    'application/vnd.ffsns': { source: 'iana' },
    'application/vnd.ficlab.flb+zip': { source: 'iana', compressible: !1 },
    'application/vnd.filmit.zfc': { source: 'iana' },
    'application/vnd.fints': { source: 'iana' },
    'application/vnd.firemonkeys.cloudcell': { source: 'iana' },
    'application/vnd.flographit': { source: 'iana', extensions: ['gph'] },
    'application/vnd.fluxtime.clip': { source: 'iana', extensions: ['ftc'] },
    'application/vnd.font-fontforge-sfd': { source: 'iana' },
    'application/vnd.framemaker': { source: 'iana', extensions: ['fm', 'frame', 'maker', 'book'] },
    'application/vnd.frogans.fnc': { source: 'iana', extensions: ['fnc'] },
    'application/vnd.frogans.ltf': { source: 'iana', extensions: ['ltf'] },
    'application/vnd.fsc.weblaunch': { source: 'iana', extensions: ['fsc'] },
    'application/vnd.fujifilm.fb.docuworks': { source: 'iana' },
    'application/vnd.fujifilm.fb.docuworks.binder': { source: 'iana' },
    'application/vnd.fujifilm.fb.docuworks.container': { source: 'iana' },
    'application/vnd.fujifilm.fb.jfi+xml': { source: 'iana', compressible: !0 },
    'application/vnd.fujitsu.oasys': { source: 'iana', extensions: ['oas'] },
    'application/vnd.fujitsu.oasys2': { source: 'iana', extensions: ['oa2'] },
    'application/vnd.fujitsu.oasys3': { source: 'iana', extensions: ['oa3'] },
    'application/vnd.fujitsu.oasysgp': { source: 'iana', extensions: ['fg5'] },
    'application/vnd.fujitsu.oasysprs': { source: 'iana', extensions: ['bh2'] },
    'application/vnd.fujixerox.art-ex': { source: 'iana' },
    'application/vnd.fujixerox.art4': { source: 'iana' },
    'application/vnd.fujixerox.ddd': { source: 'iana', extensions: ['ddd'] },
    'application/vnd.fujixerox.docuworks': { source: 'iana', extensions: ['xdw'] },
    'application/vnd.fujixerox.docuworks.binder': { source: 'iana', extensions: ['xbd'] },
    'application/vnd.fujixerox.docuworks.container': { source: 'iana' },
    'application/vnd.fujixerox.hbpl': { source: 'iana' },
    'application/vnd.fut-misnet': { source: 'iana' },
    'application/vnd.futoin+cbor': { source: 'iana' },
    'application/vnd.futoin+json': { source: 'iana', compressible: !0 },
    'application/vnd.fuzzysheet': { source: 'iana', extensions: ['fzs'] },
    'application/vnd.genomatix.tuxedo': { source: 'iana', extensions: ['txd'] },
    'application/vnd.gentics.grd+json': { source: 'iana', compressible: !0 },
    'application/vnd.geo+json': { source: 'iana', compressible: !0 },
    'application/vnd.geocube+xml': { source: 'iana', compressible: !0 },
    'application/vnd.geogebra.file': { source: 'iana', extensions: ['ggb'] },
    'application/vnd.geogebra.slides': { source: 'iana' },
    'application/vnd.geogebra.tool': { source: 'iana', extensions: ['ggt'] },
    'application/vnd.geometry-explorer': { source: 'iana', extensions: ['gex', 'gre'] },
    'application/vnd.geonext': { source: 'iana', extensions: ['gxt'] },
    'application/vnd.geoplan': { source: 'iana', extensions: ['g2w'] },
    'application/vnd.geospace': { source: 'iana', extensions: ['g3w'] },
    'application/vnd.gerber': { source: 'iana' },
    'application/vnd.globalplatform.card-content-mgt': { source: 'iana' },
    'application/vnd.globalplatform.card-content-mgt-response': { source: 'iana' },
    'application/vnd.gmx': { source: 'iana', extensions: ['gmx'] },
    'application/vnd.google-apps.document': { compressible: !1, extensions: ['gdoc'] },
    'application/vnd.google-apps.presentation': { compressible: !1, extensions: ['gslides'] },
    'application/vnd.google-apps.spreadsheet': { compressible: !1, extensions: ['gsheet'] },
    'application/vnd.google-earth.kml+xml': { source: 'iana', compressible: !0, extensions: ['kml'] },
    'application/vnd.google-earth.kmz': { source: 'iana', compressible: !1, extensions: ['kmz'] },
    'application/vnd.gov.sk.e-form+xml': { source: 'iana', compressible: !0 },
    'application/vnd.gov.sk.e-form+zip': { source: 'iana', compressible: !1 },
    'application/vnd.gov.sk.xmldatacontainer+xml': { source: 'iana', compressible: !0 },
    'application/vnd.grafeq': { source: 'iana', extensions: ['gqf', 'gqs'] },
    'application/vnd.gridmp': { source: 'iana' },
    'application/vnd.groove-account': { source: 'iana', extensions: ['gac'] },
    'application/vnd.groove-help': { source: 'iana', extensions: ['ghf'] },
    'application/vnd.groove-identity-message': { source: 'iana', extensions: ['gim'] },
    'application/vnd.groove-injector': { source: 'iana', extensions: ['grv'] },
    'application/vnd.groove-tool-message': { source: 'iana', extensions: ['gtm'] },
    'application/vnd.groove-tool-template': { source: 'iana', extensions: ['tpl'] },
    'application/vnd.groove-vcard': { source: 'iana', extensions: ['vcg'] },
    'application/vnd.hal+json': { source: 'iana', compressible: !0 },
    'application/vnd.hal+xml': { source: 'iana', compressible: !0, extensions: ['hal'] },
    'application/vnd.handheld-entertainment+xml': { source: 'iana', compressible: !0, extensions: ['zmm'] },
    'application/vnd.hbci': { source: 'iana', extensions: ['hbci'] },
    'application/vnd.hc+json': { source: 'iana', compressible: !0 },
    'application/vnd.hcl-bireports': { source: 'iana' },
    'application/vnd.hdt': { source: 'iana' },
    'application/vnd.heroku+json': { source: 'iana', compressible: !0 },
    'application/vnd.hhe.lesson-player': { source: 'iana', extensions: ['les'] },
    'application/vnd.hl7cda+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.hl7v2+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.hp-hpgl': { source: 'iana', extensions: ['hpgl'] },
    'application/vnd.hp-hpid': { source: 'iana', extensions: ['hpid'] },
    'application/vnd.hp-hps': { source: 'iana', extensions: ['hps'] },
    'application/vnd.hp-jlyt': { source: 'iana', extensions: ['jlt'] },
    'application/vnd.hp-pcl': { source: 'iana', extensions: ['pcl'] },
    'application/vnd.hp-pclxl': { source: 'iana', extensions: ['pclxl'] },
    'application/vnd.httphone': { source: 'iana' },
    'application/vnd.hydrostatix.sof-data': { source: 'iana', extensions: ['sfd-hdstx'] },
    'application/vnd.hyper+json': { source: 'iana', compressible: !0 },
    'application/vnd.hyper-item+json': { source: 'iana', compressible: !0 },
    'application/vnd.hyperdrive+json': { source: 'iana', compressible: !0 },
    'application/vnd.hzn-3d-crossword': { source: 'iana' },
    'application/vnd.ibm.afplinedata': { source: 'iana' },
    'application/vnd.ibm.electronic-media': { source: 'iana' },
    'application/vnd.ibm.minipay': { source: 'iana', extensions: ['mpy'] },
    'application/vnd.ibm.modcap': { source: 'iana', extensions: ['afp', 'listafp', 'list3820'] },
    'application/vnd.ibm.rights-management': { source: 'iana', extensions: ['irm'] },
    'application/vnd.ibm.secure-container': { source: 'iana', extensions: ['sc'] },
    'application/vnd.iccprofile': { source: 'iana', extensions: ['icc', 'icm'] },
    'application/vnd.ieee.1905': { source: 'iana' },
    'application/vnd.igloader': { source: 'iana', extensions: ['igl'] },
    'application/vnd.imagemeter.folder+zip': { source: 'iana', compressible: !1 },
    'application/vnd.imagemeter.image+zip': { source: 'iana', compressible: !1 },
    'application/vnd.immervision-ivp': { source: 'iana', extensions: ['ivp'] },
    'application/vnd.immervision-ivu': { source: 'iana', extensions: ['ivu'] },
    'application/vnd.ims.imsccv1p1': { source: 'iana' },
    'application/vnd.ims.imsccv1p2': { source: 'iana' },
    'application/vnd.ims.imsccv1p3': { source: 'iana' },
    'application/vnd.ims.lis.v2.result+json': { source: 'iana', compressible: !0 },
    'application/vnd.ims.lti.v2.toolconsumerprofile+json': { source: 'iana', compressible: !0 },
    'application/vnd.ims.lti.v2.toolproxy+json': { source: 'iana', compressible: !0 },
    'application/vnd.ims.lti.v2.toolproxy.id+json': { source: 'iana', compressible: !0 },
    'application/vnd.ims.lti.v2.toolsettings+json': { source: 'iana', compressible: !0 },
    'application/vnd.ims.lti.v2.toolsettings.simple+json': { source: 'iana', compressible: !0 },
    'application/vnd.informedcontrol.rms+xml': { source: 'iana', compressible: !0 },
    'application/vnd.informix-visionary': { source: 'iana' },
    'application/vnd.infotech.project': { source: 'iana' },
    'application/vnd.infotech.project+xml': { source: 'iana', compressible: !0 },
    'application/vnd.innopath.wamp.notification': { source: 'iana' },
    'application/vnd.insors.igm': { source: 'iana', extensions: ['igm'] },
    'application/vnd.intercon.formnet': { source: 'iana', extensions: ['xpw', 'xpx'] },
    'application/vnd.intergeo': { source: 'iana', extensions: ['i2g'] },
    'application/vnd.intertrust.digibox': { source: 'iana' },
    'application/vnd.intertrust.nncp': { source: 'iana' },
    'application/vnd.intu.qbo': { source: 'iana', extensions: ['qbo'] },
    'application/vnd.intu.qfx': { source: 'iana', extensions: ['qfx'] },
    'application/vnd.iptc.g2.catalogitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.conceptitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.knowledgeitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.newsitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.newsmessage+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.packageitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.planningitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.ipunplugged.rcprofile': { source: 'iana', extensions: ['rcprofile'] },
    'application/vnd.irepository.package+xml': { source: 'iana', compressible: !0, extensions: ['irp'] },
    'application/vnd.is-xpr': { source: 'iana', extensions: ['xpr'] },
    'application/vnd.isac.fcs': { source: 'iana', extensions: ['fcs'] },
    'application/vnd.iso11783-10+zip': { source: 'iana', compressible: !1 },
    'application/vnd.jam': { source: 'iana', extensions: ['jam'] },
    'application/vnd.japannet-directory-service': { source: 'iana' },
    'application/vnd.japannet-jpnstore-wakeup': { source: 'iana' },
    'application/vnd.japannet-payment-wakeup': { source: 'iana' },
    'application/vnd.japannet-registration': { source: 'iana' },
    'application/vnd.japannet-registration-wakeup': { source: 'iana' },
    'application/vnd.japannet-setstore-wakeup': { source: 'iana' },
    'application/vnd.japannet-verification': { source: 'iana' },
    'application/vnd.japannet-verification-wakeup': { source: 'iana' },
    'application/vnd.jcp.javame.midlet-rms': { source: 'iana', extensions: ['rms'] },
    'application/vnd.jisp': { source: 'iana', extensions: ['jisp'] },
    'application/vnd.joost.joda-archive': { source: 'iana', extensions: ['joda'] },
    'application/vnd.jsk.isdn-ngn': { source: 'iana' },
    'application/vnd.kahootz': { source: 'iana', extensions: ['ktz', 'ktr'] },
    'application/vnd.kde.karbon': { source: 'iana', extensions: ['karbon'] },
    'application/vnd.kde.kchart': { source: 'iana', extensions: ['chrt'] },
    'application/vnd.kde.kformula': { source: 'iana', extensions: ['kfo'] },
    'application/vnd.kde.kivio': { source: 'iana', extensions: ['flw'] },
    'application/vnd.kde.kontour': { source: 'iana', extensions: ['kon'] },
    'application/vnd.kde.kpresenter': { source: 'iana', extensions: ['kpr', 'kpt'] },
    'application/vnd.kde.kspread': { source: 'iana', extensions: ['ksp'] },
    'application/vnd.kde.kword': { source: 'iana', extensions: ['kwd', 'kwt'] },
    'application/vnd.kenameaapp': { source: 'iana', extensions: ['htke'] },
    'application/vnd.kidspiration': { source: 'iana', extensions: ['kia'] },
    'application/vnd.kinar': { source: 'iana', extensions: ['kne', 'knp'] },
    'application/vnd.koan': { source: 'iana', extensions: ['skp', 'skd', 'skt', 'skm'] },
    'application/vnd.kodak-descriptor': { source: 'iana', extensions: ['sse'] },
    'application/vnd.las': { source: 'iana' },
    'application/vnd.las.las+json': { source: 'iana', compressible: !0 },
    'application/vnd.las.las+xml': { source: 'iana', compressible: !0, extensions: ['lasxml'] },
    'application/vnd.laszip': { source: 'iana' },
    'application/vnd.leap+json': { source: 'iana', compressible: !0 },
    'application/vnd.liberty-request+xml': { source: 'iana', compressible: !0 },
    'application/vnd.llamagraphics.life-balance.desktop': { source: 'iana', extensions: ['lbd'] },
    'application/vnd.llamagraphics.life-balance.exchange+xml': {
      source: 'iana',
      compressible: !0,
      extensions: ['lbe'],
    },
    'application/vnd.logipipe.circuit+zip': { source: 'iana', compressible: !1 },
    'application/vnd.loom': { source: 'iana' },
    'application/vnd.lotus-1-2-3': { source: 'iana', extensions: ['123'] },
    'application/vnd.lotus-approach': { source: 'iana', extensions: ['apr'] },
    'application/vnd.lotus-freelance': { source: 'iana', extensions: ['pre'] },
    'application/vnd.lotus-notes': { source: 'iana', extensions: ['nsf'] },
    'application/vnd.lotus-organizer': { source: 'iana', extensions: ['org'] },
    'application/vnd.lotus-screencam': { source: 'iana', extensions: ['scm'] },
    'application/vnd.lotus-wordpro': { source: 'iana', extensions: ['lwp'] },
    'application/vnd.macports.portpkg': { source: 'iana', extensions: ['portpkg'] },
    'application/vnd.mapbox-vector-tile': { source: 'iana', extensions: ['mvt'] },
    'application/vnd.marlin.drm.actiontoken+xml': { source: 'iana', compressible: !0 },
    'application/vnd.marlin.drm.conftoken+xml': { source: 'iana', compressible: !0 },
    'application/vnd.marlin.drm.license+xml': { source: 'iana', compressible: !0 },
    'application/vnd.marlin.drm.mdcf': { source: 'iana' },
    'application/vnd.mason+json': { source: 'iana', compressible: !0 },
    'application/vnd.maxar.archive.3tz+zip': { source: 'iana', compressible: !1 },
    'application/vnd.maxmind.maxmind-db': { source: 'iana' },
    'application/vnd.mcd': { source: 'iana', extensions: ['mcd'] },
    'application/vnd.medcalcdata': { source: 'iana', extensions: ['mc1'] },
    'application/vnd.mediastation.cdkey': { source: 'iana', extensions: ['cdkey'] },
    'application/vnd.meridian-slingshot': { source: 'iana' },
    'application/vnd.mfer': { source: 'iana', extensions: ['mwf'] },
    'application/vnd.mfmp': { source: 'iana', extensions: ['mfm'] },
    'application/vnd.micro+json': { source: 'iana', compressible: !0 },
    'application/vnd.micrografx.flo': { source: 'iana', extensions: ['flo'] },
    'application/vnd.micrografx.igx': { source: 'iana', extensions: ['igx'] },
    'application/vnd.microsoft.portable-executable': { source: 'iana' },
    'application/vnd.microsoft.windows.thumbnail-cache': { source: 'iana' },
    'application/vnd.miele+json': { source: 'iana', compressible: !0 },
    'application/vnd.mif': { source: 'iana', extensions: ['mif'] },
    'application/vnd.minisoft-hp3000-save': { source: 'iana' },
    'application/vnd.mitsubishi.misty-guard.trustweb': { source: 'iana' },
    'application/vnd.mobius.daf': { source: 'iana', extensions: ['daf'] },
    'application/vnd.mobius.dis': { source: 'iana', extensions: ['dis'] },
    'application/vnd.mobius.mbk': { source: 'iana', extensions: ['mbk'] },
    'application/vnd.mobius.mqy': { source: 'iana', extensions: ['mqy'] },
    'application/vnd.mobius.msl': { source: 'iana', extensions: ['msl'] },
    'application/vnd.mobius.plc': { source: 'iana', extensions: ['plc'] },
    'application/vnd.mobius.txf': { source: 'iana', extensions: ['txf'] },
    'application/vnd.mophun.application': { source: 'iana', extensions: ['mpn'] },
    'application/vnd.mophun.certificate': { source: 'iana', extensions: ['mpc'] },
    'application/vnd.motorola.flexsuite': { source: 'iana' },
    'application/vnd.motorola.flexsuite.adsi': { source: 'iana' },
    'application/vnd.motorola.flexsuite.fis': { source: 'iana' },
    'application/vnd.motorola.flexsuite.gotap': { source: 'iana' },
    'application/vnd.motorola.flexsuite.kmr': { source: 'iana' },
    'application/vnd.motorola.flexsuite.ttc': { source: 'iana' },
    'application/vnd.motorola.flexsuite.wem': { source: 'iana' },
    'application/vnd.motorola.iprm': { source: 'iana' },
    'application/vnd.mozilla.xul+xml': { source: 'iana', compressible: !0, extensions: ['xul'] },
    'application/vnd.ms-3mfdocument': { source: 'iana' },
    'application/vnd.ms-artgalry': { source: 'iana', extensions: ['cil'] },
    'application/vnd.ms-asf': { source: 'iana' },
    'application/vnd.ms-cab-compressed': { source: 'iana', extensions: ['cab'] },
    'application/vnd.ms-color.iccprofile': { source: 'apache' },
    'application/vnd.ms-excel': {
      source: 'iana',
      compressible: !1,
      extensions: ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw'],
    },
    'application/vnd.ms-excel.addin.macroenabled.12': { source: 'iana', extensions: ['xlam'] },
    'application/vnd.ms-excel.sheet.binary.macroenabled.12': { source: 'iana', extensions: ['xlsb'] },
    'application/vnd.ms-excel.sheet.macroenabled.12': { source: 'iana', extensions: ['xlsm'] },
    'application/vnd.ms-excel.template.macroenabled.12': { source: 'iana', extensions: ['xltm'] },
    'application/vnd.ms-fontobject': { source: 'iana', compressible: !0, extensions: ['eot'] },
    'application/vnd.ms-htmlhelp': { source: 'iana', extensions: ['chm'] },
    'application/vnd.ms-ims': { source: 'iana', extensions: ['ims'] },
    'application/vnd.ms-lrm': { source: 'iana', extensions: ['lrm'] },
    'application/vnd.ms-office.activex+xml': { source: 'iana', compressible: !0 },
    'application/vnd.ms-officetheme': { source: 'iana', extensions: ['thmx'] },
    'application/vnd.ms-opentype': { source: 'apache', compressible: !0 },
    'application/vnd.ms-outlook': { compressible: !1, extensions: ['msg'] },
    'application/vnd.ms-package.obfuscated-opentype': { source: 'apache' },
    'application/vnd.ms-pki.seccat': { source: 'apache', extensions: ['cat'] },
    'application/vnd.ms-pki.stl': { source: 'apache', extensions: ['stl'] },
    'application/vnd.ms-playready.initiator+xml': { source: 'iana', compressible: !0 },
    'application/vnd.ms-powerpoint': { source: 'iana', compressible: !1, extensions: ['ppt', 'pps', 'pot'] },
    'application/vnd.ms-powerpoint.addin.macroenabled.12': { source: 'iana', extensions: ['ppam'] },
    'application/vnd.ms-powerpoint.presentation.macroenabled.12': { source: 'iana', extensions: ['pptm'] },
    'application/vnd.ms-powerpoint.slide.macroenabled.12': { source: 'iana', extensions: ['sldm'] },
    'application/vnd.ms-powerpoint.slideshow.macroenabled.12': { source: 'iana', extensions: ['ppsm'] },
    'application/vnd.ms-powerpoint.template.macroenabled.12': { source: 'iana', extensions: ['potm'] },
    'application/vnd.ms-printdevicecapabilities+xml': { source: 'iana', compressible: !0 },
    'application/vnd.ms-printing.printticket+xml': { source: 'apache', compressible: !0 },
    'application/vnd.ms-printschematicket+xml': { source: 'iana', compressible: !0 },
    'application/vnd.ms-project': { source: 'iana', extensions: ['mpp', 'mpt'] },
    'application/vnd.ms-tnef': { source: 'iana' },
    'application/vnd.ms-windows.devicepairing': { source: 'iana' },
    'application/vnd.ms-windows.nwprinting.oob': { source: 'iana' },
    'application/vnd.ms-windows.printerpairing': { source: 'iana' },
    'application/vnd.ms-windows.wsd.oob': { source: 'iana' },
    'application/vnd.ms-wmdrm.lic-chlg-req': { source: 'iana' },
    'application/vnd.ms-wmdrm.lic-resp': { source: 'iana' },
    'application/vnd.ms-wmdrm.meter-chlg-req': { source: 'iana' },
    'application/vnd.ms-wmdrm.meter-resp': { source: 'iana' },
    'application/vnd.ms-word.document.macroenabled.12': { source: 'iana', extensions: ['docm'] },
    'application/vnd.ms-word.template.macroenabled.12': { source: 'iana', extensions: ['dotm'] },
    'application/vnd.ms-works': { source: 'iana', extensions: ['wps', 'wks', 'wcm', 'wdb'] },
    'application/vnd.ms-wpl': { source: 'iana', extensions: ['wpl'] },
    'application/vnd.ms-xpsdocument': { source: 'iana', compressible: !1, extensions: ['xps'] },
    'application/vnd.msa-disk-image': { source: 'iana' },
    'application/vnd.mseq': { source: 'iana', extensions: ['mseq'] },
    'application/vnd.msign': { source: 'iana' },
    'application/vnd.multiad.creator': { source: 'iana' },
    'application/vnd.multiad.creator.cif': { source: 'iana' },
    'application/vnd.music-niff': { source: 'iana' },
    'application/vnd.musician': { source: 'iana', extensions: ['mus'] },
    'application/vnd.muvee.style': { source: 'iana', extensions: ['msty'] },
    'application/vnd.mynfc': { source: 'iana', extensions: ['taglet'] },
    'application/vnd.nacamar.ybrid+json': { source: 'iana', compressible: !0 },
    'application/vnd.ncd.control': { source: 'iana' },
    'application/vnd.ncd.reference': { source: 'iana' },
    'application/vnd.nearst.inv+json': { source: 'iana', compressible: !0 },
    'application/vnd.nebumind.line': { source: 'iana' },
    'application/vnd.nervana': { source: 'iana' },
    'application/vnd.netfpx': { source: 'iana' },
    'application/vnd.neurolanguage.nlu': { source: 'iana', extensions: ['nlu'] },
    'application/vnd.nimn': { source: 'iana' },
    'application/vnd.nintendo.nitro.rom': { source: 'iana' },
    'application/vnd.nintendo.snes.rom': { source: 'iana' },
    'application/vnd.nitf': { source: 'iana', extensions: ['ntf', 'nitf'] },
    'application/vnd.noblenet-directory': { source: 'iana', extensions: ['nnd'] },
    'application/vnd.noblenet-sealer': { source: 'iana', extensions: ['nns'] },
    'application/vnd.noblenet-web': { source: 'iana', extensions: ['nnw'] },
    'application/vnd.nokia.catalogs': { source: 'iana' },
    'application/vnd.nokia.conml+wbxml': { source: 'iana' },
    'application/vnd.nokia.conml+xml': { source: 'iana', compressible: !0 },
    'application/vnd.nokia.iptv.config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.nokia.isds-radio-presets': { source: 'iana' },
    'application/vnd.nokia.landmark+wbxml': { source: 'iana' },
    'application/vnd.nokia.landmark+xml': { source: 'iana', compressible: !0 },
    'application/vnd.nokia.landmarkcollection+xml': { source: 'iana', compressible: !0 },
    'application/vnd.nokia.n-gage.ac+xml': { source: 'iana', compressible: !0, extensions: ['ac'] },
    'application/vnd.nokia.n-gage.data': { source: 'iana', extensions: ['ngdat'] },
    'application/vnd.nokia.n-gage.symbian.install': { source: 'iana', extensions: ['n-gage'] },
    'application/vnd.nokia.ncd': { source: 'iana' },
    'application/vnd.nokia.pcd+wbxml': { source: 'iana' },
    'application/vnd.nokia.pcd+xml': { source: 'iana', compressible: !0 },
    'application/vnd.nokia.radio-preset': { source: 'iana', extensions: ['rpst'] },
    'application/vnd.nokia.radio-presets': { source: 'iana', extensions: ['rpss'] },
    'application/vnd.novadigm.edm': { source: 'iana', extensions: ['edm'] },
    'application/vnd.novadigm.edx': { source: 'iana', extensions: ['edx'] },
    'application/vnd.novadigm.ext': { source: 'iana', extensions: ['ext'] },
    'application/vnd.ntt-local.content-share': { source: 'iana' },
    'application/vnd.ntt-local.file-transfer': { source: 'iana' },
    'application/vnd.ntt-local.ogw_remote-access': { source: 'iana' },
    'application/vnd.ntt-local.sip-ta_remote': { source: 'iana' },
    'application/vnd.ntt-local.sip-ta_tcp_stream': { source: 'iana' },
    'application/vnd.oasis.opendocument.chart': { source: 'iana', extensions: ['odc'] },
    'application/vnd.oasis.opendocument.chart-template': { source: 'iana', extensions: ['otc'] },
    'application/vnd.oasis.opendocument.database': { source: 'iana', extensions: ['odb'] },
    'application/vnd.oasis.opendocument.formula': { source: 'iana', extensions: ['odf'] },
    'application/vnd.oasis.opendocument.formula-template': { source: 'iana', extensions: ['odft'] },
    'application/vnd.oasis.opendocument.graphics': { source: 'iana', compressible: !1, extensions: ['odg'] },
    'application/vnd.oasis.opendocument.graphics-template': { source: 'iana', extensions: ['otg'] },
    'application/vnd.oasis.opendocument.image': { source: 'iana', extensions: ['odi'] },
    'application/vnd.oasis.opendocument.image-template': { source: 'iana', extensions: ['oti'] },
    'application/vnd.oasis.opendocument.presentation': { source: 'iana', compressible: !1, extensions: ['odp'] },
    'application/vnd.oasis.opendocument.presentation-template': { source: 'iana', extensions: ['otp'] },
    'application/vnd.oasis.opendocument.spreadsheet': { source: 'iana', compressible: !1, extensions: ['ods'] },
    'application/vnd.oasis.opendocument.spreadsheet-template': { source: 'iana', extensions: ['ots'] },
    'application/vnd.oasis.opendocument.text': { source: 'iana', compressible: !1, extensions: ['odt'] },
    'application/vnd.oasis.opendocument.text-master': { source: 'iana', extensions: ['odm'] },
    'application/vnd.oasis.opendocument.text-template': { source: 'iana', extensions: ['ott'] },
    'application/vnd.oasis.opendocument.text-web': { source: 'iana', extensions: ['oth'] },
    'application/vnd.obn': { source: 'iana' },
    'application/vnd.ocf+cbor': { source: 'iana' },
    'application/vnd.oci.image.manifest.v1+json': { source: 'iana', compressible: !0 },
    'application/vnd.oftn.l10n+json': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.contentaccessdownload+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.contentaccessstreaming+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.cspg-hexbinary': { source: 'iana' },
    'application/vnd.oipf.dae.svg+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.dae.xhtml+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.mippvcontrolmessage+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.pae.gem': { source: 'iana' },
    'application/vnd.oipf.spdiscovery+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.spdlist+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.ueprofile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.userprofile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.olpc-sugar': { source: 'iana', extensions: ['xo'] },
    'application/vnd.oma-scws-config': { source: 'iana' },
    'application/vnd.oma-scws-http-request': { source: 'iana' },
    'application/vnd.oma-scws-http-response': { source: 'iana' },
    'application/vnd.oma.bcast.associated-procedure-parameter+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.drm-trigger+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.imd+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.ltkm': { source: 'iana' },
    'application/vnd.oma.bcast.notification+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.provisioningtrigger': { source: 'iana' },
    'application/vnd.oma.bcast.sgboot': { source: 'iana' },
    'application/vnd.oma.bcast.sgdd+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.sgdu': { source: 'iana' },
    'application/vnd.oma.bcast.simple-symbol-container': { source: 'iana' },
    'application/vnd.oma.bcast.smartcard-trigger+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.sprov+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.stkm': { source: 'iana' },
    'application/vnd.oma.cab-address-book+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.cab-feature-handler+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.cab-pcc+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.cab-subs-invite+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.cab-user-prefs+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.dcd': { source: 'iana' },
    'application/vnd.oma.dcdc': { source: 'iana' },
    'application/vnd.oma.dd2+xml': { source: 'iana', compressible: !0, extensions: ['dd2'] },
    'application/vnd.oma.drm.risd+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.group-usage-list+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.lwm2m+cbor': { source: 'iana' },
    'application/vnd.oma.lwm2m+json': { source: 'iana', compressible: !0 },
    'application/vnd.oma.lwm2m+tlv': { source: 'iana' },
    'application/vnd.oma.pal+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.poc.detailed-progress-report+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.poc.final-report+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.poc.groups+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.poc.invocation-descriptor+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.poc.optimized-progress-report+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.push': { source: 'iana' },
    'application/vnd.oma.scidm.messages+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.xcap-directory+xml': { source: 'iana', compressible: !0 },
    'application/vnd.omads-email+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.omads-file+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.omads-folder+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.omaloc-supl-init': { source: 'iana' },
    'application/vnd.onepager': { source: 'iana' },
    'application/vnd.onepagertamp': { source: 'iana' },
    'application/vnd.onepagertamx': { source: 'iana' },
    'application/vnd.onepagertat': { source: 'iana' },
    'application/vnd.onepagertatp': { source: 'iana' },
    'application/vnd.onepagertatx': { source: 'iana' },
    'application/vnd.openblox.game+xml': { source: 'iana', compressible: !0, extensions: ['obgx'] },
    'application/vnd.openblox.game-binary': { source: 'iana' },
    'application/vnd.openeye.oeb': { source: 'iana' },
    'application/vnd.openofficeorg.extension': { source: 'apache', extensions: ['oxt'] },
    'application/vnd.openstreetmap.data+xml': { source: 'iana', compressible: !0, extensions: ['osm'] },
    'application/vnd.opentimestamps.ots': { source: 'iana' },
    'application/vnd.openxmlformats-officedocument.custom-properties+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.customxmlproperties+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawing+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.chart+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.extended-properties+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.comments+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': {
      source: 'iana',
      compressible: !1,
      extensions: ['pptx'],
    },
    'application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.presprops+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.slide': { source: 'iana', extensions: ['sldx'] },
    'application/vnd.openxmlformats-officedocument.presentationml.slide+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow': { source: 'iana', extensions: ['ppsx'] },
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.tags+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.template': { source: 'iana', extensions: ['potx'] },
    'application/vnd.openxmlformats-officedocument.presentationml.template.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': {
      source: 'iana',
      compressible: !1,
      extensions: ['xlsx'],
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template': { source: 'iana', extensions: ['xltx'] },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.theme+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.themeoverride+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.vmldrawing': { source: 'iana' },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': {
      source: 'iana',
      compressible: !1,
      extensions: ['docx'],
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template': { source: 'iana', extensions: ['dotx'] },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-package.core-properties+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-package.relationships+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oracle.resource+json': { source: 'iana', compressible: !0 },
    'application/vnd.orange.indata': { source: 'iana' },
    'application/vnd.osa.netdeploy': { source: 'iana' },
    'application/vnd.osgeo.mapguide.package': { source: 'iana', extensions: ['mgp'] },
    'application/vnd.osgi.bundle': { source: 'iana' },
    'application/vnd.osgi.dp': { source: 'iana', extensions: ['dp'] },
    'application/vnd.osgi.subsystem': { source: 'iana', extensions: ['esa'] },
    'application/vnd.otps.ct-kip+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oxli.countgraph': { source: 'iana' },
    'application/vnd.pagerduty+json': { source: 'iana', compressible: !0 },
    'application/vnd.palm': { source: 'iana', extensions: ['pdb', 'pqa', 'oprc'] },
    'application/vnd.panoply': { source: 'iana' },
    'application/vnd.paos.xml': { source: 'iana' },
    'application/vnd.patentdive': { source: 'iana' },
    'application/vnd.patientecommsdoc': { source: 'iana' },
    'application/vnd.pawaafile': { source: 'iana', extensions: ['paw'] },
    'application/vnd.pcos': { source: 'iana' },
    'application/vnd.pg.format': { source: 'iana', extensions: ['str'] },
    'application/vnd.pg.osasli': { source: 'iana', extensions: ['ei6'] },
    'application/vnd.piaccess.application-licence': { source: 'iana' },
    'application/vnd.picsel': { source: 'iana', extensions: ['efif'] },
    'application/vnd.pmi.widget': { source: 'iana', extensions: ['wg'] },
    'application/vnd.poc.group-advertisement+xml': { source: 'iana', compressible: !0 },
    'application/vnd.pocketlearn': { source: 'iana', extensions: ['plf'] },
    'application/vnd.powerbuilder6': { source: 'iana', extensions: ['pbd'] },
    'application/vnd.powerbuilder6-s': { source: 'iana' },
    'application/vnd.powerbuilder7': { source: 'iana' },
    'application/vnd.powerbuilder7-s': { source: 'iana' },
    'application/vnd.powerbuilder75': { source: 'iana' },
    'application/vnd.powerbuilder75-s': { source: 'iana' },
    'application/vnd.preminet': { source: 'iana' },
    'application/vnd.previewsystems.box': { source: 'iana', extensions: ['box'] },
    'application/vnd.proteus.magazine': { source: 'iana', extensions: ['mgz'] },
    'application/vnd.psfs': { source: 'iana' },
    'application/vnd.publishare-delta-tree': { source: 'iana', extensions: ['qps'] },
    'application/vnd.pvi.ptid1': { source: 'iana', extensions: ['ptid'] },
    'application/vnd.pwg-multiplexed': { source: 'iana' },
    'application/vnd.pwg-xhtml-print+xml': { source: 'iana', compressible: !0 },
    'application/vnd.qualcomm.brew-app-res': { source: 'iana' },
    'application/vnd.quarantainenet': { source: 'iana' },
    'application/vnd.quark.quarkxpress': { source: 'iana', extensions: ['qxd', 'qxt', 'qwd', 'qwt', 'qxl', 'qxb'] },
    'application/vnd.quobject-quoxdocument': { source: 'iana' },
    'application/vnd.radisys.moml+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-audit+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-audit-conf+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-audit-conn+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-audit-dialog+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-audit-stream+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-conf+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-base+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-fax-detect+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-fax-sendrecv+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-group+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-speech+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-transform+xml': { source: 'iana', compressible: !0 },
    'application/vnd.rainstor.data': { source: 'iana' },
    'application/vnd.rapid': { source: 'iana' },
    'application/vnd.rar': { source: 'iana', extensions: ['rar'] },
    'application/vnd.realvnc.bed': { source: 'iana', extensions: ['bed'] },
    'application/vnd.recordare.musicxml': { source: 'iana', extensions: ['mxl'] },
    'application/vnd.recordare.musicxml+xml': { source: 'iana', compressible: !0, extensions: ['musicxml'] },
    'application/vnd.renlearn.rlprint': { source: 'iana' },
    'application/vnd.resilient.logic': { source: 'iana' },
    'application/vnd.restful+json': { source: 'iana', compressible: !0 },
    'application/vnd.rig.cryptonote': { source: 'iana', extensions: ['cryptonote'] },
    'application/vnd.rim.cod': { source: 'apache', extensions: ['cod'] },
    'application/vnd.rn-realmedia': { source: 'apache', extensions: ['rm'] },
    'application/vnd.rn-realmedia-vbr': { source: 'apache', extensions: ['rmvb'] },
    'application/vnd.route66.link66+xml': { source: 'iana', compressible: !0, extensions: ['link66'] },
    'application/vnd.rs-274x': { source: 'iana' },
    'application/vnd.ruckus.download': { source: 'iana' },
    'application/vnd.s3sms': { source: 'iana' },
    'application/vnd.sailingtracker.track': { source: 'iana', extensions: ['st'] },
    'application/vnd.sar': { source: 'iana' },
    'application/vnd.sbm.cid': { source: 'iana' },
    'application/vnd.sbm.mid2': { source: 'iana' },
    'application/vnd.scribus': { source: 'iana' },
    'application/vnd.sealed.3df': { source: 'iana' },
    'application/vnd.sealed.csf': { source: 'iana' },
    'application/vnd.sealed.doc': { source: 'iana' },
    'application/vnd.sealed.eml': { source: 'iana' },
    'application/vnd.sealed.mht': { source: 'iana' },
    'application/vnd.sealed.net': { source: 'iana' },
    'application/vnd.sealed.ppt': { source: 'iana' },
    'application/vnd.sealed.tiff': { source: 'iana' },
    'application/vnd.sealed.xls': { source: 'iana' },
    'application/vnd.sealedmedia.softseal.html': { source: 'iana' },
    'application/vnd.sealedmedia.softseal.pdf': { source: 'iana' },
    'application/vnd.seemail': { source: 'iana', extensions: ['see'] },
    'application/vnd.seis+json': { source: 'iana', compressible: !0 },
    'application/vnd.sema': { source: 'iana', extensions: ['sema'] },
    'application/vnd.semd': { source: 'iana', extensions: ['semd'] },
    'application/vnd.semf': { source: 'iana', extensions: ['semf'] },
    'application/vnd.shade-save-file': { source: 'iana' },
    'application/vnd.shana.informed.formdata': { source: 'iana', extensions: ['ifm'] },
    'application/vnd.shana.informed.formtemplate': { source: 'iana', extensions: ['itp'] },
    'application/vnd.shana.informed.interchange': { source: 'iana', extensions: ['iif'] },
    'application/vnd.shana.informed.package': { source: 'iana', extensions: ['ipk'] },
    'application/vnd.shootproof+json': { source: 'iana', compressible: !0 },
    'application/vnd.shopkick+json': { source: 'iana', compressible: !0 },
    'application/vnd.shp': { source: 'iana' },
    'application/vnd.shx': { source: 'iana' },
    'application/vnd.sigrok.session': { source: 'iana' },
    'application/vnd.simtech-mindmapper': { source: 'iana', extensions: ['twd', 'twds'] },
    'application/vnd.siren+json': { source: 'iana', compressible: !0 },
    'application/vnd.smaf': { source: 'iana', extensions: ['mmf'] },
    'application/vnd.smart.notebook': { source: 'iana' },
    'application/vnd.smart.teacher': { source: 'iana', extensions: ['teacher'] },
    'application/vnd.snesdev-page-table': { source: 'iana' },
    'application/vnd.software602.filler.form+xml': { source: 'iana', compressible: !0, extensions: ['fo'] },
    'application/vnd.software602.filler.form-xml-zip': { source: 'iana' },
    'application/vnd.solent.sdkm+xml': { source: 'iana', compressible: !0, extensions: ['sdkm', 'sdkd'] },
    'application/vnd.spotfire.dxp': { source: 'iana', extensions: ['dxp'] },
    'application/vnd.spotfire.sfs': { source: 'iana', extensions: ['sfs'] },
    'application/vnd.sqlite3': { source: 'iana' },
    'application/vnd.sss-cod': { source: 'iana' },
    'application/vnd.sss-dtf': { source: 'iana' },
    'application/vnd.sss-ntf': { source: 'iana' },
    'application/vnd.stardivision.calc': { source: 'apache', extensions: ['sdc'] },
    'application/vnd.stardivision.draw': { source: 'apache', extensions: ['sda'] },
    'application/vnd.stardivision.impress': { source: 'apache', extensions: ['sdd'] },
    'application/vnd.stardivision.math': { source: 'apache', extensions: ['smf'] },
    'application/vnd.stardivision.writer': { source: 'apache', extensions: ['sdw', 'vor'] },
    'application/vnd.stardivision.writer-global': { source: 'apache', extensions: ['sgl'] },
    'application/vnd.stepmania.package': { source: 'iana', extensions: ['smzip'] },
    'application/vnd.stepmania.stepchart': { source: 'iana', extensions: ['sm'] },
    'application/vnd.street-stream': { source: 'iana' },
    'application/vnd.sun.wadl+xml': { source: 'iana', compressible: !0, extensions: ['wadl'] },
    'application/vnd.sun.xml.calc': { source: 'apache', extensions: ['sxc'] },
    'application/vnd.sun.xml.calc.template': { source: 'apache', extensions: ['stc'] },
    'application/vnd.sun.xml.draw': { source: 'apache', extensions: ['sxd'] },
    'application/vnd.sun.xml.draw.template': { source: 'apache', extensions: ['std'] },
    'application/vnd.sun.xml.impress': { source: 'apache', extensions: ['sxi'] },
    'application/vnd.sun.xml.impress.template': { source: 'apache', extensions: ['sti'] },
    'application/vnd.sun.xml.math': { source: 'apache', extensions: ['sxm'] },
    'application/vnd.sun.xml.writer': { source: 'apache', extensions: ['sxw'] },
    'application/vnd.sun.xml.writer.global': { source: 'apache', extensions: ['sxg'] },
    'application/vnd.sun.xml.writer.template': { source: 'apache', extensions: ['stw'] },
    'application/vnd.sus-calendar': { source: 'iana', extensions: ['sus', 'susp'] },
    'application/vnd.svd': { source: 'iana', extensions: ['svd'] },
    'application/vnd.swiftview-ics': { source: 'iana' },
    'application/vnd.sycle+xml': { source: 'iana', compressible: !0 },
    'application/vnd.syft+json': { source: 'iana', compressible: !0 },
    'application/vnd.symbian.install': { source: 'apache', extensions: ['sis', 'sisx'] },
    'application/vnd.syncml+xml': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['xsm'] },
    'application/vnd.syncml.dm+wbxml': { source: 'iana', charset: 'UTF-8', extensions: ['bdm'] },
    'application/vnd.syncml.dm+xml': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['xdm'] },
    'application/vnd.syncml.dm.notification': { source: 'iana' },
    'application/vnd.syncml.dmddf+wbxml': { source: 'iana' },
    'application/vnd.syncml.dmddf+xml': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['ddf'] },
    'application/vnd.syncml.dmtnds+wbxml': { source: 'iana' },
    'application/vnd.syncml.dmtnds+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.syncml.ds.notification': { source: 'iana' },
    'application/vnd.tableschema+json': { source: 'iana', compressible: !0 },
    'application/vnd.tao.intent-module-archive': { source: 'iana', extensions: ['tao'] },
    'application/vnd.tcpdump.pcap': { source: 'iana', extensions: ['pcap', 'cap', 'dmp'] },
    'application/vnd.think-cell.ppttc+json': { source: 'iana', compressible: !0 },
    'application/vnd.tmd.mediaflex.api+xml': { source: 'iana', compressible: !0 },
    'application/vnd.tml': { source: 'iana' },
    'application/vnd.tmobile-livetv': { source: 'iana', extensions: ['tmo'] },
    'application/vnd.tri.onesource': { source: 'iana' },
    'application/vnd.trid.tpt': { source: 'iana', extensions: ['tpt'] },
    'application/vnd.triscape.mxs': { source: 'iana', extensions: ['mxs'] },
    'application/vnd.trueapp': { source: 'iana', extensions: ['tra'] },
    'application/vnd.truedoc': { source: 'iana' },
    'application/vnd.ubisoft.webplayer': { source: 'iana' },
    'application/vnd.ufdl': { source: 'iana', extensions: ['ufd', 'ufdl'] },
    'application/vnd.uiq.theme': { source: 'iana', extensions: ['utz'] },
    'application/vnd.umajin': { source: 'iana', extensions: ['umj'] },
    'application/vnd.unity': { source: 'iana', extensions: ['unityweb'] },
    'application/vnd.uoml+xml': { source: 'iana', compressible: !0, extensions: ['uoml'] },
    'application/vnd.uplanet.alert': { source: 'iana' },
    'application/vnd.uplanet.alert-wbxml': { source: 'iana' },
    'application/vnd.uplanet.bearer-choice': { source: 'iana' },
    'application/vnd.uplanet.bearer-choice-wbxml': { source: 'iana' },
    'application/vnd.uplanet.cacheop': { source: 'iana' },
    'application/vnd.uplanet.cacheop-wbxml': { source: 'iana' },
    'application/vnd.uplanet.channel': { source: 'iana' },
    'application/vnd.uplanet.channel-wbxml': { source: 'iana' },
    'application/vnd.uplanet.list': { source: 'iana' },
    'application/vnd.uplanet.list-wbxml': { source: 'iana' },
    'application/vnd.uplanet.listcmd': { source: 'iana' },
    'application/vnd.uplanet.listcmd-wbxml': { source: 'iana' },
    'application/vnd.uplanet.signal': { source: 'iana' },
    'application/vnd.uri-map': { source: 'iana' },
    'application/vnd.valve.source.material': { source: 'iana' },
    'application/vnd.vcx': { source: 'iana', extensions: ['vcx'] },
    'application/vnd.vd-study': { source: 'iana' },
    'application/vnd.vectorworks': { source: 'iana' },
    'application/vnd.vel+json': { source: 'iana', compressible: !0 },
    'application/vnd.verimatrix.vcas': { source: 'iana' },
    'application/vnd.veritone.aion+json': { source: 'iana', compressible: !0 },
    'application/vnd.veryant.thin': { source: 'iana' },
    'application/vnd.ves.encrypted': { source: 'iana' },
    'application/vnd.vidsoft.vidconference': { source: 'iana' },
    'application/vnd.visio': { source: 'iana', extensions: ['vsd', 'vst', 'vss', 'vsw'] },
    'application/vnd.visionary': { source: 'iana', extensions: ['vis'] },
    'application/vnd.vividence.scriptfile': { source: 'iana' },
    'application/vnd.vsf': { source: 'iana', extensions: ['vsf'] },
    'application/vnd.wap.sic': { source: 'iana' },
    'application/vnd.wap.slc': { source: 'iana' },
    'application/vnd.wap.wbxml': { source: 'iana', charset: 'UTF-8', extensions: ['wbxml'] },
    'application/vnd.wap.wmlc': { source: 'iana', extensions: ['wmlc'] },
    'application/vnd.wap.wmlscriptc': { source: 'iana', extensions: ['wmlsc'] },
    'application/vnd.webturbo': { source: 'iana', extensions: ['wtb'] },
    'application/vnd.wfa.dpp': { source: 'iana' },
    'application/vnd.wfa.p2p': { source: 'iana' },
    'application/vnd.wfa.wsc': { source: 'iana' },
    'application/vnd.windows.devicepairing': { source: 'iana' },
    'application/vnd.wmc': { source: 'iana' },
    'application/vnd.wmf.bootstrap': { source: 'iana' },
    'application/vnd.wolfram.mathematica': { source: 'iana' },
    'application/vnd.wolfram.mathematica.package': { source: 'iana' },
    'application/vnd.wolfram.player': { source: 'iana', extensions: ['nbp'] },
    'application/vnd.wordperfect': { source: 'iana', extensions: ['wpd'] },
    'application/vnd.wqd': { source: 'iana', extensions: ['wqd'] },
    'application/vnd.wrq-hp3000-labelled': { source: 'iana' },
    'application/vnd.wt.stf': { source: 'iana', extensions: ['stf'] },
    'application/vnd.wv.csp+wbxml': { source: 'iana' },
    'application/vnd.wv.csp+xml': { source: 'iana', compressible: !0 },
    'application/vnd.wv.ssp+xml': { source: 'iana', compressible: !0 },
    'application/vnd.xacml+json': { source: 'iana', compressible: !0 },
    'application/vnd.xara': { source: 'iana', extensions: ['xar'] },
    'application/vnd.xfdl': { source: 'iana', extensions: ['xfdl'] },
    'application/vnd.xfdl.webform': { source: 'iana' },
    'application/vnd.xmi+xml': { source: 'iana', compressible: !0 },
    'application/vnd.xmpie.cpkg': { source: 'iana' },
    'application/vnd.xmpie.dpkg': { source: 'iana' },
    'application/vnd.xmpie.plan': { source: 'iana' },
    'application/vnd.xmpie.ppkg': { source: 'iana' },
    'application/vnd.xmpie.xlim': { source: 'iana' },
    'application/vnd.yamaha.hv-dic': { source: 'iana', extensions: ['hvd'] },
    'application/vnd.yamaha.hv-script': { source: 'iana', extensions: ['hvs'] },
    'application/vnd.yamaha.hv-voice': { source: 'iana', extensions: ['hvp'] },
    'application/vnd.yamaha.openscoreformat': { source: 'iana', extensions: ['osf'] },
    'application/vnd.yamaha.openscoreformat.osfpvg+xml': { source: 'iana', compressible: !0, extensions: ['osfpvg'] },
    'application/vnd.yamaha.remote-setup': { source: 'iana' },
    'application/vnd.yamaha.smaf-audio': { source: 'iana', extensions: ['saf'] },
    'application/vnd.yamaha.smaf-phrase': { source: 'iana', extensions: ['spf'] },
    'application/vnd.yamaha.through-ngn': { source: 'iana' },
    'application/vnd.yamaha.tunnel-udpencap': { source: 'iana' },
    'application/vnd.yaoweme': { source: 'iana' },
    'application/vnd.yellowriver-custom-menu': { source: 'iana', extensions: ['cmp'] },
    'application/vnd.youtube.yt': { source: 'iana' },
    'application/vnd.zul': { source: 'iana', extensions: ['zir', 'zirz'] },
    'application/vnd.zzazz.deck+xml': { source: 'iana', compressible: !0, extensions: ['zaz'] },
    'application/voicexml+xml': { source: 'iana', compressible: !0, extensions: ['vxml'] },
    'application/voucher-cms+json': { source: 'iana', compressible: !0 },
    'application/vq-rtcpxr': { source: 'iana' },
    'application/wasm': { source: 'iana', compressible: !0, extensions: ['wasm'] },
    'application/watcherinfo+xml': { source: 'iana', compressible: !0, extensions: ['wif'] },
    'application/webpush-options+json': { source: 'iana', compressible: !0 },
    'application/whoispp-query': { source: 'iana' },
    'application/whoispp-response': { source: 'iana' },
    'application/widget': { source: 'iana', extensions: ['wgt'] },
    'application/winhlp': { source: 'apache', extensions: ['hlp'] },
    'application/wita': { source: 'iana' },
    'application/wordperfect5.1': { source: 'iana' },
    'application/wsdl+xml': { source: 'iana', compressible: !0, extensions: ['wsdl'] },
    'application/wspolicy+xml': { source: 'iana', compressible: !0, extensions: ['wspolicy'] },
    'application/x-7z-compressed': { source: 'apache', compressible: !1, extensions: ['7z'] },
    'application/x-abiword': { source: 'apache', extensions: ['abw'] },
    'application/x-ace-compressed': { source: 'apache', extensions: ['ace'] },
    'application/x-amf': { source: 'apache' },
    'application/x-apple-diskimage': { source: 'apache', extensions: ['dmg'] },
    'application/x-arj': { compressible: !1, extensions: ['arj'] },
    'application/x-authorware-bin': { source: 'apache', extensions: ['aab', 'x32', 'u32', 'vox'] },
    'application/x-authorware-map': { source: 'apache', extensions: ['aam'] },
    'application/x-authorware-seg': { source: 'apache', extensions: ['aas'] },
    'application/x-bcpio': { source: 'apache', extensions: ['bcpio'] },
    'application/x-bdoc': { compressible: !1, extensions: ['bdoc'] },
    'application/x-bittorrent': { source: 'apache', extensions: ['torrent'] },
    'application/x-blorb': { source: 'apache', extensions: ['blb', 'blorb'] },
    'application/x-bzip': { source: 'apache', compressible: !1, extensions: ['bz'] },
    'application/x-bzip2': { source: 'apache', compressible: !1, extensions: ['bz2', 'boz'] },
    'application/x-cbr': { source: 'apache', extensions: ['cbr', 'cba', 'cbt', 'cbz', 'cb7'] },
    'application/x-cdlink': { source: 'apache', extensions: ['vcd'] },
    'application/x-cfs-compressed': { source: 'apache', extensions: ['cfs'] },
    'application/x-chat': { source: 'apache', extensions: ['chat'] },
    'application/x-chess-pgn': { source: 'apache', extensions: ['pgn'] },
    'application/x-chrome-extension': { extensions: ['crx'] },
    'application/x-cocoa': { source: 'nginx', extensions: ['cco'] },
    'application/x-compress': { source: 'apache' },
    'application/x-conference': { source: 'apache', extensions: ['nsc'] },
    'application/x-cpio': { source: 'apache', extensions: ['cpio'] },
    'application/x-csh': { source: 'apache', extensions: ['csh'] },
    'application/x-deb': { compressible: !1 },
    'application/x-debian-package': { source: 'apache', extensions: ['deb', 'udeb'] },
    'application/x-dgc-compressed': { source: 'apache', extensions: ['dgc'] },
    'application/x-director': {
      source: 'apache',
      extensions: ['dir', 'dcr', 'dxr', 'cst', 'cct', 'cxt', 'w3d', 'fgd', 'swa'],
    },
    'application/x-doom': { source: 'apache', extensions: ['wad'] },
    'application/x-dtbncx+xml': { source: 'apache', compressible: !0, extensions: ['ncx'] },
    'application/x-dtbook+xml': { source: 'apache', compressible: !0, extensions: ['dtb'] },
    'application/x-dtbresource+xml': { source: 'apache', compressible: !0, extensions: ['res'] },
    'application/x-dvi': { source: 'apache', compressible: !1, extensions: ['dvi'] },
    'application/x-envoy': { source: 'apache', extensions: ['evy'] },
    'application/x-eva': { source: 'apache', extensions: ['eva'] },
    'application/x-font-bdf': { source: 'apache', extensions: ['bdf'] },
    'application/x-font-dos': { source: 'apache' },
    'application/x-font-framemaker': { source: 'apache' },
    'application/x-font-ghostscript': { source: 'apache', extensions: ['gsf'] },
    'application/x-font-libgrx': { source: 'apache' },
    'application/x-font-linux-psf': { source: 'apache', extensions: ['psf'] },
    'application/x-font-pcf': { source: 'apache', extensions: ['pcf'] },
    'application/x-font-snf': { source: 'apache', extensions: ['snf'] },
    'application/x-font-speedo': { source: 'apache' },
    'application/x-font-sunos-news': { source: 'apache' },
    'application/x-font-type1': { source: 'apache', extensions: ['pfa', 'pfb', 'pfm', 'afm'] },
    'application/x-font-vfont': { source: 'apache' },
    'application/x-freearc': { source: 'apache', extensions: ['arc'] },
    'application/x-futuresplash': { source: 'apache', extensions: ['spl'] },
    'application/x-gca-compressed': { source: 'apache', extensions: ['gca'] },
    'application/x-glulx': { source: 'apache', extensions: ['ulx'] },
    'application/x-gnumeric': { source: 'apache', extensions: ['gnumeric'] },
    'application/x-gramps-xml': { source: 'apache', extensions: ['gramps'] },
    'application/x-gtar': { source: 'apache', extensions: ['gtar'] },
    'application/x-gzip': { source: 'apache' },
    'application/x-hdf': { source: 'apache', extensions: ['hdf'] },
    'application/x-httpd-php': { compressible: !0, extensions: ['php'] },
    'application/x-install-instructions': { source: 'apache', extensions: ['install'] },
    'application/x-iso9660-image': { source: 'apache', extensions: ['iso'] },
    'application/x-iwork-keynote-sffkey': { extensions: ['key'] },
    'application/x-iwork-numbers-sffnumbers': { extensions: ['numbers'] },
    'application/x-iwork-pages-sffpages': { extensions: ['pages'] },
    'application/x-java-archive-diff': { source: 'nginx', extensions: ['jardiff'] },
    'application/x-java-jnlp-file': { source: 'apache', compressible: !1, extensions: ['jnlp'] },
    'application/x-javascript': { compressible: !0 },
    'application/x-keepass2': { extensions: ['kdbx'] },
    'application/x-latex': { source: 'apache', compressible: !1, extensions: ['latex'] },
    'application/x-lua-bytecode': { extensions: ['luac'] },
    'application/x-lzh-compressed': { source: 'apache', extensions: ['lzh', 'lha'] },
    'application/x-makeself': { source: 'nginx', extensions: ['run'] },
    'application/x-mie': { source: 'apache', extensions: ['mie'] },
    'application/x-mobipocket-ebook': { source: 'apache', extensions: ['prc', 'mobi'] },
    'application/x-mpegurl': { compressible: !1 },
    'application/x-ms-application': { source: 'apache', extensions: ['application'] },
    'application/x-ms-shortcut': { source: 'apache', extensions: ['lnk'] },
    'application/x-ms-wmd': { source: 'apache', extensions: ['wmd'] },
    'application/x-ms-wmz': { source: 'apache', extensions: ['wmz'] },
    'application/x-ms-xbap': { source: 'apache', extensions: ['xbap'] },
    'application/x-msaccess': { source: 'apache', extensions: ['mdb'] },
    'application/x-msbinder': { source: 'apache', extensions: ['obd'] },
    'application/x-mscardfile': { source: 'apache', extensions: ['crd'] },
    'application/x-msclip': { source: 'apache', extensions: ['clp'] },
    'application/x-msdos-program': { extensions: ['exe'] },
    'application/x-msdownload': { source: 'apache', extensions: ['exe', 'dll', 'com', 'bat', 'msi'] },
    'application/x-msmediaview': { source: 'apache', extensions: ['mvb', 'm13', 'm14'] },
    'application/x-msmetafile': { source: 'apache', extensions: ['wmf', 'wmz', 'emf', 'emz'] },
    'application/x-msmoney': { source: 'apache', extensions: ['mny'] },
    'application/x-mspublisher': { source: 'apache', extensions: ['pub'] },
    'application/x-msschedule': { source: 'apache', extensions: ['scd'] },
    'application/x-msterminal': { source: 'apache', extensions: ['trm'] },
    'application/x-mswrite': { source: 'apache', extensions: ['wri'] },
    'application/x-netcdf': { source: 'apache', extensions: ['nc', 'cdf'] },
    'application/x-ns-proxy-autoconfig': { compressible: !0, extensions: ['pac'] },
    'application/x-nzb': { source: 'apache', extensions: ['nzb'] },
    'application/x-perl': { source: 'nginx', extensions: ['pl', 'pm'] },
    'application/x-pilot': { source: 'nginx', extensions: ['prc', 'pdb'] },
    'application/x-pkcs12': { source: 'apache', compressible: !1, extensions: ['p12', 'pfx'] },
    'application/x-pkcs7-certificates': { source: 'apache', extensions: ['p7b', 'spc'] },
    'application/x-pkcs7-certreqresp': { source: 'apache', extensions: ['p7r'] },
    'application/x-pki-message': { source: 'iana' },
    'application/x-rar-compressed': { source: 'apache', compressible: !1, extensions: ['rar'] },
    'application/x-redhat-package-manager': { source: 'nginx', extensions: ['rpm'] },
    'application/x-research-info-systems': { source: 'apache', extensions: ['ris'] },
    'application/x-sea': { source: 'nginx', extensions: ['sea'] },
    'application/x-sh': { source: 'apache', compressible: !0, extensions: ['sh'] },
    'application/x-shar': { source: 'apache', extensions: ['shar'] },
    'application/x-shockwave-flash': { source: 'apache', compressible: !1, extensions: ['swf'] },
    'application/x-silverlight-app': { source: 'apache', extensions: ['xap'] },
    'application/x-sql': { source: 'apache', extensions: ['sql'] },
    'application/x-stuffit': { source: 'apache', compressible: !1, extensions: ['sit'] },
    'application/x-stuffitx': { source: 'apache', extensions: ['sitx'] },
    'application/x-subrip': { source: 'apache', extensions: ['srt'] },
    'application/x-sv4cpio': { source: 'apache', extensions: ['sv4cpio'] },
    'application/x-sv4crc': { source: 'apache', extensions: ['sv4crc'] },
    'application/x-t3vm-image': { source: 'apache', extensions: ['t3'] },
    'application/x-tads': { source: 'apache', extensions: ['gam'] },
    'application/x-tar': { source: 'apache', compressible: !0, extensions: ['tar'] },
    'application/x-tcl': { source: 'apache', extensions: ['tcl', 'tk'] },
    'application/x-tex': { source: 'apache', extensions: ['tex'] },
    'application/x-tex-tfm': { source: 'apache', extensions: ['tfm'] },
    'application/x-texinfo': { source: 'apache', extensions: ['texinfo', 'texi'] },
    'application/x-tgif': { source: 'apache', extensions: ['obj'] },
    'application/x-ustar': { source: 'apache', extensions: ['ustar'] },
    'application/x-virtualbox-hdd': { compressible: !0, extensions: ['hdd'] },
    'application/x-virtualbox-ova': { compressible: !0, extensions: ['ova'] },
    'application/x-virtualbox-ovf': { compressible: !0, extensions: ['ovf'] },
    'application/x-virtualbox-vbox': { compressible: !0, extensions: ['vbox'] },
    'application/x-virtualbox-vbox-extpack': { compressible: !1, extensions: ['vbox-extpack'] },
    'application/x-virtualbox-vdi': { compressible: !0, extensions: ['vdi'] },
    'application/x-virtualbox-vhd': { compressible: !0, extensions: ['vhd'] },
    'application/x-virtualbox-vmdk': { compressible: !0, extensions: ['vmdk'] },
    'application/x-wais-source': { source: 'apache', extensions: ['src'] },
    'application/x-web-app-manifest+json': { compressible: !0, extensions: ['webapp'] },
    'application/x-www-form-urlencoded': { source: 'iana', compressible: !0 },
    'application/x-x509-ca-cert': { source: 'iana', extensions: ['der', 'crt', 'pem'] },
    'application/x-x509-ca-ra-cert': { source: 'iana' },
    'application/x-x509-next-ca-cert': { source: 'iana' },
    'application/x-xfig': { source: 'apache', extensions: ['fig'] },
    'application/x-xliff+xml': { source: 'apache', compressible: !0, extensions: ['xlf'] },
    'application/x-xpinstall': { source: 'apache', compressible: !1, extensions: ['xpi'] },
    'application/x-xz': { source: 'apache', extensions: ['xz'] },
    'application/x-zmachine': { source: 'apache', extensions: ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8'] },
    'application/x400-bp': { source: 'iana' },
    'application/xacml+xml': { source: 'iana', compressible: !0 },
    'application/xaml+xml': { source: 'apache', compressible: !0, extensions: ['xaml'] },
    'application/xcap-att+xml': { source: 'iana', compressible: !0, extensions: ['xav'] },
    'application/xcap-caps+xml': { source: 'iana', compressible: !0, extensions: ['xca'] },
    'application/xcap-diff+xml': { source: 'iana', compressible: !0, extensions: ['xdf'] },
    'application/xcap-el+xml': { source: 'iana', compressible: !0, extensions: ['xel'] },
    'application/xcap-error+xml': { source: 'iana', compressible: !0 },
    'application/xcap-ns+xml': { source: 'iana', compressible: !0, extensions: ['xns'] },
    'application/xcon-conference-info+xml': { source: 'iana', compressible: !0 },
    'application/xcon-conference-info-diff+xml': { source: 'iana', compressible: !0 },
    'application/xenc+xml': { source: 'iana', compressible: !0, extensions: ['xenc'] },
    'application/xhtml+xml': { source: 'iana', compressible: !0, extensions: ['xhtml', 'xht'] },
    'application/xhtml-voice+xml': { source: 'apache', compressible: !0 },
    'application/xliff+xml': { source: 'iana', compressible: !0, extensions: ['xlf'] },
    'application/xml': { source: 'iana', compressible: !0, extensions: ['xml', 'xsl', 'xsd', 'rng'] },
    'application/xml-dtd': { source: 'iana', compressible: !0, extensions: ['dtd'] },
    'application/xml-external-parsed-entity': { source: 'iana' },
    'application/xml-patch+xml': { source: 'iana', compressible: !0 },
    'application/xmpp+xml': { source: 'iana', compressible: !0 },
    'application/xop+xml': { source: 'iana', compressible: !0, extensions: ['xop'] },
    'application/xproc+xml': { source: 'apache', compressible: !0, extensions: ['xpl'] },
    'application/xslt+xml': { source: 'iana', compressible: !0, extensions: ['xsl', 'xslt'] },
    'application/xspf+xml': { source: 'apache', compressible: !0, extensions: ['xspf'] },
    'application/xv+xml': { source: 'iana', compressible: !0, extensions: ['mxml', 'xhvml', 'xvml', 'xvm'] },
    'application/yang': { source: 'iana', extensions: ['yang'] },
    'application/yang-data+json': { source: 'iana', compressible: !0 },
    'application/yang-data+xml': { source: 'iana', compressible: !0 },
    'application/yang-patch+json': { source: 'iana', compressible: !0 },
    'application/yang-patch+xml': { source: 'iana', compressible: !0 },
    'application/yin+xml': { source: 'iana', compressible: !0, extensions: ['yin'] },
    'application/zip': { source: 'iana', compressible: !1, extensions: ['zip'] },
    'application/zlib': { source: 'iana' },
    'application/zstd': { source: 'iana' },
    'audio/1d-interleaved-parityfec': { source: 'iana' },
    'audio/32kadpcm': { source: 'iana' },
    'audio/3gpp': { source: 'iana', compressible: !1, extensions: ['3gpp'] },
    'audio/3gpp2': { source: 'iana' },
    'audio/aac': { source: 'iana' },
    'audio/ac3': { source: 'iana' },
    'audio/adpcm': { source: 'apache', extensions: ['adp'] },
    'audio/amr': { source: 'iana', extensions: ['amr'] },
    'audio/amr-wb': { source: 'iana' },
    'audio/amr-wb+': { source: 'iana' },
    'audio/aptx': { source: 'iana' },
    'audio/asc': { source: 'iana' },
    'audio/atrac-advanced-lossless': { source: 'iana' },
    'audio/atrac-x': { source: 'iana' },
    'audio/atrac3': { source: 'iana' },
    'audio/basic': { source: 'iana', compressible: !1, extensions: ['au', 'snd'] },
    'audio/bv16': { source: 'iana' },
    'audio/bv32': { source: 'iana' },
    'audio/clearmode': { source: 'iana' },
    'audio/cn': { source: 'iana' },
    'audio/dat12': { source: 'iana' },
    'audio/dls': { source: 'iana' },
    'audio/dsr-es201108': { source: 'iana' },
    'audio/dsr-es202050': { source: 'iana' },
    'audio/dsr-es202211': { source: 'iana' },
    'audio/dsr-es202212': { source: 'iana' },
    'audio/dv': { source: 'iana' },
    'audio/dvi4': { source: 'iana' },
    'audio/eac3': { source: 'iana' },
    'audio/encaprtp': { source: 'iana' },
    'audio/evrc': { source: 'iana' },
    'audio/evrc-qcp': { source: 'iana' },
    'audio/evrc0': { source: 'iana' },
    'audio/evrc1': { source: 'iana' },
    'audio/evrcb': { source: 'iana' },
    'audio/evrcb0': { source: 'iana' },
    'audio/evrcb1': { source: 'iana' },
    'audio/evrcnw': { source: 'iana' },
    'audio/evrcnw0': { source: 'iana' },
    'audio/evrcnw1': { source: 'iana' },
    'audio/evrcwb': { source: 'iana' },
    'audio/evrcwb0': { source: 'iana' },
    'audio/evrcwb1': { source: 'iana' },
    'audio/evs': { source: 'iana' },
    'audio/flexfec': { source: 'iana' },
    'audio/fwdred': { source: 'iana' },
    'audio/g711-0': { source: 'iana' },
    'audio/g719': { source: 'iana' },
    'audio/g722': { source: 'iana' },
    'audio/g7221': { source: 'iana' },
    'audio/g723': { source: 'iana' },
    'audio/g726-16': { source: 'iana' },
    'audio/g726-24': { source: 'iana' },
    'audio/g726-32': { source: 'iana' },
    'audio/g726-40': { source: 'iana' },
    'audio/g728': { source: 'iana' },
    'audio/g729': { source: 'iana' },
    'audio/g7291': { source: 'iana' },
    'audio/g729d': { source: 'iana' },
    'audio/g729e': { source: 'iana' },
    'audio/gsm': { source: 'iana' },
    'audio/gsm-efr': { source: 'iana' },
    'audio/gsm-hr-08': { source: 'iana' },
    'audio/ilbc': { source: 'iana' },
    'audio/ip-mr_v2.5': { source: 'iana' },
    'audio/isac': { source: 'apache' },
    'audio/l16': { source: 'iana' },
    'audio/l20': { source: 'iana' },
    'audio/l24': { source: 'iana', compressible: !1 },
    'audio/l8': { source: 'iana' },
    'audio/lpc': { source: 'iana' },
    'audio/melp': { source: 'iana' },
    'audio/melp1200': { source: 'iana' },
    'audio/melp2400': { source: 'iana' },
    'audio/melp600': { source: 'iana' },
    'audio/mhas': { source: 'iana' },
    'audio/midi': { source: 'apache', extensions: ['mid', 'midi', 'kar', 'rmi'] },
    'audio/mobile-xmf': { source: 'iana', extensions: ['mxmf'] },
    'audio/mp3': { compressible: !1, extensions: ['mp3'] },
    'audio/mp4': { source: 'iana', compressible: !1, extensions: ['m4a', 'mp4a'] },
    'audio/mp4a-latm': { source: 'iana' },
    'audio/mpa': { source: 'iana' },
    'audio/mpa-robust': { source: 'iana' },
    'audio/mpeg': { source: 'iana', compressible: !1, extensions: ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'] },
    'audio/mpeg4-generic': { source: 'iana' },
    'audio/musepack': { source: 'apache' },
    'audio/ogg': { source: 'iana', compressible: !1, extensions: ['oga', 'ogg', 'spx', 'opus'] },
    'audio/opus': { source: 'iana' },
    'audio/parityfec': { source: 'iana' },
    'audio/pcma': { source: 'iana' },
    'audio/pcma-wb': { source: 'iana' },
    'audio/pcmu': { source: 'iana' },
    'audio/pcmu-wb': { source: 'iana' },
    'audio/prs.sid': { source: 'iana' },
    'audio/qcelp': { source: 'iana' },
    'audio/raptorfec': { source: 'iana' },
    'audio/red': { source: 'iana' },
    'audio/rtp-enc-aescm128': { source: 'iana' },
    'audio/rtp-midi': { source: 'iana' },
    'audio/rtploopback': { source: 'iana' },
    'audio/rtx': { source: 'iana' },
    'audio/s3m': { source: 'apache', extensions: ['s3m'] },
    'audio/scip': { source: 'iana' },
    'audio/silk': { source: 'apache', extensions: ['sil'] },
    'audio/smv': { source: 'iana' },
    'audio/smv-qcp': { source: 'iana' },
    'audio/smv0': { source: 'iana' },
    'audio/sofa': { source: 'iana' },
    'audio/sp-midi': { source: 'iana' },
    'audio/speex': { source: 'iana' },
    'audio/t140c': { source: 'iana' },
    'audio/t38': { source: 'iana' },
    'audio/telephone-event': { source: 'iana' },
    'audio/tetra_acelp': { source: 'iana' },
    'audio/tetra_acelp_bb': { source: 'iana' },
    'audio/tone': { source: 'iana' },
    'audio/tsvcis': { source: 'iana' },
    'audio/uemclip': { source: 'iana' },
    'audio/ulpfec': { source: 'iana' },
    'audio/usac': { source: 'iana' },
    'audio/vdvi': { source: 'iana' },
    'audio/vmr-wb': { source: 'iana' },
    'audio/vnd.3gpp.iufp': { source: 'iana' },
    'audio/vnd.4sb': { source: 'iana' },
    'audio/vnd.audiokoz': { source: 'iana' },
    'audio/vnd.celp': { source: 'iana' },
    'audio/vnd.cisco.nse': { source: 'iana' },
    'audio/vnd.cmles.radio-events': { source: 'iana' },
    'audio/vnd.cns.anp1': { source: 'iana' },
    'audio/vnd.cns.inf1': { source: 'iana' },
    'audio/vnd.dece.audio': { source: 'iana', extensions: ['uva', 'uvva'] },
    'audio/vnd.digital-winds': { source: 'iana', extensions: ['eol'] },
    'audio/vnd.dlna.adts': { source: 'iana' },
    'audio/vnd.dolby.heaac.1': { source: 'iana' },
    'audio/vnd.dolby.heaac.2': { source: 'iana' },
    'audio/vnd.dolby.mlp': { source: 'iana' },
    'audio/vnd.dolby.mps': { source: 'iana' },
    'audio/vnd.dolby.pl2': { source: 'iana' },
    'audio/vnd.dolby.pl2x': { source: 'iana' },
    'audio/vnd.dolby.pl2z': { source: 'iana' },
    'audio/vnd.dolby.pulse.1': { source: 'iana' },
    'audio/vnd.dra': { source: 'iana', extensions: ['dra'] },
    'audio/vnd.dts': { source: 'iana', extensions: ['dts'] },
    'audio/vnd.dts.hd': { source: 'iana', extensions: ['dtshd'] },
    'audio/vnd.dts.uhd': { source: 'iana' },
    'audio/vnd.dvb.file': { source: 'iana' },
    'audio/vnd.everad.plj': { source: 'iana' },
    'audio/vnd.hns.audio': { source: 'iana' },
    'audio/vnd.lucent.voice': { source: 'iana', extensions: ['lvp'] },
    'audio/vnd.ms-playready.media.pya': { source: 'iana', extensions: ['pya'] },
    'audio/vnd.nokia.mobile-xmf': { source: 'iana' },
    'audio/vnd.nortel.vbk': { source: 'iana' },
    'audio/vnd.nuera.ecelp4800': { source: 'iana', extensions: ['ecelp4800'] },
    'audio/vnd.nuera.ecelp7470': { source: 'iana', extensions: ['ecelp7470'] },
    'audio/vnd.nuera.ecelp9600': { source: 'iana', extensions: ['ecelp9600'] },
    'audio/vnd.octel.sbc': { source: 'iana' },
    'audio/vnd.presonus.multitrack': { source: 'iana' },
    'audio/vnd.qcelp': { source: 'iana' },
    'audio/vnd.rhetorex.32kadpcm': { source: 'iana' },
    'audio/vnd.rip': { source: 'iana', extensions: ['rip'] },
    'audio/vnd.rn-realaudio': { compressible: !1 },
    'audio/vnd.sealedmedia.softseal.mpeg': { source: 'iana' },
    'audio/vnd.vmx.cvsd': { source: 'iana' },
    'audio/vnd.wave': { compressible: !1 },
    'audio/vorbis': { source: 'iana', compressible: !1 },
    'audio/vorbis-config': { source: 'iana' },
    'audio/wav': { compressible: !1, extensions: ['wav'] },
    'audio/wave': { compressible: !1, extensions: ['wav'] },
    'audio/webm': { source: 'apache', compressible: !1, extensions: ['weba'] },
    'audio/x-aac': { source: 'apache', compressible: !1, extensions: ['aac'] },
    'audio/x-aiff': { source: 'apache', extensions: ['aif', 'aiff', 'aifc'] },
    'audio/x-caf': { source: 'apache', compressible: !1, extensions: ['caf'] },
    'audio/x-flac': { source: 'apache', extensions: ['flac'] },
    'audio/x-m4a': { source: 'nginx', extensions: ['m4a'] },
    'audio/x-matroska': { source: 'apache', extensions: ['mka'] },
    'audio/x-mpegurl': { source: 'apache', extensions: ['m3u'] },
    'audio/x-ms-wax': { source: 'apache', extensions: ['wax'] },
    'audio/x-ms-wma': { source: 'apache', extensions: ['wma'] },
    'audio/x-pn-realaudio': { source: 'apache', extensions: ['ram', 'ra'] },
    'audio/x-pn-realaudio-plugin': { source: 'apache', extensions: ['rmp'] },
    'audio/x-realaudio': { source: 'nginx', extensions: ['ra'] },
    'audio/x-tta': { source: 'apache' },
    'audio/x-wav': { source: 'apache', extensions: ['wav'] },
    'audio/xm': { source: 'apache', extensions: ['xm'] },
    'chemical/x-cdx': { source: 'apache', extensions: ['cdx'] },
    'chemical/x-cif': { source: 'apache', extensions: ['cif'] },
    'chemical/x-cmdf': { source: 'apache', extensions: ['cmdf'] },
    'chemical/x-cml': { source: 'apache', extensions: ['cml'] },
    'chemical/x-csml': { source: 'apache', extensions: ['csml'] },
    'chemical/x-pdb': { source: 'apache' },
    'chemical/x-xyz': { source: 'apache', extensions: ['xyz'] },
    'font/collection': { source: 'iana', extensions: ['ttc'] },
    'font/otf': { source: 'iana', compressible: !0, extensions: ['otf'] },
    'font/sfnt': { source: 'iana' },
    'font/ttf': { source: 'iana', compressible: !0, extensions: ['ttf'] },
    'font/woff': { source: 'iana', extensions: ['woff'] },
    'font/woff2': { source: 'iana', extensions: ['woff2'] },
    'image/aces': { source: 'iana', extensions: ['exr'] },
    'image/apng': { compressible: !1, extensions: ['apng'] },
    'image/avci': { source: 'iana', extensions: ['avci'] },
    'image/avcs': { source: 'iana', extensions: ['avcs'] },
    'image/avif': { source: 'iana', compressible: !1, extensions: ['avif'] },
    'image/bmp': { source: 'iana', compressible: !0, extensions: ['bmp'] },
    'image/cgm': { source: 'iana', extensions: ['cgm'] },
    'image/dicom-rle': { source: 'iana', extensions: ['drle'] },
    'image/emf': { source: 'iana', extensions: ['emf'] },
    'image/fits': { source: 'iana', extensions: ['fits'] },
    'image/g3fax': { source: 'iana', extensions: ['g3'] },
    'image/gif': { source: 'iana', compressible: !1, extensions: ['gif'] },
    'image/heic': { source: 'iana', extensions: ['heic'] },
    'image/heic-sequence': { source: 'iana', extensions: ['heics'] },
    'image/heif': { source: 'iana', extensions: ['heif'] },
    'image/heif-sequence': { source: 'iana', extensions: ['heifs'] },
    'image/hej2k': { source: 'iana', extensions: ['hej2'] },
    'image/hsj2': { source: 'iana', extensions: ['hsj2'] },
    'image/ief': { source: 'iana', extensions: ['ief'] },
    'image/jls': { source: 'iana', extensions: ['jls'] },
    'image/jp2': { source: 'iana', compressible: !1, extensions: ['jp2', 'jpg2'] },
    'image/jpeg': { source: 'iana', compressible: !1, extensions: ['jpeg', 'jpg', 'jpe'] },
    'image/jph': { source: 'iana', extensions: ['jph'] },
    'image/jphc': { source: 'iana', extensions: ['jhc'] },
    'image/jpm': { source: 'iana', compressible: !1, extensions: ['jpm'] },
    'image/jpx': { source: 'iana', compressible: !1, extensions: ['jpx', 'jpf'] },
    'image/jxr': { source: 'iana', extensions: ['jxr'] },
    'image/jxra': { source: 'iana', extensions: ['jxra'] },
    'image/jxrs': { source: 'iana', extensions: ['jxrs'] },
    'image/jxs': { source: 'iana', extensions: ['jxs'] },
    'image/jxsc': { source: 'iana', extensions: ['jxsc'] },
    'image/jxsi': { source: 'iana', extensions: ['jxsi'] },
    'image/jxss': { source: 'iana', extensions: ['jxss'] },
    'image/ktx': { source: 'iana', extensions: ['ktx'] },
    'image/ktx2': { source: 'iana', extensions: ['ktx2'] },
    'image/naplps': { source: 'iana' },
    'image/pjpeg': { compressible: !1 },
    'image/png': { source: 'iana', compressible: !1, extensions: ['png'] },
    'image/prs.btif': { source: 'iana', extensions: ['btif'] },
    'image/prs.pti': { source: 'iana', extensions: ['pti'] },
    'image/pwg-raster': { source: 'iana' },
    'image/sgi': { source: 'apache', extensions: ['sgi'] },
    'image/svg+xml': { source: 'iana', compressible: !0, extensions: ['svg', 'svgz'] },
    'image/t38': { source: 'iana', extensions: ['t38'] },
    'image/tiff': { source: 'iana', compressible: !1, extensions: ['tif', 'tiff'] },
    'image/tiff-fx': { source: 'iana', extensions: ['tfx'] },
    'image/vnd.adobe.photoshop': { source: 'iana', compressible: !0, extensions: ['psd'] },
    'image/vnd.airzip.accelerator.azv': { source: 'iana', extensions: ['azv'] },
    'image/vnd.cns.inf2': { source: 'iana' },
    'image/vnd.dece.graphic': { source: 'iana', extensions: ['uvi', 'uvvi', 'uvg', 'uvvg'] },
    'image/vnd.djvu': { source: 'iana', extensions: ['djvu', 'djv'] },
    'image/vnd.dvb.subtitle': { source: 'iana', extensions: ['sub'] },
    'image/vnd.dwg': { source: 'iana', extensions: ['dwg'] },
    'image/vnd.dxf': { source: 'iana', extensions: ['dxf'] },
    'image/vnd.fastbidsheet': { source: 'iana', extensions: ['fbs'] },
    'image/vnd.fpx': { source: 'iana', extensions: ['fpx'] },
    'image/vnd.fst': { source: 'iana', extensions: ['fst'] },
    'image/vnd.fujixerox.edmics-mmr': { source: 'iana', extensions: ['mmr'] },
    'image/vnd.fujixerox.edmics-rlc': { source: 'iana', extensions: ['rlc'] },
    'image/vnd.globalgraphics.pgb': { source: 'iana' },
    'image/vnd.microsoft.icon': { source: 'iana', compressible: !0, extensions: ['ico'] },
    'image/vnd.mix': { source: 'iana' },
    'image/vnd.mozilla.apng': { source: 'iana' },
    'image/vnd.ms-dds': { compressible: !0, extensions: ['dds'] },
    'image/vnd.ms-modi': { source: 'iana', extensions: ['mdi'] },
    'image/vnd.ms-photo': { source: 'apache', extensions: ['wdp'] },
    'image/vnd.net-fpx': { source: 'iana', extensions: ['npx'] },
    'image/vnd.pco.b16': { source: 'iana', extensions: ['b16'] },
    'image/vnd.radiance': { source: 'iana' },
    'image/vnd.sealed.png': { source: 'iana' },
    'image/vnd.sealedmedia.softseal.gif': { source: 'iana' },
    'image/vnd.sealedmedia.softseal.jpg': { source: 'iana' },
    'image/vnd.svf': { source: 'iana' },
    'image/vnd.tencent.tap': { source: 'iana', extensions: ['tap'] },
    'image/vnd.valve.source.texture': { source: 'iana', extensions: ['vtf'] },
    'image/vnd.wap.wbmp': { source: 'iana', extensions: ['wbmp'] },
    'image/vnd.xiff': { source: 'iana', extensions: ['xif'] },
    'image/vnd.zbrush.pcx': { source: 'iana', extensions: ['pcx'] },
    'image/webp': { source: 'apache', extensions: ['webp'] },
    'image/wmf': { source: 'iana', extensions: ['wmf'] },
    'image/x-3ds': { source: 'apache', extensions: ['3ds'] },
    'image/x-cmu-raster': { source: 'apache', extensions: ['ras'] },
    'image/x-cmx': { source: 'apache', extensions: ['cmx'] },
    'image/x-freehand': { source: 'apache', extensions: ['fh', 'fhc', 'fh4', 'fh5', 'fh7'] },
    'image/x-icon': { source: 'apache', compressible: !0, extensions: ['ico'] },
    'image/x-jng': { source: 'nginx', extensions: ['jng'] },
    'image/x-mrsid-image': { source: 'apache', extensions: ['sid'] },
    'image/x-ms-bmp': { source: 'nginx', compressible: !0, extensions: ['bmp'] },
    'image/x-pcx': { source: 'apache', extensions: ['pcx'] },
    'image/x-pict': { source: 'apache', extensions: ['pic', 'pct'] },
    'image/x-portable-anymap': { source: 'apache', extensions: ['pnm'] },
    'image/x-portable-bitmap': { source: 'apache', extensions: ['pbm'] },
    'image/x-portable-graymap': { source: 'apache', extensions: ['pgm'] },
    'image/x-portable-pixmap': { source: 'apache', extensions: ['ppm'] },
    'image/x-rgb': { source: 'apache', extensions: ['rgb'] },
    'image/x-tga': { source: 'apache', extensions: ['tga'] },
    'image/x-xbitmap': { source: 'apache', extensions: ['xbm'] },
    'image/x-xcf': { compressible: !1 },
    'image/x-xpixmap': { source: 'apache', extensions: ['xpm'] },
    'image/x-xwindowdump': { source: 'apache', extensions: ['xwd'] },
    'message/cpim': { source: 'iana' },
    'message/delivery-status': { source: 'iana' },
    'message/disposition-notification': { source: 'iana', extensions: ['disposition-notification'] },
    'message/external-body': { source: 'iana' },
    'message/feedback-report': { source: 'iana' },
    'message/global': { source: 'iana', extensions: ['u8msg'] },
    'message/global-delivery-status': { source: 'iana', extensions: ['u8dsn'] },
    'message/global-disposition-notification': { source: 'iana', extensions: ['u8mdn'] },
    'message/global-headers': { source: 'iana', extensions: ['u8hdr'] },
    'message/http': { source: 'iana', compressible: !1 },
    'message/imdn+xml': { source: 'iana', compressible: !0 },
    'message/news': { source: 'iana' },
    'message/partial': { source: 'iana', compressible: !1 },
    'message/rfc822': { source: 'iana', compressible: !0, extensions: ['eml', 'mime'] },
    'message/s-http': { source: 'iana' },
    'message/sip': { source: 'iana' },
    'message/sipfrag': { source: 'iana' },
    'message/tracking-status': { source: 'iana' },
    'message/vnd.si.simp': { source: 'iana' },
    'message/vnd.wfa.wsc': { source: 'iana', extensions: ['wsc'] },
    'model/3mf': { source: 'iana', extensions: ['3mf'] },
    'model/e57': { source: 'iana' },
    'model/gltf+json': { source: 'iana', compressible: !0, extensions: ['gltf'] },
    'model/gltf-binary': { source: 'iana', compressible: !0, extensions: ['glb'] },
    'model/iges': { source: 'iana', compressible: !1, extensions: ['igs', 'iges'] },
    'model/mesh': { source: 'iana', compressible: !1, extensions: ['msh', 'mesh', 'silo'] },
    'model/mtl': { source: 'iana', extensions: ['mtl'] },
    'model/obj': { source: 'iana', extensions: ['obj'] },
    'model/step': { source: 'iana' },
    'model/step+xml': { source: 'iana', compressible: !0, extensions: ['stpx'] },
    'model/step+zip': { source: 'iana', compressible: !1, extensions: ['stpz'] },
    'model/step-xml+zip': { source: 'iana', compressible: !1, extensions: ['stpxz'] },
    'model/stl': { source: 'iana', extensions: ['stl'] },
    'model/vnd.collada+xml': { source: 'iana', compressible: !0, extensions: ['dae'] },
    'model/vnd.dwf': { source: 'iana', extensions: ['dwf'] },
    'model/vnd.flatland.3dml': { source: 'iana' },
    'model/vnd.gdl': { source: 'iana', extensions: ['gdl'] },
    'model/vnd.gs-gdl': { source: 'apache' },
    'model/vnd.gs.gdl': { source: 'iana' },
    'model/vnd.gtw': { source: 'iana', extensions: ['gtw'] },
    'model/vnd.moml+xml': { source: 'iana', compressible: !0 },
    'model/vnd.mts': { source: 'iana', extensions: ['mts'] },
    'model/vnd.opengex': { source: 'iana', extensions: ['ogex'] },
    'model/vnd.parasolid.transmit.binary': { source: 'iana', extensions: ['x_b'] },
    'model/vnd.parasolid.transmit.text': { source: 'iana', extensions: ['x_t'] },
    'model/vnd.pytha.pyox': { source: 'iana' },
    'model/vnd.rosette.annotated-data-model': { source: 'iana' },
    'model/vnd.sap.vds': { source: 'iana', extensions: ['vds'] },
    'model/vnd.usdz+zip': { source: 'iana', compressible: !1, extensions: ['usdz'] },
    'model/vnd.valve.source.compiled-map': { source: 'iana', extensions: ['bsp'] },
    'model/vnd.vtu': { source: 'iana', extensions: ['vtu'] },
    'model/vrml': { source: 'iana', compressible: !1, extensions: ['wrl', 'vrml'] },
    'model/x3d+binary': { source: 'apache', compressible: !1, extensions: ['x3db', 'x3dbz'] },
    'model/x3d+fastinfoset': { source: 'iana', extensions: ['x3db'] },
    'model/x3d+vrml': { source: 'apache', compressible: !1, extensions: ['x3dv', 'x3dvz'] },
    'model/x3d+xml': { source: 'iana', compressible: !0, extensions: ['x3d', 'x3dz'] },
    'model/x3d-vrml': { source: 'iana', extensions: ['x3dv'] },
    'multipart/alternative': { source: 'iana', compressible: !1 },
    'multipart/appledouble': { source: 'iana' },
    'multipart/byteranges': { source: 'iana' },
    'multipart/digest': { source: 'iana' },
    'multipart/encrypted': { source: 'iana', compressible: !1 },
    'multipart/form-data': { source: 'iana', compressible: !1 },
    'multipart/header-set': { source: 'iana' },
    'multipart/mixed': { source: 'iana' },
    'multipart/multilingual': { source: 'iana' },
    'multipart/parallel': { source: 'iana' },
    'multipart/related': { source: 'iana', compressible: !1 },
    'multipart/report': { source: 'iana' },
    'multipart/signed': { source: 'iana', compressible: !1 },
    'multipart/vnd.bint.med-plus': { source: 'iana' },
    'multipart/voice-message': { source: 'iana' },
    'multipart/x-mixed-replace': { source: 'iana' },
    'text/1d-interleaved-parityfec': { source: 'iana' },
    'text/cache-manifest': { source: 'iana', compressible: !0, extensions: ['appcache', 'manifest'] },
    'text/calendar': { source: 'iana', extensions: ['ics', 'ifb'] },
    'text/calender': { compressible: !0 },
    'text/cmd': { compressible: !0 },
    'text/coffeescript': { extensions: ['coffee', 'litcoffee'] },
    'text/cql': { source: 'iana' },
    'text/cql-expression': { source: 'iana' },
    'text/cql-identifier': { source: 'iana' },
    'text/css': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['css'] },
    'text/csv': { source: 'iana', compressible: !0, extensions: ['csv'] },
    'text/csv-schema': { source: 'iana' },
    'text/directory': { source: 'iana' },
    'text/dns': { source: 'iana' },
    'text/ecmascript': { source: 'iana' },
    'text/encaprtp': { source: 'iana' },
    'text/enriched': { source: 'iana' },
    'text/fhirpath': { source: 'iana' },
    'text/flexfec': { source: 'iana' },
    'text/fwdred': { source: 'iana' },
    'text/gff3': { source: 'iana' },
    'text/grammar-ref-list': { source: 'iana' },
    'text/html': { source: 'iana', compressible: !0, extensions: ['html', 'htm', 'shtml'] },
    'text/jade': { extensions: ['jade'] },
    'text/javascript': { source: 'iana', compressible: !0 },
    'text/jcr-cnd': { source: 'iana' },
    'text/jsx': { compressible: !0, extensions: ['jsx'] },
    'text/less': { compressible: !0, extensions: ['less'] },
    'text/markdown': { source: 'iana', compressible: !0, extensions: ['markdown', 'md'] },
    'text/mathml': { source: 'nginx', extensions: ['mml'] },
    'text/mdx': { compressible: !0, extensions: ['mdx'] },
    'text/mizar': { source: 'iana' },
    'text/n3': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['n3'] },
    'text/parameters': { source: 'iana', charset: 'UTF-8' },
    'text/parityfec': { source: 'iana' },
    'text/plain': {
      source: 'iana',
      compressible: !0,
      extensions: ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
    },
    'text/provenance-notation': { source: 'iana', charset: 'UTF-8' },
    'text/prs.fallenstein.rst': { source: 'iana' },
    'text/prs.lines.tag': { source: 'iana', extensions: ['dsc'] },
    'text/prs.prop.logic': { source: 'iana' },
    'text/raptorfec': { source: 'iana' },
    'text/red': { source: 'iana' },
    'text/rfc822-headers': { source: 'iana' },
    'text/richtext': { source: 'iana', compressible: !0, extensions: ['rtx'] },
    'text/rtf': { source: 'iana', compressible: !0, extensions: ['rtf'] },
    'text/rtp-enc-aescm128': { source: 'iana' },
    'text/rtploopback': { source: 'iana' },
    'text/rtx': { source: 'iana' },
    'text/sgml': { source: 'iana', extensions: ['sgml', 'sgm'] },
    'text/shaclc': { source: 'iana' },
    'text/shex': { source: 'iana', extensions: ['shex'] },
    'text/slim': { extensions: ['slim', 'slm'] },
    'text/spdx': { source: 'iana', extensions: ['spdx'] },
    'text/strings': { source: 'iana' },
    'text/stylus': { extensions: ['stylus', 'styl'] },
    'text/t140': { source: 'iana' },
    'text/tab-separated-values': { source: 'iana', compressible: !0, extensions: ['tsv'] },
    'text/troff': { source: 'iana', extensions: ['t', 'tr', 'roff', 'man', 'me', 'ms'] },
    'text/turtle': { source: 'iana', charset: 'UTF-8', extensions: ['ttl'] },
    'text/ulpfec': { source: 'iana' },
    'text/uri-list': { source: 'iana', compressible: !0, extensions: ['uri', 'uris', 'urls'] },
    'text/vcard': { source: 'iana', compressible: !0, extensions: ['vcard'] },
    'text/vnd.a': { source: 'iana' },
    'text/vnd.abc': { source: 'iana' },
    'text/vnd.ascii-art': { source: 'iana' },
    'text/vnd.curl': { source: 'iana', extensions: ['curl'] },
    'text/vnd.curl.dcurl': { source: 'apache', extensions: ['dcurl'] },
    'text/vnd.curl.mcurl': { source: 'apache', extensions: ['mcurl'] },
    'text/vnd.curl.scurl': { source: 'apache', extensions: ['scurl'] },
    'text/vnd.debian.copyright': { source: 'iana', charset: 'UTF-8' },
    'text/vnd.dmclientscript': { source: 'iana' },
    'text/vnd.dvb.subtitle': { source: 'iana', extensions: ['sub'] },
    'text/vnd.esmertec.theme-descriptor': { source: 'iana', charset: 'UTF-8' },
    'text/vnd.familysearch.gedcom': { source: 'iana', extensions: ['ged'] },
    'text/vnd.ficlab.flt': { source: 'iana' },
    'text/vnd.fly': { source: 'iana', extensions: ['fly'] },
    'text/vnd.fmi.flexstor': { source: 'iana', extensions: ['flx'] },
    'text/vnd.gml': { source: 'iana' },
    'text/vnd.graphviz': { source: 'iana', extensions: ['gv'] },
    'text/vnd.hans': { source: 'iana' },
    'text/vnd.hgl': { source: 'iana' },
    'text/vnd.in3d.3dml': { source: 'iana', extensions: ['3dml'] },
    'text/vnd.in3d.spot': { source: 'iana', extensions: ['spot'] },
    'text/vnd.iptc.newsml': { source: 'iana' },
    'text/vnd.iptc.nitf': { source: 'iana' },
    'text/vnd.latex-z': { source: 'iana' },
    'text/vnd.motorola.reflex': { source: 'iana' },
    'text/vnd.ms-mediapackage': { source: 'iana' },
    'text/vnd.net2phone.commcenter.command': { source: 'iana' },
    'text/vnd.radisys.msml-basic-layout': { source: 'iana' },
    'text/vnd.senx.warpscript': { source: 'iana' },
    'text/vnd.si.uricatalogue': { source: 'iana' },
    'text/vnd.sosi': { source: 'iana' },
    'text/vnd.sun.j2me.app-descriptor': { source: 'iana', charset: 'UTF-8', extensions: ['jad'] },
    'text/vnd.trolltech.linguist': { source: 'iana', charset: 'UTF-8' },
    'text/vnd.wap.si': { source: 'iana' },
    'text/vnd.wap.sl': { source: 'iana' },
    'text/vnd.wap.wml': { source: 'iana', extensions: ['wml'] },
    'text/vnd.wap.wmlscript': { source: 'iana', extensions: ['wmls'] },
    'text/vtt': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['vtt'] },
    'text/x-asm': { source: 'apache', extensions: ['s', 'asm'] },
    'text/x-c': { source: 'apache', extensions: ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic'] },
    'text/x-component': { source: 'nginx', extensions: ['htc'] },
    'text/x-fortran': { source: 'apache', extensions: ['f', 'for', 'f77', 'f90'] },
    'text/x-gwt-rpc': { compressible: !0 },
    'text/x-handlebars-template': { extensions: ['hbs'] },
    'text/x-java-source': { source: 'apache', extensions: ['java'] },
    'text/x-jquery-tmpl': { compressible: !0 },
    'text/x-lua': { extensions: ['lua'] },
    'text/x-markdown': { compressible: !0, extensions: ['mkd'] },
    'text/x-nfo': { source: 'apache', extensions: ['nfo'] },
    'text/x-opml': { source: 'apache', extensions: ['opml'] },
    'text/x-org': { compressible: !0, extensions: ['org'] },
    'text/x-pascal': { source: 'apache', extensions: ['p', 'pas'] },
    'text/x-processing': { compressible: !0, extensions: ['pde'] },
    'text/x-sass': { extensions: ['sass'] },
    'text/x-scss': { extensions: ['scss'] },
    'text/x-setext': { source: 'apache', extensions: ['etx'] },
    'text/x-sfv': { source: 'apache', extensions: ['sfv'] },
    'text/x-suse-ymp': { compressible: !0, extensions: ['ymp'] },
    'text/x-uuencode': { source: 'apache', extensions: ['uu'] },
    'text/x-vcalendar': { source: 'apache', extensions: ['vcs'] },
    'text/x-vcard': { source: 'apache', extensions: ['vcf'] },
    'text/xml': { source: 'iana', compressible: !0, extensions: ['xml'] },
    'text/xml-external-parsed-entity': { source: 'iana' },
    'text/yaml': { compressible: !0, extensions: ['yaml', 'yml'] },
    'video/1d-interleaved-parityfec': { source: 'iana' },
    'video/3gpp': { source: 'iana', extensions: ['3gp', '3gpp'] },
    'video/3gpp-tt': { source: 'iana' },
    'video/3gpp2': { source: 'iana', extensions: ['3g2'] },
    'video/av1': { source: 'iana' },
    'video/bmpeg': { source: 'iana' },
    'video/bt656': { source: 'iana' },
    'video/celb': { source: 'iana' },
    'video/dv': { source: 'iana' },
    'video/encaprtp': { source: 'iana' },
    'video/ffv1': { source: 'iana' },
    'video/flexfec': { source: 'iana' },
    'video/h261': { source: 'iana', extensions: ['h261'] },
    'video/h263': { source: 'iana', extensions: ['h263'] },
    'video/h263-1998': { source: 'iana' },
    'video/h263-2000': { source: 'iana' },
    'video/h264': { source: 'iana', extensions: ['h264'] },
    'video/h264-rcdo': { source: 'iana' },
    'video/h264-svc': { source: 'iana' },
    'video/h265': { source: 'iana' },
    'video/iso.segment': { source: 'iana', extensions: ['m4s'] },
    'video/jpeg': { source: 'iana', extensions: ['jpgv'] },
    'video/jpeg2000': { source: 'iana' },
    'video/jpm': { source: 'apache', extensions: ['jpm', 'jpgm'] },
    'video/jxsv': { source: 'iana' },
    'video/mj2': { source: 'iana', extensions: ['mj2', 'mjp2'] },
    'video/mp1s': { source: 'iana' },
    'video/mp2p': { source: 'iana' },
    'video/mp2t': { source: 'iana', extensions: ['ts'] },
    'video/mp4': { source: 'iana', compressible: !1, extensions: ['mp4', 'mp4v', 'mpg4'] },
    'video/mp4v-es': { source: 'iana' },
    'video/mpeg': { source: 'iana', compressible: !1, extensions: ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'] },
    'video/mpeg4-generic': { source: 'iana' },
    'video/mpv': { source: 'iana' },
    'video/nv': { source: 'iana' },
    'video/ogg': { source: 'iana', compressible: !1, extensions: ['ogv'] },
    'video/parityfec': { source: 'iana' },
    'video/pointer': { source: 'iana' },
    'video/quicktime': { source: 'iana', compressible: !1, extensions: ['qt', 'mov'] },
    'video/raptorfec': { source: 'iana' },
    'video/raw': { source: 'iana' },
    'video/rtp-enc-aescm128': { source: 'iana' },
    'video/rtploopback': { source: 'iana' },
    'video/rtx': { source: 'iana' },
    'video/scip': { source: 'iana' },
    'video/smpte291': { source: 'iana' },
    'video/smpte292m': { source: 'iana' },
    'video/ulpfec': { source: 'iana' },
    'video/vc1': { source: 'iana' },
    'video/vc2': { source: 'iana' },
    'video/vnd.cctv': { source: 'iana' },
    'video/vnd.dece.hd': { source: 'iana', extensions: ['uvh', 'uvvh'] },
    'video/vnd.dece.mobile': { source: 'iana', extensions: ['uvm', 'uvvm'] },
    'video/vnd.dece.mp4': { source: 'iana' },
    'video/vnd.dece.pd': { source: 'iana', extensions: ['uvp', 'uvvp'] },
    'video/vnd.dece.sd': { source: 'iana', extensions: ['uvs', 'uvvs'] },
    'video/vnd.dece.video': { source: 'iana', extensions: ['uvv', 'uvvv'] },
    'video/vnd.directv.mpeg': { source: 'iana' },
    'video/vnd.directv.mpeg-tts': { source: 'iana' },
    'video/vnd.dlna.mpeg-tts': { source: 'iana' },
    'video/vnd.dvb.file': { source: 'iana', extensions: ['dvb'] },
    'video/vnd.fvt': { source: 'iana', extensions: ['fvt'] },
    'video/vnd.hns.video': { source: 'iana' },
    'video/vnd.iptvforum.1dparityfec-1010': { source: 'iana' },
    'video/vnd.iptvforum.1dparityfec-2005': { source: 'iana' },
    'video/vnd.iptvforum.2dparityfec-1010': { source: 'iana' },
    'video/vnd.iptvforum.2dparityfec-2005': { source: 'iana' },
    'video/vnd.iptvforum.ttsavc': { source: 'iana' },
    'video/vnd.iptvforum.ttsmpeg2': { source: 'iana' },
    'video/vnd.motorola.video': { source: 'iana' },
    'video/vnd.motorola.videop': { source: 'iana' },
    'video/vnd.mpegurl': { source: 'iana', extensions: ['mxu', 'm4u'] },
    'video/vnd.ms-playready.media.pyv': { source: 'iana', extensions: ['pyv'] },
    'video/vnd.nokia.interleaved-multimedia': { source: 'iana' },
    'video/vnd.nokia.mp4vr': { source: 'iana' },
    'video/vnd.nokia.videovoip': { source: 'iana' },
    'video/vnd.objectvideo': { source: 'iana' },
    'video/vnd.radgamettools.bink': { source: 'iana' },
    'video/vnd.radgamettools.smacker': { source: 'iana' },
    'video/vnd.sealed.mpeg1': { source: 'iana' },
    'video/vnd.sealed.mpeg4': { source: 'iana' },
    'video/vnd.sealed.swf': { source: 'iana' },
    'video/vnd.sealedmedia.softseal.mov': { source: 'iana' },
    'video/vnd.uvvu.mp4': { source: 'iana', extensions: ['uvu', 'uvvu'] },
    'video/vnd.vivo': { source: 'iana', extensions: ['viv'] },
    'video/vnd.youtube.yt': { source: 'iana' },
    'video/vp8': { source: 'iana' },
    'video/vp9': { source: 'iana' },
    'video/webm': { source: 'apache', compressible: !1, extensions: ['webm'] },
    'video/x-f4v': { source: 'apache', extensions: ['f4v'] },
    'video/x-fli': { source: 'apache', extensions: ['fli'] },
    'video/x-flv': { source: 'apache', compressible: !1, extensions: ['flv'] },
    'video/x-m4v': { source: 'apache', extensions: ['m4v'] },
    'video/x-matroska': { source: 'apache', compressible: !1, extensions: ['mkv', 'mk3d', 'mks'] },
    'video/x-mng': { source: 'apache', extensions: ['mng'] },
    'video/x-ms-asf': { source: 'apache', extensions: ['asf', 'asx'] },
    'video/x-ms-vob': { source: 'apache', extensions: ['vob'] },
    'video/x-ms-wm': { source: 'apache', extensions: ['wm'] },
    'video/x-ms-wmv': { source: 'apache', compressible: !1, extensions: ['wmv'] },
    'video/x-ms-wmx': { source: 'apache', extensions: ['wmx'] },
    'video/x-ms-wvx': { source: 'apache', extensions: ['wvx'] },
    'video/x-msvideo': { source: 'apache', extensions: ['avi'] },
    'video/x-sgi-movie': { source: 'apache', extensions: ['movie'] },
    'video/x-smv': { source: 'apache', extensions: ['smv'] },
    'x-conference/x-cooltalk': { source: 'apache', extensions: ['ice'] },
    'x-shader/x-fragment': { compressible: !0 },
    'x-shader/x-vertex': { compressible: !0 },
  };
});
var WS = P((ore, $S) => {
  'use strict';
  $S.exports = VS();
});
var YS = P((Ei) => {
  'use strict';
  var rp = WS(),
    IB = require('path').extname,
    KS = /^\s*([^;\s]*)(?:;|\s|$)/,
    NB = /^text\//i;
  Ei.charset = XS;
  Ei.charsets = { lookup: XS };
  Ei.contentType = PB;
  Ei.extension = LB;
  Ei.extensions = Object.create(null);
  Ei.lookup = DB;
  Ei.types = Object.create(null);
  FB(Ei.extensions, Ei.types);
  function XS(t) {
    if (!t || typeof t != 'string') return !1;
    var e = KS.exec(t),
      i = e && rp[e[1].toLowerCase()];
    return i && i.charset ? i.charset : e && NB.test(e[1]) ? 'UTF-8' : !1;
  }
  function PB(t) {
    if (!t || typeof t != 'string') return !1;
    var e = t.indexOf('/') === -1 ? Ei.lookup(t) : t;
    if (!e) return !1;
    if (e.indexOf('charset') === -1) {
      var i = Ei.charset(e);
      i && (e += '; charset=' + i.toLowerCase());
    }
    return e;
  }
  function LB(t) {
    if (!t || typeof t != 'string') return !1;
    var e = KS.exec(t),
      i = e && Ei.extensions[e[1].toLowerCase()];
    return !i || !i.length ? !1 : i[0];
  }
  function DB(t) {
    if (!t || typeof t != 'string') return !1;
    var e = IB('x.' + t)
      .toLowerCase()
      .substr(1);
    return (e && Ei.types[e]) || !1;
  }
  function FB(t, e) {
    var i = ['nginx', 'apache', void 0, 'iana'];
    Object.keys(rp).forEach(function (r) {
      var s = rp[r],
        o = s.extensions;
      if (!(!o || !o.length)) {
        t[r] = o;
        for (var c = 0; c < o.length; c++) {
          var u = o[c];
          if (e[u]) {
            var l = i.indexOf(rp[e[u]].source),
              p = i.indexOf(s.source);
            if (e[u] !== 'application/octet-stream' && (l > p || (l === p && e[u].substr(0, 12) === 'application/')))
              continue;
          }
          e[u] = r;
        }
      }
    });
  }
});
var ZS = P((cre, JS) => {
  'use strict';
  JS.exports = jB;
  function jB(t) {
    var e =
      typeof setImmediate == 'function'
        ? setImmediate
        : typeof process == 'object' && typeof process.nextTick == 'function'
        ? process.nextTick
        : null;
    e ? e(t) : setTimeout(t, 0);
  }
});
var Gm = P((ure, eC) => {
  'use strict';
  var QS = ZS();
  eC.exports = MB;
  function MB(t) {
    var e = !1;
    return (
      QS(function () {
        e = !0;
      }),
      function (n, r) {
        e
          ? t(n, r)
          : QS(function () {
              t(n, r);
            });
      }
    );
  }
});
var zm = P((lre, tC) => {
  'use strict';
  tC.exports = UB;
  function UB(t) {
    Object.keys(t.jobs).forEach(qB.bind(t)), (t.jobs = {});
  }
  function qB(t) {
    typeof this.jobs[t] == 'function' && this.jobs[t]();
  }
});
var Vm = P((pre, nC) => {
  'use strict';
  var iC = Gm(),
    BB = zm();
  nC.exports = HB;
  function HB(t, e, i, n) {
    var r = i.keyedList ? i.keyedList[i.index] : i.index;
    i.jobs[r] = GB(e, r, t[r], function (s, o) {
      r in i.jobs && (delete i.jobs[r], s ? BB(i) : (i.results[r] = o), n(s, i.results));
    });
  }
  function GB(t, e, i, n) {
    var r;
    return t.length == 2 ? (r = t(i, iC(n))) : (r = t(i, e, iC(n))), r;
  }
});
var $m = P((fre, rC) => {
  'use strict';
  rC.exports = zB;
  function zB(t, e) {
    var i = !Array.isArray(t),
      n = {
        index: 0,
        keyedList: i || e ? Object.keys(t) : null,
        jobs: {},
        results: i ? {} : [],
        size: i ? Object.keys(t).length : t.length,
      };
    return (
      e &&
        n.keyedList.sort(
          i
            ? e
            : function (r, s) {
                return e(t[r], t[s]);
              }
        ),
      n
    );
  }
});
var Wm = P((dre, sC) => {
  'use strict';
  var VB = zm(),
    $B = Gm();
  sC.exports = WB;
  function WB(t) {
    Object.keys(this.jobs).length && ((this.index = this.size), VB(this), $B(t)(null, this.results));
  }
});
var aC = P((hre, oC) => {
  'use strict';
  var KB = Vm(),
    XB = $m(),
    YB = Wm();
  oC.exports = JB;
  function JB(t, e, i) {
    for (var n = XB(t); n.index < (n.keyedList || t).length; )
      KB(t, e, n, function (r, s) {
        if (r) {
          i(r, s);
          return;
        }
        if (Object.keys(n.jobs).length === 0) {
          i(null, n.results);
          return;
        }
      }),
        n.index++;
    return YB.bind(n, i);
  }
});
var Km = P((mre, sp) => {
  'use strict';
  var cC = Vm(),
    ZB = $m(),
    QB = Wm();
  sp.exports = e3;
  sp.exports.ascending = uC;
  sp.exports.descending = t3;
  function e3(t, e, i, n) {
    var r = ZB(t, i);
    return (
      cC(t, e, r, function s(o, c) {
        if (o) {
          n(o, c);
          return;
        }
        if ((r.index++, r.index < (r.keyedList || t).length)) {
          cC(t, e, r, s);
          return;
        }
        n(null, r.results);
      }),
      QB.bind(r, n)
    );
  }
  function uC(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  function t3(t, e) {
    return -1 * uC(t, e);
  }
});
var pC = P((gre, lC) => {
  'use strict';
  var i3 = Km();
  lC.exports = n3;
  function n3(t, e, i) {
    return i3(t, e, null, i);
  }
});
var dC = P((xre, fC) => {
  'use strict';
  fC.exports = { parallel: aC(), serial: pC(), serialOrdered: Km() };
});
var mC = P((yre, hC) => {
  'use strict';
  hC.exports = function (t, e) {
    return (
      Object.keys(e).forEach(function (i) {
        t[i] = t[i] || e[i];
      }),
      t
    );
  };
});
var Qm = P((bre, xC) => {
  'use strict';
  var Zm = zS(),
    gC = require('util'),
    Xm = require('path'),
    r3 = require('http'),
    s3 = require('https'),
    o3 = require('url').parse,
    a3 = require('fs'),
    c3 = require('stream').Stream,
    Ym = YS(),
    u3 = dC(),
    Jm = mC();
  xC.exports = We;
  gC.inherits(We, Zm);
  function We(t) {
    if (!(this instanceof We)) return new We(t);
    (this._overheadLength = 0), (this._valueLength = 0), (this._valuesToMeasure = []), Zm.call(this), (t = t || {});
    for (var e in t) this[e] = t[e];
  }
  We.LINE_BREAK = `\r
`;
  We.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
  We.prototype.append = function (t, e, i) {
    (i = i || {}), typeof i == 'string' && (i = { filename: i });
    var n = Zm.prototype.append.bind(this);
    if ((typeof e == 'number' && (e = '' + e), gC.isArray(e))) {
      this._error(new Error('Arrays are not supported.'));
      return;
    }
    var r = this._multiPartHeader(t, e, i),
      s = this._multiPartFooter();
    n(r), n(e), n(s), this._trackLength(r, e, i);
  };
  We.prototype._trackLength = function (t, e, i) {
    var n = 0;
    i.knownLength != null
      ? (n += +i.knownLength)
      : Buffer.isBuffer(e)
      ? (n = e.length)
      : typeof e == 'string' && (n = Buffer.byteLength(e)),
      (this._valueLength += n),
      (this._overheadLength += Buffer.byteLength(t) + We.LINE_BREAK.length),
      !(!e || (!e.path && !(e.readable && e.hasOwnProperty('httpVersion')) && !(e instanceof c3))) &&
        (i.knownLength || this._valuesToMeasure.push(e));
  };
  We.prototype._lengthRetriever = function (t, e) {
    t.hasOwnProperty('fd')
      ? t.end != null && t.end != 1 / 0 && t.start != null
        ? e(null, t.end + 1 - (t.start ? t.start : 0))
        : a3.stat(t.path, function (i, n) {
            var r;
            if (i) {
              e(i);
              return;
            }
            (r = n.size - (t.start ? t.start : 0)), e(null, r);
          })
      : t.hasOwnProperty('httpVersion')
      ? e(null, +t.headers['content-length'])
      : t.hasOwnProperty('httpModule')
      ? (t.on('response', function (i) {
          t.pause(), e(null, +i.headers['content-length']);
        }),
        t.resume())
      : e('Unknown stream');
  };
  We.prototype._multiPartHeader = function (t, e, i) {
    if (typeof i.header == 'string') return i.header;
    var n = this._getContentDisposition(e, i),
      r = this._getContentType(e, i),
      s = '',
      o = {
        'Content-Disposition': ['form-data', 'name="' + t + '"'].concat(n || []),
        'Content-Type': [].concat(r || []),
      };
    typeof i.header == 'object' && Jm(o, i.header);
    var c;
    for (var u in o)
      o.hasOwnProperty(u) &&
        ((c = o[u]),
        c != null && (Array.isArray(c) || (c = [c]), c.length && (s += u + ': ' + c.join('; ') + We.LINE_BREAK)));
    return '--' + this.getBoundary() + We.LINE_BREAK + s + We.LINE_BREAK;
  };
  We.prototype._getContentDisposition = function (t, e) {
    var i, n;
    return (
      typeof e.filepath == 'string'
        ? (i = Xm.normalize(e.filepath).replace(/\\/g, '/'))
        : e.filename || t.name || t.path
        ? (i = Xm.basename(e.filename || t.name || t.path))
        : t.readable && t.hasOwnProperty('httpVersion') && (i = Xm.basename(t.client._httpMessage.path || '')),
      i && (n = 'filename="' + i + '"'),
      n
    );
  };
  We.prototype._getContentType = function (t, e) {
    var i = e.contentType;
    return (
      !i && t.name && (i = Ym.lookup(t.name)),
      !i && t.path && (i = Ym.lookup(t.path)),
      !i && t.readable && t.hasOwnProperty('httpVersion') && (i = t.headers['content-type']),
      !i && (e.filepath || e.filename) && (i = Ym.lookup(e.filepath || e.filename)),
      !i && typeof t == 'object' && (i = We.DEFAULT_CONTENT_TYPE),
      i
    );
  };
  We.prototype._multiPartFooter = function () {
    return function (t) {
      var e = We.LINE_BREAK,
        i = this._streams.length === 0;
      i && (e += this._lastBoundary()), t(e);
    }.bind(this);
  };
  We.prototype._lastBoundary = function () {
    return '--' + this.getBoundary() + '--' + We.LINE_BREAK;
  };
  We.prototype.getHeaders = function (t) {
    var e,
      i = { 'content-type': 'multipart/form-data; boundary=' + this.getBoundary() };
    for (e in t) t.hasOwnProperty(e) && (i[e.toLowerCase()] = t[e]);
    return i;
  };
  We.prototype.setBoundary = function (t) {
    this._boundary = t;
  };
  We.prototype.getBoundary = function () {
    return this._boundary || this._generateBoundary(), this._boundary;
  };
  We.prototype.getBuffer = function () {
    for (var t = new Buffer.alloc(0), e = this.getBoundary(), i = 0, n = this._streams.length; i < n; i++)
      typeof this._streams[i] != 'function' &&
        (Buffer.isBuffer(this._streams[i])
          ? (t = Buffer.concat([t, this._streams[i]]))
          : (t = Buffer.concat([t, Buffer.from(this._streams[i])])),
        (typeof this._streams[i] != 'string' || this._streams[i].substring(2, e.length + 2) !== e) &&
          (t = Buffer.concat([t, Buffer.from(We.LINE_BREAK)])));
    return Buffer.concat([t, Buffer.from(this._lastBoundary())]);
  };
  We.prototype._generateBoundary = function () {
    for (var t = '--------------------------', e = 0; e < 24; e++) t += Math.floor(Math.random() * 10).toString(16);
    this._boundary = t;
  };
  We.prototype.getLengthSync = function () {
    var t = this._overheadLength + this._valueLength;
    return (
      this._streams.length && (t += this._lastBoundary().length),
      this.hasKnownLength() || this._error(new Error('Cannot calculate proper length in synchronous way.')),
      t
    );
  };
  We.prototype.hasKnownLength = function () {
    var t = !0;
    return this._valuesToMeasure.length && (t = !1), t;
  };
  We.prototype.getLength = function (t) {
    var e = this._overheadLength + this._valueLength;
    if ((this._streams.length && (e += this._lastBoundary().length), !this._valuesToMeasure.length)) {
      process.nextTick(t.bind(this, null, e));
      return;
    }
    u3.parallel(this._valuesToMeasure, this._lengthRetriever, function (i, n) {
      if (i) {
        t(i);
        return;
      }
      n.forEach(function (r) {
        e += r;
      }),
        t(null, e);
    });
  };
  We.prototype.submit = function (t, e) {
    var i,
      n,
      r = { method: 'post' };
    return (
      typeof t == 'string'
        ? ((t = o3(t)), (n = Jm({ port: t.port, path: t.pathname, host: t.hostname, protocol: t.protocol }, r)))
        : ((n = Jm(t, r)), n.port || (n.port = n.protocol == 'https:' ? 443 : 80)),
      (n.headers = this.getHeaders(t.headers)),
      n.protocol == 'https:' ? (i = s3.request(n)) : (i = r3.request(n)),
      this.getLength(
        function (s, o) {
          if (s && s !== 'Unknown stream') {
            this._error(s);
            return;
          }
          if ((o && i.setHeader('Content-Length', o), this.pipe(i), e)) {
            var c,
              u = function (l, p) {
                return i.removeListener('error', u), i.removeListener('response', c), e.call(this, l, p);
              };
            (c = u.bind(this, null)), i.on('error', u), i.on('response', c);
          }
        }.bind(this)
      ),
      i
    );
  };
  We.prototype._error = function (t) {
    this.error || ((this.error = t), this.pause(), this.emit('error', t));
  };
  We.prototype.toString = function () {
    return '[object FormData]';
  };
});
var eg = P((yC) => {
  'use strict';
  var l3 = require('url').parse,
    p3 = { ftp: 21, gopher: 70, http: 80, https: 443, ws: 80, wss: 443 },
    f3 =
      String.prototype.endsWith ||
      function (t) {
        return t.length <= this.length && this.indexOf(t, this.length - t.length) !== -1;
      };
  function d3(t) {
    var e = typeof t == 'string' ? l3(t) : t || {},
      i = e.protocol,
      n = e.host,
      r = e.port;
    if (
      typeof n != 'string' ||
      !n ||
      typeof i != 'string' ||
      ((i = i.split(':', 1)[0]), (n = n.replace(/:\d*$/, '')), (r = parseInt(r) || p3[i] || 0), !h3(n, r))
    )
      return '';
    var s = Jo('npm_config_' + i + '_proxy') || Jo(i + '_proxy') || Jo('npm_config_proxy') || Jo('all_proxy');
    return s && s.indexOf('://') === -1 && (s = i + '://' + s), s;
  }
  function h3(t, e) {
    var i = (Jo('npm_config_no_proxy') || Jo('no_proxy')).toLowerCase();
    return i
      ? i === '*'
        ? !1
        : i.split(/[,\s]/).every(function (n) {
            if (!n) return !0;
            var r = n.match(/^(.+):(\d+)$/),
              s = r ? r[1] : n,
              o = r ? parseInt(r[2]) : 0;
            return o && o !== e
              ? !0
              : /^[.*]/.test(s)
              ? (s.charAt(0) === '*' && (s = s.slice(1)), !f3.call(t, s))
              : t !== s;
          })
      : !0;
  }
  function Jo(t) {
    return process.env[t.toLowerCase()] || process.env[t.toUpperCase()] || '';
  }
  yC.getProxyForUrl = d3;
});
var vC = P((wre, bC) => {
  'use strict';
  var Zo = 1e3,
    Qo = Zo * 60,
    ea = Qo * 60,
    zs = ea * 24,
    m3 = zs * 7,
    g3 = zs * 365.25;
  bC.exports = function (t, e) {
    e = e || {};
    var i = typeof t;
    if (i === 'string' && t.length > 0) return x3(t);
    if (i === 'number' && isFinite(t)) return e.long ? b3(t) : y3(t);
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(t));
  };
  function x3(t) {
    if (((t = String(t)), !(t.length > 100))) {
      var e =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          t
        );
      if (e) {
        var i = parseFloat(e[1]),
          n = (e[2] || 'ms').toLowerCase();
        switch (n) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return i * g3;
          case 'weeks':
          case 'week':
          case 'w':
            return i * m3;
          case 'days':
          case 'day':
          case 'd':
            return i * zs;
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return i * ea;
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return i * Qo;
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return i * Zo;
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return i;
          default:
            return;
        }
      }
    }
  }
  function y3(t) {
    var e = Math.abs(t);
    return e >= zs
      ? Math.round(t / zs) + 'd'
      : e >= ea
      ? Math.round(t / ea) + 'h'
      : e >= Qo
      ? Math.round(t / Qo) + 'm'
      : e >= Zo
      ? Math.round(t / Zo) + 's'
      : t + 'ms';
  }
  function b3(t) {
    var e = Math.abs(t);
    return e >= zs
      ? op(t, e, zs, 'day')
      : e >= ea
      ? op(t, e, ea, 'hour')
      : e >= Qo
      ? op(t, e, Qo, 'minute')
      : e >= Zo
      ? op(t, e, Zo, 'second')
      : t + ' ms';
  }
  function op(t, e, i, n) {
    var r = e >= i * 1.5;
    return Math.round(t / i) + ' ' + n + (r ? 's' : '');
  }
});
var tg = P((Ere, wC) => {
  'use strict';
  function v3(t) {
    (i.debug = i),
      (i.default = i),
      (i.coerce = u),
      (i.disable = s),
      (i.enable = r),
      (i.enabled = o),
      (i.humanize = vC()),
      (i.destroy = l),
      Object.keys(t).forEach((p) => {
        i[p] = t[p];
      }),
      (i.names = []),
      (i.skips = []),
      (i.formatters = {});
    function e(p) {
      let d = 0;
      for (let x = 0; x < p.length; x++) (d = (d << 5) - d + p.charCodeAt(x)), (d |= 0);
      return i.colors[Math.abs(d) % i.colors.length];
    }
    i.selectColor = e;
    function i(p) {
      let d,
        x = null,
        b,
        g;
      function y(...h) {
        if (!y.enabled) return;
        let v = y,
          C = Number(new Date()),
          _ = C - (d || C);
        (v.diff = _),
          (v.prev = d),
          (v.curr = C),
          (d = C),
          (h[0] = i.coerce(h[0])),
          typeof h[0] != 'string' && h.unshift('%O');
        let m = 0;
        (h[0] = h[0].replace(/%([a-zA-Z%])/g, (N, D) => {
          if (N === '%%') return '%';
          m++;
          let z = i.formatters[D];
          if (typeof z == 'function') {
            let H = h[m];
            (N = z.call(v, H)), h.splice(m, 1), m--;
          }
          return N;
        })),
          i.formatArgs.call(v, h),
          (v.log || i.log).apply(v, h);
      }
      return (
        (y.namespace = p),
        (y.useColors = i.useColors()),
        (y.color = i.selectColor(p)),
        (y.extend = n),
        (y.destroy = i.destroy),
        Object.defineProperty(y, 'enabled', {
          enumerable: !0,
          configurable: !1,
          get: () => (x !== null ? x : (b !== i.namespaces && ((b = i.namespaces), (g = i.enabled(p))), g)),
          set: (h) => {
            x = h;
          },
        }),
        typeof i.init == 'function' && i.init(y),
        y
      );
    }
    function n(p, d) {
      let x = i(this.namespace + (typeof d > 'u' ? ':' : d) + p);
      return (x.log = this.log), x;
    }
    function r(p) {
      i.save(p), (i.namespaces = p), (i.names = []), (i.skips = []);
      let d,
        x = (typeof p == 'string' ? p : '').split(/[\s,]+/),
        b = x.length;
      for (d = 0; d < b; d++)
        x[d] &&
          ((p = x[d].replace(/\*/g, '.*?')),
          p[0] === '-' ? i.skips.push(new RegExp('^' + p.slice(1) + '$')) : i.names.push(new RegExp('^' + p + '$')));
    }
    function s() {
      let p = [...i.names.map(c), ...i.skips.map(c).map((d) => '-' + d)].join(',');
      return i.enable(''), p;
    }
    function o(p) {
      if (p[p.length - 1] === '*') return !0;
      let d, x;
      for (d = 0, x = i.skips.length; d < x; d++) if (i.skips[d].test(p)) return !1;
      for (d = 0, x = i.names.length; d < x; d++) if (i.names[d].test(p)) return !0;
      return !1;
    }
    function c(p) {
      return p
        .toString()
        .substring(2, p.toString().length - 2)
        .replace(/\.\*\?$/, '*');
    }
    function u(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    function l() {
      console.warn(
        'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
      );
    }
    return i.enable(i.load()), i;
  }
  wC.exports = v3;
});
var EC = P((Ui, ap) => {
  'use strict';
  Ui.formatArgs = E3;
  Ui.save = _3;
  Ui.load = S3;
  Ui.useColors = w3;
  Ui.storage = C3();
  Ui.destroy = (() => {
    let t = !1;
    return () => {
      t ||
        ((t = !0),
        console.warn(
          'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
        ));
    };
  })();
  Ui.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33',
  ];
  function w3() {
    return typeof window < 'u' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)
      ? !0
      : typeof navigator < 'u' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
      ? !1
      : (typeof document < 'u' &&
          document.documentElement &&
          document.documentElement.style &&
          document.documentElement.style.WebkitAppearance) ||
        (typeof window < 'u' &&
          window.console &&
          (window.console.firebug || (window.console.exception && window.console.table))) ||
        (typeof navigator < 'u' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
          parseInt(RegExp.$1, 10) >= 31) ||
        (typeof navigator < 'u' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }
  function E3(t) {
    if (
      ((t[0] =
        (this.useColors ? '%c' : '') +
        this.namespace +
        (this.useColors ? ' %c' : ' ') +
        t[0] +
        (this.useColors ? '%c ' : ' ') +
        '+' +
        ap.exports.humanize(this.diff)),
      !this.useColors)
    )
      return;
    let e = 'color: ' + this.color;
    t.splice(1, 0, e, 'color: inherit');
    let i = 0,
      n = 0;
    t[0].replace(/%[a-zA-Z%]/g, (r) => {
      r !== '%%' && (i++, r === '%c' && (n = i));
    }),
      t.splice(n, 0, e);
  }
  Ui.log = console.debug || console.log || (() => {});
  function _3(t) {
    try {
      t ? Ui.storage.setItem('debug', t) : Ui.storage.removeItem('debug');
    } catch {}
  }
  function S3() {
    let t;
    try {
      t = Ui.storage.getItem('debug');
    } catch {}
    return !t && typeof process < 'u' && 'env' in process && (t = process.env.DEBUG), t;
  }
  function C3() {
    try {
      return localStorage;
    } catch {}
  }
  ap.exports = tg()(Ui);
  var { formatters: R3 } = ap.exports;
  R3.j = function (t) {
    try {
      return JSON.stringify(t);
    } catch (e) {
      return '[UnexpectedJSONParseError]: ' + e.message;
    }
  };
});
var SC = P((_re, _C) => {
  'use strict';
  _C.exports = (t, e = process.argv) => {
    let i = t.startsWith('-') ? '' : t.length === 1 ? '-' : '--',
      n = e.indexOf(i + t),
      r = e.indexOf('--');
    return n !== -1 && (r === -1 || n < r);
  };
});
var TC = P((Sre, RC) => {
  'use strict';
  var T3 = require('os'),
    CC = require('tty'),
    Wi = SC(),
    { env: Gt } = process,
    Mr;
  Wi('no-color') || Wi('no-colors') || Wi('color=false') || Wi('color=never')
    ? (Mr = 0)
    : (Wi('color') || Wi('colors') || Wi('color=true') || Wi('color=always')) && (Mr = 1);
  'FORCE_COLOR' in Gt &&
    (Gt.FORCE_COLOR === 'true'
      ? (Mr = 1)
      : Gt.FORCE_COLOR === 'false'
      ? (Mr = 0)
      : (Mr = Gt.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(Gt.FORCE_COLOR, 10), 3)));
  function ig(t) {
    return t === 0 ? !1 : { level: t, hasBasic: !0, has256: t >= 2, has16m: t >= 3 };
  }
  function ng(t, e) {
    if (Mr === 0) return 0;
    if (Wi('color=16m') || Wi('color=full') || Wi('color=truecolor')) return 3;
    if (Wi('color=256')) return 2;
    if (t && !e && Mr === void 0) return 0;
    let i = Mr || 0;
    if (Gt.TERM === 'dumb') return i;
    if (process.platform === 'win32') {
      let n = T3.release().split('.');
      return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? (Number(n[2]) >= 14931 ? 3 : 2) : 1;
    }
    if ('CI' in Gt)
      return ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some((n) => n in Gt) ||
        Gt.CI_NAME === 'codeship'
        ? 1
        : i;
    if ('TEAMCITY_VERSION' in Gt) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Gt.TEAMCITY_VERSION) ? 1 : 0;
    if (Gt.COLORTERM === 'truecolor') return 3;
    if ('TERM_PROGRAM' in Gt) {
      let n = parseInt((Gt.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
      switch (Gt.TERM_PROGRAM) {
        case 'iTerm.app':
          return n >= 3 ? 3 : 2;
        case 'Apple_Terminal':
          return 2;
      }
    }
    return /-256(color)?$/i.test(Gt.TERM)
      ? 2
      : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Gt.TERM) || 'COLORTERM' in Gt
      ? 1
      : i;
  }
  function O3(t) {
    let e = ng(t, t && t.isTTY);
    return ig(e);
  }
  RC.exports = { supportsColor: O3, stdout: ig(ng(!0, CC.isatty(1))), stderr: ig(ng(!0, CC.isatty(2))) };
});
var kC = P((ei, up) => {
  'use strict';
  var k3 = require('tty'),
    cp = require('util');
  ei.init = F3;
  ei.log = P3;
  ei.formatArgs = I3;
  ei.save = L3;
  ei.load = D3;
  ei.useColors = A3;
  ei.destroy = cp.deprecate(() => {},
  'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  ei.colors = [6, 2, 3, 4, 5, 1];
  try {
    let t = TC();
    t &&
      (t.stderr || t).level >= 2 &&
      (ei.colors = [
        20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81,
        92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170,
        171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214,
        215, 220, 221,
      ]);
  } catch {}
  ei.inspectOpts = Object.keys(process.env)
    .filter((t) => /^debug_/i.test(t))
    .reduce((t, e) => {
      let i = e
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (r, s) => s.toUpperCase()),
        n = process.env[e];
      return (
        /^(yes|on|true|enabled)$/i.test(n)
          ? (n = !0)
          : /^(no|off|false|disabled)$/i.test(n)
          ? (n = !1)
          : n === 'null'
          ? (n = null)
          : (n = Number(n)),
        (t[i] = n),
        t
      );
    }, {});
  function A3() {
    return 'colors' in ei.inspectOpts ? !!ei.inspectOpts.colors : k3.isatty(process.stderr.fd);
  }
  function I3(t) {
    let { namespace: e, useColors: i } = this;
    if (i) {
      let n = this.color,
        r = '\x1B[3' + (n < 8 ? n : '8;5;' + n),
        s = `  ${r};1m${e} \x1B[0m`;
      (t[0] =
        s +
        t[0]
          .split(
            `
`
          )
          .join(
            `
` + s
          )),
        t.push(r + 'm+' + up.exports.humanize(this.diff) + '\x1B[0m');
    } else t[0] = N3() + e + ' ' + t[0];
  }
  function N3() {
    return ei.inspectOpts.hideDate ? '' : new Date().toISOString() + ' ';
  }
  function P3(...t) {
    return process.stderr.write(
      cp.format(...t) +
        `
`
    );
  }
  function L3(t) {
    t ? (process.env.DEBUG = t) : delete process.env.DEBUG;
  }
  function D3() {
    return process.env.DEBUG;
  }
  function F3(t) {
    t.inspectOpts = {};
    let e = Object.keys(ei.inspectOpts);
    for (let i = 0; i < e.length; i++) t.inspectOpts[e[i]] = ei.inspectOpts[e[i]];
  }
  up.exports = tg()(ei);
  var { formatters: OC } = up.exports;
  OC.o = function (t) {
    return (
      (this.inspectOpts.colors = this.useColors),
      cp
        .inspect(t, this.inspectOpts)
        .split(
          `
`
        )
        .map((e) => e.trim())
        .join(' ')
    );
  };
  OC.O = function (t) {
    return (this.inspectOpts.colors = this.useColors), cp.inspect(t, this.inspectOpts);
  };
});
var AC = P((Cre, rg) => {
  'use strict';
  typeof process > 'u' || process.type === 'renderer' || process.browser === !0 || process.__nwjs
    ? (rg.exports = EC())
    : (rg.exports = kC());
});
var NC = P((Rre, IC) => {
  'use strict';
  var qc;
  IC.exports = function () {
    if (!qc) {
      try {
        qc = AC()('follow-redirects');
      } catch {}
      typeof qc != 'function' && (qc = function () {});
    }
    qc.apply(null, arguments);
  };
});
var xg = P((Tre, gg) => {
  'use strict';
  var Gc = require('url'),
    Bc = Gc.URL,
    j3 = require('http'),
    M3 = require('https'),
    ug = require('stream').Writable,
    lg = require('assert'),
    PC = NC(),
    pg = !1;
  try {
    lg(new Bc());
  } catch (t) {
    pg = t.code === 'ERR_INVALID_URL';
  }
  var U3 = ['auth', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'hash'],
    fg = ['abort', 'aborted', 'connect', 'error', 'socket', 'timeout'],
    dg = Object.create(null);
  fg.forEach(function (t) {
    dg[t] = function (e, i, n) {
      this._redirectable.emit(t, e, i, n);
    };
  });
  var og = zc('ERR_INVALID_URL', 'Invalid URL', TypeError),
    ag = zc('ERR_FR_REDIRECTION_FAILURE', 'Redirected request failed'),
    q3 = zc('ERR_FR_TOO_MANY_REDIRECTS', 'Maximum number of redirects exceeded', ag),
    B3 = zc('ERR_FR_MAX_BODY_LENGTH_EXCEEDED', 'Request body larger than maxBodyLength limit'),
    H3 = zc('ERR_STREAM_WRITE_AFTER_END', 'write after end'),
    G3 = ug.prototype.destroy || DC;
  function _i(t, e) {
    ug.call(this),
      this._sanitizeOptions(t),
      (this._options = t),
      (this._ended = !1),
      (this._ending = !1),
      (this._redirectCount = 0),
      (this._redirects = []),
      (this._requestBodyLength = 0),
      (this._requestBodyBuffers = []),
      e && this.on('response', e);
    var i = this;
    (this._onNativeResponse = function (n) {
      try {
        i._processResponse(n);
      } catch (r) {
        i.emit('error', r instanceof ag ? r : new ag({ cause: r }));
      }
    }),
      this._performRequest();
  }
  _i.prototype = Object.create(ug.prototype);
  _i.prototype.abort = function () {
    mg(this._currentRequest), this._currentRequest.abort(), this.emit('abort');
  };
  _i.prototype.destroy = function (t) {
    return mg(this._currentRequest, t), G3.call(this, t), this;
  };
  _i.prototype.write = function (t, e, i) {
    if (this._ending) throw new H3();
    if (!Vs(t) && !$3(t)) throw new TypeError('data should be a string, Buffer or Uint8Array');
    if ((Hc(e) && ((i = e), (e = null)), t.length === 0)) {
      i && i();
      return;
    }
    this._requestBodyLength + t.length <= this._options.maxBodyLength
      ? ((this._requestBodyLength += t.length),
        this._requestBodyBuffers.push({ data: t, encoding: e }),
        this._currentRequest.write(t, e, i))
      : (this.emit('error', new B3()), this.abort());
  };
  _i.prototype.end = function (t, e, i) {
    if ((Hc(t) ? ((i = t), (t = e = null)) : Hc(e) && ((i = e), (e = null)), !t))
      (this._ended = this._ending = !0), this._currentRequest.end(null, null, i);
    else {
      var n = this,
        r = this._currentRequest;
      this.write(t, e, function () {
        (n._ended = !0), r.end(null, null, i);
      }),
        (this._ending = !0);
    }
  };
  _i.prototype.setHeader = function (t, e) {
    (this._options.headers[t] = e), this._currentRequest.setHeader(t, e);
  };
  _i.prototype.removeHeader = function (t) {
    delete this._options.headers[t], this._currentRequest.removeHeader(t);
  };
  _i.prototype.setTimeout = function (t, e) {
    var i = this;
    function n(o) {
      o.setTimeout(t), o.removeListener('timeout', o.destroy), o.addListener('timeout', o.destroy);
    }
    function r(o) {
      i._timeout && clearTimeout(i._timeout),
        (i._timeout = setTimeout(function () {
          i.emit('timeout'), s();
        }, t)),
        n(o);
    }
    function s() {
      i._timeout && (clearTimeout(i._timeout), (i._timeout = null)),
        i.removeListener('abort', s),
        i.removeListener('error', s),
        i.removeListener('response', s),
        i.removeListener('close', s),
        e && i.removeListener('timeout', e),
        i.socket || i._currentRequest.removeListener('socket', r);
    }
    return (
      e && this.on('timeout', e),
      this.socket ? r(this.socket) : this._currentRequest.once('socket', r),
      this.on('socket', n),
      this.on('abort', s),
      this.on('error', s),
      this.on('response', s),
      this.on('close', s),
      this
    );
  };
  ['flushHeaders', 'getHeader', 'setNoDelay', 'setSocketKeepAlive'].forEach(function (t) {
    _i.prototype[t] = function (e, i) {
      return this._currentRequest[t](e, i);
    };
  });
  ['aborted', 'connection', 'socket'].forEach(function (t) {
    Object.defineProperty(_i.prototype, t, {
      get: function () {
        return this._currentRequest[t];
      },
    });
  });
  _i.prototype._sanitizeOptions = function (t) {
    if (
      (t.headers || (t.headers = {}),
      t.host && (t.hostname || (t.hostname = t.host), delete t.host),
      !t.pathname && t.path)
    ) {
      var e = t.path.indexOf('?');
      e < 0 ? (t.pathname = t.path) : ((t.pathname = t.path.substring(0, e)), (t.search = t.path.substring(e)));
    }
  };
  _i.prototype._performRequest = function () {
    var t = this._options.protocol,
      e = this._options.nativeProtocols[t];
    if (!e) throw new TypeError('Unsupported protocol ' + t);
    if (this._options.agents) {
      var i = t.slice(0, -1);
      this._options.agent = this._options.agents[i];
    }
    var n = (this._currentRequest = e.request(this._options, this._onNativeResponse));
    n._redirectable = this;
    for (var r of fg) n.on(r, dg[r]);
    if (
      ((this._currentUrl = /^\//.test(this._options.path) ? Gc.format(this._options) : this._options.path),
      this._isRedirect)
    ) {
      var s = 0,
        o = this,
        c = this._requestBodyBuffers;
      (function u(l) {
        if (n === o._currentRequest)
          if (l) o.emit('error', l);
          else if (s < c.length) {
            var p = c[s++];
            n.finished || n.write(p.data, p.encoding, u);
          } else o._ended && n.end();
      })();
    }
  };
  _i.prototype._processResponse = function (t) {
    var e = t.statusCode;
    this._options.trackRedirects && this._redirects.push({ url: this._currentUrl, headers: t.headers, statusCode: e });
    var i = t.headers.location;
    if (!i || this._options.followRedirects === !1 || e < 300 || e >= 400) {
      (t.responseUrl = this._currentUrl),
        (t.redirects = this._redirects),
        this.emit('response', t),
        (this._requestBodyBuffers = []);
      return;
    }
    if ((mg(this._currentRequest), t.destroy(), ++this._redirectCount > this._options.maxRedirects)) throw new q3();
    var n,
      r = this._options.beforeRedirect;
    r && (n = Object.assign({ Host: t.req.getHeader('host') }, this._options.headers));
    var s = this._options.method;
    (((e === 301 || e === 302) && this._options.method === 'POST') ||
      (e === 303 && !/^(?:GET|HEAD)$/.test(this._options.method))) &&
      ((this._options.method = 'GET'), (this._requestBodyBuffers = []), sg(/^content-/i, this._options.headers));
    var o = sg(/^host$/i, this._options.headers),
      c = hg(this._currentUrl),
      u = o || c.host,
      l = /^\w+:/.test(i) ? this._currentUrl : Gc.format(Object.assign(c, { host: u })),
      p = z3(i, l);
    if (
      (PC('redirecting to', p.href),
      (this._isRedirect = !0),
      cg(p, this._options),
      ((p.protocol !== c.protocol && p.protocol !== 'https:') || (p.host !== u && !V3(p.host, u))) &&
        sg(/^(?:authorization|cookie)$/i, this._options.headers),
      Hc(r))
    ) {
      var d = { headers: t.headers, statusCode: e },
        x = { url: l, method: s, headers: n };
      r(this._options, d, x), this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function LC(t) {
    var e = { maxRedirects: 21, maxBodyLength: 10485760 },
      i = {};
    return (
      Object.keys(t).forEach(function (n) {
        var r = n + ':',
          s = (i[r] = t[n]),
          o = (e[n] = Object.create(s));
        function c(l, p, d) {
          return (
            W3(l) ? (l = cg(l)) : Vs(l) ? (l = cg(hg(l))) : ((d = p), (p = FC(l)), (l = { protocol: r })),
            Hc(p) && ((d = p), (p = null)),
            (p = Object.assign({ maxRedirects: e.maxRedirects, maxBodyLength: e.maxBodyLength }, l, p)),
            (p.nativeProtocols = i),
            !Vs(p.host) && !Vs(p.hostname) && (p.hostname = '::1'),
            lg.equal(p.protocol, r, 'protocol mismatch'),
            PC('options', p),
            new _i(p, d)
          );
        }
        function u(l, p, d) {
          var x = o.request(l, p, d);
          return x.end(), x;
        }
        Object.defineProperties(o, {
          request: { value: c, configurable: !0, enumerable: !0, writable: !0 },
          get: { value: u, configurable: !0, enumerable: !0, writable: !0 },
        });
      }),
      e
    );
  }
  function DC() {}
  function hg(t) {
    var e;
    if (pg) e = new Bc(t);
    else if (((e = FC(Gc.parse(t))), !Vs(e.protocol))) throw new og({ input: t });
    return e;
  }
  function z3(t, e) {
    return pg ? new Bc(t, e) : hg(Gc.resolve(e, t));
  }
  function FC(t) {
    if (/^\[/.test(t.hostname) && !/^\[[:0-9a-f]+\]$/i.test(t.hostname)) throw new og({ input: t.href || t });
    if (/^\[/.test(t.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(t.host)) throw new og({ input: t.href || t });
    return t;
  }
  function cg(t, e) {
    var i = e || {};
    for (var n of U3) i[n] = t[n];
    return (
      i.hostname.startsWith('[') && (i.hostname = i.hostname.slice(1, -1)),
      i.port !== '' && (i.port = Number(i.port)),
      (i.path = i.search ? i.pathname + i.search : i.pathname),
      i
    );
  }
  function sg(t, e) {
    var i;
    for (var n in e) t.test(n) && ((i = e[n]), delete e[n]);
    return i === null || typeof i > 'u' ? void 0 : String(i).trim();
  }
  function zc(t, e, i) {
    function n(r) {
      Error.captureStackTrace(this, this.constructor),
        Object.assign(this, r || {}),
        (this.code = t),
        (this.message = this.cause ? e + ': ' + this.cause.message : e);
    }
    return (
      (n.prototype = new (i || Error)()),
      Object.defineProperties(n.prototype, {
        constructor: { value: n, enumerable: !1 },
        name: { value: 'Error [' + t + ']', enumerable: !1 },
      }),
      n
    );
  }
  function mg(t, e) {
    for (var i of fg) t.removeListener(i, dg[i]);
    t.on('error', DC), t.destroy(e);
  }
  function V3(t, e) {
    lg(Vs(t) && Vs(e));
    var i = t.length - e.length - 1;
    return i > 0 && t[i] === '.' && t.endsWith(e);
  }
  function Vs(t) {
    return typeof t == 'string' || t instanceof String;
  }
  function Hc(t) {
    return typeof t == 'function';
  }
  function $3(t) {
    return typeof t == 'object' && 'length' in t;
  }
  function W3(t) {
    return Bc && t instanceof Bc;
  }
  gg.exports = LC({ http: j3, https: M3 });
  gg.exports.wrap = LC;
});
var Ug = P((Ore, CR) => {
  'use strict';
  var K3 = Qm(),
    X3 = require('url'),
    Y3 = eg(),
    J3 = require('http'),
    Z3 = require('https'),
    eR = require('util'),
    Q3 = xg(),
    e4 = require('zlib'),
    tR = require('stream'),
    t4 = require('events');
  function er(t) {
    return t && typeof t == 'object' && 'default' in t ? t : { default: t };
  }
  var iR = er(K3),
    i4 = er(X3),
    n4 = er(J3),
    r4 = er(Z3),
    s4 = er(eR),
    o4 = er(Q3),
    Hr = er(e4),
    qr = er(tR),
    a4 = er(t4);
  function nR(t, e) {
    return function () {
      return t.apply(e, arguments);
    };
  }
  var { toString: c4 } = Object.prototype,
    { getPrototypeOf: Ng } = Object,
    mp = ((t) => (e) => {
      let i = c4.call(e);
      return t[i] || (t[i] = i.slice(8, -1).toLowerCase());
    })(Object.create(null)),
    Ln = (t) => ((t = t.toLowerCase()), (e) => mp(e) === t),
    gp = (t) => (e) => typeof e === t,
    { isArray: ra } = Array,
    Wc = gp('undefined');
  function u4(t) {
    return (
      t !== null &&
      !Wc(t) &&
      t.constructor !== null &&
      !Wc(t.constructor) &&
      Xi(t.constructor.isBuffer) &&
      t.constructor.isBuffer(t)
    );
  }
  var rR = Ln('ArrayBuffer');
  function l4(t) {
    let e;
    return (
      typeof ArrayBuffer < 'u' && ArrayBuffer.isView
        ? (e = ArrayBuffer.isView(t))
        : (e = t && t.buffer && rR(t.buffer)),
      e
    );
  }
  var p4 = gp('string'),
    Xi = gp('function'),
    sR = gp('number'),
    xp = (t) => t !== null && typeof t == 'object',
    f4 = (t) => t === !0 || t === !1,
    pp = (t) => {
      if (mp(t) !== 'object') return !1;
      let e = Ng(t);
      return (
        (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) &&
        !(Symbol.toStringTag in t) &&
        !(Symbol.iterator in t)
      );
    },
    d4 = Ln('Date'),
    h4 = Ln('File'),
    m4 = Ln('Blob'),
    g4 = Ln('FileList'),
    x4 = (t) => xp(t) && Xi(t.pipe),
    y4 = (t) => {
      let e;
      return (
        t &&
        ((typeof FormData == 'function' && t instanceof FormData) ||
          (Xi(t.append) &&
            ((e = mp(t)) === 'formdata' || (e === 'object' && Xi(t.toString) && t.toString() === '[object FormData]'))))
      );
    },
    b4 = Ln('URLSearchParams'),
    v4 = (t) => (t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''));
  function Xc(t, e, { allOwnKeys: i = !1 } = {}) {
    if (t === null || typeof t > 'u') return;
    let n, r;
    if ((typeof t != 'object' && (t = [t]), ra(t))) for (n = 0, r = t.length; n < r; n++) e.call(null, t[n], n, t);
    else {
      let s = i ? Object.getOwnPropertyNames(t) : Object.keys(t),
        o = s.length,
        c;
      for (n = 0; n < o; n++) (c = s[n]), e.call(null, t[c], c, t);
    }
  }
  function oR(t, e) {
    e = e.toLowerCase();
    let i = Object.keys(t),
      n = i.length,
      r;
    for (; n-- > 0; ) if (((r = i[n]), e === r.toLowerCase())) return r;
    return null;
  }
  var aR = typeof globalThis < 'u' ? globalThis : typeof self < 'u' ? self : typeof window < 'u' ? window : global,
    cR = (t) => !Wc(t) && t !== aR;
  function Eg() {
    let { caseless: t } = (cR(this) && this) || {},
      e = {},
      i = (n, r) => {
        let s = (t && oR(e, r)) || r;
        pp(e[s]) && pp(n) ? (e[s] = Eg(e[s], n)) : pp(n) ? (e[s] = Eg({}, n)) : ra(n) ? (e[s] = n.slice()) : (e[s] = n);
      };
    for (let n = 0, r = arguments.length; n < r; n++) arguments[n] && Xc(arguments[n], i);
    return e;
  }
  var w4 = (t, e, i, { allOwnKeys: n } = {}) => (
      Xc(
        e,
        (r, s) => {
          i && Xi(r) ? (t[s] = nR(r, i)) : (t[s] = r);
        },
        { allOwnKeys: n }
      ),
      t
    ),
    E4 = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t),
    _4 = (t, e, i, n) => {
      (t.prototype = Object.create(e.prototype, n)),
        (t.prototype.constructor = t),
        Object.defineProperty(t, 'super', { value: e.prototype }),
        i && Object.assign(t.prototype, i);
    },
    S4 = (t, e, i, n) => {
      let r,
        s,
        o,
        c = {};
      if (((e = e || {}), t == null)) return e;
      do {
        for (r = Object.getOwnPropertyNames(t), s = r.length; s-- > 0; )
          (o = r[s]), (!n || n(o, t, e)) && !c[o] && ((e[o] = t[o]), (c[o] = !0));
        t = i !== !1 && Ng(t);
      } while (t && (!i || i(t, e)) && t !== Object.prototype);
      return e;
    },
    C4 = (t, e, i) => {
      (t = String(t)), (i === void 0 || i > t.length) && (i = t.length), (i -= e.length);
      let n = t.indexOf(e, i);
      return n !== -1 && n === i;
    },
    R4 = (t) => {
      if (!t) return null;
      if (ra(t)) return t;
      let e = t.length;
      if (!sR(e)) return null;
      let i = new Array(e);
      for (; e-- > 0; ) i[e] = t[e];
      return i;
    },
    T4 = (
      (t) => (e) =>
        t && e instanceof t
    )(typeof Uint8Array < 'u' && Ng(Uint8Array)),
    O4 = (t, e) => {
      let n = (t && t[Symbol.iterator]).call(t),
        r;
      for (; (r = n.next()) && !r.done; ) {
        let s = r.value;
        e.call(t, s[0], s[1]);
      }
    },
    k4 = (t, e) => {
      let i,
        n = [];
      for (; (i = t.exec(e)) !== null; ) n.push(i);
      return n;
    },
    A4 = Ln('HTMLFormElement'),
    I4 = (t) =>
      t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (i, n, r) {
        return n.toUpperCase() + r;
      }),
    jC = (
      ({ hasOwnProperty: t }) =>
      (e, i) =>
        t.call(e, i)
    )(Object.prototype),
    N4 = Ln('RegExp'),
    uR = (t, e) => {
      let i = Object.getOwnPropertyDescriptors(t),
        n = {};
      Xc(i, (r, s) => {
        let o;
        (o = e(r, s, t)) !== !1 && (n[s] = o || r);
      }),
        Object.defineProperties(t, n);
    },
    P4 = (t) => {
      uR(t, (e, i) => {
        if (Xi(t) && ['arguments', 'caller', 'callee'].indexOf(i) !== -1) return !1;
        let n = t[i];
        if (Xi(n)) {
          if (((e.enumerable = !1), 'writable' in e)) {
            e.writable = !1;
            return;
          }
          e.set ||
            (e.set = () => {
              throw Error("Can not rewrite read-only method '" + i + "'");
            });
        }
      });
    },
    L4 = (t, e) => {
      let i = {},
        n = (r) => {
          r.forEach((s) => {
            i[s] = !0;
          });
        };
      return ra(t) ? n(t) : n(String(t).split(e)), i;
    },
    D4 = () => {},
    F4 = (t, e) => ((t = +t), Number.isFinite(t) ? t : e),
    yg = 'abcdefghijklmnopqrstuvwxyz',
    MC = '0123456789',
    lR = { DIGIT: MC, ALPHA: yg, ALPHA_DIGIT: yg + yg.toUpperCase() + MC },
    j4 = (t = 16, e = lR.ALPHA_DIGIT) => {
      let i = '',
        { length: n } = e;
      for (; t--; ) i += e[(Math.random() * n) | 0];
      return i;
    };
  function M4(t) {
    return !!(t && Xi(t.append) && t[Symbol.toStringTag] === 'FormData' && t[Symbol.iterator]);
  }
  var U4 = (t) => {
      let e = new Array(10),
        i = (n, r) => {
          if (xp(n)) {
            if (e.indexOf(n) >= 0) return;
            if (!('toJSON' in n)) {
              e[r] = n;
              let s = ra(n) ? [] : {};
              return (
                Xc(n, (o, c) => {
                  let u = i(o, r + 1);
                  !Wc(u) && (s[c] = u);
                }),
                (e[r] = void 0),
                s
              );
            }
          }
          return n;
        };
      return i(t, 0);
    },
    q4 = Ln('AsyncFunction'),
    B4 = (t) => t && (xp(t) || Xi(t)) && Xi(t.then) && Xi(t.catch),
    Y = {
      isArray: ra,
      isArrayBuffer: rR,
      isBuffer: u4,
      isFormData: y4,
      isArrayBufferView: l4,
      isString: p4,
      isNumber: sR,
      isBoolean: f4,
      isObject: xp,
      isPlainObject: pp,
      isUndefined: Wc,
      isDate: d4,
      isFile: h4,
      isBlob: m4,
      isRegExp: N4,
      isFunction: Xi,
      isStream: x4,
      isURLSearchParams: b4,
      isTypedArray: T4,
      isFileList: g4,
      forEach: Xc,
      merge: Eg,
      extend: w4,
      trim: v4,
      stripBOM: E4,
      inherits: _4,
      toFlatObject: S4,
      kindOf: mp,
      kindOfTest: Ln,
      endsWith: C4,
      toArray: R4,
      forEachEntry: O4,
      matchAll: k4,
      isHTMLForm: A4,
      hasOwnProperty: jC,
      hasOwnProp: jC,
      reduceDescriptors: uR,
      freezeMethods: P4,
      toObjectSet: L4,
      toCamelCase: I4,
      noop: D4,
      toFiniteNumber: F4,
      findKey: oR,
      global: aR,
      isContextDefined: cR,
      ALPHABET: lR,
      generateString: j4,
      isSpecCompliantForm: M4,
      toJSONObject: U4,
      isAsyncFn: q4,
      isThenable: B4,
    };
  function Se(t, e, i, n, r) {
    Error.call(this),
      Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error().stack),
      (this.message = t),
      (this.name = 'AxiosError'),
      e && (this.code = e),
      i && (this.config = i),
      n && (this.request = n),
      r && (this.response = r);
  }
  Y.inherits(Se, Error, {
    toJSON: function () {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: Y.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null,
      };
    },
  });
  var pR = Se.prototype,
    fR = {};
  [
    'ERR_BAD_OPTION_VALUE',
    'ERR_BAD_OPTION',
    'ECONNABORTED',
    'ETIMEDOUT',
    'ERR_NETWORK',
    'ERR_FR_TOO_MANY_REDIRECTS',
    'ERR_DEPRECATED',
    'ERR_BAD_RESPONSE',
    'ERR_BAD_REQUEST',
    'ERR_CANCELED',
    'ERR_NOT_SUPPORT',
    'ERR_INVALID_URL',
  ].forEach((t) => {
    fR[t] = { value: t };
  });
  Object.defineProperties(Se, fR);
  Object.defineProperty(pR, 'isAxiosError', { value: !0 });
  Se.from = (t, e, i, n, r, s) => {
    let o = Object.create(pR);
    return (
      Y.toFlatObject(
        t,
        o,
        function (u) {
          return u !== Error.prototype;
        },
        (c) => c !== 'isAxiosError'
      ),
      Se.call(o, t.message, e, i, n, r),
      (o.cause = t),
      (o.name = t.name),
      s && Object.assign(o, s),
      o
    );
  };
  function _g(t) {
    return Y.isPlainObject(t) || Y.isArray(t);
  }
  function dR(t) {
    return Y.endsWith(t, '[]') ? t.slice(0, -2) : t;
  }
  function UC(t, e, i) {
    return t
      ? t
          .concat(e)
          .map(function (r, s) {
            return (r = dR(r)), !i && s ? '[' + r + ']' : r;
          })
          .join(i ? '.' : '')
      : e;
  }
  function H4(t) {
    return Y.isArray(t) && !t.some(_g);
  }
  var G4 = Y.toFlatObject(Y, {}, null, function (e) {
    return /^is[A-Z]/.test(e);
  });
  function yp(t, e, i) {
    if (!Y.isObject(t)) throw new TypeError('target must be an object');
    (e = e || new (iR.default || FormData)()),
      (i = Y.toFlatObject(i, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (y, h) {
        return !Y.isUndefined(h[y]);
      }));
    let n = i.metaTokens,
      r = i.visitor || p,
      s = i.dots,
      o = i.indexes,
      u = (i.Blob || (typeof Blob < 'u' && Blob)) && Y.isSpecCompliantForm(e);
    if (!Y.isFunction(r)) throw new TypeError('visitor must be a function');
    function l(g) {
      if (g === null) return '';
      if (Y.isDate(g)) return g.toISOString();
      if (!u && Y.isBlob(g)) throw new Se('Blob is not supported. Use a Buffer instead.');
      return Y.isArrayBuffer(g) || Y.isTypedArray(g)
        ? u && typeof Blob == 'function'
          ? new Blob([g])
          : Buffer.from(g)
        : g;
    }
    function p(g, y, h) {
      let v = g;
      if (g && !h && typeof g == 'object') {
        if (Y.endsWith(y, '{}')) (y = n ? y : y.slice(0, -2)), (g = JSON.stringify(g));
        else if ((Y.isArray(g) && H4(g)) || ((Y.isFileList(g) || Y.endsWith(y, '[]')) && (v = Y.toArray(g))))
          return (
            (y = dR(y)),
            v.forEach(function (_, m) {
              !(Y.isUndefined(_) || _ === null) && e.append(o === !0 ? UC([y], m, s) : o === null ? y : y + '[]', l(_));
            }),
            !1
          );
      }
      return _g(g) ? !0 : (e.append(UC(h, y, s), l(g)), !1);
    }
    let d = [],
      x = Object.assign(G4, { defaultVisitor: p, convertValue: l, isVisitable: _g });
    function b(g, y) {
      if (!Y.isUndefined(g)) {
        if (d.indexOf(g) !== -1) throw Error('Circular reference detected in ' + y.join('.'));
        d.push(g),
          Y.forEach(g, function (v, C) {
            (!(Y.isUndefined(v) || v === null) && r.call(e, v, Y.isString(C) ? C.trim() : C, y, x)) === !0 &&
              b(v, y ? y.concat(C) : [C]);
          }),
          d.pop();
      }
    }
    if (!Y.isObject(t)) throw new TypeError('data must be an object');
    return b(t), e;
  }
  function qC(t) {
    let e = { '!': '%21', "'": '%27', '(': '%28', ')': '%29', '~': '%7E', '%20': '+', '%00': '\0' };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (n) {
      return e[n];
    });
  }
  function hR(t, e) {
    (this._pairs = []), t && yp(t, this, e);
  }
  var mR = hR.prototype;
  mR.append = function (e, i) {
    this._pairs.push([e, i]);
  };
  mR.toString = function (e) {
    let i = e
      ? function (n) {
          return e.call(this, n, qC);
        }
      : qC;
    return this._pairs
      .map(function (r) {
        return i(r[0]) + '=' + i(r[1]);
      }, '')
      .join('&');
  };
  function z4(t) {
    return encodeURIComponent(t)
      .replace(/%3A/gi, ':')
      .replace(/%24/g, '$')
      .replace(/%2C/gi, ',')
      .replace(/%20/g, '+')
      .replace(/%5B/gi, '[')
      .replace(/%5D/gi, ']');
  }
  function Pg(t, e, i) {
    if (!e) return t;
    let n = (i && i.encode) || z4,
      r = i && i.serialize,
      s;
    if ((r ? (s = r(e, i)) : (s = Y.isURLSearchParams(e) ? e.toString() : new hR(e, i).toString(n)), s)) {
      let o = t.indexOf('#');
      o !== -1 && (t = t.slice(0, o)), (t += (t.indexOf('?') === -1 ? '?' : '&') + s);
    }
    return t;
  }
  var Sg = class {
      constructor() {
        this.handlers = [];
      }
      use(e, i, n) {
        return (
          this.handlers.push({
            fulfilled: e,
            rejected: i,
            synchronous: n ? n.synchronous : !1,
            runWhen: n ? n.runWhen : null,
          }),
          this.handlers.length - 1
        );
      }
      eject(e) {
        this.handlers[e] && (this.handlers[e] = null);
      }
      clear() {
        this.handlers && (this.handlers = []);
      }
      forEach(e) {
        Y.forEach(this.handlers, function (n) {
          n !== null && e(n);
        });
      }
    },
    BC = Sg,
    Lg = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 },
    V4 = i4.default.URLSearchParams,
    $4 = {
      isNode: !0,
      classes: { URLSearchParams: V4, FormData: iR.default, Blob: (typeof Blob < 'u' && Blob) || null },
      protocols: ['http', 'https', 'file', 'data'],
    },
    gR = typeof window < 'u' && typeof document < 'u',
    W4 = ((t) => gR && ['ReactNative', 'NativeScript', 'NS'].indexOf(t) < 0)(
      typeof navigator < 'u' && navigator.product
    ),
    K4 = typeof WorkerGlobalScope < 'u' && self instanceof WorkerGlobalScope && typeof self.importScripts == 'function',
    X4 = Object.freeze({
      __proto__: null,
      hasBrowserEnv: gR,
      hasStandardBrowserWebWorkerEnv: K4,
      hasStandardBrowserEnv: W4,
    }),
    Ki = { ...X4, ...$4 };
  function Y4(t, e) {
    return yp(
      t,
      new Ki.classes.URLSearchParams(),
      Object.assign(
        {
          visitor: function (i, n, r, s) {
            return Ki.isNode && Y.isBuffer(i)
              ? (this.append(n, i.toString('base64')), !1)
              : s.defaultVisitor.apply(this, arguments);
          },
        },
        e
      )
    );
  }
  function J4(t) {
    return Y.matchAll(/\w+|\[(\w*)]/g, t).map((e) => (e[0] === '[]' ? '' : e[1] || e[0]));
  }
  function Z4(t) {
    let e = {},
      i = Object.keys(t),
      n,
      r = i.length,
      s;
    for (n = 0; n < r; n++) (s = i[n]), (e[s] = t[s]);
    return e;
  }
  function xR(t) {
    function e(i, n, r, s) {
      let o = i[s++];
      if (o === '__proto__') return !0;
      let c = Number.isFinite(+o),
        u = s >= i.length;
      return (
        (o = !o && Y.isArray(r) ? r.length : o),
        u
          ? (Y.hasOwnProp(r, o) ? (r[o] = [r[o], n]) : (r[o] = n), !c)
          : ((!r[o] || !Y.isObject(r[o])) && (r[o] = []), e(i, n, r[o], s) && Y.isArray(r[o]) && (r[o] = Z4(r[o])), !c)
      );
    }
    if (Y.isFormData(t) && Y.isFunction(t.entries)) {
      let i = {};
      return (
        Y.forEachEntry(t, (n, r) => {
          e(J4(n), r, i, 0);
        }),
        i
      );
    }
    return null;
  }
  function Q4(t, e, i) {
    if (Y.isString(t))
      try {
        return (e || JSON.parse)(t), Y.trim(t);
      } catch (n) {
        if (n.name !== 'SyntaxError') throw n;
      }
    return (i || JSON.stringify)(t);
  }
  var Dg = {
    transitional: Lg,
    adapter: ['xhr', 'http'],
    transformRequest: [
      function (e, i) {
        let n = i.getContentType() || '',
          r = n.indexOf('application/json') > -1,
          s = Y.isObject(e);
        if ((s && Y.isHTMLForm(e) && (e = new FormData(e)), Y.isFormData(e))) return r ? JSON.stringify(xR(e)) : e;
        if (Y.isArrayBuffer(e) || Y.isBuffer(e) || Y.isStream(e) || Y.isFile(e) || Y.isBlob(e)) return e;
        if (Y.isArrayBufferView(e)) return e.buffer;
        if (Y.isURLSearchParams(e))
          return i.setContentType('application/x-www-form-urlencoded;charset=utf-8', !1), e.toString();
        let c;
        if (s) {
          if (n.indexOf('application/x-www-form-urlencoded') > -1) return Y4(e, this.formSerializer).toString();
          if ((c = Y.isFileList(e)) || n.indexOf('multipart/form-data') > -1) {
            let u = this.env && this.env.FormData;
            return yp(c ? { 'files[]': e } : e, u && new u(), this.formSerializer);
          }
        }
        return s || r ? (i.setContentType('application/json', !1), Q4(e)) : e;
      },
    ],
    transformResponse: [
      function (e) {
        let i = this.transitional || Dg.transitional,
          n = i && i.forcedJSONParsing,
          r = this.responseType === 'json';
        if (e && Y.isString(e) && ((n && !this.responseType) || r)) {
          let o = !(i && i.silentJSONParsing) && r;
          try {
            return JSON.parse(e);
          } catch (c) {
            if (o) throw c.name === 'SyntaxError' ? Se.from(c, Se.ERR_BAD_RESPONSE, this, null, this.response) : c;
          }
        }
        return e;
      },
    ],
    timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    env: { FormData: Ki.classes.FormData, Blob: Ki.classes.Blob },
    validateStatus: function (e) {
      return e >= 200 && e < 300;
    },
    headers: { common: { Accept: 'application/json, text/plain, */*', 'Content-Type': void 0 } },
  };
  Y.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (t) => {
    Dg.headers[t] = {};
  });
  var Fg = Dg,
    e6 = Y.toObjectSet([
      'age',
      'authorization',
      'content-length',
      'content-type',
      'etag',
      'expires',
      'from',
      'host',
      'if-modified-since',
      'if-unmodified-since',
      'last-modified',
      'location',
      'max-forwards',
      'proxy-authorization',
      'referer',
      'retry-after',
      'user-agent',
    ]),
    t6 = (t) => {
      let e = {},
        i,
        n,
        r;
      return (
        t &&
          t
            .split(
              `
`
            )
            .forEach(function (o) {
              (r = o.indexOf(':')),
                (i = o.substring(0, r).trim().toLowerCase()),
                (n = o.substring(r + 1).trim()),
                !(!i || (e[i] && e6[i])) &&
                  (i === 'set-cookie' ? (e[i] ? e[i].push(n) : (e[i] = [n])) : (e[i] = e[i] ? e[i] + ', ' + n : n));
            }),
        e
      );
    },
    HC = Symbol('internals');
  function Vc(t) {
    return t && String(t).trim().toLowerCase();
  }
  function fp(t) {
    return t === !1 || t == null ? t : Y.isArray(t) ? t.map(fp) : String(t);
  }
  function i6(t) {
    let e = Object.create(null),
      i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g,
      n;
    for (; (n = i.exec(t)); ) e[n[1]] = n[2];
    return e;
  }
  var n6 = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
  function bg(t, e, i, n, r) {
    if (Y.isFunction(n)) return n.call(this, e, i);
    if ((r && (e = i), !!Y.isString(e))) {
      if (Y.isString(n)) return e.indexOf(n) !== -1;
      if (Y.isRegExp(n)) return n.test(e);
    }
  }
  function r6(t) {
    return t
      .trim()
      .toLowerCase()
      .replace(/([a-z\d])(\w*)/g, (e, i, n) => i.toUpperCase() + n);
  }
  function s6(t, e) {
    let i = Y.toCamelCase(' ' + e);
    ['get', 'set', 'has'].forEach((n) => {
      Object.defineProperty(t, n + i, {
        value: function (r, s, o) {
          return this[n].call(this, e, r, s, o);
        },
        configurable: !0,
      });
    });
  }
  var ta = class {
    constructor(e) {
      e && this.set(e);
    }
    set(e, i, n) {
      let r = this;
      function s(c, u, l) {
        let p = Vc(u);
        if (!p) throw new Error('header name must be a non-empty string');
        let d = Y.findKey(r, p);
        (!d || r[d] === void 0 || l === !0 || (l === void 0 && r[d] !== !1)) && (r[d || u] = fp(c));
      }
      let o = (c, u) => Y.forEach(c, (l, p) => s(l, p, u));
      return (
        Y.isPlainObject(e) || e instanceof this.constructor
          ? o(e, i)
          : Y.isString(e) && (e = e.trim()) && !n6(e)
          ? o(t6(e), i)
          : e != null && s(i, e, n),
        this
      );
    }
    get(e, i) {
      if (((e = Vc(e)), e)) {
        let n = Y.findKey(this, e);
        if (n) {
          let r = this[n];
          if (!i) return r;
          if (i === !0) return i6(r);
          if (Y.isFunction(i)) return i.call(this, r, n);
          if (Y.isRegExp(i)) return i.exec(r);
          throw new TypeError('parser must be boolean|regexp|function');
        }
      }
    }
    has(e, i) {
      if (((e = Vc(e)), e)) {
        let n = Y.findKey(this, e);
        return !!(n && this[n] !== void 0 && (!i || bg(this, this[n], n, i)));
      }
      return !1;
    }
    delete(e, i) {
      let n = this,
        r = !1;
      function s(o) {
        if (((o = Vc(o)), o)) {
          let c = Y.findKey(n, o);
          c && (!i || bg(n, n[c], c, i)) && (delete n[c], (r = !0));
        }
      }
      return Y.isArray(e) ? e.forEach(s) : s(e), r;
    }
    clear(e) {
      let i = Object.keys(this),
        n = i.length,
        r = !1;
      for (; n--; ) {
        let s = i[n];
        (!e || bg(this, this[s], s, e, !0)) && (delete this[s], (r = !0));
      }
      return r;
    }
    normalize(e) {
      let i = this,
        n = {};
      return (
        Y.forEach(this, (r, s) => {
          let o = Y.findKey(n, s);
          if (o) {
            (i[o] = fp(r)), delete i[s];
            return;
          }
          let c = e ? r6(s) : String(s).trim();
          c !== s && delete i[s], (i[c] = fp(r)), (n[c] = !0);
        }),
        this
      );
    }
    concat(...e) {
      return this.constructor.concat(this, ...e);
    }
    toJSON(e) {
      let i = Object.create(null);
      return (
        Y.forEach(this, (n, r) => {
          n != null && n !== !1 && (i[r] = e && Y.isArray(n) ? n.join(', ') : n);
        }),
        i
      );
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([e, i]) => e + ': ' + i).join(`
`);
    }
    get [Symbol.toStringTag]() {
      return 'AxiosHeaders';
    }
    static from(e) {
      return e instanceof this ? e : new this(e);
    }
    static concat(e, ...i) {
      let n = new this(e);
      return i.forEach((r) => n.set(r)), n;
    }
    static accessor(e) {
      let n = (this[HC] = this[HC] = { accessors: {} }).accessors,
        r = this.prototype;
      function s(o) {
        let c = Vc(o);
        n[c] || (s6(r, o), (n[c] = !0));
      }
      return Y.isArray(e) ? e.forEach(s) : s(e), this;
    }
  };
  ta.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);
  Y.reduceDescriptors(ta.prototype, ({ value: t }, e) => {
    let i = e[0].toUpperCase() + e.slice(1);
    return {
      get: () => t,
      set(n) {
        this[i] = n;
      },
    };
  });
  Y.freezeMethods(ta);
  var Yi = ta;
  function vg(t, e) {
    let i = this || Fg,
      n = e || i,
      r = Yi.from(n.headers),
      s = n.data;
    return (
      Y.forEach(t, function (c) {
        s = c.call(i, s, r.normalize(), e ? e.status : void 0);
      }),
      r.normalize(),
      s
    );
  }
  function yR(t) {
    return !!(t && t.__CANCEL__);
  }
  function $s(t, e, i) {
    Se.call(this, t ?? 'canceled', Se.ERR_CANCELED, e, i), (this.name = 'CanceledError');
  }
  Y.inherits($s, Se, { __CANCEL__: !0 });
  function $c(t, e, i) {
    let n = i.config.validateStatus;
    !i.status || !n || n(i.status)
      ? t(i)
      : e(
          new Se(
            'Request failed with status code ' + i.status,
            [Se.ERR_BAD_REQUEST, Se.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4],
            i.config,
            i.request,
            i
          )
        );
  }
  function o6(t) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
  }
  function a6(t, e) {
    return e ? t.replace(/\/?\/$/, '') + '/' + e.replace(/^\/+/, '') : t;
  }
  function jg(t, e) {
    return t && !o6(e) ? a6(t, e) : e;
  }
  var hp = '1.6.7';
  function bR(t) {
    let e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
    return (e && e[1]) || '';
  }
  var c6 = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
  function u6(t, e, i) {
    let n = (i && i.Blob) || Ki.classes.Blob,
      r = bR(t);
    if ((e === void 0 && n && (e = !0), r === 'data')) {
      t = r.length ? t.slice(r.length + 1) : t;
      let s = c6.exec(t);
      if (!s) throw new Se('Invalid URL', Se.ERR_INVALID_URL);
      let o = s[1],
        c = s[2],
        u = s[3],
        l = Buffer.from(decodeURIComponent(u), c ? 'base64' : 'utf8');
      if (e) {
        if (!n) throw new Se('Blob is not supported', Se.ERR_NOT_SUPPORT);
        return new n([l], { type: o });
      }
      return l;
    }
    throw new Se('Unsupported protocol ' + r, Se.ERR_NOT_SUPPORT);
  }
  function l6(t, e) {
    let i = 0,
      n = 1e3 / e,
      r = null;
    return function (o, c) {
      let u = Date.now();
      if (o || u - i > n) return r && (clearTimeout(r), (r = null)), (i = u), t.apply(null, c);
      r || (r = setTimeout(() => ((r = null), (i = Date.now()), t.apply(null, c)), n - (u - i)));
    };
  }
  function vR(t, e) {
    t = t || 10;
    let i = new Array(t),
      n = new Array(t),
      r = 0,
      s = 0,
      o;
    return (
      (e = e !== void 0 ? e : 1e3),
      function (u) {
        let l = Date.now(),
          p = n[s];
        o || (o = l), (i[r] = u), (n[r] = l);
        let d = s,
          x = 0;
        for (; d !== r; ) (x += i[d++]), (d = d % t);
        if (((r = (r + 1) % t), r === s && (s = (s + 1) % t), l - o < e)) return;
        let b = p && l - p;
        return b ? Math.round((x * 1e3) / b) : void 0;
      }
    );
  }
  var lp = Symbol('internals'),
    Cg = class extends qr.default.Transform {
      constructor(e) {
        (e = Y.toFlatObject(
          e,
          { maxRate: 0, chunkSize: 64 * 1024, minChunkSize: 100, timeWindow: 500, ticksRate: 2, samplesCount: 15 },
          null,
          (c, u) => !Y.isUndefined(u[c])
        )),
          super({ readableHighWaterMark: e.chunkSize });
        let i = this,
          n = (this[lp] = {
            length: e.length,
            timeWindow: e.timeWindow,
            ticksRate: e.ticksRate,
            chunkSize: e.chunkSize,
            maxRate: e.maxRate,
            minChunkSize: e.minChunkSize,
            bytesSeen: 0,
            isCaptured: !1,
            notifiedBytesLoaded: 0,
            ts: Date.now(),
            bytes: 0,
            onReadCallback: null,
          }),
          r = vR(n.ticksRate * e.samplesCount, n.timeWindow);
        this.on('newListener', (c) => {
          c === 'progress' && (n.isCaptured || (n.isCaptured = !0));
        });
        let s = 0;
        n.updateProgress = l6(function () {
          let u = n.length,
            l = n.bytesSeen,
            p = l - s;
          if (!p || i.destroyed) return;
          let d = r(p);
          (s = l),
            process.nextTick(() => {
              i.emit('progress', {
                loaded: l,
                total: u,
                progress: u ? l / u : void 0,
                bytes: p,
                rate: d || void 0,
                estimated: d && u && l <= u ? (u - l) / d : void 0,
              });
            });
        }, n.ticksRate);
        let o = () => {
          n.updateProgress(!0);
        };
        this.once('end', o), this.once('error', o);
      }
      _read(e) {
        let i = this[lp];
        return i.onReadCallback && i.onReadCallback(), super._read(e);
      }
      _transform(e, i, n) {
        let r = this,
          s = this[lp],
          o = s.maxRate,
          c = this.readableHighWaterMark,
          u = s.timeWindow,
          l = 1e3 / u,
          p = o / l,
          d = s.minChunkSize !== !1 ? Math.max(s.minChunkSize, p * 0.01) : 0;
        function x(g, y) {
          let h = Buffer.byteLength(g);
          (s.bytesSeen += h),
            (s.bytes += h),
            s.isCaptured && s.updateProgress(),
            r.push(g)
              ? process.nextTick(y)
              : (s.onReadCallback = () => {
                  (s.onReadCallback = null), process.nextTick(y);
                });
        }
        let b = (g, y) => {
          let h = Buffer.byteLength(g),
            v = null,
            C = c,
            _,
            m = 0;
          if (o) {
            let O = Date.now();
            (!s.ts || (m = O - s.ts) >= u) && ((s.ts = O), (_ = p - s.bytes), (s.bytes = _ < 0 ? -_ : 0), (m = 0)),
              (_ = p - s.bytes);
          }
          if (o) {
            if (_ <= 0)
              return setTimeout(() => {
                y(null, g);
              }, u - m);
            _ < C && (C = _);
          }
          C && h > C && h - C > d && ((v = g.subarray(C)), (g = g.subarray(0, C))),
            x(
              g,
              v
                ? () => {
                    process.nextTick(y, null, v);
                  }
                : y
            );
        };
        b(e, function g(y, h) {
          if (y) return n(y);
          h ? b(h, g) : n(null);
        });
      }
      setLength(e) {
        return (this[lp].length = +e), this;
      }
    },
    GC = Cg,
    { asyncIterator: zC } = Symbol,
    p6 = async function* (t) {
      t.stream ? yield* t.stream() : t.arrayBuffer ? yield await t.arrayBuffer() : t[zC] ? yield* t[zC]() : yield t;
    },
    wR = p6,
    f6 = Y.ALPHABET.ALPHA_DIGIT + '-_',
    Kc = new eR.TextEncoder(),
    Br = `\r
`,
    d6 = Kc.encode(Br),
    h6 = 2,
    Rg = class {
      constructor(e, i) {
        let { escapeName: n } = this.constructor,
          r = Y.isString(i),
          s = `Content-Disposition: form-data; name="${n(e)}"${!r && i.name ? `; filename="${n(i.name)}"` : ''}${Br}`;
        r
          ? (i = Kc.encode(String(i).replace(/\r?\n|\r\n?/g, Br)))
          : (s += `Content-Type: ${i.type || 'application/octet-stream'}${Br}`),
          (this.headers = Kc.encode(s + Br)),
          (this.contentLength = r ? i.byteLength : i.size),
          (this.size = this.headers.byteLength + this.contentLength + h6),
          (this.name = e),
          (this.value = i);
      }
      async *encode() {
        yield this.headers;
        let { value: e } = this;
        Y.isTypedArray(e) ? yield e : yield* wR(e), yield d6;
      }
      static escapeName(e) {
        return String(e).replace(/[\r\n"]/g, (i) => ({ '\r': '%0D', '\n': '%0A', '"': '%22' }[i]));
      }
    },
    m6 = (t, e, i) => {
      let { tag: n = 'form-data-boundary', size: r = 25, boundary: s = n + '-' + Y.generateString(r, f6) } = i || {};
      if (!Y.isFormData(t)) throw TypeError('FormData instance required');
      if (s.length < 1 || s.length > 70) throw Error('boundary must be 10-70 characters long');
      let o = Kc.encode('--' + s + Br),
        c = Kc.encode('--' + s + '--' + Br + Br),
        u = c.byteLength,
        l = Array.from(t.entries()).map(([d, x]) => {
          let b = new Rg(d, x);
          return (u += b.size), b;
        });
      (u += o.byteLength * l.length), (u = Y.toFiniteNumber(u));
      let p = { 'Content-Type': `multipart/form-data; boundary=${s}` };
      return (
        Number.isFinite(u) && (p['Content-Length'] = u),
        e && e(p),
        tR.Readable.from(
          (async function* () {
            for (let d of l) yield o, yield* d.encode();
            yield c;
          })()
        )
      );
    },
    g6 = m6,
    Tg = class extends qr.default.Transform {
      __transform(e, i, n) {
        this.push(e), n();
      }
      _transform(e, i, n) {
        if (e.length !== 0 && ((this._transform = this.__transform), e[0] !== 120)) {
          let r = Buffer.alloc(2);
          (r[0] = 120), (r[1] = 156), this.push(r, i);
        }
        this.__transform(e, i, n);
      }
    },
    x6 = Tg,
    y6 = (t, e) =>
      Y.isAsyncFn(t)
        ? function (...i) {
            let n = i.pop();
            t.apply(this, i).then((r) => {
              try {
                e ? n(null, ...e(r)) : n(null, r);
              } catch (s) {
                n(s);
              }
            }, n);
          }
        : t,
    b6 = y6,
    VC = { flush: Hr.default.constants.Z_SYNC_FLUSH, finishFlush: Hr.default.constants.Z_SYNC_FLUSH },
    v6 = {
      flush: Hr.default.constants.BROTLI_OPERATION_FLUSH,
      finishFlush: Hr.default.constants.BROTLI_OPERATION_FLUSH,
    },
    $C = Y.isFunction(Hr.default.createBrotliDecompress),
    { http: w6, https: E6 } = o4.default,
    _6 = /https:?/,
    WC = Ki.protocols.map((t) => t + ':');
  function S6(t, e) {
    t.beforeRedirects.proxy && t.beforeRedirects.proxy(t), t.beforeRedirects.config && t.beforeRedirects.config(t, e);
  }
  function ER(t, e, i) {
    let n = e;
    if (!n && n !== !1) {
      let r = Y3.getProxyForUrl(i);
      r && (n = new URL(r));
    }
    if (n) {
      if ((n.username && (n.auth = (n.username || '') + ':' + (n.password || '')), n.auth)) {
        (n.auth.username || n.auth.password) && (n.auth = (n.auth.username || '') + ':' + (n.auth.password || ''));
        let s = Buffer.from(n.auth, 'utf8').toString('base64');
        t.headers['Proxy-Authorization'] = 'Basic ' + s;
      }
      t.headers.host = t.hostname + (t.port ? ':' + t.port : '');
      let r = n.hostname || n.host;
      (t.hostname = r),
        (t.host = r),
        (t.port = n.port),
        (t.path = i),
        n.protocol && (t.protocol = n.protocol.includes(':') ? n.protocol : `${n.protocol}:`);
    }
    t.beforeRedirects.proxy = function (s) {
      ER(s, e, s.href);
    };
  }
  var C6 = typeof process < 'u' && Y.kindOf(process) === 'process',
    R6 = (t) =>
      new Promise((e, i) => {
        let n,
          r,
          s = (u, l) => {
            r || ((r = !0), n && n(u, l));
          },
          o = (u) => {
            s(u), e(u);
          },
          c = (u) => {
            s(u, !0), i(u);
          };
        t(o, c, (u) => (n = u)).catch(c);
      }),
    T6 = ({ address: t, family: e }) => {
      if (!Y.isString(t)) throw TypeError('address must be a string');
      return { address: t, family: e || (t.indexOf('.') < 0 ? 6 : 4) };
    },
    KC = (t, e) => T6(Y.isObject(t) ? t : { address: t, family: e }),
    O6 =
      C6 &&
      function (e) {
        return R6(async function (n, r, s) {
          let { data: o, lookup: c, family: u } = e,
            { responseType: l, responseEncoding: p } = e,
            d = e.method.toUpperCase(),
            x,
            b = !1,
            g;
          if (c) {
            let q = b6(c, (B) => (Y.isArray(B) ? B : [B]));
            c = (B, ee, xe) => {
              q(B, ee, (de, Z, oe) => {
                if (de) return xe(de);
                let I = Y.isArray(Z) ? Z.map((X) => KC(X)) : [KC(Z, oe)];
                ee.all ? xe(de, I) : xe(de, I[0].address, I[0].family);
              });
            };
          }
          let y = new a4.default(),
            h = () => {
              e.cancelToken && e.cancelToken.unsubscribe(v),
                e.signal && e.signal.removeEventListener('abort', v),
                y.removeAllListeners();
            };
          s((q, B) => {
            (x = !0), B && ((b = !0), h());
          });
          function v(q) {
            y.emit('abort', !q || q.type ? new $s(null, e, g) : q);
          }
          y.once('abort', r),
            (e.cancelToken || e.signal) &&
              (e.cancelToken && e.cancelToken.subscribe(v),
              e.signal && (e.signal.aborted ? v() : e.signal.addEventListener('abort', v)));
          let C = jg(e.baseURL, e.url),
            _ = new URL(C, 'http://localhost'),
            m = _.protocol || WC[0];
          if (m === 'data:') {
            let q;
            if (d !== 'GET') return $c(n, r, { status: 405, statusText: 'method not allowed', headers: {}, config: e });
            try {
              q = u6(e.url, l === 'blob', { Blob: e.env && e.env.Blob });
            } catch (B) {
              throw Se.from(B, Se.ERR_BAD_REQUEST, e);
            }
            return (
              l === 'text'
                ? ((q = q.toString(p)), (!p || p === 'utf8') && (q = Y.stripBOM(q)))
                : l === 'stream' && (q = qr.default.Readable.from(q)),
              $c(n, r, { data: q, status: 200, statusText: 'OK', headers: new Yi(), config: e })
            );
          }
          if (WC.indexOf(m) === -1) return r(new Se('Unsupported protocol ' + m, Se.ERR_BAD_REQUEST, e));
          let O = Yi.from(e.headers).normalize();
          O.set('User-Agent', 'axios/' + hp, !1);
          let N = e.onDownloadProgress,
            D = e.onUploadProgress,
            z = e.maxRate,
            H,
            F;
          if (Y.isSpecCompliantForm(o)) {
            let q = O.getContentType(/boundary=([-_\w\d]{10,70})/i);
            o = g6(
              o,
              (B) => {
                O.set(B);
              },
              { tag: `axios-${hp}-boundary`, boundary: (q && q[1]) || void 0 }
            );
          } else if (Y.isFormData(o) && Y.isFunction(o.getHeaders)) {
            if ((O.set(o.getHeaders()), !O.hasContentLength()))
              try {
                let q = await s4.default.promisify(o.getLength).call(o);
                Number.isFinite(q) && q >= 0 && O.setContentLength(q);
              } catch {}
          } else if (Y.isBlob(o))
            o.size && O.setContentType(o.type || 'application/octet-stream'),
              O.setContentLength(o.size || 0),
              (o = qr.default.Readable.from(wR(o)));
          else if (o && !Y.isStream(o)) {
            if (!Buffer.isBuffer(o))
              if (Y.isArrayBuffer(o)) o = Buffer.from(new Uint8Array(o));
              else if (Y.isString(o)) o = Buffer.from(o, 'utf-8');
              else
                return r(
                  new Se(
                    'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
                    Se.ERR_BAD_REQUEST,
                    e
                  )
                );
            if ((O.setContentLength(o.length, !1), e.maxBodyLength > -1 && o.length > e.maxBodyLength))
              return r(new Se('Request body larger than maxBodyLength limit', Se.ERR_BAD_REQUEST, e));
          }
          let ne = Y.toFiniteNumber(O.getContentLength());
          Y.isArray(z) ? ((H = z[0]), (F = z[1])) : (H = F = z),
            o &&
              (D || H) &&
              (Y.isStream(o) || (o = qr.default.Readable.from(o, { objectMode: !1 })),
              (o = qr.default.pipeline([o, new GC({ length: ne, maxRate: Y.toFiniteNumber(H) })], Y.noop)),
              D &&
                o.on('progress', (q) => {
                  D(Object.assign(q, { upload: !0 }));
                }));
          let pe;
          if (e.auth) {
            let q = e.auth.username || '',
              B = e.auth.password || '';
            pe = q + ':' + B;
          }
          if (!pe && _.username) {
            let q = _.username,
              B = _.password;
            pe = q + ':' + B;
          }
          pe && O.delete('authorization');
          let le;
          try {
            le = Pg(_.pathname + _.search, e.params, e.paramsSerializer).replace(/^\?/, '');
          } catch (q) {
            let B = new Error(q.message);
            return (B.config = e), (B.url = e.url), (B.exists = !0), r(B);
          }
          O.set('Accept-Encoding', 'gzip, compress, deflate' + ($C ? ', br' : ''), !1);
          let V = {
            path: le,
            method: d,
            headers: O.toJSON(),
            agents: { http: e.httpAgent, https: e.httpsAgent },
            auth: pe,
            protocol: m,
            family: u,
            beforeRedirect: S6,
            beforeRedirects: {},
          };
          !Y.isUndefined(c) && (V.lookup = c),
            e.socketPath
              ? (V.socketPath = e.socketPath)
              : ((V.hostname = _.hostname),
                (V.port = _.port),
                ER(V, e.proxy, m + '//' + _.hostname + (_.port ? ':' + _.port : '') + V.path));
          let W,
            K = _6.test(V.protocol);
          if (
            ((V.agent = K ? e.httpsAgent : e.httpAgent),
            e.transport
              ? (W = e.transport)
              : e.maxRedirects === 0
              ? (W = K ? r4.default : n4.default)
              : (e.maxRedirects && (V.maxRedirects = e.maxRedirects),
                e.beforeRedirect && (V.beforeRedirects.config = e.beforeRedirect),
                (W = K ? E6 : w6)),
            e.maxBodyLength > -1 ? (V.maxBodyLength = e.maxBodyLength) : (V.maxBodyLength = 1 / 0),
            e.insecureHTTPParser && (V.insecureHTTPParser = e.insecureHTTPParser),
            (g = W.request(V, function (B) {
              if (g.destroyed) return;
              let ee = [B],
                xe = +B.headers['content-length'];
              if (N) {
                let X = new GC({ length: Y.toFiniteNumber(xe), maxRate: Y.toFiniteNumber(F) });
                N &&
                  X.on('progress', (Q) => {
                    N(Object.assign(Q, { download: !0 }));
                  }),
                  ee.push(X);
              }
              let de = B,
                Z = B.req || g;
              if (e.decompress !== !1 && B.headers['content-encoding'])
                switch (
                  ((d === 'HEAD' || B.statusCode === 204) && delete B.headers['content-encoding'],
                  (B.headers['content-encoding'] || '').toLowerCase())
                ) {
                  case 'gzip':
                  case 'x-gzip':
                  case 'compress':
                  case 'x-compress':
                    ee.push(Hr.default.createUnzip(VC)), delete B.headers['content-encoding'];
                    break;
                  case 'deflate':
                    ee.push(new x6()), ee.push(Hr.default.createUnzip(VC)), delete B.headers['content-encoding'];
                    break;
                  case 'br':
                    $C && (ee.push(Hr.default.createBrotliDecompress(v6)), delete B.headers['content-encoding']);
                }
              de = ee.length > 1 ? qr.default.pipeline(ee, Y.noop) : ee[0];
              let oe = qr.default.finished(de, () => {
                  oe(), h();
                }),
                I = {
                  status: B.statusCode,
                  statusText: B.statusMessage,
                  headers: new Yi(B.headers),
                  config: e,
                  request: Z,
                };
              if (l === 'stream') (I.data = de), $c(n, r, I);
              else {
                let X = [],
                  Q = 0;
                de.on('data', function (ce) {
                  X.push(ce),
                    (Q += ce.length),
                    e.maxContentLength > -1 &&
                      Q > e.maxContentLength &&
                      ((b = !0),
                      de.destroy(),
                      r(
                        new Se(
                          'maxContentLength size of ' + e.maxContentLength + ' exceeded',
                          Se.ERR_BAD_RESPONSE,
                          e,
                          Z
                        )
                      ));
                }),
                  de.on('aborted', function () {
                    if (b) return;
                    let ce = new Se(
                      'maxContentLength size of ' + e.maxContentLength + ' exceeded',
                      Se.ERR_BAD_RESPONSE,
                      e,
                      Z
                    );
                    de.destroy(ce), r(ce);
                  }),
                  de.on('error', function (ce) {
                    g.destroyed || r(Se.from(ce, null, e, Z));
                  }),
                  de.on('end', function () {
                    try {
                      let ce = X.length === 1 ? X[0] : Buffer.concat(X);
                      l !== 'arraybuffer' && ((ce = ce.toString(p)), (!p || p === 'utf8') && (ce = Y.stripBOM(ce))),
                        (I.data = ce);
                    } catch (ce) {
                      return r(Se.from(ce, null, e, I.request, I));
                    }
                    $c(n, r, I);
                  });
              }
              y.once('abort', (X) => {
                de.destroyed || (de.emit('error', X), de.destroy());
              });
            })),
            y.once('abort', (q) => {
              r(q), g.destroy(q);
            }),
            g.on('error', function (B) {
              r(Se.from(B, null, e, g));
            }),
            g.on('socket', function (B) {
              B.setKeepAlive(!0, 1e3 * 60);
            }),
            e.timeout)
          ) {
            let q = parseInt(e.timeout, 10);
            if (Number.isNaN(q)) {
              r(new Se('error trying to parse `config.timeout` to int', Se.ERR_BAD_OPTION_VALUE, e, g));
              return;
            }
            g.setTimeout(q, function () {
              if (x) return;
              let ee = e.timeout ? 'timeout of ' + e.timeout + 'ms exceeded' : 'timeout exceeded',
                xe = e.transitional || Lg;
              e.timeoutErrorMessage && (ee = e.timeoutErrorMessage),
                r(new Se(ee, xe.clarifyTimeoutError ? Se.ETIMEDOUT : Se.ECONNABORTED, e, g)),
                v();
            });
          }
          if (Y.isStream(o)) {
            let q = !1,
              B = !1;
            o.on('end', () => {
              q = !0;
            }),
              o.once('error', (ee) => {
                (B = !0), g.destroy(ee);
              }),
              o.on('close', () => {
                !q && !B && v(new $s('Request stream has been aborted', e, g));
              }),
              o.pipe(g);
          } else g.end(o);
        });
      },
    k6 = Ki.hasStandardBrowserEnv
      ? {
          write(t, e, i, n, r, s) {
            let o = [t + '=' + encodeURIComponent(e)];
            Y.isNumber(i) && o.push('expires=' + new Date(i).toGMTString()),
              Y.isString(n) && o.push('path=' + n),
              Y.isString(r) && o.push('domain=' + r),
              s === !0 && o.push('secure'),
              (document.cookie = o.join('; '));
          },
          read(t) {
            let e = document.cookie.match(new RegExp('(^|;\\s*)(' + t + ')=([^;]*)'));
            return e ? decodeURIComponent(e[3]) : null;
          },
          remove(t) {
            this.write(t, '', Date.now() - 864e5);
          },
        }
      : {
          write() {},
          read() {
            return null;
          },
          remove() {},
        },
    A6 = Ki.hasStandardBrowserEnv
      ? (function () {
          let e = /(msie|trident)/i.test(navigator.userAgent),
            i = document.createElement('a'),
            n;
          function r(s) {
            let o = s;
            return (
              e && (i.setAttribute('href', o), (o = i.href)),
              i.setAttribute('href', o),
              {
                href: i.href,
                protocol: i.protocol ? i.protocol.replace(/:$/, '') : '',
                host: i.host,
                search: i.search ? i.search.replace(/^\?/, '') : '',
                hash: i.hash ? i.hash.replace(/^#/, '') : '',
                hostname: i.hostname,
                port: i.port,
                pathname: i.pathname.charAt(0) === '/' ? i.pathname : '/' + i.pathname,
              }
            );
          }
          return (
            (n = r(window.location.href)),
            function (o) {
              let c = Y.isString(o) ? r(o) : o;
              return c.protocol === n.protocol && c.host === n.host;
            }
          );
        })()
      : (function () {
          return function () {
            return !0;
          };
        })();
  function XC(t, e) {
    let i = 0,
      n = vR(50, 250);
    return (r) => {
      let s = r.loaded,
        o = r.lengthComputable ? r.total : void 0,
        c = s - i,
        u = n(c),
        l = s <= o;
      i = s;
      let p = {
        loaded: s,
        total: o,
        progress: o ? s / o : void 0,
        bytes: c,
        rate: u || void 0,
        estimated: u && o && l ? (o - s) / u : void 0,
        event: r,
      };
      (p[e ? 'download' : 'upload'] = !0), t(p);
    };
  }
  var I6 = typeof XMLHttpRequest < 'u',
    N6 =
      I6 &&
      function (t) {
        return new Promise(function (i, n) {
          let r = t.data,
            s = Yi.from(t.headers).normalize(),
            { responseType: o, withXSRFToken: c } = t,
            u;
          function l() {
            t.cancelToken && t.cancelToken.unsubscribe(u), t.signal && t.signal.removeEventListener('abort', u);
          }
          let p;
          if (Y.isFormData(r)) {
            if (Ki.hasStandardBrowserEnv || Ki.hasStandardBrowserWebWorkerEnv) s.setContentType(!1);
            else if ((p = s.getContentType()) !== !1) {
              let [y, ...h] = p
                ? p
                    .split(';')
                    .map((v) => v.trim())
                    .filter(Boolean)
                : [];
              s.setContentType([y || 'multipart/form-data', ...h].join('; '));
            }
          }
          let d = new XMLHttpRequest();
          if (t.auth) {
            let y = t.auth.username || '',
              h = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : '';
            s.set('Authorization', 'Basic ' + btoa(y + ':' + h));
          }
          let x = jg(t.baseURL, t.url);
          d.open(t.method.toUpperCase(), Pg(x, t.params, t.paramsSerializer), !0), (d.timeout = t.timeout);
          function b() {
            if (!d) return;
            let y = Yi.from('getAllResponseHeaders' in d && d.getAllResponseHeaders()),
              v = {
                data: !o || o === 'text' || o === 'json' ? d.responseText : d.response,
                status: d.status,
                statusText: d.statusText,
                headers: y,
                config: t,
                request: d,
              };
            $c(
              function (_) {
                i(_), l();
              },
              function (_) {
                n(_), l();
              },
              v
            ),
              (d = null);
          }
          if (
            ('onloadend' in d
              ? (d.onloadend = b)
              : (d.onreadystatechange = function () {
                  !d ||
                    d.readyState !== 4 ||
                    (d.status === 0 && !(d.responseURL && d.responseURL.indexOf('file:') === 0)) ||
                    setTimeout(b);
                }),
            (d.onabort = function () {
              d && (n(new Se('Request aborted', Se.ECONNABORTED, t, d)), (d = null));
            }),
            (d.onerror = function () {
              n(new Se('Network Error', Se.ERR_NETWORK, t, d)), (d = null);
            }),
            (d.ontimeout = function () {
              let h = t.timeout ? 'timeout of ' + t.timeout + 'ms exceeded' : 'timeout exceeded',
                v = t.transitional || Lg;
              t.timeoutErrorMessage && (h = t.timeoutErrorMessage),
                n(new Se(h, v.clarifyTimeoutError ? Se.ETIMEDOUT : Se.ECONNABORTED, t, d)),
                (d = null);
            }),
            Ki.hasStandardBrowserEnv && (c && Y.isFunction(c) && (c = c(t)), c || (c !== !1 && A6(x))))
          ) {
            let y = t.xsrfHeaderName && t.xsrfCookieName && k6.read(t.xsrfCookieName);
            y && s.set(t.xsrfHeaderName, y);
          }
          r === void 0 && s.setContentType(null),
            'setRequestHeader' in d &&
              Y.forEach(s.toJSON(), function (h, v) {
                d.setRequestHeader(v, h);
              }),
            Y.isUndefined(t.withCredentials) || (d.withCredentials = !!t.withCredentials),
            o && o !== 'json' && (d.responseType = t.responseType),
            typeof t.onDownloadProgress == 'function' && d.addEventListener('progress', XC(t.onDownloadProgress, !0)),
            typeof t.onUploadProgress == 'function' &&
              d.upload &&
              d.upload.addEventListener('progress', XC(t.onUploadProgress)),
            (t.cancelToken || t.signal) &&
              ((u = (y) => {
                d && (n(!y || y.type ? new $s(null, t, d) : y), d.abort(), (d = null));
              }),
              t.cancelToken && t.cancelToken.subscribe(u),
              t.signal && (t.signal.aborted ? u() : t.signal.addEventListener('abort', u)));
          let g = bR(x);
          if (g && Ki.protocols.indexOf(g) === -1) {
            n(new Se('Unsupported protocol ' + g + ':', Se.ERR_BAD_REQUEST, t));
            return;
          }
          d.send(r || null);
        });
      },
    Og = { http: O6, xhr: N6 };
  Y.forEach(Og, (t, e) => {
    if (t) {
      try {
        Object.defineProperty(t, 'name', { value: e });
      } catch {}
      Object.defineProperty(t, 'adapterName', { value: e });
    }
  });
  var YC = (t) => `- ${t}`,
    P6 = (t) => Y.isFunction(t) || t === null || t === !1,
    _R = {
      getAdapter: (t) => {
        t = Y.isArray(t) ? t : [t];
        let { length: e } = t,
          i,
          n,
          r = {};
        for (let s = 0; s < e; s++) {
          i = t[s];
          let o;
          if (((n = i), !P6(i) && ((n = Og[(o = String(i)).toLowerCase()]), n === void 0)))
            throw new Se(`Unknown adapter '${o}'`);
          if (n) break;
          r[o || '#' + s] = n;
        }
        if (!n) {
          let s = Object.entries(r).map(
              ([c, u]) =>
                `adapter ${c} ` + (u === !1 ? 'is not supported by the environment' : 'is not available in the build')
            ),
            o = e
              ? s.length > 1
                ? `since :
` +
                  s.map(YC).join(`
`)
                : ' ' + YC(s[0])
              : 'as no adapter specified';
          throw new Se('There is no suitable adapter to dispatch the request ' + o, 'ERR_NOT_SUPPORT');
        }
        return n;
      },
      adapters: Og,
    };
  function wg(t) {
    if ((t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)) throw new $s(null, t);
  }
  function JC(t) {
    return (
      wg(t),
      (t.headers = Yi.from(t.headers)),
      (t.data = vg.call(t, t.transformRequest)),
      ['post', 'put', 'patch'].indexOf(t.method) !== -1 &&
        t.headers.setContentType('application/x-www-form-urlencoded', !1),
      _R
        .getAdapter(t.adapter || Fg.adapter)(t)
        .then(
          function (n) {
            return wg(t), (n.data = vg.call(t, t.transformResponse, n)), (n.headers = Yi.from(n.headers)), n;
          },
          function (n) {
            return (
              yR(n) ||
                (wg(t),
                n &&
                  n.response &&
                  ((n.response.data = vg.call(t, t.transformResponse, n.response)),
                  (n.response.headers = Yi.from(n.response.headers)))),
              Promise.reject(n)
            );
          }
        )
    );
  }
  var ZC = (t) => (t instanceof Yi ? t.toJSON() : t);
  function ia(t, e) {
    e = e || {};
    let i = {};
    function n(l, p, d) {
      return Y.isPlainObject(l) && Y.isPlainObject(p)
        ? Y.merge.call({ caseless: d }, l, p)
        : Y.isPlainObject(p)
        ? Y.merge({}, p)
        : Y.isArray(p)
        ? p.slice()
        : p;
    }
    function r(l, p, d) {
      if (Y.isUndefined(p)) {
        if (!Y.isUndefined(l)) return n(void 0, l, d);
      } else return n(l, p, d);
    }
    function s(l, p) {
      if (!Y.isUndefined(p)) return n(void 0, p);
    }
    function o(l, p) {
      if (Y.isUndefined(p)) {
        if (!Y.isUndefined(l)) return n(void 0, l);
      } else return n(void 0, p);
    }
    function c(l, p, d) {
      if (d in e) return n(l, p);
      if (d in t) return n(void 0, l);
    }
    let u = {
      url: s,
      method: s,
      data: s,
      baseURL: o,
      transformRequest: o,
      transformResponse: o,
      paramsSerializer: o,
      timeout: o,
      timeoutMessage: o,
      withCredentials: o,
      withXSRFToken: o,
      adapter: o,
      responseType: o,
      xsrfCookieName: o,
      xsrfHeaderName: o,
      onUploadProgress: o,
      onDownloadProgress: o,
      decompress: o,
      maxContentLength: o,
      maxBodyLength: o,
      beforeRedirect: o,
      transport: o,
      httpAgent: o,
      httpsAgent: o,
      cancelToken: o,
      socketPath: o,
      responseEncoding: o,
      validateStatus: c,
      headers: (l, p) => r(ZC(l), ZC(p), !0),
    };
    return (
      Y.forEach(Object.keys(Object.assign({}, t, e)), function (p) {
        let d = u[p] || r,
          x = d(t[p], e[p], p);
        (Y.isUndefined(x) && d !== c) || (i[p] = x);
      }),
      i
    );
  }
  var Mg = {};
  ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((t, e) => {
    Mg[t] = function (n) {
      return typeof n === t || 'a' + (e < 1 ? 'n ' : ' ') + t;
    };
  });
  var QC = {};
  Mg.transitional = function (e, i, n) {
    function r(s, o) {
      return '[Axios v' + hp + "] Transitional option '" + s + "'" + o + (n ? '. ' + n : '');
    }
    return (s, o, c) => {
      if (e === !1) throw new Se(r(o, ' has been removed' + (i ? ' in ' + i : '')), Se.ERR_DEPRECATED);
      return (
        i &&
          !QC[o] &&
          ((QC[o] = !0),
          console.warn(r(o, ' has been deprecated since v' + i + ' and will be removed in the near future'))),
        e ? e(s, o, c) : !0
      );
    };
  };
  function L6(t, e, i) {
    if (typeof t != 'object') throw new Se('options must be an object', Se.ERR_BAD_OPTION_VALUE);
    let n = Object.keys(t),
      r = n.length;
    for (; r-- > 0; ) {
      let s = n[r],
        o = e[s];
      if (o) {
        let c = t[s],
          u = c === void 0 || o(c, s, t);
        if (u !== !0) throw new Se('option ' + s + ' must be ' + u, Se.ERR_BAD_OPTION_VALUE);
        continue;
      }
      if (i !== !0) throw new Se('Unknown option ' + s, Se.ERR_BAD_OPTION);
    }
  }
  var kg = { assertOptions: L6, validators: Mg },
    Ur = kg.validators,
    na = class {
      constructor(e) {
        (this.defaults = e), (this.interceptors = { request: new BC(), response: new BC() });
      }
      async request(e, i) {
        try {
          return await this._request(e, i);
        } catch (n) {
          if (n instanceof Error) {
            let r;
            Error.captureStackTrace ? Error.captureStackTrace((r = {})) : (r = new Error());
            let s = r.stack ? r.stack.replace(/^.+\n/, '') : '';
            n.stack
              ? s &&
                !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, '')) &&
                (n.stack +=
                  `
` + s)
              : (n.stack = s);
          }
          throw n;
        }
      }
      _request(e, i) {
        typeof e == 'string' ? ((i = i || {}), (i.url = e)) : (i = e || {}), (i = ia(this.defaults, i));
        let { transitional: n, paramsSerializer: r, headers: s } = i;
        n !== void 0 &&
          kg.assertOptions(
            n,
            {
              silentJSONParsing: Ur.transitional(Ur.boolean),
              forcedJSONParsing: Ur.transitional(Ur.boolean),
              clarifyTimeoutError: Ur.transitional(Ur.boolean),
            },
            !1
          ),
          r != null &&
            (Y.isFunction(r)
              ? (i.paramsSerializer = { serialize: r })
              : kg.assertOptions(r, { encode: Ur.function, serialize: Ur.function }, !0)),
          (i.method = (i.method || this.defaults.method || 'get').toLowerCase());
        let o = s && Y.merge(s.common, s[i.method]);
        s &&
          Y.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], (g) => {
            delete s[g];
          }),
          (i.headers = Yi.concat(o, s));
        let c = [],
          u = !0;
        this.interceptors.request.forEach(function (y) {
          (typeof y.runWhen == 'function' && y.runWhen(i) === !1) ||
            ((u = u && y.synchronous), c.unshift(y.fulfilled, y.rejected));
        });
        let l = [];
        this.interceptors.response.forEach(function (y) {
          l.push(y.fulfilled, y.rejected);
        });
        let p,
          d = 0,
          x;
        if (!u) {
          let g = [JC.bind(this), void 0];
          for (g.unshift.apply(g, c), g.push.apply(g, l), x = g.length, p = Promise.resolve(i); d < x; )
            p = p.then(g[d++], g[d++]);
          return p;
        }
        x = c.length;
        let b = i;
        for (d = 0; d < x; ) {
          let g = c[d++],
            y = c[d++];
          try {
            b = g(b);
          } catch (h) {
            y.call(this, h);
            break;
          }
        }
        try {
          p = JC.call(this, b);
        } catch (g) {
          return Promise.reject(g);
        }
        for (d = 0, x = l.length; d < x; ) p = p.then(l[d++], l[d++]);
        return p;
      }
      getUri(e) {
        e = ia(this.defaults, e);
        let i = jg(e.baseURL, e.url);
        return Pg(i, e.params, e.paramsSerializer);
      }
    };
  Y.forEach(['delete', 'get', 'head', 'options'], function (e) {
    na.prototype[e] = function (i, n) {
      return this.request(ia(n || {}, { method: e, url: i, data: (n || {}).data }));
    };
  });
  Y.forEach(['post', 'put', 'patch'], function (e) {
    function i(n) {
      return function (s, o, c) {
        return this.request(
          ia(c || {}, { method: e, headers: n ? { 'Content-Type': 'multipart/form-data' } : {}, url: s, data: o })
        );
      };
    }
    (na.prototype[e] = i()), (na.prototype[e + 'Form'] = i(!0));
  });
  var dp = na,
    Ag = class t {
      constructor(e) {
        if (typeof e != 'function') throw new TypeError('executor must be a function.');
        let i;
        this.promise = new Promise(function (s) {
          i = s;
        });
        let n = this;
        this.promise.then((r) => {
          if (!n._listeners) return;
          let s = n._listeners.length;
          for (; s-- > 0; ) n._listeners[s](r);
          n._listeners = null;
        }),
          (this.promise.then = (r) => {
            let s,
              o = new Promise((c) => {
                n.subscribe(c), (s = c);
              }).then(r);
            return (
              (o.cancel = function () {
                n.unsubscribe(s);
              }),
              o
            );
          }),
          e(function (s, o, c) {
            n.reason || ((n.reason = new $s(s, o, c)), i(n.reason));
          });
      }
      throwIfRequested() {
        if (this.reason) throw this.reason;
      }
      subscribe(e) {
        if (this.reason) {
          e(this.reason);
          return;
        }
        this._listeners ? this._listeners.push(e) : (this._listeners = [e]);
      }
      unsubscribe(e) {
        if (!this._listeners) return;
        let i = this._listeners.indexOf(e);
        i !== -1 && this._listeners.splice(i, 1);
      }
      static source() {
        let e;
        return {
          token: new t(function (r) {
            e = r;
          }),
          cancel: e,
        };
      }
    },
    D6 = Ag;
  function F6(t) {
    return function (i) {
      return t.apply(null, i);
    };
  }
  function j6(t) {
    return Y.isObject(t) && t.isAxiosError === !0;
  }
  var Ig = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
  };
  Object.entries(Ig).forEach(([t, e]) => {
    Ig[e] = t;
  });
  var M6 = Ig;
  function SR(t) {
    let e = new dp(t),
      i = nR(dp.prototype.request, e);
    return (
      Y.extend(i, dp.prototype, e, { allOwnKeys: !0 }),
      Y.extend(i, e, null, { allOwnKeys: !0 }),
      (i.create = function (r) {
        return SR(ia(t, r));
      }),
      i
    );
  }
  var Nt = SR(Fg);
  Nt.Axios = dp;
  Nt.CanceledError = $s;
  Nt.CancelToken = D6;
  Nt.isCancel = yR;
  Nt.VERSION = hp;
  Nt.toFormData = yp;
  Nt.AxiosError = Se;
  Nt.Cancel = Nt.CanceledError;
  Nt.all = function (e) {
    return Promise.all(e);
  };
  Nt.spread = F6;
  Nt.isAxiosError = j6;
  Nt.mergeConfig = ia;
  Nt.AxiosHeaders = Yi;
  Nt.formToJSON = (t) => xR(Y.isHTMLForm(t) ? new FormData(t) : t);
  Nt.getAdapter = _R.getAdapter;
  Nt.HttpStatusCode = M6;
  Nt.default = Nt;
  CR.exports = Nt;
});
function zt(t, e = null, i = 1e4) {
  let n = (c) => c,
    r = process.env.NX_CLOUD_API || t.url || 'https://cloud.nx.app',
    s = Zn ? Zn : t.accessToken,
    o = t.nxCloudId;
  if (((e = e ?? new In(r)), !s && !o))
    throw new Error(
      'Unable to authenticate. Please connect your workspace to Nx Cloud to define a valid Nx Cloud ID. If you are in a CI context, please set the NX_CLOUD_ACCESS_TOKEN environment variable or define an access token in your nx.json.'
    );
  if (t.customProxyConfigPath) {
    let { nxCloudProxyConfig: c } = require((0, TR.join)(process.cwd(), t.customProxyConfigPath));
    n = c ?? n;
  }
  return U6.create(
    n({
      baseURL: r,
      timeout: ji ? $o : i,
      headers: {
        authorization: s,
        [B6]: t.nxCloudId,
        [q6]: e.getPersonalAccessTokenFromNxCloudUrl(),
        'Nx-Cloud-Client-Version': t.clientVersion || 'unknown',
      },
    })
  );
}
async function Hg(t, e) {
  let i = new Date(),
    n = await e();
  return ie && console.log(`${t}: ${new Date().getTime() - i.getTime()}`), n;
}
async function Gg(t) {
  try {
    return await t();
  } catch (e) {
    let i = (e.response && e.response.status) || e.code,
      n = e.response ? (e.response.data.message ? e.response.data.message : e.response.data) : e.message;
    n = jS(n);
    let r =
      (n == null
        ? void 0
        : n.split(`
`)) || [];
    throw new Bg('failure', H6(i), e, r);
  }
}
async function tt(t, e = Ql) {
  var i, n, r;
  try {
    return await Gg(t);
  } catch (s) {
    let o = ((i = s.axiosException) == null ? void 0 : i.code) ?? s.code,
      c = ((n = s.axiosException) == null ? void 0 : n.message) ?? s.message;
    if (e === 0 || o === 401 || o === 403)
      throw (
        (ie &&
          qg.note({
            title: `Connection to Nx Cloud failed with status code ${o}`,
            bodyLines: (r = s.axiosException) == null ? void 0 : r.bodyLines,
          }),
        s.axiosException ?? s)
      );
    if (o === 429) {
      if (!bp) {
        let u = 1e4 + (Ql + 1 - e) * 6e4 * Math.random();
        qg.note({ title: `Received Code ${o}. ${c ? `${c}. ` : ''}Retrying in ${RR(u)}s.` }), (bp = wt(u));
      }
      await bp, (bp = null);
    } else {
      let u = 1e3 + (Ql + 1 - e) * 4e3 * Math.random();
      ie && qg.note({ title: `Received Code ${o}. Retrying in ${RR(u)}s.` }), await wt(u);
    }
    return tt(t, e - 1);
  }
}
function RR(t) {
  return Math.round(t / 1e3);
}
function H6(t) {
  let e = `${t}:`;
  switch (t) {
    case 400:
      return `${e} Invalid request to Nx Cloud.`;
    case 403:
      return `${e} Access to resource is not authorized.`;
    case 404:
      return `${e} Cannot find requested resource.`;
    case 500:
      return `${e} Unexpected server error.`;
    case 'ECONNABORTED':
    case 'ETIMEOUT':
      return `${e} Connection timed out, check for other network problems.`;
    case 'ECONNRESET':
      return `${e} The connection to Nx Cloud was closed suddenly.`;
    case 'ECONNREFUSED':
      return `${e} Cannot connect to server. Please check that you have the correct server address and port number.`;
    case 'ENOTFOUND':
      return `${e} DNS error due to invalid host. Are you accessing Nx Cloud from a network proxy?`;
    case 'SELF_SIGNED_CERT_IN_CHAIN':
      return `${e} Found a self-signed cert in certificate chain. Ensure you have verified trust for all certs in your network.`;
    default:
      return `${e} Unable to connect to Nx Cloud.`;
  }
}
var TR,
  qg,
  U6,
  Bg,
  q6,
  B6,
  bp,
  mn = te(() => {
    'use strict';
    TR = require('path');
    Le();
    Mc();
    Uc();
    Pn();
    ({ output: qg } = Ae()),
      (U6 = Ug()),
      (Bg = class {
        constructor(e, i, n, r) {
          this.type = e;
          this.message = i;
          this.axiosException = n;
          this.bodyLines = r;
        }
      }),
      (q6 = 'Nx-Cloud-Personal-Access-Token'),
      (B6 = 'Nx-Cloud-Id');
    bp = null;
  });
function qi() {
  for (let t of Object.values(G6))
    if (t.detectorFn(process.env)) {
      let e = t.contextRetrieverFn(process.env);
      return ie && console.log(JSON.stringify(e, null, 2)), e;
    }
  return ie && console.log('[Nx Cloud] Unable to detect a VCS context from the environment.'), null;
}
function z6(t) {
  return t.CIRCLECI === 'true';
}
function V6(t) {
  ie && console.log('[Nx Cloud] Detected Env: CircleCI');
  let e = (n) => {
      if (n.CIRCLE_PR_NUMBER !== void 0) return n.CIRCLE_PR_NUMBER;
      if (n.CIRCLE_PULL_REQUEST !== void 0) {
        let r = n.CIRCLE_PULL_REQUEST.split('/');
        return r[r.length - 1];
      }
      return n.CIRCLE_BRANCH !== void 0 ? n.CIRCLE_BRANCH : 'unknown';
    },
    i = (n) => (n.CIRCLE_USERNAME !== void 0 ? n.CIRCLE_USERNAME : n.CIRCLE_PR_USERNAME ? n.CIRCLE_PR_USERNAME : null);
  return {
    branch: e(t),
    ref: t.CIRCLE_BRANCH ?? null,
    title: Ws(),
    headSha: t.CIRCLE_SHA1 ?? 'unknown',
    baseSha: null,
    commitLink: t.CIRCLE_PULL_REQUEST ?? null,
    author: i(t),
    authorUrl: null,
    authorAvatarUrl: null,
    repositoryUrl: t.CIRCLE_REPOSITORY_URL ?? null,
    platformName: 'CIRCLE_CI',
  };
}
function $6(t) {
  return t.TRAVIS === 'true';
}
function W6(t) {
  return (
    ie && console.log('[Nx Cloud] Detected Env: TravisCI'),
    {
      branch: ((i) => (i.TRAVIS_EVENT_TYPE === 'pull_request' ? i.TRAVIS_PULL_REQUEST : i.TRAVIS_BRANCH))(t),
      ref: null,
      title: Ws(),
      headSha: t.TRAVIS_COMMIT ?? 'unknown',
      baseSha: null,
      commitLink: null,
      author: zg(),
      authorUrl: null,
      authorAvatarUrl: null,
      repositoryUrl: null,
      platformName: 'TRAVIS_CI',
    }
  );
}
function K6(t) {
  return t.GITHUB_ACTIONS === 'true';
}
function X6(t) {
  ie && console.log('[Nx Cloud] Detected Env: GitHub Actions');
  let e = (r) => {
      if (r.GITHUB_REF) {
        let s = r.GITHUB_REF.match(/refs\/pull\/(\d+)\/merge/);
        if (s) return s[1];
      }
      return r.GITHUB_HEAD_REF ? r.GITHUB_HEAD_REF : r.GITHUB_REF_NAME ? r.GITHUB_REF_NAME : 'unknown';
    },
    i = (r) => {
      let s = `${r.GITHUB_SERVER_URL}/${r.GITHUB_REPOSITORY}`;
      return r.GITHUB_EVENT_NAME === 'pull_request' ? `${s}/pull/${e(r)}` : `${s}/commit/${r.GITHUB_SHA}`;
    },
    n = (r) => (r.GITHUB_HEAD_REF ? r.GITHUB_HEAD_REF : r.GITHUB_REF ? r.GITHUB_REF : null);
  return {
    branch: e(t),
    ref: n(t),
    title: Ws(),
    headSha: t.GITHUB_SHA ?? 'unknown',
    baseSha: null,
    commitLink: i(t),
    author: t.GITHUB_ACTOR ?? null,
    authorUrl: `${t.GITHUB_SERVER_URL}/${t.GITHUB_ACTOR}`,
    authorAvatarUrl: `${t.GITHUB_SERVER_URL}/${t.GITHUB_ACTOR}.png`,
    repositoryUrl: `${t.GITHUB_SERVER_URL}/${t.GITHUB_REPOSITORY}`,
    platformName: 'GITHUB_ACTIONS',
  };
}
function Y6(t) {
  return t.BITBUCKET_BUILD_NUMBER != null;
}
function J6(t) {
  return (
    ie && console.log('[Nx Cloud] Detected Env: BitBucket Pipelines'),
    {
      branch: t.BITBUCKET_PR_ID ?? t.BITBUCKET_BRANCH ?? 'unknown',
      ref: null,
      title: Ws(),
      headSha: t.BITBUCKET_COMMIT ?? 'unknown',
      baseSha: null,
      commitLink: null,
      author: zg(),
      authorUrl: null,
      authorAvatarUrl: null,
      repositoryUrl: t.BITBUCKET_GIT_HTTP_ORIGIN ?? null,
      platformName: 'BITBUCKET_PIPELINES',
    }
  );
}
function Z6(t) {
  return t.BUILD_BUILDID !== void 0 && t.AGENT_NAME !== void 0;
}
function Q6(t) {
  return (
    ie && console.log('[Nx Cloud] Detected Env: Azure DevOps'),
    {
      branch: t.SYSTEM_PULLREQUEST_PULLREQUESTNUMBER ?? t.BUILD_SOURCEBRANCHNAME ?? 'unknown',
      ref: null,
      title: Ws(),
      headSha: Qt() ?? 'unknown',
      baseSha: null,
      commitLink: null,
      author: t.BUILD_REQUESTEDFOR ?? null,
      authorUrl: null,
      authorAvatarUrl: null,
      repositoryUrl: t.SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI ?? t.BUILD_REPOSITORY_URI ?? null,
      platformName: 'AZURE_DEVOPS',
    }
  );
}
function eH(t) {
  return t.GITLAB_CI === 'true';
}
function tH(t) {
  return (
    ie && console.log('[Nx Cloud] Detected Env: GitLab Pipelines'),
    {
      branch: ((i) =>
        i.CI_MERGE_REQUEST_IID ? i.CI_MERGE_REQUEST_IID : i.CI_COMMIT_BRANCH ? i.CI_COMMIT_BRANCH : 'unknown')(t),
      ref: t.CI_COMMIT_REF_NAME ?? null,
      title: Ws(),
      headSha: Qt() ?? 'unknown',
      baseSha: null,
      commitLink: null,
      author: t.GITLAB_USER_NAME ?? null,
      authorUrl: null,
      authorAvatarUrl: null,
      repositoryUrl: t.CI_REPOSITORY_URL ?? null,
      platformName: 'GITLAB_PIPELINES',
    }
  );
}
function iH(t) {
  return t.NX_CLOUD_VERSION != null && t.NX_CLOUD_VERSION !== '';
}
function nH(t) {
  return (
    ie && console.log('[Nx Cloud] Detected Env: Nx Cloud'),
    {
      branch: rH() ?? 'unknown',
      ref: sH(),
      title: Ws(),
      headSha: Qt() ?? 'unknown',
      baseSha: null,
      commitLink: null,
      author: zg(),
      authorUrl: null,
      authorAvatarUrl: null,
      repositoryUrl: null,
      platformName: 'NX_CLOUD',
    }
  );
}
function Ws() {
  try {
    return (0, Yc.execSync)('git log -1 --pretty=%B', { encoding: 'utf-8' }).trim();
  } catch {
    return null;
  }
}
function zg() {
  try {
    return (0, Yc.execSync)('git log -1 --pretty=%aN', { encoding: 'utf-8' }).trim();
  } catch {
    return null;
  }
}
function rH() {
  try {
    return (0, Yc.execSync)('git branch --show-current', { encoding: 'utf-8' }).trim();
  } catch {
    return null;
  }
}
function sH() {
  try {
    return (0, Yc.execSync)('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim();
  } catch {
    return null;
  }
}
var Yc,
  G6,
  sa = te(() => {
    'use strict';
    Yc = require('child_process');
    Le();
    G6 = {
      CIRCLE_CI: { detectorFn: z6, contextRetrieverFn: V6 },
      TRAVIS_CI: { detectorFn: $6, contextRetrieverFn: W6 },
      GITHUB_ACTIONS: { detectorFn: K6, contextRetrieverFn: X6 },
      BITBUCKET_PIPELINES: { detectorFn: Y6, contextRetrieverFn: J6 },
      AZURE_DEVOPS: { detectorFn: Z6, contextRetrieverFn: Q6 },
      GITLAB_PIPELINES: { detectorFn: eH, contextRetrieverFn: tH },
      NX_CLOUD: { detectorFn: iH, contextRetrieverFn: nH },
    };
  });
var kR,
  AR,
  OR,
  Gr,
  vp = te(() => {
    'use strict';
    (kR = require('util')), (AR = require('zlib'));
    mn();
    sa();
    ({ output: OR } = Ae()),
      (Gr = class {
        constructor(e) {
          this.apiAxiosInstance = zt(e);
        }
        async createRunGroup(e, i, n, r, s, o, c, u, l, p, d, x, b = !1, g = []) {
          var y, h;
          try {
            return this.apiAxiosInstance.post(
              '/nx-cloud/executions/create-run-group',
              {
                branch: e,
                runGroup: i,
                ciExecutionId: n,
                ciExecutionEnv: r,
                stopAgentsOnFailure: s,
                agentCount: o,
                stopAgentsAfter: c,
                commitSha: l,
                distributeOn: u,
                affectedProjectRatio: d,
                vcsContext: qi(),
                envVars: x,
                requireExplicitCompletion: b,
                touchedProjects: g,
              },
              { timeout: 3e4 }
            );
          } catch (v) {
            OR.error({
              title: v.message,
              bodyLines:
                ((h = (y = v.response) == null ? void 0 : y.data) == null
                  ? void 0
                  : h.split(`
`)) || [],
            }),
              process.exit(1);
          }
        }
        async completeRunGroup(e, i, n, r) {
          try {
            await this.apiAxiosInstance.post('/nx-cloud/executions/complete-run-group', {
              branch: e,
              runGroup: i,
              ciExecutionId: n,
              ciExecutionEnv: r,
              vcsContext: qi(),
            });
          } catch (s) {
            OR.error({ title: s.message }), process.exit(1);
          }
        }
        async sendHeartbeat(e, i) {
          await this.apiAxiosInstance.post('/nx-cloud/heartbeat', { ciExecutionId: e, runGroup: i });
        }
        async sendHeartbeatLogs(e, i, n) {
          let r = { logs: e, ciExecutionId: i, runGroup: n },
            s = Buffer.from(JSON.stringify(r)),
            o = await (0, kR.promisify)(AR.gzip)(s);
          await this.apiAxiosInstance.post('/nx-cloud/heartbeat/logs', o, {
            headers: {
              ...this.apiAxiosInstance.defaults.headers,
              'Content-Encoding': 'gzip',
              'Content-Type': 'application/octet-stream',
            },
          });
        }
        async fetchProjectGraph() {
          return await this.apiAxiosInstance.get('/nx-cloud/executions/project-graph');
        }
      });
  });
function wp(t, e) {
  let i = {};
  return (
    e.forEach((n) => {
      var c;
      let r = t[n.target.project],
        s = (c = r == null ? void 0 : r.data.metadata) == null ? void 0 : c.targetGroups,
        o = {};
      if (s) for (let [u, l] of Object.entries(s)) l.includes(n.target.target) && l.length > 0 && (o[u] = l);
      o &&
        Object.entries(o).length > 0 &&
        (n.target.project in i
          ? (i[n.target.project].targetGroups = { ...i[n.target.project].targetGroups, ...o })
          : (i[n.target.project] = { targetGroups: o }));
    }),
    { projects: Object.keys(i).length > 0 ? i : null }
  );
}
function IR(t, e) {
  var c, u, l;
  let i = t[e.projectName],
    n = ((c = i == null ? void 0 : i.data.metadata) == null ? void 0 : c.technologies) || [],
    r = (u = i == null ? void 0 : i.data.targets) == null ? void 0 : u[e.target],
    s = ((l = r == null ? void 0 : r.metadata) == null ? void 0 : l.technologies) || [],
    o = new Set(n.concat(s));
  e.meta = o.size > 0 ? { technologies: Array.from(o) } : null;
}
var Vg = te(() => {
  'use strict';
});
function Ep(t) {
  return t[t.length - 1] === '/' ? t.substr(0, t.length - 1) : t;
}
var $g = te(() => {
  'use strict';
});
var oH,
  Si,
  Ks = te(() => {
    'use strict';
    mn();
    ({ output: oH } = Ae()),
      (Si = class {
        constructor(e) {
          this.apiAxiosInstance = zt(e);
        }
        async reportError(e) {
          try {
            await tt(() => this.apiAxiosInstance.post('/nx-cloud/report-client-error', { message: e }));
          } catch (i) {
            oH.warn({ title: `Unable to record the following error: '${e}'`, bodyLines: [i.message] });
          }
        }
      });
  });
var tr,
  aa,
  Xg,
  oa,
  _p,
  Ci,
  Wg,
  Kg,
  Xs = te(() => {
    'use strict';
    (tr = require('crypto')),
      (aa = require('fs')),
      (Xg = require('stream')),
      (oa = 16),
      (_p = 'aes-256-cbc'),
      (Ci = class {
        constructor(e) {
          e && (this.encryptionKey = this.to32bytes(e));
        }
        to32bytes(e) {
          let i = e;
          for (; i.length < 32; ) i += e;
          return Buffer.from(i).slice(0, 32);
        }
        hasEncryption() {
          return !!this.encryptionKey;
        }
        encryptFile(e) {
          let i = (0, tr.randomBytes)(oa),
            n = (0, tr.createCipheriv)(_p, this.encryptionKey, i),
            r = (0, aa.readFileSync)(e),
            s = n.update(r),
            o = Buffer.concat([i, s, n.final()]);
          (0, aa.writeFileSync)(e, o);
        }
        encryptFileStream() {
          return new Wg(this.encryptionKey);
        }
        decryptFile(e) {
          let i = (0, aa.readFileSync)(e);
          try {
            let n = (0, tr.createDecipheriv)(_p, this.encryptionKey, i.slice(0, oa)),
              r = i.slice(oa),
              s = n.update(r),
              o = Buffer.concat([s, n.final()]);
            (0, aa.writeFileSync)(e, o);
          } catch {
            throw new Error('Could not decrypt the artifact. Please check your encryption key.');
          }
        }
        decryptFileStream() {
          return new Kg(this.encryptionKey);
        }
      }),
      (Wg = class extends Xg.Transform {
        constructor(i) {
          super();
          this.key = i;
          this.iv = (0, tr.randomBytes)(oa);
          this.cipher = (0, tr.createCipheriv)(_p, this.key, this.iv);
          this.initialized = !1;
        }
        _transform(i, n, r) {
          try {
            this.initialized || (this.push(this.iv), (this.initialized = !0)), this.push(this.cipher.update(i)), r();
          } catch (s) {
            r(s);
          }
        }
        _flush(i) {
          try {
            this.push(this.cipher.final()), i();
          } catch (n) {
            i(n);
          }
        }
      }),
      (Kg = class extends Xg.Transform {
        constructor(i) {
          super();
          this.key = i;
          this.decipher = null;
          this.iv = null;
        }
        _transform(i, n, r) {
          try {
            if (this.iv) this.push(this.decipher.update(i));
            else {
              (this.iv = i.subarray(0, oa)), (this.decipher = (0, tr.createDecipheriv)(_p, this.key, this.iv));
              let s = i.subarray(oa);
              s.length > 0 && this.push(this.decipher.update(s));
            }
            r();
          } catch (s) {
            r(s);
          }
        }
        _flush(i) {
          try {
            this.decipher && this.push(this.decipher.final()), i();
          } catch (n) {
            i(n);
          }
        }
      });
  });
var ca = P((Vre, PR) => {
  'use strict';
  var NR = new Map([
    ['C', 'cwd'],
    ['f', 'file'],
    ['z', 'gzip'],
    ['P', 'preservePaths'],
    ['U', 'unlink'],
    ['strip-components', 'strip'],
    ['stripComponents', 'strip'],
    ['keep-newer', 'newer'],
    ['keepNewer', 'newer'],
    ['keep-newer-files', 'newer'],
    ['keepNewerFiles', 'newer'],
    ['k', 'keep'],
    ['keep-existing', 'keep'],
    ['keepExisting', 'keep'],
    ['m', 'noMtime'],
    ['no-mtime', 'noMtime'],
    ['p', 'preserveOwner'],
    ['L', 'follow'],
    ['h', 'follow'],
  ]);
  PR.exports = (t) =>
    t
      ? Object.keys(t)
          .map((e) => [NR.has(e) ? NR.get(e) : e, t[e]])
          .reduce((e, i) => ((e[i[0]] = i[1]), e), Object.create(null))
      : {};
});
var Ap = P((GR) => {
  'use strict';
  var LR = typeof process == 'object' && process ? process : { stdout: null, stderr: null },
    aH = require('events'),
    DR = require('stream'),
    cH = require('string_decoder'),
    FR = cH.StringDecoder,
    ir = Symbol('EOF'),
    nr = Symbol('maybeEmitEnd'),
    zr = Symbol('emittedEnd'),
    Sp = Symbol('emittingEnd'),
    Jc = Symbol('emittedError'),
    Cp = Symbol('closed'),
    jR = Symbol('read'),
    Rp = Symbol('flush'),
    MR = Symbol('flushChunk'),
    Ri = Symbol('encoding'),
    rr = Symbol('decoder'),
    Tp = Symbol('flowing'),
    Zc = Symbol('paused'),
    ua = Symbol('resume'),
    Rt = Symbol('buffer'),
    Dn = Symbol('pipes'),
    Vt = Symbol('bufferLength'),
    Yg = Symbol('bufferPush'),
    Jg = Symbol('bufferShift'),
    ti = Symbol('objectMode'),
    Tt = Symbol('destroyed'),
    Zg = Symbol('error'),
    Qg = Symbol('emitData'),
    UR = Symbol('emitEnd'),
    ex = Symbol('emitEnd2'),
    sr = Symbol('async'),
    tx = Symbol('abort'),
    Op = Symbol('aborted'),
    Ys = Symbol('signal'),
    Qc = (t) => Promise.resolve().then(t),
    HR = global._MP_NO_ITERATOR_SYMBOLS_ !== '1',
    qR = (HR && Symbol.asyncIterator) || Symbol('asyncIterator not implemented'),
    BR = (HR && Symbol.iterator) || Symbol('iterator not implemented'),
    uH = (t) => t === 'end' || t === 'finish' || t === 'prefinish',
    lH = (t) =>
      t instanceof ArrayBuffer ||
      (typeof t == 'object' && t.constructor && t.constructor.name === 'ArrayBuffer' && t.byteLength >= 0),
    pH = (t) => !Buffer.isBuffer(t) && ArrayBuffer.isView(t),
    kp = class {
      constructor(e, i, n) {
        (this.src = e), (this.dest = i), (this.opts = n), (this.ondrain = () => e[ua]()), i.on('drain', this.ondrain);
      }
      unpipe() {
        this.dest.removeListener('drain', this.ondrain);
      }
      proxyErrors() {}
      end() {
        this.unpipe(), this.opts.end && this.dest.end();
      }
    },
    ix = class extends kp {
      unpipe() {
        this.src.removeListener('error', this.proxyErrors), super.unpipe();
      }
      constructor(e, i, n) {
        super(e, i, n), (this.proxyErrors = (r) => i.emit('error', r)), e.on('error', this.proxyErrors);
      }
    },
    nx = class t extends DR {
      constructor(e) {
        super(),
          (this[Tp] = !1),
          (this[Zc] = !1),
          (this[Dn] = []),
          (this[Rt] = []),
          (this[ti] = (e && e.objectMode) || !1),
          this[ti] ? (this[Ri] = null) : (this[Ri] = (e && e.encoding) || null),
          this[Ri] === 'buffer' && (this[Ri] = null),
          (this[sr] = (e && !!e.async) || !1),
          (this[rr] = this[Ri] ? new FR(this[Ri]) : null),
          (this[ir] = !1),
          (this[zr] = !1),
          (this[Sp] = !1),
          (this[Cp] = !1),
          (this[Jc] = null),
          (this.writable = !0),
          (this.readable = !0),
          (this[Vt] = 0),
          (this[Tt] = !1),
          e && e.debugExposeBuffer === !0 && Object.defineProperty(this, 'buffer', { get: () => this[Rt] }),
          e && e.debugExposePipes === !0 && Object.defineProperty(this, 'pipes', { get: () => this[Dn] }),
          (this[Ys] = e && e.signal),
          (this[Op] = !1),
          this[Ys] && (this[Ys].addEventListener('abort', () => this[tx]()), this[Ys].aborted && this[tx]());
      }
      get bufferLength() {
        return this[Vt];
      }
      get encoding() {
        return this[Ri];
      }
      set encoding(e) {
        if (this[ti]) throw new Error('cannot set encoding in objectMode');
        if (this[Ri] && e !== this[Ri] && ((this[rr] && this[rr].lastNeed) || this[Vt]))
          throw new Error('cannot change encoding');
        this[Ri] !== e &&
          ((this[rr] = e ? new FR(e) : null), this[Rt].length && (this[Rt] = this[Rt].map((i) => this[rr].write(i)))),
          (this[Ri] = e);
      }
      setEncoding(e) {
        this.encoding = e;
      }
      get objectMode() {
        return this[ti];
      }
      set objectMode(e) {
        this[ti] = this[ti] || !!e;
      }
      get async() {
        return this[sr];
      }
      set async(e) {
        this[sr] = this[sr] || !!e;
      }
      [tx]() {
        (this[Op] = !0), this.emit('abort', this[Ys].reason), this.destroy(this[Ys].reason);
      }
      get aborted() {
        return this[Op];
      }
      set aborted(e) {}
      write(e, i, n) {
        if (this[Op]) return !1;
        if (this[ir]) throw new Error('write after end');
        if (this[Tt])
          return (
            this.emit(
              'error',
              Object.assign(new Error('Cannot call write after a stream was destroyed'), {
                code: 'ERR_STREAM_DESTROYED',
              })
            ),
            !0
          );
        typeof i == 'function' && ((n = i), (i = 'utf8')), i || (i = 'utf8');
        let r = this[sr] ? Qc : (s) => s();
        return (
          !this[ti] &&
            !Buffer.isBuffer(e) &&
            (pH(e)
              ? (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength))
              : lH(e)
              ? (e = Buffer.from(e))
              : typeof e != 'string' && (this.objectMode = !0)),
          this[ti]
            ? (this.flowing && this[Vt] !== 0 && this[Rp](!0),
              this.flowing ? this.emit('data', e) : this[Yg](e),
              this[Vt] !== 0 && this.emit('readable'),
              n && r(n),
              this.flowing)
            : e.length
            ? (typeof e == 'string' && !(i === this[Ri] && !this[rr].lastNeed) && (e = Buffer.from(e, i)),
              Buffer.isBuffer(e) && this[Ri] && (e = this[rr].write(e)),
              this.flowing && this[Vt] !== 0 && this[Rp](!0),
              this.flowing ? this.emit('data', e) : this[Yg](e),
              this[Vt] !== 0 && this.emit('readable'),
              n && r(n),
              this.flowing)
            : (this[Vt] !== 0 && this.emit('readable'), n && r(n), this.flowing)
        );
      }
      read(e) {
        if (this[Tt]) return null;
        if (this[Vt] === 0 || e === 0 || e > this[Vt]) return this[nr](), null;
        this[ti] && (e = null),
          this[Rt].length > 1 &&
            !this[ti] &&
            (this.encoding ? (this[Rt] = [this[Rt].join('')]) : (this[Rt] = [Buffer.concat(this[Rt], this[Vt])]));
        let i = this[jR](e || null, this[Rt][0]);
        return this[nr](), i;
      }
      [jR](e, i) {
        return (
          e === i.length || e === null
            ? this[Jg]()
            : ((this[Rt][0] = i.slice(e)), (i = i.slice(0, e)), (this[Vt] -= e)),
          this.emit('data', i),
          !this[Rt].length && !this[ir] && this.emit('drain'),
          i
        );
      }
      end(e, i, n) {
        return (
          typeof e == 'function' && ((n = e), (e = null)),
          typeof i == 'function' && ((n = i), (i = 'utf8')),
          e && this.write(e, i),
          n && this.once('end', n),
          (this[ir] = !0),
          (this.writable = !1),
          (this.flowing || !this[Zc]) && this[nr](),
          this
        );
      }
      [ua]() {
        this[Tt] ||
          ((this[Zc] = !1),
          (this[Tp] = !0),
          this.emit('resume'),
          this[Rt].length ? this[Rp]() : this[ir] ? this[nr]() : this.emit('drain'));
      }
      resume() {
        return this[ua]();
      }
      pause() {
        (this[Tp] = !1), (this[Zc] = !0);
      }
      get destroyed() {
        return this[Tt];
      }
      get flowing() {
        return this[Tp];
      }
      get paused() {
        return this[Zc];
      }
      [Yg](e) {
        this[ti] ? (this[Vt] += 1) : (this[Vt] += e.length), this[Rt].push(e);
      }
      [Jg]() {
        return this[ti] ? (this[Vt] -= 1) : (this[Vt] -= this[Rt][0].length), this[Rt].shift();
      }
      [Rp](e) {
        do;
        while (this[MR](this[Jg]()) && this[Rt].length);
        !e && !this[Rt].length && !this[ir] && this.emit('drain');
      }
      [MR](e) {
        return this.emit('data', e), this.flowing;
      }
      pipe(e, i) {
        if (this[Tt]) return;
        let n = this[zr];
        return (
          (i = i || {}),
          e === LR.stdout || e === LR.stderr ? (i.end = !1) : (i.end = i.end !== !1),
          (i.proxyErrors = !!i.proxyErrors),
          n
            ? i.end && e.end()
            : (this[Dn].push(i.proxyErrors ? new ix(this, e, i) : new kp(this, e, i)),
              this[sr] ? Qc(() => this[ua]()) : this[ua]()),
          e
        );
      }
      unpipe(e) {
        let i = this[Dn].find((n) => n.dest === e);
        i && (this[Dn].splice(this[Dn].indexOf(i), 1), i.unpipe());
      }
      addListener(e, i) {
        return this.on(e, i);
      }
      on(e, i) {
        let n = super.on(e, i);
        return (
          e === 'data' && !this[Dn].length && !this.flowing
            ? this[ua]()
            : e === 'readable' && this[Vt] !== 0
            ? super.emit('readable')
            : uH(e) && this[zr]
            ? (super.emit(e), this.removeAllListeners(e))
            : e === 'error' && this[Jc] && (this[sr] ? Qc(() => i.call(this, this[Jc])) : i.call(this, this[Jc])),
          n
        );
      }
      get emittedEnd() {
        return this[zr];
      }
      [nr]() {
        !this[Sp] &&
          !this[zr] &&
          !this[Tt] &&
          this[Rt].length === 0 &&
          this[ir] &&
          ((this[Sp] = !0),
          this.emit('end'),
          this.emit('prefinish'),
          this.emit('finish'),
          this[Cp] && this.emit('close'),
          (this[Sp] = !1));
      }
      emit(e, i, ...n) {
        if (e !== 'error' && e !== 'close' && e !== Tt && this[Tt]) return;
        if (e === 'data') return !this[ti] && !i ? !1 : this[sr] ? Qc(() => this[Qg](i)) : this[Qg](i);
        if (e === 'end') return this[UR]();
        if (e === 'close') {
          if (((this[Cp] = !0), !this[zr] && !this[Tt])) return;
          let s = super.emit('close');
          return this.removeAllListeners('close'), s;
        } else if (e === 'error') {
          (this[Jc] = i), super.emit(Zg, i);
          let s = !this[Ys] || this.listeners('error').length ? super.emit('error', i) : !1;
          return this[nr](), s;
        } else if (e === 'resume') {
          let s = super.emit('resume');
          return this[nr](), s;
        } else if (e === 'finish' || e === 'prefinish') {
          let s = super.emit(e);
          return this.removeAllListeners(e), s;
        }
        let r = super.emit(e, i, ...n);
        return this[nr](), r;
      }
      [Qg](e) {
        for (let n of this[Dn]) n.dest.write(e) === !1 && this.pause();
        let i = super.emit('data', e);
        return this[nr](), i;
      }
      [UR]() {
        this[zr] || ((this[zr] = !0), (this.readable = !1), this[sr] ? Qc(() => this[ex]()) : this[ex]());
      }
      [ex]() {
        if (this[rr]) {
          let i = this[rr].end();
          if (i) {
            for (let n of this[Dn]) n.dest.write(i);
            super.emit('data', i);
          }
        }
        for (let i of this[Dn]) i.end();
        let e = super.emit('end');
        return this.removeAllListeners('end'), e;
      }
      collect() {
        let e = [];
        this[ti] || (e.dataLength = 0);
        let i = this.promise();
        return (
          this.on('data', (n) => {
            e.push(n), this[ti] || (e.dataLength += n.length);
          }),
          i.then(() => e)
        );
      }
      concat() {
        return this[ti]
          ? Promise.reject(new Error('cannot concat in objectMode'))
          : this.collect().then((e) =>
              this[ti]
                ? Promise.reject(new Error('cannot concat in objectMode'))
                : this[Ri]
                ? e.join('')
                : Buffer.concat(e, e.dataLength)
            );
      }
      promise() {
        return new Promise((e, i) => {
          this.on(Tt, () => i(new Error('stream destroyed'))), this.on('error', (n) => i(n)), this.on('end', () => e());
        });
      }
      [qR]() {
        let e = !1,
          i = () => (this.pause(), (e = !0), Promise.resolve({ done: !0 }));
        return {
          next: () => {
            if (e) return i();
            let r = this.read();
            if (r !== null) return Promise.resolve({ done: !1, value: r });
            if (this[ir]) return i();
            let s = null,
              o = null,
              c = (d) => {
                this.removeListener('data', u), this.removeListener('end', l), this.removeListener(Tt, p), i(), o(d);
              },
              u = (d) => {
                this.removeListener('error', c),
                  this.removeListener('end', l),
                  this.removeListener(Tt, p),
                  this.pause(),
                  s({ value: d, done: !!this[ir] });
              },
              l = () => {
                this.removeListener('error', c),
                  this.removeListener('data', u),
                  this.removeListener(Tt, p),
                  i(),
                  s({ done: !0 });
              },
              p = () => c(new Error('stream destroyed'));
            return new Promise((d, x) => {
              (o = x), (s = d), this.once(Tt, p), this.once('error', c), this.once('end', l), this.once('data', u);
            });
          },
          throw: i,
          return: i,
          [qR]() {
            return this;
          },
        };
      }
      [BR]() {
        let e = !1,
          i = () => (
            this.pause(),
            this.removeListener(Zg, i),
            this.removeListener(Tt, i),
            this.removeListener('end', i),
            (e = !0),
            { done: !0 }
          ),
          n = () => {
            if (e) return i();
            let r = this.read();
            return r === null ? i() : { value: r };
          };
        return (
          this.once('end', i),
          this.once(Zg, i),
          this.once(Tt, i),
          {
            next: n,
            throw: i,
            return: i,
            [BR]() {
              return this;
            },
          }
        );
      }
      destroy(e) {
        return this[Tt]
          ? (e ? this.emit('error', e) : this.emit(Tt), this)
          : ((this[Tt] = !0),
            (this[Rt].length = 0),
            (this[Vt] = 0),
            typeof this.close == 'function' && !this[Cp] && this.close(),
            e ? this.emit('error', e) : this.emit(Tt),
            this);
      }
      static isStream(e) {
        return (
          !!e &&
          (e instanceof t ||
            e instanceof DR ||
            (e instanceof aH &&
              (typeof e.pipe == 'function' || (typeof e.write == 'function' && typeof e.end == 'function'))))
        );
      }
    };
  GR.Minipass = nx;
});
var VR = P((Wre, zR) => {
  'use strict';
  var fH = require('zlib').constants || { ZLIB_VERNUM: 4736 };
  zR.exports = Object.freeze(
    Object.assign(
      Object.create(null),
      {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_VERSION_ERROR: -6,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        DEFLATE: 1,
        INFLATE: 2,
        GZIP: 3,
        GUNZIP: 4,
        DEFLATERAW: 5,
        INFLATERAW: 6,
        UNZIP: 7,
        BROTLI_DECODE: 8,
        BROTLI_ENCODE: 9,
        Z_MIN_WINDOWBITS: 8,
        Z_MAX_WINDOWBITS: 15,
        Z_DEFAULT_WINDOWBITS: 15,
        Z_MIN_CHUNK: 64,
        Z_MAX_CHUNK: 1 / 0,
        Z_DEFAULT_CHUNK: 16384,
        Z_MIN_MEMLEVEL: 1,
        Z_MAX_MEMLEVEL: 9,
        Z_DEFAULT_MEMLEVEL: 8,
        Z_MIN_LEVEL: -1,
        Z_MAX_LEVEL: 9,
        Z_DEFAULT_LEVEL: -1,
        BROTLI_OPERATION_PROCESS: 0,
        BROTLI_OPERATION_FLUSH: 1,
        BROTLI_OPERATION_FINISH: 2,
        BROTLI_OPERATION_EMIT_METADATA: 3,
        BROTLI_MODE_GENERIC: 0,
        BROTLI_MODE_TEXT: 1,
        BROTLI_MODE_FONT: 2,
        BROTLI_DEFAULT_MODE: 0,
        BROTLI_MIN_QUALITY: 0,
        BROTLI_MAX_QUALITY: 11,
        BROTLI_DEFAULT_QUALITY: 11,
        BROTLI_MIN_WINDOW_BITS: 10,
        BROTLI_MAX_WINDOW_BITS: 24,
        BROTLI_LARGE_MAX_WINDOW_BITS: 30,
        BROTLI_DEFAULT_WINDOW: 22,
        BROTLI_MIN_INPUT_BLOCK_BITS: 16,
        BROTLI_MAX_INPUT_BLOCK_BITS: 24,
        BROTLI_PARAM_MODE: 0,
        BROTLI_PARAM_QUALITY: 1,
        BROTLI_PARAM_LGWIN: 2,
        BROTLI_PARAM_LGBLOCK: 3,
        BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
        BROTLI_PARAM_SIZE_HINT: 5,
        BROTLI_PARAM_LARGE_WINDOW: 6,
        BROTLI_PARAM_NPOSTFIX: 7,
        BROTLI_PARAM_NDIRECT: 8,
        BROTLI_DECODER_RESULT_ERROR: 0,
        BROTLI_DECODER_RESULT_SUCCESS: 1,
        BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
        BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
        BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
        BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
        BROTLI_DECODER_NO_ERROR: 0,
        BROTLI_DECODER_SUCCESS: 1,
        BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
        BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
        BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
        BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
        BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
        BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
        BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
        BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
        BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
        BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
        BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
        BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
        BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
        BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
        BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
        BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
        BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
        BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
        BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
        BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
        BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
        BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
        BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
        BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
        BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
        BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
        BROTLI_DECODER_ERROR_UNREACHABLE: -31,
      },
      fH
    )
  );
});
var tT = P((Kre, eT) => {
  'use strict';
  var $R = typeof process == 'object' && process ? process : { stdout: null, stderr: null },
    dH = require('events'),
    WR = require('stream'),
    KR = require('string_decoder').StringDecoder,
    or = Symbol('EOF'),
    ar = Symbol('maybeEmitEnd'),
    Vr = Symbol('emittedEnd'),
    Ip = Symbol('emittingEnd'),
    eu = Symbol('emittedError'),
    Np = Symbol('closed'),
    XR = Symbol('read'),
    Pp = Symbol('flush'),
    YR = Symbol('flushChunk'),
    Ti = Symbol('encoding'),
    cr = Symbol('decoder'),
    Lp = Symbol('flowing'),
    tu = Symbol('paused'),
    la = Symbol('resume'),
    $t = Symbol('bufferLength'),
    rx = Symbol('bufferPush'),
    sx = Symbol('bufferShift'),
    ai = Symbol('objectMode'),
    ci = Symbol('destroyed'),
    ox = Symbol('emitData'),
    JR = Symbol('emitEnd'),
    ax = Symbol('emitEnd2'),
    ur = Symbol('async'),
    iu = (t) => Promise.resolve().then(t),
    ZR = global._MP_NO_ITERATOR_SYMBOLS_ !== '1',
    hH = (ZR && Symbol.asyncIterator) || Symbol('asyncIterator not implemented'),
    mH = (ZR && Symbol.iterator) || Symbol('iterator not implemented'),
    gH = (t) => t === 'end' || t === 'finish' || t === 'prefinish',
    xH = (t) =>
      t instanceof ArrayBuffer ||
      (typeof t == 'object' && t.constructor && t.constructor.name === 'ArrayBuffer' && t.byteLength >= 0),
    yH = (t) => !Buffer.isBuffer(t) && ArrayBuffer.isView(t),
    Dp = class {
      constructor(e, i, n) {
        (this.src = e), (this.dest = i), (this.opts = n), (this.ondrain = () => e[la]()), i.on('drain', this.ondrain);
      }
      unpipe() {
        this.dest.removeListener('drain', this.ondrain);
      }
      proxyErrors() {}
      end() {
        this.unpipe(), this.opts.end && this.dest.end();
      }
    },
    cx = class extends Dp {
      unpipe() {
        this.src.removeListener('error', this.proxyErrors), super.unpipe();
      }
      constructor(e, i, n) {
        super(e, i, n), (this.proxyErrors = (r) => i.emit('error', r)), e.on('error', this.proxyErrors);
      }
    };
  eT.exports = class QR extends WR {
    constructor(e) {
      super(),
        (this[Lp] = !1),
        (this[tu] = !1),
        (this.pipes = []),
        (this.buffer = []),
        (this[ai] = (e && e.objectMode) || !1),
        this[ai] ? (this[Ti] = null) : (this[Ti] = (e && e.encoding) || null),
        this[Ti] === 'buffer' && (this[Ti] = null),
        (this[ur] = (e && !!e.async) || !1),
        (this[cr] = this[Ti] ? new KR(this[Ti]) : null),
        (this[or] = !1),
        (this[Vr] = !1),
        (this[Ip] = !1),
        (this[Np] = !1),
        (this[eu] = null),
        (this.writable = !0),
        (this.readable = !0),
        (this[$t] = 0),
        (this[ci] = !1);
    }
    get bufferLength() {
      return this[$t];
    }
    get encoding() {
      return this[Ti];
    }
    set encoding(e) {
      if (this[ai]) throw new Error('cannot set encoding in objectMode');
      if (this[Ti] && e !== this[Ti] && ((this[cr] && this[cr].lastNeed) || this[$t]))
        throw new Error('cannot change encoding');
      this[Ti] !== e &&
        ((this[cr] = e ? new KR(e) : null),
        this.buffer.length && (this.buffer = this.buffer.map((i) => this[cr].write(i)))),
        (this[Ti] = e);
    }
    setEncoding(e) {
      this.encoding = e;
    }
    get objectMode() {
      return this[ai];
    }
    set objectMode(e) {
      this[ai] = this[ai] || !!e;
    }
    get async() {
      return this[ur];
    }
    set async(e) {
      this[ur] = this[ur] || !!e;
    }
    write(e, i, n) {
      if (this[or]) throw new Error('write after end');
      if (this[ci])
        return (
          this.emit(
            'error',
            Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' })
          ),
          !0
        );
      typeof i == 'function' && ((n = i), (i = 'utf8')), i || (i = 'utf8');
      let r = this[ur] ? iu : (s) => s();
      return (
        !this[ai] &&
          !Buffer.isBuffer(e) &&
          (yH(e)
            ? (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength))
            : xH(e)
            ? (e = Buffer.from(e))
            : typeof e != 'string' && (this.objectMode = !0)),
        this[ai]
          ? (this.flowing && this[$t] !== 0 && this[Pp](!0),
            this.flowing ? this.emit('data', e) : this[rx](e),
            this[$t] !== 0 && this.emit('readable'),
            n && r(n),
            this.flowing)
          : e.length
          ? (typeof e == 'string' && !(i === this[Ti] && !this[cr].lastNeed) && (e = Buffer.from(e, i)),
            Buffer.isBuffer(e) && this[Ti] && (e = this[cr].write(e)),
            this.flowing && this[$t] !== 0 && this[Pp](!0),
            this.flowing ? this.emit('data', e) : this[rx](e),
            this[$t] !== 0 && this.emit('readable'),
            n && r(n),
            this.flowing)
          : (this[$t] !== 0 && this.emit('readable'), n && r(n), this.flowing)
      );
    }
    read(e) {
      if (this[ci]) return null;
      if (this[$t] === 0 || e === 0 || e > this[$t]) return this[ar](), null;
      this[ai] && (e = null),
        this.buffer.length > 1 &&
          !this[ai] &&
          (this.encoding
            ? (this.buffer = [this.buffer.join('')])
            : (this.buffer = [Buffer.concat(this.buffer, this[$t])]));
      let i = this[XR](e || null, this.buffer[0]);
      return this[ar](), i;
    }
    [XR](e, i) {
      return (
        e === i.length || e === null
          ? this[sx]()
          : ((this.buffer[0] = i.slice(e)), (i = i.slice(0, e)), (this[$t] -= e)),
        this.emit('data', i),
        !this.buffer.length && !this[or] && this.emit('drain'),
        i
      );
    }
    end(e, i, n) {
      return (
        typeof e == 'function' && ((n = e), (e = null)),
        typeof i == 'function' && ((n = i), (i = 'utf8')),
        e && this.write(e, i),
        n && this.once('end', n),
        (this[or] = !0),
        (this.writable = !1),
        (this.flowing || !this[tu]) && this[ar](),
        this
      );
    }
    [la]() {
      this[ci] ||
        ((this[tu] = !1),
        (this[Lp] = !0),
        this.emit('resume'),
        this.buffer.length ? this[Pp]() : this[or] ? this[ar]() : this.emit('drain'));
    }
    resume() {
      return this[la]();
    }
    pause() {
      (this[Lp] = !1), (this[tu] = !0);
    }
    get destroyed() {
      return this[ci];
    }
    get flowing() {
      return this[Lp];
    }
    get paused() {
      return this[tu];
    }
    [rx](e) {
      this[ai] ? (this[$t] += 1) : (this[$t] += e.length), this.buffer.push(e);
    }
    [sx]() {
      return (
        this.buffer.length && (this[ai] ? (this[$t] -= 1) : (this[$t] -= this.buffer[0].length)), this.buffer.shift()
      );
    }
    [Pp](e) {
      do;
      while (this[YR](this[sx]()));
      !e && !this.buffer.length && !this[or] && this.emit('drain');
    }
    [YR](e) {
      return e ? (this.emit('data', e), this.flowing) : !1;
    }
    pipe(e, i) {
      if (this[ci]) return;
      let n = this[Vr];
      return (
        (i = i || {}),
        e === $R.stdout || e === $R.stderr ? (i.end = !1) : (i.end = i.end !== !1),
        (i.proxyErrors = !!i.proxyErrors),
        n
          ? i.end && e.end()
          : (this.pipes.push(i.proxyErrors ? new cx(this, e, i) : new Dp(this, e, i)),
            this[ur] ? iu(() => this[la]()) : this[la]()),
        e
      );
    }
    unpipe(e) {
      let i = this.pipes.find((n) => n.dest === e);
      i && (this.pipes.splice(this.pipes.indexOf(i), 1), i.unpipe());
    }
    addListener(e, i) {
      return this.on(e, i);
    }
    on(e, i) {
      let n = super.on(e, i);
      return (
        e === 'data' && !this.pipes.length && !this.flowing
          ? this[la]()
          : e === 'readable' && this[$t] !== 0
          ? super.emit('readable')
          : gH(e) && this[Vr]
          ? (super.emit(e), this.removeAllListeners(e))
          : e === 'error' && this[eu] && (this[ur] ? iu(() => i.call(this, this[eu])) : i.call(this, this[eu])),
        n
      );
    }
    get emittedEnd() {
      return this[Vr];
    }
    [ar]() {
      !this[Ip] &&
        !this[Vr] &&
        !this[ci] &&
        this.buffer.length === 0 &&
        this[or] &&
        ((this[Ip] = !0),
        this.emit('end'),
        this.emit('prefinish'),
        this.emit('finish'),
        this[Np] && this.emit('close'),
        (this[Ip] = !1));
    }
    emit(e, i, ...n) {
      if (e !== 'error' && e !== 'close' && e !== ci && this[ci]) return;
      if (e === 'data') return i ? (this[ur] ? iu(() => this[ox](i)) : this[ox](i)) : !1;
      if (e === 'end') return this[JR]();
      if (e === 'close') {
        if (((this[Np] = !0), !this[Vr] && !this[ci])) return;
        let s = super.emit('close');
        return this.removeAllListeners('close'), s;
      } else if (e === 'error') {
        this[eu] = i;
        let s = super.emit('error', i);
        return this[ar](), s;
      } else if (e === 'resume') {
        let s = super.emit('resume');
        return this[ar](), s;
      } else if (e === 'finish' || e === 'prefinish') {
        let s = super.emit(e);
        return this.removeAllListeners(e), s;
      }
      let r = super.emit(e, i, ...n);
      return this[ar](), r;
    }
    [ox](e) {
      for (let n of this.pipes) n.dest.write(e) === !1 && this.pause();
      let i = super.emit('data', e);
      return this[ar](), i;
    }
    [JR]() {
      this[Vr] || ((this[Vr] = !0), (this.readable = !1), this[ur] ? iu(() => this[ax]()) : this[ax]());
    }
    [ax]() {
      if (this[cr]) {
        let i = this[cr].end();
        if (i) {
          for (let n of this.pipes) n.dest.write(i);
          super.emit('data', i);
        }
      }
      for (let i of this.pipes) i.end();
      let e = super.emit('end');
      return this.removeAllListeners('end'), e;
    }
    collect() {
      let e = [];
      this[ai] || (e.dataLength = 0);
      let i = this.promise();
      return (
        this.on('data', (n) => {
          e.push(n), this[ai] || (e.dataLength += n.length);
        }),
        i.then(() => e)
      );
    }
    concat() {
      return this[ai]
        ? Promise.reject(new Error('cannot concat in objectMode'))
        : this.collect().then((e) =>
            this[ai]
              ? Promise.reject(new Error('cannot concat in objectMode'))
              : this[Ti]
              ? e.join('')
              : Buffer.concat(e, e.dataLength)
          );
    }
    promise() {
      return new Promise((e, i) => {
        this.on(ci, () => i(new Error('stream destroyed'))), this.on('error', (n) => i(n)), this.on('end', () => e());
      });
    }
    [hH]() {
      return {
        next: () => {
          let i = this.read();
          if (i !== null) return Promise.resolve({ done: !1, value: i });
          if (this[or]) return Promise.resolve({ done: !0 });
          let n = null,
            r = null,
            s = (l) => {
              this.removeListener('data', o), this.removeListener('end', c), r(l);
            },
            o = (l) => {
              this.removeListener('error', s),
                this.removeListener('end', c),
                this.pause(),
                n({ value: l, done: !!this[or] });
            },
            c = () => {
              this.removeListener('error', s), this.removeListener('data', o), n({ done: !0 });
            },
            u = () => s(new Error('stream destroyed'));
          return new Promise((l, p) => {
            (r = p), (n = l), this.once(ci, u), this.once('error', s), this.once('end', c), this.once('data', o);
          });
        },
      };
    }
    [mH]() {
      return {
        next: () => {
          let i = this.read();
          return { value: i, done: i === null };
        },
      };
    }
    destroy(e) {
      return this[ci]
        ? (e ? this.emit('error', e) : this.emit(ci), this)
        : ((this[ci] = !0),
          (this.buffer.length = 0),
          (this[$t] = 0),
          typeof this.close == 'function' && !this[Np] && this.close(),
          e ? this.emit('error', e) : this.emit(ci),
          this);
    }
    static isStream(e) {
      return (
        !!e &&
        (e instanceof QR ||
          e instanceof WR ||
          (e instanceof dH &&
            (typeof e.pipe == 'function' || (typeof e.write == 'function' && typeof e.end == 'function'))))
      );
    }
  };
});
var Sx = P((Bi) => {
  'use strict';
  var dx = require('assert'),
    $r = require('buffer').Buffer,
    rT = require('zlib'),
    Js = (Bi.constants = VR()),
    bH = tT(),
    iT = $r.concat,
    Zs = Symbol('_superWrite'),
    fa = class extends Error {
      constructor(e) {
        super('zlib: ' + e.message),
          (this.code = e.code),
          (this.errno = e.errno),
          this.code || (this.code = 'ZLIB_ERROR'),
          (this.message = 'zlib: ' + e.message),
          Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return 'ZlibError';
      }
    },
    vH = Symbol('opts'),
    nu = Symbol('flushFlag'),
    nT = Symbol('finishFlushFlag'),
    _x = Symbol('fullFlushFlag'),
    ot = Symbol('handle'),
    Fp = Symbol('onError'),
    pa = Symbol('sawError'),
    ux = Symbol('level'),
    lx = Symbol('strategy'),
    px = Symbol('ended'),
    Xre = Symbol('_defaultFullFlush'),
    jp = class extends bH {
      constructor(e, i) {
        if (!e || typeof e != 'object') throw new TypeError('invalid options for ZlibBase constructor');
        super(e), (this[pa] = !1), (this[px] = !1), (this[vH] = e), (this[nu] = e.flush), (this[nT] = e.finishFlush);
        try {
          this[ot] = new rT[i](e);
        } catch (n) {
          throw new fa(n);
        }
        (this[Fp] = (n) => {
          this[pa] || ((this[pa] = !0), this.close(), this.emit('error', n));
        }),
          this[ot].on('error', (n) => this[Fp](new fa(n))),
          this.once('end', () => this.close);
      }
      close() {
        this[ot] && (this[ot].close(), (this[ot] = null), this.emit('close'));
      }
      reset() {
        if (!this[pa]) return dx(this[ot], 'zlib binding closed'), this[ot].reset();
      }
      flush(e) {
        this.ended || (typeof e != 'number' && (e = this[_x]), this.write(Object.assign($r.alloc(0), { [nu]: e })));
      }
      end(e, i, n) {
        return e && this.write(e, i), this.flush(this[nT]), (this[px] = !0), super.end(null, null, n);
      }
      get ended() {
        return this[px];
      }
      write(e, i, n) {
        if ((typeof i == 'function' && ((n = i), (i = 'utf8')), typeof e == 'string' && (e = $r.from(e, i)), this[pa]))
          return;
        dx(this[ot], 'zlib binding closed');
        let r = this[ot]._handle,
          s = r.close;
        r.close = () => {};
        let o = this[ot].close;
        (this[ot].close = () => {}), ($r.concat = (l) => l);
        let c;
        try {
          let l = typeof e[nu] == 'number' ? e[nu] : this[nu];
          (c = this[ot]._processChunk(e, l)), ($r.concat = iT);
        } catch (l) {
          ($r.concat = iT), this[Fp](new fa(l));
        } finally {
          this[ot] &&
            ((this[ot]._handle = r), (r.close = s), (this[ot].close = o), this[ot].removeAllListeners('error'));
        }
        this[ot] && this[ot].on('error', (l) => this[Fp](new fa(l)));
        let u;
        if (c)
          if (Array.isArray(c) && c.length > 0) {
            u = this[Zs]($r.from(c[0]));
            for (let l = 1; l < c.length; l++) u = this[Zs](c[l]);
          } else u = this[Zs]($r.from(c));
        return n && n(), u;
      }
      [Zs](e) {
        return super.write(e);
      }
    },
    lr = class extends jp {
      constructor(e, i) {
        (e = e || {}),
          (e.flush = e.flush || Js.Z_NO_FLUSH),
          (e.finishFlush = e.finishFlush || Js.Z_FINISH),
          super(e, i),
          (this[_x] = Js.Z_FULL_FLUSH),
          (this[ux] = e.level),
          (this[lx] = e.strategy);
      }
      params(e, i) {
        if (!this[pa]) {
          if (!this[ot]) throw new Error('cannot switch params when binding is closed');
          if (!this[ot].params) throw new Error('not supported in this implementation');
          if (this[ux] !== e || this[lx] !== i) {
            this.flush(Js.Z_SYNC_FLUSH), dx(this[ot], 'zlib binding closed');
            let n = this[ot].flush;
            this[ot].flush = (r, s) => {
              this.flush(r), s();
            };
            try {
              this[ot].params(e, i);
            } finally {
              this[ot].flush = n;
            }
            this[ot] && ((this[ux] = e), (this[lx] = i));
          }
        }
      }
    },
    hx = class extends lr {
      constructor(e) {
        super(e, 'Deflate');
      }
    },
    mx = class extends lr {
      constructor(e) {
        super(e, 'Inflate');
      }
    },
    fx = Symbol('_portable'),
    gx = class extends lr {
      constructor(e) {
        super(e, 'Gzip'), (this[fx] = e && !!e.portable);
      }
      [Zs](e) {
        return this[fx] ? ((this[fx] = !1), (e[9] = 255), super[Zs](e)) : super[Zs](e);
      }
    },
    xx = class extends lr {
      constructor(e) {
        super(e, 'Gunzip');
      }
    },
    yx = class extends lr {
      constructor(e) {
        super(e, 'DeflateRaw');
      }
    },
    bx = class extends lr {
      constructor(e) {
        super(e, 'InflateRaw');
      }
    },
    vx = class extends lr {
      constructor(e) {
        super(e, 'Unzip');
      }
    },
    Mp = class extends jp {
      constructor(e, i) {
        (e = e || {}),
          (e.flush = e.flush || Js.BROTLI_OPERATION_PROCESS),
          (e.finishFlush = e.finishFlush || Js.BROTLI_OPERATION_FINISH),
          super(e, i),
          (this[_x] = Js.BROTLI_OPERATION_FLUSH);
      }
    },
    wx = class extends Mp {
      constructor(e) {
        super(e, 'BrotliCompress');
      }
    },
    Ex = class extends Mp {
      constructor(e) {
        super(e, 'BrotliDecompress');
      }
    };
  Bi.Deflate = hx;
  Bi.Inflate = mx;
  Bi.Gzip = gx;
  Bi.Gunzip = xx;
  Bi.DeflateRaw = yx;
  Bi.InflateRaw = bx;
  Bi.Unzip = vx;
  typeof rT.BrotliCompress == 'function'
    ? ((Bi.BrotliCompress = wx), (Bi.BrotliDecompress = Ex))
    : (Bi.BrotliCompress = Bi.BrotliDecompress =
        class {
          constructor() {
            throw new Error('Brotli is not supported in this version of Node.js');
          }
        });
});
var da = P((Zre, sT) => {
  'use strict';
  var wH = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
  sT.exports = wH !== 'win32' ? (t) => t : (t) => t && t.replace(/\\/g, '/');
});
var Up = P((ese, oT) => {
  'use strict';
  var { Minipass: EH } = Ap(),
    Cx = da(),
    Rx = Symbol('slurp');
  oT.exports = class extends EH {
    constructor(e, i, n) {
      switch (
        (super(),
        this.pause(),
        (this.extended = i),
        (this.globalExtended = n),
        (this.header = e),
        (this.startBlockSize = 512 * Math.ceil(e.size / 512)),
        (this.blockRemain = this.startBlockSize),
        (this.remain = e.size),
        (this.type = e.type),
        (this.meta = !1),
        (this.ignore = !1),
        this.type)
      ) {
        case 'File':
        case 'OldFile':
        case 'Link':
        case 'SymbolicLink':
        case 'CharacterDevice':
        case 'BlockDevice':
        case 'Directory':
        case 'FIFO':
        case 'ContiguousFile':
        case 'GNUDumpDir':
          break;
        case 'NextFileHasLongLinkpath':
        case 'NextFileHasLongPath':
        case 'OldGnuLongPath':
        case 'GlobalExtendedHeader':
        case 'ExtendedHeader':
        case 'OldExtendedHeader':
          this.meta = !0;
          break;
        default:
          this.ignore = !0;
      }
      (this.path = Cx(e.path)),
        (this.mode = e.mode),
        this.mode && (this.mode = this.mode & 4095),
        (this.uid = e.uid),
        (this.gid = e.gid),
        (this.uname = e.uname),
        (this.gname = e.gname),
        (this.size = e.size),
        (this.mtime = e.mtime),
        (this.atime = e.atime),
        (this.ctime = e.ctime),
        (this.linkpath = Cx(e.linkpath)),
        (this.uname = e.uname),
        (this.gname = e.gname),
        i && this[Rx](i),
        n && this[Rx](n, !0);
    }
    write(e) {
      let i = e.length;
      if (i > this.blockRemain) throw new Error('writing more to entry than is appropriate');
      let n = this.remain,
        r = this.blockRemain;
      return (
        (this.remain = Math.max(0, n - i)),
        (this.blockRemain = Math.max(0, r - i)),
        this.ignore ? !0 : n >= i ? super.write(e) : super.write(e.slice(0, n))
      );
    }
    [Rx](e, i) {
      for (let n in e)
        e[n] !== null &&
          e[n] !== void 0 &&
          !(i && n === 'path') &&
          (this[n] = n === 'path' || n === 'linkpath' ? Cx(e[n]) : e[n]);
    }
  };
});
var Tx = P((qp) => {
  'use strict';
  qp.name = new Map([
    ['0', 'File'],
    ['', 'OldFile'],
    ['1', 'Link'],
    ['2', 'SymbolicLink'],
    ['3', 'CharacterDevice'],
    ['4', 'BlockDevice'],
    ['5', 'Directory'],
    ['6', 'FIFO'],
    ['7', 'ContiguousFile'],
    ['g', 'GlobalExtendedHeader'],
    ['x', 'ExtendedHeader'],
    ['A', 'SolarisACL'],
    ['D', 'GNUDumpDir'],
    ['I', 'Inode'],
    ['K', 'NextFileHasLongLinkpath'],
    ['L', 'NextFileHasLongPath'],
    ['M', 'ContinuationFile'],
    ['N', 'OldGnuLongPath'],
    ['S', 'SparseFile'],
    ['V', 'TapeVolumeHeader'],
    ['X', 'OldExtendedHeader'],
  ]);
  qp.code = new Map(Array.from(qp.name).map((t) => [t[1], t[0]]));
});
var lT = P((ise, uT) => {
  'use strict';
  var _H = (t, e) => {
      if (Number.isSafeInteger(t)) t < 0 ? CH(t, e) : SH(t, e);
      else throw Error('cannot encode number outside of javascript safe integer range');
      return e;
    },
    SH = (t, e) => {
      e[0] = 128;
      for (var i = e.length; i > 1; i--) (e[i - 1] = t & 255), (t = Math.floor(t / 256));
    },
    CH = (t, e) => {
      e[0] = 255;
      var i = !1;
      t = t * -1;
      for (var n = e.length; n > 1; n--) {
        var r = t & 255;
        (t = Math.floor(t / 256)), i ? (e[n - 1] = aT(r)) : r === 0 ? (e[n - 1] = 0) : ((i = !0), (e[n - 1] = cT(r)));
      }
    },
    RH = (t) => {
      let e = t[0],
        i = e === 128 ? OH(t.slice(1, t.length)) : e === 255 ? TH(t) : null;
      if (i === null) throw Error('invalid base256 encoding');
      if (!Number.isSafeInteger(i)) throw Error('parsed number outside of javascript safe integer range');
      return i;
    },
    TH = (t) => {
      for (var e = t.length, i = 0, n = !1, r = e - 1; r > -1; r--) {
        var s = t[r],
          o;
        n ? (o = aT(s)) : s === 0 ? (o = s) : ((n = !0), (o = cT(s))), o !== 0 && (i -= o * Math.pow(256, e - r - 1));
      }
      return i;
    },
    OH = (t) => {
      for (var e = t.length, i = 0, n = e - 1; n > -1; n--) {
        var r = t[n];
        r !== 0 && (i += r * Math.pow(256, e - n - 1));
      }
      return i;
    },
    aT = (t) => (255 ^ t) & 255,
    cT = (t) => ((255 ^ t) + 1) & 255;
  uT.exports = { encode: _H, parse: RH };
});
var ma = P((nse, fT) => {
  'use strict';
  var Ox = Tx(),
    ha = require('path').posix,
    pT = lT(),
    kx = Symbol('slurp'),
    Hi = Symbol('type'),
    Nx = class {
      constructor(e, i, n, r) {
        (this.cksumValid = !1),
          (this.needPax = !1),
          (this.nullBlock = !1),
          (this.block = null),
          (this.path = null),
          (this.mode = null),
          (this.uid = null),
          (this.gid = null),
          (this.size = null),
          (this.mtime = null),
          (this.cksum = null),
          (this[Hi] = '0'),
          (this.linkpath = null),
          (this.uname = null),
          (this.gname = null),
          (this.devmaj = 0),
          (this.devmin = 0),
          (this.atime = null),
          (this.ctime = null),
          Buffer.isBuffer(e) ? this.decode(e, i || 0, n, r) : e && this.set(e);
      }
      decode(e, i, n, r) {
        if ((i || (i = 0), !e || !(e.length >= i + 512))) throw new Error('need 512 bytes for header');
        if (
          ((this.path = Qs(e, i, 100)),
          (this.mode = Wr(e, i + 100, 8)),
          (this.uid = Wr(e, i + 108, 8)),
          (this.gid = Wr(e, i + 116, 8)),
          (this.size = Wr(e, i + 124, 12)),
          (this.mtime = Ax(e, i + 136, 12)),
          (this.cksum = Wr(e, i + 148, 12)),
          this[kx](n),
          this[kx](r, !0),
          (this[Hi] = Qs(e, i + 156, 1)),
          this[Hi] === '' && (this[Hi] = '0'),
          this[Hi] === '0' && this.path.slice(-1) === '/' && (this[Hi] = '5'),
          this[Hi] === '5' && (this.size = 0),
          (this.linkpath = Qs(e, i + 157, 100)),
          e.slice(i + 257, i + 265).toString() === 'ustar\x0000')
        )
          if (
            ((this.uname = Qs(e, i + 265, 32)),
            (this.gname = Qs(e, i + 297, 32)),
            (this.devmaj = Wr(e, i + 329, 8)),
            (this.devmin = Wr(e, i + 337, 8)),
            e[i + 475] !== 0)
          ) {
            let o = Qs(e, i + 345, 155);
            this.path = o + '/' + this.path;
          } else {
            let o = Qs(e, i + 345, 130);
            o && (this.path = o + '/' + this.path),
              (this.atime = Ax(e, i + 476, 12)),
              (this.ctime = Ax(e, i + 488, 12));
          }
        let s = 8 * 32;
        for (let o = i; o < i + 148; o++) s += e[o];
        for (let o = i + 156; o < i + 512; o++) s += e[o];
        (this.cksumValid = s === this.cksum), this.cksum === null && s === 8 * 32 && (this.nullBlock = !0);
      }
      [kx](e, i) {
        for (let n in e) e[n] !== null && e[n] !== void 0 && !(i && n === 'path') && (this[n] = e[n]);
      }
      encode(e, i) {
        if ((e || ((e = this.block = Buffer.alloc(512)), (i = 0)), i || (i = 0), !(e.length >= i + 512)))
          throw new Error('need 512 bytes for header');
        let n = this.ctime || this.atime ? 130 : 155,
          r = kH(this.path || '', n),
          s = r[0],
          o = r[1];
        (this.needPax = r[2]),
          (this.needPax = eo(e, i, 100, s) || this.needPax),
          (this.needPax = Kr(e, i + 100, 8, this.mode) || this.needPax),
          (this.needPax = Kr(e, i + 108, 8, this.uid) || this.needPax),
          (this.needPax = Kr(e, i + 116, 8, this.gid) || this.needPax),
          (this.needPax = Kr(e, i + 124, 12, this.size) || this.needPax),
          (this.needPax = Ix(e, i + 136, 12, this.mtime) || this.needPax),
          (e[i + 156] = this[Hi].charCodeAt(0)),
          (this.needPax = eo(e, i + 157, 100, this.linkpath) || this.needPax),
          e.write('ustar\x0000', i + 257, 8),
          (this.needPax = eo(e, i + 265, 32, this.uname) || this.needPax),
          (this.needPax = eo(e, i + 297, 32, this.gname) || this.needPax),
          (this.needPax = Kr(e, i + 329, 8, this.devmaj) || this.needPax),
          (this.needPax = Kr(e, i + 337, 8, this.devmin) || this.needPax),
          (this.needPax = eo(e, i + 345, n, o) || this.needPax),
          e[i + 475] !== 0
            ? (this.needPax = eo(e, i + 345, 155, o) || this.needPax)
            : ((this.needPax = eo(e, i + 345, 130, o) || this.needPax),
              (this.needPax = Ix(e, i + 476, 12, this.atime) || this.needPax),
              (this.needPax = Ix(e, i + 488, 12, this.ctime) || this.needPax));
        let c = 8 * 32;
        for (let u = i; u < i + 148; u++) c += e[u];
        for (let u = i + 156; u < i + 512; u++) c += e[u];
        return (this.cksum = c), Kr(e, i + 148, 8, this.cksum), (this.cksumValid = !0), this.needPax;
      }
      set(e) {
        for (let i in e) e[i] !== null && e[i] !== void 0 && (this[i] = e[i]);
      }
      get type() {
        return Ox.name.get(this[Hi]) || this[Hi];
      }
      get typeKey() {
        return this[Hi];
      }
      set type(e) {
        Ox.code.has(e) ? (this[Hi] = Ox.code.get(e)) : (this[Hi] = e);
      }
    },
    kH = (t, e) => {
      let n = t,
        r = '',
        s,
        o = ha.parse(t).root || '.';
      if (Buffer.byteLength(n) < 100) s = [n, r, !1];
      else {
        (r = ha.dirname(n)), (n = ha.basename(n));
        do
          Buffer.byteLength(n) <= 100 && Buffer.byteLength(r) <= e
            ? (s = [n, r, !1])
            : Buffer.byteLength(n) > 100 && Buffer.byteLength(r) <= e
            ? (s = [n.slice(0, 99), r, !0])
            : ((n = ha.join(ha.basename(r), n)), (r = ha.dirname(r)));
        while (r !== o && !s);
        s || (s = [t.slice(0, 99), '', !0]);
      }
      return s;
    },
    Qs = (t, e, i) =>
      t
        .slice(e, e + i)
        .toString('utf8')
        .replace(/\0.*/, ''),
    Ax = (t, e, i) => AH(Wr(t, e, i)),
    AH = (t) => (t === null ? null : new Date(t * 1e3)),
    Wr = (t, e, i) => (t[e] & 128 ? pT.parse(t.slice(e, e + i)) : NH(t, e, i)),
    IH = (t) => (isNaN(t) ? null : t),
    NH = (t, e, i) =>
      IH(
        parseInt(
          t
            .slice(e, e + i)
            .toString('utf8')
            .replace(/\0.*$/, '')
            .trim(),
          8
        )
      ),
    PH = { 12: 8589934591, 8: 2097151 },
    Kr = (t, e, i, n) =>
      n === null ? !1 : n > PH[i] || n < 0 ? (pT.encode(n, t.slice(e, e + i)), !0) : (LH(t, e, i, n), !1),
    LH = (t, e, i, n) => t.write(DH(n, i), e, i, 'ascii'),
    DH = (t, e) => FH(Math.floor(t).toString(8), e),
    FH = (t, e) => (t.length === e - 1 ? t : new Array(e - t.length - 1).join('0') + t + ' ') + '\0',
    Ix = (t, e, i, n) => (n === null ? !1 : Kr(t, e, i, n.getTime() / 1e3)),
    jH = new Array(156).join('\0'),
    eo = (t, e, i, n) =>
      n === null ? !1 : (t.write(n + jH, e, i, 'utf8'), n.length !== Buffer.byteLength(n) || n.length > i);
  fT.exports = Nx;
});
var Bp = P((rse, dT) => {
  'use strict';
  var MH = ma(),
    UH = require('path'),
    ru = class {
      constructor(e, i) {
        (this.atime = e.atime || null),
          (this.charset = e.charset || null),
          (this.comment = e.comment || null),
          (this.ctime = e.ctime || null),
          (this.gid = e.gid || null),
          (this.gname = e.gname || null),
          (this.linkpath = e.linkpath || null),
          (this.mtime = e.mtime || null),
          (this.path = e.path || null),
          (this.size = e.size || null),
          (this.uid = e.uid || null),
          (this.uname = e.uname || null),
          (this.dev = e.dev || null),
          (this.ino = e.ino || null),
          (this.nlink = e.nlink || null),
          (this.global = i || !1);
      }
      encode() {
        let e = this.encodeBody();
        if (e === '') return null;
        let i = Buffer.byteLength(e),
          n = 512 * Math.ceil(1 + i / 512),
          r = Buffer.allocUnsafe(n);
        for (let s = 0; s < 512; s++) r[s] = 0;
        new MH({
          path: ('PaxHeader/' + UH.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: i,
          mtime: this.mtime || null,
          type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',
          linkpath: '',
          uname: this.uname || '',
          gname: this.gname || '',
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null,
        }).encode(r),
          r.write(e, 512, i, 'utf8');
        for (let s = i + 512; s < r.length; s++) r[s] = 0;
        return r;
      }
      encodeBody() {
        return (
          this.encodeField('path') +
          this.encodeField('ctime') +
          this.encodeField('atime') +
          this.encodeField('dev') +
          this.encodeField('ino') +
          this.encodeField('nlink') +
          this.encodeField('charset') +
          this.encodeField('comment') +
          this.encodeField('gid') +
          this.encodeField('gname') +
          this.encodeField('linkpath') +
          this.encodeField('mtime') +
          this.encodeField('size') +
          this.encodeField('uid') +
          this.encodeField('uname')
        );
      }
      encodeField(e) {
        if (this[e] === null || this[e] === void 0) return '';
        let i = this[e] instanceof Date ? this[e].getTime() / 1e3 : this[e],
          n =
            ' ' +
            (e === 'dev' || e === 'ino' || e === 'nlink' ? 'SCHILY.' : '') +
            e +
            '=' +
            i +
            `
`,
          r = Buffer.byteLength(n),
          s = Math.floor(Math.log(r) / Math.log(10)) + 1;
        return r + s >= Math.pow(10, s) && (s += 1), s + r + n;
      }
    };
  ru.parse = (t, e, i) => new ru(qH(BH(t), e), i);
  var qH = (t, e) => (e ? Object.keys(t).reduce((i, n) => ((i[n] = t[n]), i), e) : t),
    BH = (t) =>
      t
        .replace(/\n$/, '')
        .split(
          `
`
        )
        .reduce(HH, Object.create(null)),
    HH = (t, e) => {
      let i = parseInt(e, 10);
      if (i !== Buffer.byteLength(e) + 1) return t;
      e = e.slice((i + ' ').length);
      let n = e.split('='),
        r = n.shift().replace(/^SCHILY\.(dev|ino|nlink)/, '$1');
      if (!r) return t;
      let s = n.join('=');
      return (
        (t[r] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(r) ? new Date(s * 1e3) : /^[0-9]+$/.test(s) ? +s : s), t
      );
    };
  dT.exports = ru;
});
var ga = P((sse, hT) => {
  'use strict';
  hT.exports = (t) => {
    let e = t.length - 1,
      i = -1;
    for (; e > -1 && t.charAt(e) === '/'; ) (i = e), e--;
    return i === -1 ? t : t.slice(0, i);
  };
});
var Hp = P((ose, mT) => {
  'use strict';
  mT.exports = (t) =>
    class extends t {
      warn(e, i, n = {}) {
        this.file && (n.file = this.file),
          this.cwd && (n.cwd = this.cwd),
          (n.code = (i instanceof Error && i.code) || e),
          (n.tarCode = e),
          !this.strict && n.recoverable !== !1
            ? (i instanceof Error && ((n = Object.assign(i, n)), (i = i.message)), this.emit('warn', n.tarCode, i, n))
            : i instanceof Error
            ? this.emit('error', Object.assign(i, n))
            : this.emit('error', Object.assign(new Error(`${e}: ${i}`), n));
      }
    };
});
var Lx = P((cse, gT) => {
  'use strict';
  var Gp = ['|', '<', '>', '?', ':'],
    Px = Gp.map((t) => String.fromCharCode(61440 + t.charCodeAt(0))),
    GH = new Map(Gp.map((t, e) => [t, Px[e]])),
    zH = new Map(Px.map((t, e) => [t, Gp[e]]));
  gT.exports = {
    encode: (t) => Gp.reduce((e, i) => e.split(i).join(GH.get(i)), t),
    decode: (t) => Px.reduce((e, i) => e.split(i).join(zH.get(i)), t),
  };
});
var Dx = P((use, yT) => {
  'use strict';
  var { isAbsolute: VH, parse: xT } = require('path').win32;
  yT.exports = (t) => {
    let e = '',
      i = xT(t);
    for (; VH(t) || i.root; ) {
      let n = t.charAt(0) === '/' && t.slice(0, 4) !== '//?/' ? '/' : i.root;
      (t = t.slice(n.length)), (e += n), (i = xT(t));
    }
    return [e, t];
  };
});
var vT = P((lse, bT) => {
  'use strict';
  bT.exports = (t, e, i) => (
    (t &= 4095), i && (t = (t | 384) & -19), e && (t & 256 && (t |= 64), t & 32 && (t |= 8), t & 4 && (t |= 1)), t
  );
});
var Vx = P((dse, LT) => {
  'use strict';
  var { Minipass: TT } = Ap(),
    OT = Bp(),
    kT = ma(),
    jn = require('fs'),
    wT = require('path'),
    Fn = da(),
    $H = ga(),
    AT = (t, e) => (e ? ((t = Fn(t).replace(/^\.(\/|$)/, '')), $H(e) + '/' + t) : Fn(t)),
    WH = 16 * 1024 * 1024,
    ET = Symbol('process'),
    _T = Symbol('file'),
    ST = Symbol('directory'),
    jx = Symbol('symlink'),
    CT = Symbol('hardlink'),
    su = Symbol('header'),
    zp = Symbol('read'),
    Mx = Symbol('lstat'),
    Vp = Symbol('onlstat'),
    Ux = Symbol('onread'),
    qx = Symbol('onreadlink'),
    Bx = Symbol('openfile'),
    Hx = Symbol('onopenfile'),
    Xr = Symbol('close'),
    $p = Symbol('mode'),
    Gx = Symbol('awaitDrain'),
    Fx = Symbol('ondrain'),
    Mn = Symbol('prefix'),
    RT = Symbol('hadError'),
    IT = Hp(),
    KH = Lx(),
    NT = Dx(),
    PT = vT(),
    Wp = IT(
      class extends TT {
        constructor(e, i) {
          if (((i = i || {}), super(i), typeof e != 'string')) throw new TypeError('path is required');
          (this.path = Fn(e)),
            (this.portable = !!i.portable),
            (this.myuid = (process.getuid && process.getuid()) || 0),
            (this.myuser = process.env.USER || ''),
            (this.maxReadSize = i.maxReadSize || WH),
            (this.linkCache = i.linkCache || new Map()),
            (this.statCache = i.statCache || new Map()),
            (this.preservePaths = !!i.preservePaths),
            (this.cwd = Fn(i.cwd || process.cwd())),
            (this.strict = !!i.strict),
            (this.noPax = !!i.noPax),
            (this.noMtime = !!i.noMtime),
            (this.mtime = i.mtime || null),
            (this.prefix = i.prefix ? Fn(i.prefix) : null),
            (this.fd = null),
            (this.blockLen = null),
            (this.blockRemain = null),
            (this.buf = null),
            (this.offset = null),
            (this.length = null),
            (this.pos = null),
            (this.remain = null),
            typeof i.onwarn == 'function' && this.on('warn', i.onwarn);
          let n = !1;
          if (!this.preservePaths) {
            let [r, s] = NT(this.path);
            r && ((this.path = s), (n = r));
          }
          (this.win32 = !!i.win32 || process.platform === 'win32'),
            this.win32 && ((this.path = KH.decode(this.path.replace(/\\/g, '/'))), (e = e.replace(/\\/g, '/'))),
            (this.absolute = Fn(i.absolute || wT.resolve(this.cwd, e))),
            this.path === '' && (this.path = './'),
            n && this.warn('TAR_ENTRY_INFO', `stripping ${n} from absolute path`, { entry: this, path: n + this.path }),
            this.statCache.has(this.absolute) ? this[Vp](this.statCache.get(this.absolute)) : this[Mx]();
        }
        emit(e, ...i) {
          return e === 'error' && (this[RT] = !0), super.emit(e, ...i);
        }
        [Mx]() {
          jn.lstat(this.absolute, (e, i) => {
            if (e) return this.emit('error', e);
            this[Vp](i);
          });
        }
        [Vp](e) {
          this.statCache.set(this.absolute, e),
            (this.stat = e),
            e.isFile() || (e.size = 0),
            (this.type = YH(e)),
            this.emit('stat', e),
            this[ET]();
        }
        [ET]() {
          switch (this.type) {
            case 'File':
              return this[_T]();
            case 'Directory':
              return this[ST]();
            case 'SymbolicLink':
              return this[jx]();
            default:
              return this.end();
          }
        }
        [$p](e) {
          return PT(e, this.type === 'Directory', this.portable);
        }
        [Mn](e) {
          return AT(e, this.prefix);
        }
        [su]() {
          this.type === 'Directory' && this.portable && (this.noMtime = !0),
            (this.header = new kT({
              path: this[Mn](this.path),
              linkpath: this.type === 'Link' ? this[Mn](this.linkpath) : this.linkpath,
              mode: this[$p](this.stat.mode),
              uid: this.portable ? null : this.stat.uid,
              gid: this.portable ? null : this.stat.gid,
              size: this.stat.size,
              mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
              type: this.type,
              uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',
              atime: this.portable ? null : this.stat.atime,
              ctime: this.portable ? null : this.stat.ctime,
            })),
            this.header.encode() &&
              !this.noPax &&
              super.write(
                new OT({
                  atime: this.portable ? null : this.header.atime,
                  ctime: this.portable ? null : this.header.ctime,
                  gid: this.portable ? null : this.header.gid,
                  mtime: this.noMtime ? null : this.mtime || this.header.mtime,
                  path: this[Mn](this.path),
                  linkpath: this.type === 'Link' ? this[Mn](this.linkpath) : this.linkpath,
                  size: this.header.size,
                  uid: this.portable ? null : this.header.uid,
                  uname: this.portable ? null : this.header.uname,
                  dev: this.portable ? null : this.stat.dev,
                  ino: this.portable ? null : this.stat.ino,
                  nlink: this.portable ? null : this.stat.nlink,
                }).encode()
              ),
            super.write(this.header.block);
        }
        [ST]() {
          this.path.slice(-1) !== '/' && (this.path += '/'), (this.stat.size = 0), this[su](), this.end();
        }
        [jx]() {
          jn.readlink(this.absolute, (e, i) => {
            if (e) return this.emit('error', e);
            this[qx](i);
          });
        }
        [qx](e) {
          (this.linkpath = Fn(e)), this[su](), this.end();
        }
        [CT](e) {
          (this.type = 'Link'),
            (this.linkpath = Fn(wT.relative(this.cwd, e))),
            (this.stat.size = 0),
            this[su](),
            this.end();
        }
        [_T]() {
          if (this.stat.nlink > 1) {
            let e = this.stat.dev + ':' + this.stat.ino;
            if (this.linkCache.has(e)) {
              let i = this.linkCache.get(e);
              if (i.indexOf(this.cwd) === 0) return this[CT](i);
            }
            this.linkCache.set(e, this.absolute);
          }
          if ((this[su](), this.stat.size === 0)) return this.end();
          this[Bx]();
        }
        [Bx]() {
          jn.open(this.absolute, 'r', (e, i) => {
            if (e) return this.emit('error', e);
            this[Hx](i);
          });
        }
        [Hx](e) {
          if (((this.fd = e), this[RT])) return this[Xr]();
          (this.blockLen = 512 * Math.ceil(this.stat.size / 512)), (this.blockRemain = this.blockLen);
          let i = Math.min(this.blockLen, this.maxReadSize);
          (this.buf = Buffer.allocUnsafe(i)),
            (this.offset = 0),
            (this.pos = 0),
            (this.remain = this.stat.size),
            (this.length = this.buf.length),
            this[zp]();
        }
        [zp]() {
          let { fd: e, buf: i, offset: n, length: r, pos: s } = this;
          jn.read(e, i, n, r, s, (o, c) => {
            if (o) return this[Xr](() => this.emit('error', o));
            this[Ux](c);
          });
        }
        [Xr](e) {
          jn.close(this.fd, e);
        }
        [Ux](e) {
          if (e <= 0 && this.remain > 0) {
            let r = new Error('encountered unexpected EOF');
            return (
              (r.path = this.absolute), (r.syscall = 'read'), (r.code = 'EOF'), this[Xr](() => this.emit('error', r))
            );
          }
          if (e > this.remain) {
            let r = new Error('did not encounter expected EOF');
            return (
              (r.path = this.absolute), (r.syscall = 'read'), (r.code = 'EOF'), this[Xr](() => this.emit('error', r))
            );
          }
          if (e === this.remain)
            for (let r = e; r < this.length && e < this.blockRemain; r++)
              (this.buf[r + this.offset] = 0), e++, this.remain++;
          let i = this.offset === 0 && e === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + e);
          this.write(i) ? this[Fx]() : this[Gx](() => this[Fx]());
        }
        [Gx](e) {
          this.once('drain', e);
        }
        write(e) {
          if (this.blockRemain < e.length) {
            let i = new Error('writing more data than expected');
            return (i.path = this.absolute), this.emit('error', i);
          }
          return (
            (this.remain -= e.length),
            (this.blockRemain -= e.length),
            (this.pos += e.length),
            (this.offset += e.length),
            super.write(e)
          );
        }
        [Fx]() {
          if (!this.remain)
            return (
              this.blockRemain && super.write(Buffer.alloc(this.blockRemain)),
              this[Xr]((e) => (e ? this.emit('error', e) : this.end()))
            );
          this.offset >= this.length &&
            ((this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))), (this.offset = 0)),
            (this.length = this.buf.length - this.offset),
            this[zp]();
        }
      }
    ),
    zx = class extends Wp {
      [Mx]() {
        this[Vp](jn.lstatSync(this.absolute));
      }
      [jx]() {
        this[qx](jn.readlinkSync(this.absolute));
      }
      [Bx]() {
        this[Hx](jn.openSync(this.absolute, 'r'));
      }
      [zp]() {
        let e = !0;
        try {
          let { fd: i, buf: n, offset: r, length: s, pos: o } = this,
            c = jn.readSync(i, n, r, s, o);
          this[Ux](c), (e = !1);
        } finally {
          if (e)
            try {
              this[Xr](() => {});
            } catch {}
        }
      }
      [Gx](e) {
        e();
      }
      [Xr](e) {
        jn.closeSync(this.fd), e();
      }
    },
    XH = IT(
      class extends TT {
        constructor(e, i) {
          (i = i || {}),
            super(i),
            (this.preservePaths = !!i.preservePaths),
            (this.portable = !!i.portable),
            (this.strict = !!i.strict),
            (this.noPax = !!i.noPax),
            (this.noMtime = !!i.noMtime),
            (this.readEntry = e),
            (this.type = e.type),
            this.type === 'Directory' && this.portable && (this.noMtime = !0),
            (this.prefix = i.prefix || null),
            (this.path = Fn(e.path)),
            (this.mode = this[$p](e.mode)),
            (this.uid = this.portable ? null : e.uid),
            (this.gid = this.portable ? null : e.gid),
            (this.uname = this.portable ? null : e.uname),
            (this.gname = this.portable ? null : e.gname),
            (this.size = e.size),
            (this.mtime = this.noMtime ? null : i.mtime || e.mtime),
            (this.atime = this.portable ? null : e.atime),
            (this.ctime = this.portable ? null : e.ctime),
            (this.linkpath = Fn(e.linkpath)),
            typeof i.onwarn == 'function' && this.on('warn', i.onwarn);
          let n = !1;
          if (!this.preservePaths) {
            let [r, s] = NT(this.path);
            r && ((this.path = s), (n = r));
          }
          (this.remain = e.size),
            (this.blockRemain = e.startBlockSize),
            (this.header = new kT({
              path: this[Mn](this.path),
              linkpath: this.type === 'Link' ? this[Mn](this.linkpath) : this.linkpath,
              mode: this.mode,
              uid: this.portable ? null : this.uid,
              gid: this.portable ? null : this.gid,
              size: this.size,
              mtime: this.noMtime ? null : this.mtime,
              type: this.type,
              uname: this.portable ? null : this.uname,
              atime: this.portable ? null : this.atime,
              ctime: this.portable ? null : this.ctime,
            })),
            n && this.warn('TAR_ENTRY_INFO', `stripping ${n} from absolute path`, { entry: this, path: n + this.path }),
            this.header.encode() &&
              !this.noPax &&
              super.write(
                new OT({
                  atime: this.portable ? null : this.atime,
                  ctime: this.portable ? null : this.ctime,
                  gid: this.portable ? null : this.gid,
                  mtime: this.noMtime ? null : this.mtime,
                  path: this[Mn](this.path),
                  linkpath: this.type === 'Link' ? this[Mn](this.linkpath) : this.linkpath,
                  size: this.size,
                  uid: this.portable ? null : this.uid,
                  uname: this.portable ? null : this.uname,
                  dev: this.portable ? null : this.readEntry.dev,
                  ino: this.portable ? null : this.readEntry.ino,
                  nlink: this.portable ? null : this.readEntry.nlink,
                }).encode()
              ),
            super.write(this.header.block),
            e.pipe(this);
        }
        [Mn](e) {
          return AT(e, this.prefix);
        }
        [$p](e) {
          return PT(e, this.type === 'Directory', this.portable);
        }
        write(e) {
          let i = e.length;
          if (i > this.blockRemain) throw new Error('writing more to entry than is appropriate');
          return (this.blockRemain -= i), super.write(e);
        }
        end() {
          return this.blockRemain && super.write(Buffer.alloc(this.blockRemain)), super.end();
        }
      }
    );
  Wp.Sync = zx;
  Wp.Tar = XH;
  var YH = (t) =>
    t.isFile() ? 'File' : t.isDirectory() ? 'Directory' : t.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';
  LT.exports = Wp;
});
var FT = P((hse, DT) => {
  'use strict';
  DT.exports = function (t) {
    t.prototype[Symbol.iterator] = function* () {
      for (let e = this.head; e; e = e.next) yield e.value;
    };
  };
});
var $x = P((mse, jT) => {
  'use strict';
  jT.exports = Xe;
  Xe.Node = to;
  Xe.create = Xe;
  function Xe(t) {
    var e = this;
    if (
      (e instanceof Xe || (e = new Xe()),
      (e.tail = null),
      (e.head = null),
      (e.length = 0),
      t && typeof t.forEach == 'function')
    )
      t.forEach(function (r) {
        e.push(r);
      });
    else if (arguments.length > 0) for (var i = 0, n = arguments.length; i < n; i++) e.push(arguments[i]);
    return e;
  }
  Xe.prototype.removeNode = function (t) {
    if (t.list !== this) throw new Error('removing node which does not belong to this list');
    var e = t.next,
      i = t.prev;
    return (
      e && (e.prev = i),
      i && (i.next = e),
      t === this.head && (this.head = e),
      t === this.tail && (this.tail = i),
      t.list.length--,
      (t.next = null),
      (t.prev = null),
      (t.list = null),
      e
    );
  };
  Xe.prototype.unshiftNode = function (t) {
    if (t !== this.head) {
      t.list && t.list.removeNode(t);
      var e = this.head;
      (t.list = this), (t.next = e), e && (e.prev = t), (this.head = t), this.tail || (this.tail = t), this.length++;
    }
  };
  Xe.prototype.pushNode = function (t) {
    if (t !== this.tail) {
      t.list && t.list.removeNode(t);
      var e = this.tail;
      (t.list = this), (t.prev = e), e && (e.next = t), (this.tail = t), this.head || (this.head = t), this.length++;
    }
  };
  Xe.prototype.push = function () {
    for (var t = 0, e = arguments.length; t < e; t++) ZH(this, arguments[t]);
    return this.length;
  };
  Xe.prototype.unshift = function () {
    for (var t = 0, e = arguments.length; t < e; t++) QH(this, arguments[t]);
    return this.length;
  };
  Xe.prototype.pop = function () {
    if (this.tail) {
      var t = this.tail.value;
      return (this.tail = this.tail.prev), this.tail ? (this.tail.next = null) : (this.head = null), this.length--, t;
    }
  };
  Xe.prototype.shift = function () {
    if (this.head) {
      var t = this.head.value;
      return (this.head = this.head.next), this.head ? (this.head.prev = null) : (this.tail = null), this.length--, t;
    }
  };
  Xe.prototype.forEach = function (t, e) {
    e = e || this;
    for (var i = this.head, n = 0; i !== null; n++) t.call(e, i.value, n, this), (i = i.next);
  };
  Xe.prototype.forEachReverse = function (t, e) {
    e = e || this;
    for (var i = this.tail, n = this.length - 1; i !== null; n--) t.call(e, i.value, n, this), (i = i.prev);
  };
  Xe.prototype.get = function (t) {
    for (var e = 0, i = this.head; i !== null && e < t; e++) i = i.next;
    if (e === t && i !== null) return i.value;
  };
  Xe.prototype.getReverse = function (t) {
    for (var e = 0, i = this.tail; i !== null && e < t; e++) i = i.prev;
    if (e === t && i !== null) return i.value;
  };
  Xe.prototype.map = function (t, e) {
    e = e || this;
    for (var i = new Xe(), n = this.head; n !== null; ) i.push(t.call(e, n.value, this)), (n = n.next);
    return i;
  };
  Xe.prototype.mapReverse = function (t, e) {
    e = e || this;
    for (var i = new Xe(), n = this.tail; n !== null; ) i.push(t.call(e, n.value, this)), (n = n.prev);
    return i;
  };
  Xe.prototype.reduce = function (t, e) {
    var i,
      n = this.head;
    if (arguments.length > 1) i = e;
    else if (this.head) (n = this.head.next), (i = this.head.value);
    else throw new TypeError('Reduce of empty list with no initial value');
    for (var r = 0; n !== null; r++) (i = t(i, n.value, r)), (n = n.next);
    return i;
  };
  Xe.prototype.reduceReverse = function (t, e) {
    var i,
      n = this.tail;
    if (arguments.length > 1) i = e;
    else if (this.tail) (n = this.tail.prev), (i = this.tail.value);
    else throw new TypeError('Reduce of empty list with no initial value');
    for (var r = this.length - 1; n !== null; r--) (i = t(i, n.value, r)), (n = n.prev);
    return i;
  };
  Xe.prototype.toArray = function () {
    for (var t = new Array(this.length), e = 0, i = this.head; i !== null; e++) (t[e] = i.value), (i = i.next);
    return t;
  };
  Xe.prototype.toArrayReverse = function () {
    for (var t = new Array(this.length), e = 0, i = this.tail; i !== null; e++) (t[e] = i.value), (i = i.prev);
    return t;
  };
  Xe.prototype.slice = function (t, e) {
    (e = e || this.length), e < 0 && (e += this.length), (t = t || 0), t < 0 && (t += this.length);
    var i = new Xe();
    if (e < t || e < 0) return i;
    t < 0 && (t = 0), e > this.length && (e = this.length);
    for (var n = 0, r = this.head; r !== null && n < t; n++) r = r.next;
    for (; r !== null && n < e; n++, r = r.next) i.push(r.value);
    return i;
  };
  Xe.prototype.sliceReverse = function (t, e) {
    (e = e || this.length), e < 0 && (e += this.length), (t = t || 0), t < 0 && (t += this.length);
    var i = new Xe();
    if (e < t || e < 0) return i;
    t < 0 && (t = 0), e > this.length && (e = this.length);
    for (var n = this.length, r = this.tail; r !== null && n > e; n--) r = r.prev;
    for (; r !== null && n > t; n--, r = r.prev) i.push(r.value);
    return i;
  };
  Xe.prototype.splice = function (t, e, ...i) {
    t > this.length && (t = this.length - 1), t < 0 && (t = this.length + t);
    for (var n = 0, r = this.head; r !== null && n < t; n++) r = r.next;
    for (var s = [], n = 0; r && n < e; n++) s.push(r.value), (r = this.removeNode(r));
    r === null && (r = this.tail), r !== this.head && r !== this.tail && (r = r.prev);
    for (var n = 0; n < i.length; n++) r = JH(this, r, i[n]);
    return s;
  };
  Xe.prototype.reverse = function () {
    for (var t = this.head, e = this.tail, i = t; i !== null; i = i.prev) {
      var n = i.prev;
      (i.prev = i.next), (i.next = n);
    }
    return (this.head = e), (this.tail = t), this;
  };
  function JH(t, e, i) {
    var n = e === t.head ? new to(i, null, e, t) : new to(i, e, e.next, t);
    return n.next === null && (t.tail = n), n.prev === null && (t.head = n), t.length++, n;
  }
  function ZH(t, e) {
    (t.tail = new to(e, t.tail, null, t)), t.head || (t.head = t.tail), t.length++;
  }
  function QH(t, e) {
    (t.head = new to(e, null, t.head, t)), t.tail || (t.tail = t.head), t.length++;
  }
  function to(t, e, i, n) {
    if (!(this instanceof to)) return new to(t, e, i, n);
    (this.list = n),
      (this.value = t),
      e ? ((e.next = this), (this.prev = e)) : (this.prev = null),
      i ? ((i.prev = this), (this.next = i)) : (this.next = null);
  }
  try {
    FT()(Xe);
  } catch {}
});
var nf = P((xse, VT) => {
  'use strict';
  var ef = class {
      constructor(e, i) {
        (this.path = e || './'),
          (this.absolute = i),
          (this.entry = null),
          (this.stat = null),
          (this.readdir = null),
          (this.pending = !1),
          (this.ignore = !1),
          (this.piped = !1);
      }
    },
    { Minipass: eG } = Ap(),
    MT = Sx(),
    tG = Up(),
    ty = Vx(),
    iG = ty.Sync,
    nG = ty.Tar,
    rG = $x(),
    UT = Buffer.alloc(1024),
    Yp = Symbol('onStat'),
    Kp = Symbol('ended'),
    Un = Symbol('queue'),
    xa = Symbol('current'),
    io = Symbol('process'),
    Xp = Symbol('processing'),
    qT = Symbol('processJob'),
    qn = Symbol('jobs'),
    Wx = Symbol('jobDone'),
    Jp = Symbol('addFSEntry'),
    BT = Symbol('addTarEntry'),
    Jx = Symbol('stat'),
    Zx = Symbol('readdir'),
    Zp = Symbol('onreaddir'),
    Qp = Symbol('pipe'),
    HT = Symbol('entry'),
    Kx = Symbol('entryOpt'),
    Qx = Symbol('writeEntryClass'),
    zT = Symbol('write'),
    Xx = Symbol('ondrain'),
    tf = require('fs'),
    GT = require('path'),
    sG = Hp(),
    Yx = da(),
    iy = sG(
      class extends eG {
        constructor(e) {
          if (
            (super(e),
            (e = e || Object.create(null)),
            (this.opt = e),
            (this.file = e.file || ''),
            (this.cwd = e.cwd || process.cwd()),
            (this.maxReadSize = e.maxReadSize),
            (this.preservePaths = !!e.preservePaths),
            (this.strict = !!e.strict),
            (this.noPax = !!e.noPax),
            (this.prefix = Yx(e.prefix || '')),
            (this.linkCache = e.linkCache || new Map()),
            (this.statCache = e.statCache || new Map()),
            (this.readdirCache = e.readdirCache || new Map()),
            (this[Qx] = ty),
            typeof e.onwarn == 'function' && this.on('warn', e.onwarn),
            (this.portable = !!e.portable),
            (this.zip = null),
            e.gzip || e.brotli)
          ) {
            if (e.gzip && e.brotli) throw new TypeError('gzip and brotli are mutually exclusive');
            e.gzip &&
              (typeof e.gzip != 'object' && (e.gzip = {}),
              this.portable && (e.gzip.portable = !0),
              (this.zip = new MT.Gzip(e.gzip))),
              e.brotli &&
                (typeof e.brotli != 'object' && (e.brotli = {}), (this.zip = new MT.BrotliCompress(e.brotli))),
              this.zip.on('data', (i) => super.write(i)),
              this.zip.on('end', (i) => super.end()),
              this.zip.on('drain', (i) => this[Xx]()),
              this.on('resume', (i) => this.zip.resume());
          } else this.on('drain', this[Xx]);
          (this.noDirRecurse = !!e.noDirRecurse),
            (this.follow = !!e.follow),
            (this.noMtime = !!e.noMtime),
            (this.mtime = e.mtime || null),
            (this.filter = typeof e.filter == 'function' ? e.filter : (i) => !0),
            (this[Un] = new rG()),
            (this[qn] = 0),
            (this.jobs = +e.jobs || 4),
            (this[Xp] = !1),
            (this[Kp] = !1);
        }
        [zT](e) {
          return super.write(e);
        }
        add(e) {
          return this.write(e), this;
        }
        end(e) {
          return e && this.write(e), (this[Kp] = !0), this[io](), this;
        }
        write(e) {
          if (this[Kp]) throw new Error('write after end');
          return e instanceof tG ? this[BT](e) : this[Jp](e), this.flowing;
        }
        [BT](e) {
          let i = Yx(GT.resolve(this.cwd, e.path));
          if (!this.filter(e.path, e)) e.resume();
          else {
            let n = new ef(e.path, i, !1);
            (n.entry = new nG(e, this[Kx](n))),
              n.entry.on('end', (r) => this[Wx](n)),
              (this[qn] += 1),
              this[Un].push(n);
          }
          this[io]();
        }
        [Jp](e) {
          let i = Yx(GT.resolve(this.cwd, e));
          this[Un].push(new ef(e, i)), this[io]();
        }
        [Jx](e) {
          (e.pending = !0), (this[qn] += 1);
          let i = this.follow ? 'stat' : 'lstat';
          tf[i](e.absolute, (n, r) => {
            (e.pending = !1), (this[qn] -= 1), n ? this.emit('error', n) : this[Yp](e, r);
          });
        }
        [Yp](e, i) {
          this.statCache.set(e.absolute, i), (e.stat = i), this.filter(e.path, i) || (e.ignore = !0), this[io]();
        }
        [Zx](e) {
          (e.pending = !0),
            (this[qn] += 1),
            tf.readdir(e.absolute, (i, n) => {
              if (((e.pending = !1), (this[qn] -= 1), i)) return this.emit('error', i);
              this[Zp](e, n);
            });
        }
        [Zp](e, i) {
          this.readdirCache.set(e.absolute, i), (e.readdir = i), this[io]();
        }
        [io]() {
          if (!this[Xp]) {
            this[Xp] = !0;
            for (let e = this[Un].head; e !== null && this[qn] < this.jobs; e = e.next)
              if ((this[qT](e.value), e.value.ignore)) {
                let i = e.next;
                this[Un].removeNode(e), (e.next = i);
              }
            (this[Xp] = !1),
              this[Kp] &&
                !this[Un].length &&
                this[qn] === 0 &&
                (this.zip ? this.zip.end(UT) : (super.write(UT), super.end()));
          }
        }
        get [xa]() {
          return this[Un] && this[Un].head && this[Un].head.value;
        }
        [Wx](e) {
          this[Un].shift(), (this[qn] -= 1), this[io]();
        }
        [qT](e) {
          if (!e.pending) {
            if (e.entry) {
              e === this[xa] && !e.piped && this[Qp](e);
              return;
            }
            if (
              (e.stat || (this.statCache.has(e.absolute) ? this[Yp](e, this.statCache.get(e.absolute)) : this[Jx](e)),
              !!e.stat &&
                !e.ignore &&
                !(
                  !this.noDirRecurse &&
                  e.stat.isDirectory() &&
                  !e.readdir &&
                  (this.readdirCache.has(e.absolute) ? this[Zp](e, this.readdirCache.get(e.absolute)) : this[Zx](e),
                  !e.readdir)
                ))
            ) {
              if (((e.entry = this[HT](e)), !e.entry)) {
                e.ignore = !0;
                return;
              }
              e === this[xa] && !e.piped && this[Qp](e);
            }
          }
        }
        [Kx](e) {
          return {
            onwarn: (i, n, r) => this.warn(i, n, r),
            noPax: this.noPax,
            cwd: this.cwd,
            absolute: e.absolute,
            preservePaths: this.preservePaths,
            maxReadSize: this.maxReadSize,
            strict: this.strict,
            portable: this.portable,
            linkCache: this.linkCache,
            statCache: this.statCache,
            noMtime: this.noMtime,
            mtime: this.mtime,
            prefix: this.prefix,
          };
        }
        [HT](e) {
          this[qn] += 1;
          try {
            return new this[Qx](e.path, this[Kx](e))
              .on('end', () => this[Wx](e))
              .on('error', (i) => this.emit('error', i));
          } catch (i) {
            this.emit('error', i);
          }
        }
        [Xx]() {
          this[xa] && this[xa].entry && this[xa].entry.resume();
        }
        [Qp](e) {
          (e.piped = !0),
            e.readdir &&
              e.readdir.forEach((r) => {
                let s = e.path,
                  o = s === './' ? '' : s.replace(/\/*$/, '/');
                this[Jp](o + r);
              });
          let i = e.entry,
            n = this.zip;
          n
            ? i.on('data', (r) => {
                n.write(r) || i.pause();
              })
            : i.on('data', (r) => {
                super.write(r) || i.pause();
              });
        }
        pause() {
          return this.zip && this.zip.pause(), super.pause();
        }
      }
    ),
    ey = class extends iy {
      constructor(e) {
        super(e), (this[Qx] = iG);
      }
      pause() {}
      resume() {}
      [Jx](e) {
        let i = this.follow ? 'statSync' : 'lstatSync';
        this[Yp](e, tf[i](e.absolute));
      }
      [Zx](e, i) {
        this[Zp](e, tf.readdirSync(e.absolute));
      }
      [Qp](e) {
        let i = e.entry,
          n = this.zip;
        e.readdir &&
          e.readdir.forEach((r) => {
            let s = e.path,
              o = s === './' ? '' : s.replace(/\/*$/, '/');
            this[Jp](o + r);
          }),
          n
            ? i.on('data', (r) => {
                n.write(r);
              })
            : i.on('data', (r) => {
                super[zT](r);
              });
      }
    };
  iy.Sync = ey;
  VT.exports = iy;
});
var t1 = P((yse, e1) => {
  'use strict';
  var $T = typeof process == 'object' && process ? process : { stdout: null, stderr: null },
    oG = require('events'),
    WT = require('stream'),
    KT = require('string_decoder').StringDecoder,
    pr = Symbol('EOF'),
    fr = Symbol('maybeEmitEnd'),
    Yr = Symbol('emittedEnd'),
    rf = Symbol('emittingEnd'),
    ou = Symbol('emittedError'),
    sf = Symbol('closed'),
    XT = Symbol('read'),
    of = Symbol('flush'),
    YT = Symbol('flushChunk'),
    Oi = Symbol('encoding'),
    dr = Symbol('decoder'),
    af = Symbol('flowing'),
    au = Symbol('paused'),
    ya = Symbol('resume'),
    Wt = Symbol('bufferLength'),
    ny = Symbol('bufferPush'),
    ry = Symbol('bufferShift'),
    ui = Symbol('objectMode'),
    li = Symbol('destroyed'),
    sy = Symbol('emitData'),
    JT = Symbol('emitEnd'),
    oy = Symbol('emitEnd2'),
    hr = Symbol('async'),
    cu = (t) => Promise.resolve().then(t),
    ZT = global._MP_NO_ITERATOR_SYMBOLS_ !== '1',
    aG = (ZT && Symbol.asyncIterator) || Symbol('asyncIterator not implemented'),
    cG = (ZT && Symbol.iterator) || Symbol('iterator not implemented'),
    uG = (t) => t === 'end' || t === 'finish' || t === 'prefinish',
    lG = (t) =>
      t instanceof ArrayBuffer ||
      (typeof t == 'object' && t.constructor && t.constructor.name === 'ArrayBuffer' && t.byteLength >= 0),
    pG = (t) => !Buffer.isBuffer(t) && ArrayBuffer.isView(t),
    cf = class {
      constructor(e, i, n) {
        (this.src = e), (this.dest = i), (this.opts = n), (this.ondrain = () => e[ya]()), i.on('drain', this.ondrain);
      }
      unpipe() {
        this.dest.removeListener('drain', this.ondrain);
      }
      proxyErrors() {}
      end() {
        this.unpipe(), this.opts.end && this.dest.end();
      }
    },
    ay = class extends cf {
      unpipe() {
        this.src.removeListener('error', this.proxyErrors), super.unpipe();
      }
      constructor(e, i, n) {
        super(e, i, n), (this.proxyErrors = (r) => i.emit('error', r)), e.on('error', this.proxyErrors);
      }
    };
  e1.exports = class QT extends WT {
    constructor(e) {
      super(),
        (this[af] = !1),
        (this[au] = !1),
        (this.pipes = []),
        (this.buffer = []),
        (this[ui] = (e && e.objectMode) || !1),
        this[ui] ? (this[Oi] = null) : (this[Oi] = (e && e.encoding) || null),
        this[Oi] === 'buffer' && (this[Oi] = null),
        (this[hr] = (e && !!e.async) || !1),
        (this[dr] = this[Oi] ? new KT(this[Oi]) : null),
        (this[pr] = !1),
        (this[Yr] = !1),
        (this[rf] = !1),
        (this[sf] = !1),
        (this[ou] = null),
        (this.writable = !0),
        (this.readable = !0),
        (this[Wt] = 0),
        (this[li] = !1);
    }
    get bufferLength() {
      return this[Wt];
    }
    get encoding() {
      return this[Oi];
    }
    set encoding(e) {
      if (this[ui]) throw new Error('cannot set encoding in objectMode');
      if (this[Oi] && e !== this[Oi] && ((this[dr] && this[dr].lastNeed) || this[Wt]))
        throw new Error('cannot change encoding');
      this[Oi] !== e &&
        ((this[dr] = e ? new KT(e) : null),
        this.buffer.length && (this.buffer = this.buffer.map((i) => this[dr].write(i)))),
        (this[Oi] = e);
    }
    setEncoding(e) {
      this.encoding = e;
    }
    get objectMode() {
      return this[ui];
    }
    set objectMode(e) {
      this[ui] = this[ui] || !!e;
    }
    get async() {
      return this[hr];
    }
    set async(e) {
      this[hr] = this[hr] || !!e;
    }
    write(e, i, n) {
      if (this[pr]) throw new Error('write after end');
      if (this[li])
        return (
          this.emit(
            'error',
            Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' })
          ),
          !0
        );
      typeof i == 'function' && ((n = i), (i = 'utf8')), i || (i = 'utf8');
      let r = this[hr] ? cu : (s) => s();
      return (
        !this[ui] &&
          !Buffer.isBuffer(e) &&
          (pG(e)
            ? (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength))
            : lG(e)
            ? (e = Buffer.from(e))
            : typeof e != 'string' && (this.objectMode = !0)),
        this[ui]
          ? (this.flowing && this[Wt] !== 0 && this[of](!0),
            this.flowing ? this.emit('data', e) : this[ny](e),
            this[Wt] !== 0 && this.emit('readable'),
            n && r(n),
            this.flowing)
          : e.length
          ? (typeof e == 'string' && !(i === this[Oi] && !this[dr].lastNeed) && (e = Buffer.from(e, i)),
            Buffer.isBuffer(e) && this[Oi] && (e = this[dr].write(e)),
            this.flowing && this[Wt] !== 0 && this[of](!0),
            this.flowing ? this.emit('data', e) : this[ny](e),
            this[Wt] !== 0 && this.emit('readable'),
            n && r(n),
            this.flowing)
          : (this[Wt] !== 0 && this.emit('readable'), n && r(n), this.flowing)
      );
    }
    read(e) {
      if (this[li]) return null;
      if (this[Wt] === 0 || e === 0 || e > this[Wt]) return this[fr](), null;
      this[ui] && (e = null),
        this.buffer.length > 1 &&
          !this[ui] &&
          (this.encoding
            ? (this.buffer = [this.buffer.join('')])
            : (this.buffer = [Buffer.concat(this.buffer, this[Wt])]));
      let i = this[XT](e || null, this.buffer[0]);
      return this[fr](), i;
    }
    [XT](e, i) {
      return (
        e === i.length || e === null
          ? this[ry]()
          : ((this.buffer[0] = i.slice(e)), (i = i.slice(0, e)), (this[Wt] -= e)),
        this.emit('data', i),
        !this.buffer.length && !this[pr] && this.emit('drain'),
        i
      );
    }
    end(e, i, n) {
      return (
        typeof e == 'function' && ((n = e), (e = null)),
        typeof i == 'function' && ((n = i), (i = 'utf8')),
        e && this.write(e, i),
        n && this.once('end', n),
        (this[pr] = !0),
        (this.writable = !1),
        (this.flowing || !this[au]) && this[fr](),
        this
      );
    }
    [ya]() {
      this[li] ||
        ((this[au] = !1),
        (this[af] = !0),
        this.emit('resume'),
        this.buffer.length ? this[of]() : this[pr] ? this[fr]() : this.emit('drain'));
    }
    resume() {
      return this[ya]();
    }
    pause() {
      (this[af] = !1), (this[au] = !0);
    }
    get destroyed() {
      return this[li];
    }
    get flowing() {
      return this[af];
    }
    get paused() {
      return this[au];
    }
    [ny](e) {
      this[ui] ? (this[Wt] += 1) : (this[Wt] += e.length), this.buffer.push(e);
    }
    [ry]() {
      return (
        this.buffer.length && (this[ui] ? (this[Wt] -= 1) : (this[Wt] -= this.buffer[0].length)), this.buffer.shift()
      );
    }
    [of](e) {
      do;
      while (this[YT](this[ry]()));
      !e && !this.buffer.length && !this[pr] && this.emit('drain');
    }
    [YT](e) {
      return e ? (this.emit('data', e), this.flowing) : !1;
    }
    pipe(e, i) {
      if (this[li]) return;
      let n = this[Yr];
      return (
        (i = i || {}),
        e === $T.stdout || e === $T.stderr ? (i.end = !1) : (i.end = i.end !== !1),
        (i.proxyErrors = !!i.proxyErrors),
        n
          ? i.end && e.end()
          : (this.pipes.push(i.proxyErrors ? new ay(this, e, i) : new cf(this, e, i)),
            this[hr] ? cu(() => this[ya]()) : this[ya]()),
        e
      );
    }
    unpipe(e) {
      let i = this.pipes.find((n) => n.dest === e);
      i && (this.pipes.splice(this.pipes.indexOf(i), 1), i.unpipe());
    }
    addListener(e, i) {
      return this.on(e, i);
    }
    on(e, i) {
      let n = super.on(e, i);
      return (
        e === 'data' && !this.pipes.length && !this.flowing
          ? this[ya]()
          : e === 'readable' && this[Wt] !== 0
          ? super.emit('readable')
          : uG(e) && this[Yr]
          ? (super.emit(e), this.removeAllListeners(e))
          : e === 'error' && this[ou] && (this[hr] ? cu(() => i.call(this, this[ou])) : i.call(this, this[ou])),
        n
      );
    }
    get emittedEnd() {
      return this[Yr];
    }
    [fr]() {
      !this[rf] &&
        !this[Yr] &&
        !this[li] &&
        this.buffer.length === 0 &&
        this[pr] &&
        ((this[rf] = !0),
        this.emit('end'),
        this.emit('prefinish'),
        this.emit('finish'),
        this[sf] && this.emit('close'),
        (this[rf] = !1));
    }
    emit(e, i, ...n) {
      if (e !== 'error' && e !== 'close' && e !== li && this[li]) return;
      if (e === 'data') return i ? (this[hr] ? cu(() => this[sy](i)) : this[sy](i)) : !1;
      if (e === 'end') return this[JT]();
      if (e === 'close') {
        if (((this[sf] = !0), !this[Yr] && !this[li])) return;
        let s = super.emit('close');
        return this.removeAllListeners('close'), s;
      } else if (e === 'error') {
        this[ou] = i;
        let s = super.emit('error', i);
        return this[fr](), s;
      } else if (e === 'resume') {
        let s = super.emit('resume');
        return this[fr](), s;
      } else if (e === 'finish' || e === 'prefinish') {
        let s = super.emit(e);
        return this.removeAllListeners(e), s;
      }
      let r = super.emit(e, i, ...n);
      return this[fr](), r;
    }
    [sy](e) {
      for (let n of this.pipes) n.dest.write(e) === !1 && this.pause();
      let i = super.emit('data', e);
      return this[fr](), i;
    }
    [JT]() {
      this[Yr] || ((this[Yr] = !0), (this.readable = !1), this[hr] ? cu(() => this[oy]()) : this[oy]());
    }
    [oy]() {
      if (this[dr]) {
        let i = this[dr].end();
        if (i) {
          for (let n of this.pipes) n.dest.write(i);
          super.emit('data', i);
        }
      }
      for (let i of this.pipes) i.end();
      let e = super.emit('end');
      return this.removeAllListeners('end'), e;
    }
    collect() {
      let e = [];
      this[ui] || (e.dataLength = 0);
      let i = this.promise();
      return (
        this.on('data', (n) => {
          e.push(n), this[ui] || (e.dataLength += n.length);
        }),
        i.then(() => e)
      );
    }
    concat() {
      return this[ui]
        ? Promise.reject(new Error('cannot concat in objectMode'))
        : this.collect().then((e) =>
            this[ui]
              ? Promise.reject(new Error('cannot concat in objectMode'))
              : this[Oi]
              ? e.join('')
              : Buffer.concat(e, e.dataLength)
          );
    }
    promise() {
      return new Promise((e, i) => {
        this.on(li, () => i(new Error('stream destroyed'))), this.on('error', (n) => i(n)), this.on('end', () => e());
      });
    }
    [aG]() {
      return {
        next: () => {
          let i = this.read();
          if (i !== null) return Promise.resolve({ done: !1, value: i });
          if (this[pr]) return Promise.resolve({ done: !0 });
          let n = null,
            r = null,
            s = (l) => {
              this.removeListener('data', o), this.removeListener('end', c), r(l);
            },
            o = (l) => {
              this.removeListener('error', s),
                this.removeListener('end', c),
                this.pause(),
                n({ value: l, done: !!this[pr] });
            },
            c = () => {
              this.removeListener('error', s), this.removeListener('data', o), n({ done: !0 });
            },
            u = () => s(new Error('stream destroyed'));
          return new Promise((l, p) => {
            (r = p), (n = l), this.once(li, u), this.once('error', s), this.once('end', c), this.once('data', o);
          });
        },
      };
    }
    [cG]() {
      return {
        next: () => {
          let i = this.read();
          return { value: i, done: i === null };
        },
      };
    }
    destroy(e) {
      return this[li]
        ? (e ? this.emit('error', e) : this.emit(li), this)
        : ((this[li] = !0),
          (this.buffer.length = 0),
          (this[Wt] = 0),
          typeof this.close == 'function' && !this[sf] && this.close(),
          e ? this.emit('error', e) : this.emit(li),
          this);
    }
    static isStream(e) {
      return (
        !!e &&
        (e instanceof QT ||
          e instanceof WT ||
          (e instanceof oG &&
            (typeof e.pipe == 'function' || (typeof e.write == 'function' && typeof e.end == 'function'))))
      );
    }
  };
});
var Ra = P((lu) => {
  'use strict';
  var fG = t1(),
    dG = require('events').EventEmitter,
    ki = require('fs'),
    ly = ki.writev;
  if (!ly) {
    let t = process.binding('fs'),
      e = t.FSReqWrap || t.FSReqCallback;
    ly = (i, n, r, s) => {
      let o = (u, l) => s(u, l, n),
        c = new e();
      (c.oncomplete = o), t.writeBuffers(i, n, r, c);
    };
  }
  var Sa = Symbol('_autoClose'),
    gn = Symbol('_close'),
    uu = Symbol('_ended'),
    it = Symbol('_fd'),
    i1 = Symbol('_finished'),
    Zr = Symbol('_flags'),
    cy = Symbol('_flush'),
    py = Symbol('_handleChunk'),
    fy = Symbol('_makeBuf'),
    df = Symbol('_mode'),
    uf = Symbol('_needDrain'),
    Ea = Symbol('_onerror'),
    Ca = Symbol('_onopen'),
    uy = Symbol('_onread'),
    va = Symbol('_onwrite'),
    Qr = Symbol('_open'),
    mr = Symbol('_path'),
    no = Symbol('_pos'),
    Bn = Symbol('_queue'),
    wa = Symbol('_read'),
    n1 = Symbol('_readSize'),
    Jr = Symbol('_reading'),
    lf = Symbol('_remain'),
    r1 = Symbol('_size'),
    pf = Symbol('_write'),
    ba = Symbol('_writing'),
    ff = Symbol('_defaultFlag'),
    _a = Symbol('_errored'),
    hf = class extends fG {
      constructor(e, i) {
        if (((i = i || {}), super(i), (this.readable = !0), (this.writable = !1), typeof e != 'string'))
          throw new TypeError('path must be a string');
        (this[_a] = !1),
          (this[it] = typeof i.fd == 'number' ? i.fd : null),
          (this[mr] = e),
          (this[n1] = i.readSize || 16 * 1024 * 1024),
          (this[Jr] = !1),
          (this[r1] = typeof i.size == 'number' ? i.size : 1 / 0),
          (this[lf] = this[r1]),
          (this[Sa] = typeof i.autoClose == 'boolean' ? i.autoClose : !0),
          typeof this[it] == 'number' ? this[wa]() : this[Qr]();
      }
      get fd() {
        return this[it];
      }
      get path() {
        return this[mr];
      }
      write() {
        throw new TypeError('this is a readable stream');
      }
      end() {
        throw new TypeError('this is a readable stream');
      }
      [Qr]() {
        ki.open(this[mr], 'r', (e, i) => this[Ca](e, i));
      }
      [Ca](e, i) {
        e ? this[Ea](e) : ((this[it] = i), this.emit('open', i), this[wa]());
      }
      [fy]() {
        return Buffer.allocUnsafe(Math.min(this[n1], this[lf]));
      }
      [wa]() {
        if (!this[Jr]) {
          this[Jr] = !0;
          let e = this[fy]();
          if (e.length === 0) return process.nextTick(() => this[uy](null, 0, e));
          ki.read(this[it], e, 0, e.length, null, (i, n, r) => this[uy](i, n, r));
        }
      }
      [uy](e, i, n) {
        (this[Jr] = !1), e ? this[Ea](e) : this[py](i, n) && this[wa]();
      }
      [gn]() {
        if (this[Sa] && typeof this[it] == 'number') {
          let e = this[it];
          (this[it] = null), ki.close(e, (i) => (i ? this.emit('error', i) : this.emit('close')));
        }
      }
      [Ea](e) {
        (this[Jr] = !0), this[gn](), this.emit('error', e);
      }
      [py](e, i) {
        let n = !1;
        return (
          (this[lf] -= e),
          e > 0 && (n = super.write(e < i.length ? i.slice(0, e) : i)),
          (e === 0 || this[lf] <= 0) && ((n = !1), this[gn](), super.end()),
          n
        );
      }
      emit(e, i) {
        switch (e) {
          case 'prefinish':
          case 'finish':
            break;
          case 'drain':
            typeof this[it] == 'number' && this[wa]();
            break;
          case 'error':
            return this[_a] ? void 0 : ((this[_a] = !0), super.emit(e, i));
          default:
            return super.emit(e, i);
        }
      }
    },
    dy = class extends hf {
      [Qr]() {
        let e = !0;
        try {
          this[Ca](null, ki.openSync(this[mr], 'r')), (e = !1);
        } finally {
          e && this[gn]();
        }
      }
      [wa]() {
        let e = !0;
        try {
          if (!this[Jr]) {
            this[Jr] = !0;
            do {
              let i = this[fy](),
                n = i.length === 0 ? 0 : ki.readSync(this[it], i, 0, i.length, null);
              if (!this[py](n, i)) break;
            } while (!0);
            this[Jr] = !1;
          }
          e = !1;
        } finally {
          e && this[gn]();
        }
      }
      [gn]() {
        if (this[Sa] && typeof this[it] == 'number') {
          let e = this[it];
          (this[it] = null), ki.closeSync(e), this.emit('close');
        }
      }
    },
    mf = class extends dG {
      constructor(e, i) {
        (i = i || {}),
          super(i),
          (this.readable = !1),
          (this.writable = !0),
          (this[_a] = !1),
          (this[ba] = !1),
          (this[uu] = !1),
          (this[uf] = !1),
          (this[Bn] = []),
          (this[mr] = e),
          (this[it] = typeof i.fd == 'number' ? i.fd : null),
          (this[df] = i.mode === void 0 ? 438 : i.mode),
          (this[no] = typeof i.start == 'number' ? i.start : null),
          (this[Sa] = typeof i.autoClose == 'boolean' ? i.autoClose : !0);
        let n = this[no] !== null ? 'r+' : 'w';
        (this[ff] = i.flags === void 0), (this[Zr] = this[ff] ? n : i.flags), this[it] === null && this[Qr]();
      }
      emit(e, i) {
        if (e === 'error') {
          if (this[_a]) return;
          this[_a] = !0;
        }
        return super.emit(e, i);
      }
      get fd() {
        return this[it];
      }
      get path() {
        return this[mr];
      }
      [Ea](e) {
        this[gn](), (this[ba] = !0), this.emit('error', e);
      }
      [Qr]() {
        ki.open(this[mr], this[Zr], this[df], (e, i) => this[Ca](e, i));
      }
      [Ca](e, i) {
        this[ff] && this[Zr] === 'r+' && e && e.code === 'ENOENT'
          ? ((this[Zr] = 'w'), this[Qr]())
          : e
          ? this[Ea](e)
          : ((this[it] = i), this.emit('open', i), this[cy]());
      }
      end(e, i) {
        return (
          e && this.write(e, i),
          (this[uu] = !0),
          !this[ba] && !this[Bn].length && typeof this[it] == 'number' && this[va](null, 0),
          this
        );
      }
      write(e, i) {
        return (
          typeof e == 'string' && (e = Buffer.from(e, i)),
          this[uu]
            ? (this.emit('error', new Error('write() after end()')), !1)
            : this[it] === null || this[ba] || this[Bn].length
            ? (this[Bn].push(e), (this[uf] = !0), !1)
            : ((this[ba] = !0), this[pf](e), !0)
        );
      }
      [pf](e) {
        ki.write(this[it], e, 0, e.length, this[no], (i, n) => this[va](i, n));
      }
      [va](e, i) {
        e
          ? this[Ea](e)
          : (this[no] !== null && (this[no] += i),
            this[Bn].length
              ? this[cy]()
              : ((this[ba] = !1),
                this[uu] && !this[i1]
                  ? ((this[i1] = !0), this[gn](), this.emit('finish'))
                  : this[uf] && ((this[uf] = !1), this.emit('drain'))));
      }
      [cy]() {
        if (this[Bn].length === 0) this[uu] && this[va](null, 0);
        else if (this[Bn].length === 1) this[pf](this[Bn].pop());
        else {
          let e = this[Bn];
          (this[Bn] = []), ly(this[it], e, this[no], (i, n) => this[va](i, n));
        }
      }
      [gn]() {
        if (this[Sa] && typeof this[it] == 'number') {
          let e = this[it];
          (this[it] = null), ki.close(e, (i) => (i ? this.emit('error', i) : this.emit('close')));
        }
      }
    },
    hy = class extends mf {
      [Qr]() {
        let e;
        if (this[ff] && this[Zr] === 'r+')
          try {
            e = ki.openSync(this[mr], this[Zr], this[df]);
          } catch (i) {
            if (i.code === 'ENOENT') return (this[Zr] = 'w'), this[Qr]();
            throw i;
          }
        else e = ki.openSync(this[mr], this[Zr], this[df]);
        this[Ca](null, e);
      }
      [gn]() {
        if (this[Sa] && typeof this[it] == 'number') {
          let e = this[it];
          (this[it] = null), ki.closeSync(e), this.emit('close');
        }
      }
      [pf](e) {
        let i = !0;
        try {
          this[va](null, ki.writeSync(this[it], e, 0, e.length, this[no])), (i = !1);
        } finally {
          if (i)
            try {
              this[gn]();
            } catch {}
        }
      }
    };
  lu.ReadStream = hf;
  lu.ReadStreamSync = dy;
  lu.WriteStream = mf;
  lu.WriteStreamSync = hy;
});
var Ef = P((wse, h1) => {
  'use strict';
  var hG = Hp(),
    s1 = ma(),
    mG = require('events'),
    gG = $x(),
    xG = 1024 * 1024,
    yG = Up(),
    o1 = Bp(),
    a1 = Sx(),
    { nextTick: bG } = require('process'),
    my = Buffer.from([31, 139]),
    Ji = Symbol('state'),
    ro = Symbol('writeEntry'),
    gr = Symbol('readEntry'),
    gy = Symbol('nextEntry'),
    c1 = Symbol('processEntry'),
    Zi = Symbol('extendedHeader'),
    pu = Symbol('globalExtendedHeader'),
    es = Symbol('meta'),
    u1 = Symbol('emitMeta'),
    at = Symbol('buffer'),
    xr = Symbol('queue'),
    ts = Symbol('ended'),
    l1 = Symbol('emittedEnd'),
    so = Symbol('emit'),
    Kt = Symbol('unzip'),
    gf = Symbol('consumeChunk'),
    xf = Symbol('consumeChunkSub'),
    xy = Symbol('consumeBody'),
    p1 = Symbol('consumeMeta'),
    f1 = Symbol('consumeHeader'),
    yf = Symbol('consuming'),
    yy = Symbol('bufferConcat'),
    by = Symbol('maybeEnd'),
    fu = Symbol('writing'),
    is = Symbol('aborted'),
    bf = Symbol('onDone'),
    oo = Symbol('sawValidEntry'),
    vf = Symbol('sawNullBlock'),
    wf = Symbol('sawEOF'),
    d1 = Symbol('closeStream'),
    vG = (t) => !0;
  h1.exports = hG(
    class extends mG {
      constructor(e) {
        (e = e || {}),
          super(e),
          (this.file = e.file || ''),
          (this[oo] = null),
          this.on(bf, (n) => {
            (this[Ji] === 'begin' || this[oo] === !1) && this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format');
          }),
          e.ondone
            ? this.on(bf, e.ondone)
            : this.on(bf, (n) => {
                this.emit('prefinish'), this.emit('finish'), this.emit('end');
              }),
          (this.strict = !!e.strict),
          (this.maxMetaEntrySize = e.maxMetaEntrySize || xG),
          (this.filter = typeof e.filter == 'function' ? e.filter : vG);
        let i = e.file && (e.file.endsWith('.tar.br') || e.file.endsWith('.tbr'));
        (this.brotli = !e.gzip && e.brotli !== void 0 ? e.brotli : i ? void 0 : !1),
          (this.writable = !0),
          (this.readable = !1),
          (this[xr] = new gG()),
          (this[at] = null),
          (this[gr] = null),
          (this[ro] = null),
          (this[Ji] = 'begin'),
          (this[es] = ''),
          (this[Zi] = null),
          (this[pu] = null),
          (this[ts] = !1),
          (this[Kt] = null),
          (this[is] = !1),
          (this[vf] = !1),
          (this[wf] = !1),
          this.on('end', () => this[d1]()),
          typeof e.onwarn == 'function' && this.on('warn', e.onwarn),
          typeof e.onentry == 'function' && this.on('entry', e.onentry);
      }
      [f1](e, i) {
        this[oo] === null && (this[oo] = !1);
        let n;
        try {
          n = new s1(e, i, this[Zi], this[pu]);
        } catch (r) {
          return this.warn('TAR_ENTRY_INVALID', r);
        }
        if (n.nullBlock)
          this[vf]
            ? ((this[wf] = !0), this[Ji] === 'begin' && (this[Ji] = 'header'), this[so]('eof'))
            : ((this[vf] = !0), this[so]('nullBlock'));
        else if (((this[vf] = !1), !n.cksumValid)) this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header: n });
        else if (!n.path) this.warn('TAR_ENTRY_INVALID', 'path is required', { header: n });
        else {
          let r = n.type;
          if (/^(Symbolic)?Link$/.test(r) && !n.linkpath)
            this.warn('TAR_ENTRY_INVALID', 'linkpath required', { header: n });
          else if (!/^(Symbolic)?Link$/.test(r) && n.linkpath)
            this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', { header: n });
          else {
            let s = (this[ro] = new yG(n, this[Zi], this[pu]));
            if (!this[oo])
              if (s.remain) {
                let o = () => {
                  s.invalid || (this[oo] = !0);
                };
                s.on('end', o);
              } else this[oo] = !0;
            s.meta
              ? s.size > this.maxMetaEntrySize
                ? ((s.ignore = !0), this[so]('ignoredEntry', s), (this[Ji] = 'ignore'), s.resume())
                : s.size > 0 && ((this[es] = ''), s.on('data', (o) => (this[es] += o)), (this[Ji] = 'meta'))
              : ((this[Zi] = null),
                (s.ignore = s.ignore || !this.filter(s.path, s)),
                s.ignore
                  ? (this[so]('ignoredEntry', s), (this[Ji] = s.remain ? 'ignore' : 'header'), s.resume())
                  : (s.remain ? (this[Ji] = 'body') : ((this[Ji] = 'header'), s.end()),
                    this[gr] ? this[xr].push(s) : (this[xr].push(s), this[gy]())));
          }
        }
      }
      [d1]() {
        bG(() => this.emit('close'));
      }
      [c1](e) {
        let i = !0;
        return (
          e
            ? Array.isArray(e)
              ? this.emit.apply(this, e)
              : ((this[gr] = e), this.emit('entry', e), e.emittedEnd || (e.on('end', (n) => this[gy]()), (i = !1)))
            : ((this[gr] = null), (i = !1)),
          i
        );
      }
      [gy]() {
        do;
        while (this[c1](this[xr].shift()));
        if (!this[xr].length) {
          let e = this[gr];
          !e || e.flowing || e.size === e.remain
            ? this[fu] || this.emit('drain')
            : e.once('drain', (n) => this.emit('drain'));
        }
      }
      [xy](e, i) {
        let n = this[ro],
          r = n.blockRemain,
          s = r >= e.length && i === 0 ? e : e.slice(i, i + r);
        return n.write(s), n.blockRemain || ((this[Ji] = 'header'), (this[ro] = null), n.end()), s.length;
      }
      [p1](e, i) {
        let n = this[ro],
          r = this[xy](e, i);
        return this[ro] || this[u1](n), r;
      }
      [so](e, i, n) {
        !this[xr].length && !this[gr] ? this.emit(e, i, n) : this[xr].push([e, i, n]);
      }
      [u1](e) {
        switch ((this[so]('meta', this[es]), e.type)) {
          case 'ExtendedHeader':
          case 'OldExtendedHeader':
            this[Zi] = o1.parse(this[es], this[Zi], !1);
            break;
          case 'GlobalExtendedHeader':
            this[pu] = o1.parse(this[es], this[pu], !0);
            break;
          case 'NextFileHasLongPath':
          case 'OldGnuLongPath':
            (this[Zi] = this[Zi] || Object.create(null)), (this[Zi].path = this[es].replace(/\0.*/, ''));
            break;
          case 'NextFileHasLongLinkpath':
            (this[Zi] = this[Zi] || Object.create(null)), (this[Zi].linkpath = this[es].replace(/\0.*/, ''));
            break;
          default:
            throw new Error('unknown meta: ' + e.type);
        }
      }
      abort(e) {
        (this[is] = !0), this.emit('abort', e), this.warn('TAR_ABORT', e, { recoverable: !1 });
      }
      write(e) {
        if (this[is]) return;
        if ((this[Kt] === null || (this.brotli === void 0 && this[Kt] === !1)) && e) {
          if ((this[at] && ((e = Buffer.concat([this[at], e])), (this[at] = null)), e.length < my.length))
            return (this[at] = e), !0;
          for (let s = 0; this[Kt] === null && s < my.length; s++) e[s] !== my[s] && (this[Kt] = !1);
          let r = this.brotli === void 0;
          if (this[Kt] === !1 && r)
            if (e.length < 512)
              if (this[ts]) this.brotli = !0;
              else return (this[at] = e), !0;
            else
              try {
                new s1(e.slice(0, 512)), (this.brotli = !1);
              } catch {
                this.brotli = !0;
              }
          if (this[Kt] === null || (this[Kt] === !1 && this.brotli)) {
            let s = this[ts];
            (this[ts] = !1),
              (this[Kt] = this[Kt] === null ? new a1.Unzip() : new a1.BrotliDecompress()),
              this[Kt].on('data', (c) => this[gf](c)),
              this[Kt].on('error', (c) => this.abort(c)),
              this[Kt].on('end', (c) => {
                (this[ts] = !0), this[gf]();
              }),
              (this[fu] = !0);
            let o = this[Kt][s ? 'end' : 'write'](e);
            return (this[fu] = !1), o;
          }
        }
        (this[fu] = !0), this[Kt] ? this[Kt].write(e) : this[gf](e), (this[fu] = !1);
        let n = this[xr].length ? !1 : this[gr] ? this[gr].flowing : !0;
        return !n && !this[xr].length && this[gr].once('drain', (r) => this.emit('drain')), n;
      }
      [yy](e) {
        e && !this[is] && (this[at] = this[at] ? Buffer.concat([this[at], e]) : e);
      }
      [by]() {
        if (this[ts] && !this[l1] && !this[is] && !this[yf]) {
          this[l1] = !0;
          let e = this[ro];
          if (e && e.blockRemain) {
            let i = this[at] ? this[at].length : 0;
            this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${e.blockRemain} more bytes, only ${i} available)`, {
              entry: e,
            }),
              this[at] && e.write(this[at]),
              e.end();
          }
          this[so](bf);
        }
      }
      [gf](e) {
        if (this[yf]) this[yy](e);
        else if (!e && !this[at]) this[by]();
        else {
          if (((this[yf] = !0), this[at])) {
            this[yy](e);
            let i = this[at];
            (this[at] = null), this[xf](i);
          } else this[xf](e);
          for (; this[at] && this[at].length >= 512 && !this[is] && !this[wf]; ) {
            let i = this[at];
            (this[at] = null), this[xf](i);
          }
          this[yf] = !1;
        }
        (!this[at] || this[ts]) && this[by]();
      }
      [xf](e) {
        let i = 0,
          n = e.length;
        for (; i + 512 <= n && !this[is] && !this[wf]; )
          switch (this[Ji]) {
            case 'begin':
            case 'header':
              this[f1](e, i), (i += 512);
              break;
            case 'ignore':
            case 'body':
              i += this[xy](e, i);
              break;
            case 'meta':
              i += this[p1](e, i);
              break;
            default:
              throw new Error('invalid state: ' + this[Ji]);
          }
        i < n && (this[at] ? (this[at] = Buffer.concat([e.slice(i), this[at]])) : (this[at] = e.slice(i)));
      }
      end(e) {
        this[is] ||
          (this[Kt]
            ? this[Kt].end(e)
            : ((this[ts] = !0), this.brotli === void 0 && (e = e || Buffer.alloc(0)), this.write(e)));
      }
    }
  );
});
var _f = P((Ese, y1) => {
  'use strict';
  var wG = ca(),
    g1 = Ef(),
    Ta = require('fs'),
    EG = Ra(),
    m1 = require('path'),
    vy = ga();
  y1.exports = (t, e, i) => {
    typeof t == 'function' ? ((i = t), (e = null), (t = {})) : Array.isArray(t) && ((e = t), (t = {})),
      typeof e == 'function' && ((i = e), (e = null)),
      e ? (e = Array.from(e)) : (e = []);
    let n = wG(t);
    if (n.sync && typeof i == 'function') throw new TypeError('callback not supported for sync tar functions');
    if (!n.file && typeof i == 'function') throw new TypeError('callback only supported with file option');
    return e.length && SG(n, e), n.noResume || _G(n), n.file && n.sync ? CG(n) : n.file ? RG(n, i) : x1(n);
  };
  var _G = (t) => {
      let e = t.onentry;
      t.onentry = e
        ? (i) => {
            e(i), i.resume();
          }
        : (i) => i.resume();
    },
    SG = (t, e) => {
      let i = new Map(e.map((s) => [vy(s), !0])),
        n = t.filter,
        r = (s, o) => {
          let c = o || m1.parse(s).root || '.',
            u = s === c ? !1 : i.has(s) ? i.get(s) : r(m1.dirname(s), c);
          return i.set(s, u), u;
        };
      t.filter = n ? (s, o) => n(s, o) && r(vy(s)) : (s) => r(vy(s));
    },
    CG = (t) => {
      let e = x1(t),
        i = t.file,
        n = !0,
        r;
      try {
        let s = Ta.statSync(i),
          o = t.maxReadSize || 16 * 1024 * 1024;
        if (s.size < o) e.end(Ta.readFileSync(i));
        else {
          let c = 0,
            u = Buffer.allocUnsafe(o);
          for (r = Ta.openSync(i, 'r'); c < s.size; ) {
            let l = Ta.readSync(r, u, 0, o, c);
            (c += l), e.write(u.slice(0, l));
          }
          e.end();
        }
        n = !1;
      } finally {
        if (n && r)
          try {
            Ta.closeSync(r);
          } catch {}
      }
    },
    RG = (t, e) => {
      let i = new g1(t),
        n = t.maxReadSize || 16 * 1024 * 1024,
        r = t.file,
        s = new Promise((o, c) => {
          i.on('error', c),
            i.on('end', o),
            Ta.stat(r, (u, l) => {
              if (u) c(u);
              else {
                let p = new EG.ReadStream(r, { readSize: n, size: l.size });
                p.on('error', c), p.pipe(i);
              }
            });
        });
      return e ? s.then(e, e) : s;
    },
    x1 = (t) => new g1(t);
});
var S1 = P((_se, _1) => {
  'use strict';
  var TG = ca(),
    Sf = nf(),
    b1 = Ra(),
    v1 = _f(),
    w1 = require('path');
  _1.exports = (t, e, i) => {
    if (
      (typeof e == 'function' && (i = e), Array.isArray(t) && ((e = t), (t = {})), !e || !Array.isArray(e) || !e.length)
    )
      throw new TypeError('no files or directories specified');
    e = Array.from(e);
    let n = TG(t);
    if (n.sync && typeof i == 'function') throw new TypeError('callback not supported for sync tar functions');
    if (!n.file && typeof i == 'function') throw new TypeError('callback only supported with file option');
    return n.file && n.sync ? OG(n, e) : n.file ? kG(n, e, i) : n.sync ? AG(n, e) : IG(n, e);
  };
  var OG = (t, e) => {
      let i = new Sf.Sync(t),
        n = new b1.WriteStreamSync(t.file, { mode: t.mode || 438 });
      i.pipe(n), E1(i, e);
    },
    kG = (t, e, i) => {
      let n = new Sf(t),
        r = new b1.WriteStream(t.file, { mode: t.mode || 438 });
      n.pipe(r);
      let s = new Promise((o, c) => {
        r.on('error', c), r.on('close', o), n.on('error', c);
      });
      return wy(n, e), i ? s.then(i, i) : s;
    },
    E1 = (t, e) => {
      e.forEach((i) => {
        i.charAt(0) === '@'
          ? v1({ file: w1.resolve(t.cwd, i.slice(1)), sync: !0, noResume: !0, onentry: (n) => t.add(n) })
          : t.add(i);
      }),
        t.end();
    },
    wy = (t, e) => {
      for (; e.length; ) {
        let i = e.shift();
        if (i.charAt(0) === '@')
          return v1({ file: w1.resolve(t.cwd, i.slice(1)), noResume: !0, onentry: (n) => t.add(n) }).then((n) =>
            wy(t, e)
          );
        t.add(i);
      }
      t.end();
    },
    AG = (t, e) => {
      let i = new Sf.Sync(t);
      return E1(i, e), i;
    },
    IG = (t, e) => {
      let i = new Sf(t);
      return wy(i, e), i;
    };
});
var Ey = P((Sse, I1) => {
  'use strict';
  var NG = ca(),
    C1 = nf(),
    Gi = require('fs'),
    R1 = Ra(),
    T1 = _f(),
    O1 = require('path'),
    k1 = ma();
  I1.exports = (t, e, i) => {
    let n = NG(t);
    if (!n.file) throw new TypeError('file is required');
    if (n.gzip || n.brotli || n.file.endsWith('.br') || n.file.endsWith('.tbr'))
      throw new TypeError('cannot append to compressed archives');
    if (!e || !Array.isArray(e) || !e.length) throw new TypeError('no files or directories specified');
    return (e = Array.from(e)), n.sync ? PG(n, e) : DG(n, e, i);
  };
  var PG = (t, e) => {
      let i = new C1.Sync(t),
        n = !0,
        r,
        s;
      try {
        try {
          r = Gi.openSync(t.file, 'r+');
        } catch (u) {
          if (u.code === 'ENOENT') r = Gi.openSync(t.file, 'w+');
          else throw u;
        }
        let o = Gi.fstatSync(r),
          c = Buffer.alloc(512);
        e: for (s = 0; s < o.size; s += 512) {
          for (let p = 0, d = 0; p < 512; p += d) {
            if (((d = Gi.readSync(r, c, p, c.length - p, s + p)), s === 0 && c[0] === 31 && c[1] === 139))
              throw new Error('cannot append to compressed archives');
            if (!d) break e;
          }
          let u = new k1(c);
          if (!u.cksumValid) break;
          let l = 512 * Math.ceil(u.size / 512);
          if (s + l + 512 > o.size) break;
          (s += l), t.mtimeCache && t.mtimeCache.set(u.path, u.mtime);
        }
        (n = !1), LG(t, i, s, r, e);
      } finally {
        if (n)
          try {
            Gi.closeSync(r);
          } catch {}
      }
    },
    LG = (t, e, i, n, r) => {
      let s = new R1.WriteStreamSync(t.file, { fd: n, start: i });
      e.pipe(s), FG(e, r);
    },
    DG = (t, e, i) => {
      e = Array.from(e);
      let n = new C1(t),
        r = (o, c, u) => {
          let l = (g, y) => {
              g ? Gi.close(o, (h) => u(g)) : u(null, y);
            },
            p = 0;
          if (c === 0) return l(null, 0);
          let d = 0,
            x = Buffer.alloc(512),
            b = (g, y) => {
              if (g) return l(g);
              if (((d += y), d < 512 && y)) return Gi.read(o, x, d, x.length - d, p + d, b);
              if (p === 0 && x[0] === 31 && x[1] === 139) return l(new Error('cannot append to compressed archives'));
              if (d < 512) return l(null, p);
              let h = new k1(x);
              if (!h.cksumValid) return l(null, p);
              let v = 512 * Math.ceil(h.size / 512);
              if (p + v + 512 > c || ((p += v + 512), p >= c)) return l(null, p);
              t.mtimeCache && t.mtimeCache.set(h.path, h.mtime), (d = 0), Gi.read(o, x, 0, 512, p, b);
            };
          Gi.read(o, x, 0, 512, p, b);
        },
        s = new Promise((o, c) => {
          n.on('error', c);
          let u = 'r+',
            l = (p, d) => {
              if (p && p.code === 'ENOENT' && u === 'r+') return (u = 'w+'), Gi.open(t.file, u, l);
              if (p) return c(p);
              Gi.fstat(d, (x, b) => {
                if (x) return Gi.close(d, () => c(x));
                r(d, b.size, (g, y) => {
                  if (g) return c(g);
                  let h = new R1.WriteStream(t.file, { fd: d, start: y });
                  n.pipe(h), h.on('error', c), h.on('close', o), A1(n, e);
                });
              });
            };
          Gi.open(t.file, u, l);
        });
      return i ? s.then(i, i) : s;
    },
    FG = (t, e) => {
      e.forEach((i) => {
        i.charAt(0) === '@'
          ? T1({ file: O1.resolve(t.cwd, i.slice(1)), sync: !0, noResume: !0, onentry: (n) => t.add(n) })
          : t.add(i);
      }),
        t.end();
    },
    A1 = (t, e) => {
      for (; e.length; ) {
        let i = e.shift();
        if (i.charAt(0) === '@')
          return T1({ file: O1.resolve(t.cwd, i.slice(1)), noResume: !0, onentry: (n) => t.add(n) }).then((n) =>
            A1(t, e)
          );
        t.add(i);
      }
      t.end();
    };
});
var P1 = P((Cse, N1) => {
  'use strict';
  var jG = ca(),
    MG = Ey();
  N1.exports = (t, e, i) => {
    let n = jG(t);
    if (!n.file) throw new TypeError('file is required');
    if (n.gzip || n.brotli || n.file.endsWith('.br') || n.file.endsWith('.tbr'))
      throw new TypeError('cannot append to compressed archives');
    if (!e || !Array.isArray(e) || !e.length) throw new TypeError('no files or directories specified');
    return (e = Array.from(e)), UG(n), MG(n, e, i);
  };
  var UG = (t) => {
    let e = t.filter;
    t.mtimeCache || (t.mtimeCache = new Map()),
      (t.filter = e
        ? (i, n) => e(i, n) && !(t.mtimeCache.get(i) > n.mtime)
        : (i, n) => !(t.mtimeCache.get(i) > n.mtime));
  };
});
var F1 = P((Rse, D1) => {
  'use strict';
  var { promisify: L1 } = require('util'),
    ns = require('fs'),
    qG = (t) => {
      if (!t) t = { mode: 511, fs: ns };
      else if (typeof t == 'object') t = { mode: 511, fs: ns, ...t };
      else if (typeof t == 'number') t = { mode: t, fs: ns };
      else if (typeof t == 'string') t = { mode: parseInt(t, 8), fs: ns };
      else throw new TypeError('invalid options argument');
      return (
        (t.mkdir = t.mkdir || t.fs.mkdir || ns.mkdir),
        (t.mkdirAsync = L1(t.mkdir)),
        (t.stat = t.stat || t.fs.stat || ns.stat),
        (t.statAsync = L1(t.stat)),
        (t.statSync = t.statSync || t.fs.statSync || ns.statSync),
        (t.mkdirSync = t.mkdirSync || t.fs.mkdirSync || ns.mkdirSync),
        t
      );
    };
  D1.exports = qG;
});
var M1 = P((Tse, j1) => {
  'use strict';
  var BG = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform,
    { resolve: HG, parse: GG } = require('path'),
    zG = (t) => {
      if (/\0/.test(t))
        throw Object.assign(new TypeError('path must be a string without null bytes'), {
          path: t,
          code: 'ERR_INVALID_ARG_VALUE',
        });
      if (((t = HG(t)), BG === 'win32')) {
        let e = /[*|"<>?:]/,
          { root: i } = GG(t);
        if (e.test(t.substr(i.length)))
          throw Object.assign(new Error('Illegal characters in path.'), { path: t, code: 'EINVAL' });
      }
      return t;
    };
  j1.exports = zG;
});
var G1 = P((Ose, H1) => {
  'use strict';
  var { dirname: U1 } = require('path'),
    q1 = (t, e, i = void 0) =>
      i === e
        ? Promise.resolve()
        : t.statAsync(e).then(
            (n) => (n.isDirectory() ? i : void 0),
            (n) => (n.code === 'ENOENT' ? q1(t, U1(e), e) : void 0)
          ),
    B1 = (t, e, i = void 0) => {
      if (i !== e)
        try {
          return t.statSync(e).isDirectory() ? i : void 0;
        } catch (n) {
          return n.code === 'ENOENT' ? B1(t, U1(e), e) : void 0;
        }
    };
  H1.exports = { findMade: q1, findMadeSync: B1 };
});
var Cy = P((kse, V1) => {
  'use strict';
  var { dirname: z1 } = require('path'),
    _y = (t, e, i) => {
      e.recursive = !1;
      let n = z1(t);
      return n === t
        ? e.mkdirAsync(t, e).catch((r) => {
            if (r.code !== 'EISDIR') throw r;
          })
        : e.mkdirAsync(t, e).then(
            () => i || t,
            (r) => {
              if (r.code === 'ENOENT') return _y(n, e).then((s) => _y(t, e, s));
              if (r.code !== 'EEXIST' && r.code !== 'EROFS') throw r;
              return e.statAsync(t).then(
                (s) => {
                  if (s.isDirectory()) return i;
                  throw r;
                },
                () => {
                  throw r;
                }
              );
            }
          );
    },
    Sy = (t, e, i) => {
      let n = z1(t);
      if (((e.recursive = !1), n === t))
        try {
          return e.mkdirSync(t, e);
        } catch (r) {
          if (r.code !== 'EISDIR') throw r;
          return;
        }
      try {
        return e.mkdirSync(t, e), i || t;
      } catch (r) {
        if (r.code === 'ENOENT') return Sy(t, e, Sy(n, e, i));
        if (r.code !== 'EEXIST' && r.code !== 'EROFS') throw r;
        try {
          if (!e.statSync(t).isDirectory()) throw r;
        } catch {
          throw r;
        }
      }
    };
  V1.exports = { mkdirpManual: _y, mkdirpManualSync: Sy };
});
var K1 = P((Ase, W1) => {
  'use strict';
  var { dirname: $1 } = require('path'),
    { findMade: VG, findMadeSync: $G } = G1(),
    { mkdirpManual: WG, mkdirpManualSync: KG } = Cy(),
    XG = (t, e) => (
      (e.recursive = !0),
      $1(t) === t
        ? e.mkdirAsync(t, e)
        : VG(e, t).then((n) =>
            e
              .mkdirAsync(t, e)
              .then(() => n)
              .catch((r) => {
                if (r.code === 'ENOENT') return WG(t, e);
                throw r;
              })
          )
    ),
    YG = (t, e) => {
      if (((e.recursive = !0), $1(t) === t)) return e.mkdirSync(t, e);
      let n = $G(e, t);
      try {
        return e.mkdirSync(t, e), n;
      } catch (r) {
        if (r.code === 'ENOENT') return KG(t, e);
        throw r;
      }
    };
  W1.exports = { mkdirpNative: XG, mkdirpNativeSync: YG };
});
var Z1 = P((Ise, J1) => {
  'use strict';
  var X1 = require('fs'),
    JG = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version,
    Ry = JG.replace(/^v/, '').split('.'),
    Y1 = +Ry[0] > 10 || (+Ry[0] == 10 && +Ry[1] >= 12),
    ZG = Y1 ? (t) => t.mkdir === X1.mkdir : () => !1,
    QG = Y1 ? (t) => t.mkdirSync === X1.mkdirSync : () => !1;
  J1.exports = { useNative: ZG, useNativeSync: QG };
});
var rO = P((Nse, nO) => {
  'use strict';
  var Oa = F1(),
    ka = M1(),
    { mkdirpNative: Q1, mkdirpNativeSync: eO } = K1(),
    { mkdirpManual: tO, mkdirpManualSync: iO } = Cy(),
    { useNative: ez, useNativeSync: tz } = Z1(),
    Aa = (t, e) => ((t = ka(t)), (e = Oa(e)), ez(e) ? Q1(t, e) : tO(t, e)),
    iz = (t, e) => ((t = ka(t)), (e = Oa(e)), tz(e) ? eO(t, e) : iO(t, e));
  Aa.sync = iz;
  Aa.native = (t, e) => Q1(ka(t), Oa(e));
  Aa.manual = (t, e) => tO(ka(t), Oa(e));
  Aa.nativeSync = (t, e) => eO(ka(t), Oa(e));
  Aa.manualSync = (t, e) => iO(ka(t), Oa(e));
  nO.exports = Aa;
});
var pO = P((Pse, lO) => {
  'use strict';
  var Qi = require('fs'),
    ao = require('path'),
    nz = Qi.lchown ? 'lchown' : 'chown',
    rz = Qi.lchownSync ? 'lchownSync' : 'chownSync',
    oO = Qi.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/),
    sO = (t, e, i) => {
      try {
        return Qi[rz](t, e, i);
      } catch (n) {
        if (n.code !== 'ENOENT') throw n;
      }
    },
    sz = (t, e, i) => {
      try {
        return Qi.chownSync(t, e, i);
      } catch (n) {
        if (n.code !== 'ENOENT') throw n;
      }
    },
    oz = oO
      ? (t, e, i, n) => (r) => {
          !r || r.code !== 'EISDIR' ? n(r) : Qi.chown(t, e, i, n);
        }
      : (t, e, i, n) => n,
    Ty = oO
      ? (t, e, i) => {
          try {
            return sO(t, e, i);
          } catch (n) {
            if (n.code !== 'EISDIR') throw n;
            sz(t, e, i);
          }
        }
      : (t, e, i) => sO(t, e, i),
    az = process.version,
    aO = (t, e, i) => Qi.readdir(t, e, i),
    cz = (t, e) => Qi.readdirSync(t, e);
  /^v4\./.test(az) && (aO = (t, e, i) => Qi.readdir(t, i));
  var Cf = (t, e, i, n) => {
      Qi[nz](
        t,
        e,
        i,
        oz(t, e, i, (r) => {
          n(r && r.code !== 'ENOENT' ? r : null);
        })
      );
    },
    cO = (t, e, i, n, r) => {
      if (typeof e == 'string')
        return Qi.lstat(ao.resolve(t, e), (s, o) => {
          if (s) return r(s.code !== 'ENOENT' ? s : null);
          (o.name = e), cO(t, o, i, n, r);
        });
      if (e.isDirectory())
        Oy(ao.resolve(t, e.name), i, n, (s) => {
          if (s) return r(s);
          let o = ao.resolve(t, e.name);
          Cf(o, i, n, r);
        });
      else {
        let s = ao.resolve(t, e.name);
        Cf(s, i, n, r);
      }
    },
    Oy = (t, e, i, n) => {
      aO(t, { withFileTypes: !0 }, (r, s) => {
        if (r) {
          if (r.code === 'ENOENT') return n();
          if (r.code !== 'ENOTDIR' && r.code !== 'ENOTSUP') return n(r);
        }
        if (r || !s.length) return Cf(t, e, i, n);
        let o = s.length,
          c = null,
          u = (l) => {
            if (!c) {
              if (l) return n((c = l));
              if (--o === 0) return Cf(t, e, i, n);
            }
          };
        s.forEach((l) => cO(t, l, e, i, u));
      });
    },
    uz = (t, e, i, n) => {
      if (typeof e == 'string')
        try {
          let r = Qi.lstatSync(ao.resolve(t, e));
          (r.name = e), (e = r);
        } catch (r) {
          if (r.code === 'ENOENT') return;
          throw r;
        }
      e.isDirectory() && uO(ao.resolve(t, e.name), i, n), Ty(ao.resolve(t, e.name), i, n);
    },
    uO = (t, e, i) => {
      let n;
      try {
        n = cz(t, { withFileTypes: !0 });
      } catch (r) {
        if (r.code === 'ENOENT') return;
        if (r.code === 'ENOTDIR' || r.code === 'ENOTSUP') return Ty(t, e, i);
        throw r;
      }
      return n && n.length && n.forEach((r) => uz(t, r, e, i)), Ty(t, e, i);
    };
  lO.exports = Oy;
  Oy.sync = uO;
});
var mO = P((Lse, ky) => {
  'use strict';
  var fO = rO(),
    en = require('fs'),
    Rf = require('path'),
    dO = pO(),
    xn = da(),
    Tf = class extends Error {
      constructor(e, i) {
        super('Cannot extract through symbolic link'), (this.path = i), (this.symlink = e);
      }
      get name() {
        return 'SylinkError';
      }
    },
    Of = class extends Error {
      constructor(e, i) {
        super(i + ": Cannot cd into '" + e + "'"), (this.path = e), (this.code = i);
      }
      get name() {
        return 'CwdError';
      }
    },
    kf = (t, e) => t.get(xn(e)),
    du = (t, e, i) => t.set(xn(e), i),
    lz = (t, e) => {
      en.stat(t, (i, n) => {
        (i || !n.isDirectory()) && (i = new Of(t, (i && i.code) || 'ENOTDIR')), e(i);
      });
    };
  ky.exports = (t, e, i) => {
    t = xn(t);
    let n = e.umask,
      r = e.mode | 448,
      s = (r & n) !== 0,
      o = e.uid,
      c = e.gid,
      u = typeof o == 'number' && typeof c == 'number' && (o !== e.processUid || c !== e.processGid),
      l = e.preserve,
      p = e.unlink,
      d = e.cache,
      x = xn(e.cwd),
      b = (h, v) => {
        h ? i(h) : (du(d, t, !0), v && u ? dO(v, o, c, (C) => b(C)) : s ? en.chmod(t, r, i) : i());
      };
    if (d && kf(d, t) === !0) return b();
    if (t === x) return lz(t, b);
    if (l) return fO(t, { mode: r }).then((h) => b(null, h), b);
    let y = xn(Rf.relative(x, t)).split('/');
    Af(x, y, r, d, p, x, null, b);
  };
  var Af = (t, e, i, n, r, s, o, c) => {
      if (!e.length) return c(null, o);
      let u = e.shift(),
        l = xn(Rf.resolve(t + '/' + u));
      if (kf(n, l)) return Af(l, e, i, n, r, s, o, c);
      en.mkdir(l, i, hO(l, e, i, n, r, s, o, c));
    },
    hO = (t, e, i, n, r, s, o, c) => (u) => {
      u
        ? en.lstat(t, (l, p) => {
            if (l) (l.path = l.path && xn(l.path)), c(l);
            else if (p.isDirectory()) Af(t, e, i, n, r, s, o, c);
            else if (r)
              en.unlink(t, (d) => {
                if (d) return c(d);
                en.mkdir(t, i, hO(t, e, i, n, r, s, o, c));
              });
            else {
              if (p.isSymbolicLink()) return c(new Tf(t, t + '/' + e.join('/')));
              c(u);
            }
          })
        : ((o = o || t), Af(t, e, i, n, r, s, o, c));
    },
    pz = (t) => {
      let e = !1,
        i = 'ENOTDIR';
      try {
        e = en.statSync(t).isDirectory();
      } catch (n) {
        i = n.code;
      } finally {
        if (!e) throw new Of(t, i);
      }
    };
  ky.exports.sync = (t, e) => {
    t = xn(t);
    let i = e.umask,
      n = e.mode | 448,
      r = (n & i) !== 0,
      s = e.uid,
      o = e.gid,
      c = typeof s == 'number' && typeof o == 'number' && (s !== e.processUid || o !== e.processGid),
      u = e.preserve,
      l = e.unlink,
      p = e.cache,
      d = xn(e.cwd),
      x = (h) => {
        du(p, t, !0), h && c && dO.sync(h, s, o), r && en.chmodSync(t, n);
      };
    if (p && kf(p, t) === !0) return x();
    if (t === d) return pz(d), x();
    if (u) return x(fO.sync(t, n));
    let g = xn(Rf.relative(d, t)).split('/'),
      y = null;
    for (let h = g.shift(), v = d; h && (v += '/' + h); h = g.shift())
      if (((v = xn(Rf.resolve(v))), !kf(p, v)))
        try {
          en.mkdirSync(v, n), (y = y || v), du(p, v, !0);
        } catch {
          let _ = en.lstatSync(v);
          if (_.isDirectory()) {
            du(p, v, !0);
            continue;
          } else if (l) {
            en.unlinkSync(v), en.mkdirSync(v, n), (y = y || v), du(p, v, !0);
            continue;
          } else if (_.isSymbolicLink()) return new Tf(v, v + '/' + g.join('/'));
        }
    return x(y);
  };
});
var Iy = P((Dse, gO) => {
  'use strict';
  var Ay = Object.create(null),
    { hasOwnProperty: fz } = Object.prototype;
  gO.exports = (t) => (fz.call(Ay, t) || (Ay[t] = t.normalize('NFD')), Ay[t]);
});
var vO = P((Fse, bO) => {
  'use strict';
  var xO = require('assert'),
    dz = Iy(),
    hz = ga(),
    { join: yO } = require('path'),
    mz = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform,
    gz = mz === 'win32';
  bO.exports = () => {
    let t = new Map(),
      e = new Map(),
      i = (l) =>
        l
          .split('/')
          .slice(0, -1)
          .reduce((d, x) => (d.length && (x = yO(d[d.length - 1], x)), d.push(x || '/'), d), []),
      n = new Set(),
      r = (l) => {
        let p = e.get(l);
        if (!p) throw new Error('function does not have any path reservations');
        return { paths: p.paths.map((d) => t.get(d)), dirs: [...p.dirs].map((d) => t.get(d)) };
      },
      s = (l) => {
        let { paths: p, dirs: d } = r(l);
        return p.every((x) => x[0] === l) && d.every((x) => x[0] instanceof Set && x[0].has(l));
      },
      o = (l) => (n.has(l) || !s(l) ? !1 : (n.add(l), l(() => c(l)), !0)),
      c = (l) => {
        if (!n.has(l)) return !1;
        let { paths: p, dirs: d } = e.get(l),
          x = new Set();
        return (
          p.forEach((b) => {
            let g = t.get(b);
            xO.equal(g[0], l),
              g.length === 1
                ? t.delete(b)
                : (g.shift(), typeof g[0] == 'function' ? x.add(g[0]) : g[0].forEach((y) => x.add(y)));
          }),
          d.forEach((b) => {
            let g = t.get(b);
            xO(g[0] instanceof Set),
              g[0].size === 1 && g.length === 1
                ? t.delete(b)
                : g[0].size === 1
                ? (g.shift(), x.add(g[0]))
                : g[0].delete(l);
          }),
          n.delete(l),
          x.forEach((b) => o(b)),
          !0
        );
      };
    return {
      check: s,
      reserve: (l, p) => {
        l = gz ? ['win32 parallelization disabled'] : l.map((x) => hz(yO(dz(x))).toLowerCase());
        let d = new Set(l.map((x) => i(x)).reduce((x, b) => x.concat(b)));
        return (
          e.set(p, { dirs: d, paths: l }),
          l.forEach((x) => {
            let b = t.get(x);
            b ? b.push(p) : t.set(x, [p]);
          }),
          d.forEach((x) => {
            let b = t.get(x);
            b
              ? b[b.length - 1] instanceof Set
                ? b[b.length - 1].add(p)
                : b.push(new Set([p]))
              : t.set(x, [new Set([p])]);
          }),
          o(p)
        );
      },
    };
  };
});
var _O = P((jse, EO) => {
  'use strict';
  var xz = process.env.__FAKE_PLATFORM__ || process.platform,
    yz = xz === 'win32',
    bz = global.__FAKE_TESTING_FS__ || require('fs'),
    { O_CREAT: vz, O_TRUNC: wz, O_WRONLY: Ez, UV_FS_O_FILEMAP: wO = 0 } = bz.constants,
    _z = yz && !!wO,
    Sz = 512 * 1024,
    Cz = wO | wz | vz | Ez;
  EO.exports = _z ? (t) => (t < Sz ? Cz : 'w') : () => 'w';
});
var qy = P((Mse, jO) => {
  'use strict';
  var Rz = require('assert'),
    Tz = Ef(),
    Ye = require('fs'),
    Oz = Ra(),
    yr = require('path'),
    LO = mO(),
    SO = Lx(),
    kz = vO(),
    Az = Dx(),
    tn = da(),
    Iz = ga(),
    Nz = Iy(),
    CO = Symbol('onEntry'),
    Ly = Symbol('checkFs'),
    RO = Symbol('checkFs2'),
    Pf = Symbol('pruneCache'),
    Dy = Symbol('isReusable'),
    nn = Symbol('makeFs'),
    Fy = Symbol('file'),
    jy = Symbol('directory'),
    Lf = Symbol('link'),
    TO = Symbol('symlink'),
    OO = Symbol('hardlink'),
    kO = Symbol('unsupported'),
    AO = Symbol('checkPath'),
    rs = Symbol('mkdir'),
    pi = Symbol('onError'),
    If = Symbol('pending'),
    IO = Symbol('pend'),
    Ia = Symbol('unpend'),
    Ny = Symbol('ended'),
    Py = Symbol('maybeClose'),
    My = Symbol('skip'),
    hu = Symbol('doChown'),
    mu = Symbol('uid'),
    gu = Symbol('gid'),
    xu = Symbol('checkedCwd'),
    DO = require('crypto'),
    FO = _O(),
    Pz = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform,
    yu = Pz === 'win32',
    Lz = 1024,
    Dz = (t, e) => {
      if (!yu) return Ye.unlink(t, e);
      let i = t + '.DELETE.' + DO.randomBytes(16).toString('hex');
      Ye.rename(t, i, (n) => {
        if (n) return e(n);
        Ye.unlink(i, e);
      });
    },
    Fz = (t) => {
      if (!yu) return Ye.unlinkSync(t);
      let e = t + '.DELETE.' + DO.randomBytes(16).toString('hex');
      Ye.renameSync(t, e), Ye.unlinkSync(e);
    },
    NO = (t, e, i) => (t === t >>> 0 ? t : e === e >>> 0 ? e : i),
    PO = (t) => Iz(tn(Nz(t))).toLowerCase(),
    jz = (t, e) => {
      e = PO(e);
      for (let i of t.keys()) {
        let n = PO(i);
        (n === e || n.indexOf(e + '/') === 0) && t.delete(i);
      }
    },
    Mz = (t) => {
      for (let e of t.keys()) t.delete(e);
    },
    bu = class extends Tz {
      constructor(e) {
        if (
          (e || (e = {}),
          (e.ondone = (i) => {
            (this[Ny] = !0), this[Py]();
          }),
          super(e),
          (this[xu] = !1),
          (this.reservations = kz()),
          (this.transform = typeof e.transform == 'function' ? e.transform : null),
          (this.writable = !0),
          (this.readable = !1),
          (this[If] = 0),
          (this[Ny] = !1),
          (this.dirCache = e.dirCache || new Map()),
          typeof e.uid == 'number' || typeof e.gid == 'number')
        ) {
          if (typeof e.uid != 'number' || typeof e.gid != 'number')
            throw new TypeError('cannot set owner without number uid and gid');
          if (e.preserveOwner) throw new TypeError('cannot preserve owner in archive and also set owner explicitly');
          (this.uid = e.uid), (this.gid = e.gid), (this.setOwner = !0);
        } else (this.uid = null), (this.gid = null), (this.setOwner = !1);
        e.preserveOwner === void 0 && typeof e.uid != 'number'
          ? (this.preserveOwner = process.getuid && process.getuid() === 0)
          : (this.preserveOwner = !!e.preserveOwner),
          (this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null),
          (this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null),
          (this.maxDepth = typeof e.maxDepth == 'number' ? e.maxDepth : Lz),
          (this.forceChown = e.forceChown === !0),
          (this.win32 = !!e.win32 || yu),
          (this.newer = !!e.newer),
          (this.keep = !!e.keep),
          (this.noMtime = !!e.noMtime),
          (this.preservePaths = !!e.preservePaths),
          (this.unlink = !!e.unlink),
          (this.cwd = tn(yr.resolve(e.cwd || process.cwd()))),
          (this.strip = +e.strip || 0),
          (this.processUmask = e.noChmod ? 0 : process.umask()),
          (this.umask = typeof e.umask == 'number' ? e.umask : this.processUmask),
          (this.dmode = e.dmode || 511 & ~this.umask),
          (this.fmode = e.fmode || 438 & ~this.umask),
          this.on('entry', (i) => this[CO](i));
      }
      warn(e, i, n = {}) {
        return (e === 'TAR_BAD_ARCHIVE' || e === 'TAR_ABORT') && (n.recoverable = !1), super.warn(e, i, n);
      }
      [Py]() {
        this[Ny] && this[If] === 0 && (this.emit('prefinish'), this.emit('finish'), this.emit('end'));
      }
      [AO](e) {
        let i = tn(e.path),
          n = i.split('/');
        if (this.strip) {
          if (n.length < this.strip) return !1;
          if (e.type === 'Link') {
            let r = tn(e.linkpath).split('/');
            if (r.length >= this.strip) e.linkpath = r.slice(this.strip).join('/');
            else return !1;
          }
          n.splice(0, this.strip), (e.path = n.join('/'));
        }
        if (isFinite(this.maxDepth) && n.length > this.maxDepth)
          return (
            this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {
              entry: e,
              path: i,
              depth: n.length,
              maxDepth: this.maxDepth,
            }),
            !1
          );
        if (!this.preservePaths) {
          if (n.includes('..') || (yu && /^[a-z]:\.\.$/i.test(n[0])))
            return this.warn('TAR_ENTRY_ERROR', "path contains '..'", { entry: e, path: i }), !1;
          let [r, s] = Az(i);
          r && ((e.path = s), this.warn('TAR_ENTRY_INFO', `stripping ${r} from absolute path`, { entry: e, path: i }));
        }
        if (
          (yr.isAbsolute(e.path)
            ? (e.absolute = tn(yr.resolve(e.path)))
            : (e.absolute = tn(yr.resolve(this.cwd, e.path))),
          !this.preservePaths && e.absolute.indexOf(this.cwd + '/') !== 0 && e.absolute !== this.cwd)
        )
          return (
            this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {
              entry: e,
              path: tn(e.path),
              resolvedPath: e.absolute,
              cwd: this.cwd,
            }),
            !1
          );
        if (e.absolute === this.cwd && e.type !== 'Directory' && e.type !== 'GNUDumpDir') return !1;
        if (this.win32) {
          let { root: r } = yr.win32.parse(e.absolute);
          e.absolute = r + SO.encode(e.absolute.slice(r.length));
          let { root: s } = yr.win32.parse(e.path);
          e.path = s + SO.encode(e.path.slice(s.length));
        }
        return !0;
      }
      [CO](e) {
        if (!this[AO](e)) return e.resume();
        switch ((Rz.equal(typeof e.absolute, 'string'), e.type)) {
          case 'Directory':
          case 'GNUDumpDir':
            e.mode && (e.mode = e.mode | 448);
          case 'File':
          case 'OldFile':
          case 'ContiguousFile':
          case 'Link':
          case 'SymbolicLink':
            return this[Ly](e);
          case 'CharacterDevice':
          case 'BlockDevice':
          case 'FIFO':
          default:
            return this[kO](e);
        }
      }
      [pi](e, i) {
        e.name === 'CwdError'
          ? this.emit('error', e)
          : (this.warn('TAR_ENTRY_ERROR', e, { entry: i }), this[Ia](), i.resume());
      }
      [rs](e, i, n) {
        LO(
          tn(e),
          {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode: i,
            noChmod: this.noChmod,
          },
          n
        );
      }
      [hu](e) {
        return (
          this.forceChown ||
          (this.preserveOwner &&
            ((typeof e.uid == 'number' && e.uid !== this.processUid) ||
              (typeof e.gid == 'number' && e.gid !== this.processGid))) ||
          (typeof this.uid == 'number' && this.uid !== this.processUid) ||
          (typeof this.gid == 'number' && this.gid !== this.processGid)
        );
      }
      [mu](e) {
        return NO(this.uid, e.uid, this.processUid);
      }
      [gu](e) {
        return NO(this.gid, e.gid, this.processGid);
      }
      [Fy](e, i) {
        let n = e.mode & 4095 || this.fmode,
          r = new Oz.WriteStream(e.absolute, { flags: FO(e.size), mode: n, autoClose: !1 });
        r.on('error', (u) => {
          r.fd && Ye.close(r.fd, () => {}), (r.write = () => !0), this[pi](u, e), i();
        });
        let s = 1,
          o = (u) => {
            if (u) {
              r.fd && Ye.close(r.fd, () => {}), this[pi](u, e), i();
              return;
            }
            --s === 0 &&
              Ye.close(r.fd, (l) => {
                l ? this[pi](l, e) : this[Ia](), i();
              });
          };
        r.on('finish', (u) => {
          let l = e.absolute,
            p = r.fd;
          if (e.mtime && !this.noMtime) {
            s++;
            let d = e.atime || new Date(),
              x = e.mtime;
            Ye.futimes(p, d, x, (b) => (b ? Ye.utimes(l, d, x, (g) => o(g && b)) : o()));
          }
          if (this[hu](e)) {
            s++;
            let d = this[mu](e),
              x = this[gu](e);
            Ye.fchown(p, d, x, (b) => (b ? Ye.chown(l, d, x, (g) => o(g && b)) : o()));
          }
          o();
        });
        let c = (this.transform && this.transform(e)) || e;
        c !== e &&
          (c.on('error', (u) => {
            this[pi](u, e), i();
          }),
          e.pipe(c)),
          c.pipe(r);
      }
      [jy](e, i) {
        let n = e.mode & 4095 || this.dmode;
        this[rs](e.absolute, n, (r) => {
          if (r) {
            this[pi](r, e), i();
            return;
          }
          let s = 1,
            o = (c) => {
              --s === 0 && (i(), this[Ia](), e.resume());
            };
          e.mtime && !this.noMtime && (s++, Ye.utimes(e.absolute, e.atime || new Date(), e.mtime, o)),
            this[hu](e) && (s++, Ye.chown(e.absolute, this[mu](e), this[gu](e), o)),
            o();
        });
      }
      [kO](e) {
        (e.unsupported = !0),
          this.warn('TAR_ENTRY_UNSUPPORTED', `unsupported entry type: ${e.type}`, { entry: e }),
          e.resume();
      }
      [TO](e, i) {
        this[Lf](e, e.linkpath, 'symlink', i);
      }
      [OO](e, i) {
        let n = tn(yr.resolve(this.cwd, e.linkpath));
        this[Lf](e, n, 'link', i);
      }
      [IO]() {
        this[If]++;
      }
      [Ia]() {
        this[If]--, this[Py]();
      }
      [My](e) {
        this[Ia](), e.resume();
      }
      [Dy](e, i) {
        return e.type === 'File' && !this.unlink && i.isFile() && i.nlink <= 1 && !yu;
      }
      [Ly](e) {
        this[IO]();
        let i = [e.path];
        e.linkpath && i.push(e.linkpath), this.reservations.reserve(i, (n) => this[RO](e, n));
      }
      [Pf](e) {
        e.type === 'SymbolicLink' ? Mz(this.dirCache) : e.type !== 'Directory' && jz(this.dirCache, e.absolute);
      }
      [RO](e, i) {
        this[Pf](e);
        let n = (c) => {
            this[Pf](e), i(c);
          },
          r = () => {
            this[rs](this.cwd, this.dmode, (c) => {
              if (c) {
                this[pi](c, e), n();
                return;
              }
              (this[xu] = !0), s();
            });
          },
          s = () => {
            if (e.absolute !== this.cwd) {
              let c = tn(yr.dirname(e.absolute));
              if (c !== this.cwd)
                return this[rs](c, this.dmode, (u) => {
                  if (u) {
                    this[pi](u, e), n();
                    return;
                  }
                  o();
                });
            }
            o();
          },
          o = () => {
            Ye.lstat(e.absolute, (c, u) => {
              if (u && (this.keep || (this.newer && u.mtime > e.mtime))) {
                this[My](e), n();
                return;
              }
              if (c || this[Dy](e, u)) return this[nn](null, e, n);
              if (u.isDirectory()) {
                if (e.type === 'Directory') {
                  let l = !this.noChmod && e.mode && (u.mode & 4095) !== e.mode,
                    p = (d) => this[nn](d, e, n);
                  return l ? Ye.chmod(e.absolute, e.mode, p) : p();
                }
                if (e.absolute !== this.cwd) return Ye.rmdir(e.absolute, (l) => this[nn](l, e, n));
              }
              if (e.absolute === this.cwd) return this[nn](null, e, n);
              Dz(e.absolute, (l) => this[nn](l, e, n));
            });
          };
        this[xu] ? s() : r();
      }
      [nn](e, i, n) {
        if (e) {
          this[pi](e, i), n();
          return;
        }
        switch (i.type) {
          case 'File':
          case 'OldFile':
          case 'ContiguousFile':
            return this[Fy](i, n);
          case 'Link':
            return this[OO](i, n);
          case 'SymbolicLink':
            return this[TO](i, n);
          case 'Directory':
          case 'GNUDumpDir':
            return this[jy](i, n);
        }
      }
      [Lf](e, i, n, r) {
        Ye[n](i, e.absolute, (s) => {
          s ? this[pi](s, e) : (this[Ia](), e.resume()), r();
        });
      }
    },
    Nf = (t) => {
      try {
        return [null, t()];
      } catch (e) {
        return [e, null];
      }
    },
    Uy = class extends bu {
      [nn](e, i) {
        return super[nn](e, i, () => {});
      }
      [Ly](e) {
        if ((this[Pf](e), !this[xu])) {
          let s = this[rs](this.cwd, this.dmode);
          if (s) return this[pi](s, e);
          this[xu] = !0;
        }
        if (e.absolute !== this.cwd) {
          let s = tn(yr.dirname(e.absolute));
          if (s !== this.cwd) {
            let o = this[rs](s, this.dmode);
            if (o) return this[pi](o, e);
          }
        }
        let [i, n] = Nf(() => Ye.lstatSync(e.absolute));
        if (n && (this.keep || (this.newer && n.mtime > e.mtime))) return this[My](e);
        if (i || this[Dy](e, n)) return this[nn](null, e);
        if (n.isDirectory()) {
          if (e.type === 'Directory') {
            let o = !this.noChmod && e.mode && (n.mode & 4095) !== e.mode,
              [c] = o
                ? Nf(() => {
                    Ye.chmodSync(e.absolute, e.mode);
                  })
                : [];
            return this[nn](c, e);
          }
          let [s] = Nf(() => Ye.rmdirSync(e.absolute));
          this[nn](s, e);
        }
        let [r] = e.absolute === this.cwd ? [] : Nf(() => Fz(e.absolute));
        this[nn](r, e);
      }
      [Fy](e, i) {
        let n = e.mode & 4095 || this.fmode,
          r = (c) => {
            let u;
            try {
              Ye.closeSync(s);
            } catch (l) {
              u = l;
            }
            (c || u) && this[pi](c || u, e), i();
          },
          s;
        try {
          s = Ye.openSync(e.absolute, FO(e.size), n);
        } catch (c) {
          return r(c);
        }
        let o = (this.transform && this.transform(e)) || e;
        o !== e && (o.on('error', (c) => this[pi](c, e)), e.pipe(o)),
          o.on('data', (c) => {
            try {
              Ye.writeSync(s, c, 0, c.length);
            } catch (u) {
              r(u);
            }
          }),
          o.on('end', (c) => {
            let u = null;
            if (e.mtime && !this.noMtime) {
              let l = e.atime || new Date(),
                p = e.mtime;
              try {
                Ye.futimesSync(s, l, p);
              } catch (d) {
                try {
                  Ye.utimesSync(e.absolute, l, p);
                } catch {
                  u = d;
                }
              }
            }
            if (this[hu](e)) {
              let l = this[mu](e),
                p = this[gu](e);
              try {
                Ye.fchownSync(s, l, p);
              } catch (d) {
                try {
                  Ye.chownSync(e.absolute, l, p);
                } catch {
                  u = u || d;
                }
              }
            }
            r(u);
          });
      }
      [jy](e, i) {
        let n = e.mode & 4095 || this.dmode,
          r = this[rs](e.absolute, n);
        if (r) {
          this[pi](r, e), i();
          return;
        }
        if (e.mtime && !this.noMtime)
          try {
            Ye.utimesSync(e.absolute, e.atime || new Date(), e.mtime);
          } catch {}
        if (this[hu](e))
          try {
            Ye.chownSync(e.absolute, this[mu](e), this[gu](e));
          } catch {}
        i(), e.resume();
      }
      [rs](e, i) {
        try {
          return LO.sync(tn(e), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode: i,
          });
        } catch (n) {
          return n;
        }
      }
      [Lf](e, i, n, r) {
        try {
          Ye[n + 'Sync'](i, e.absolute), r(), e.resume();
        } catch (s) {
          return this[pi](s, e);
        }
      }
    };
  bu.Sync = Uy;
  jO.exports = bu;
});
var HO = P((Use, BO) => {
  'use strict';
  var Uz = ca(),
    Df = qy(),
    UO = require('fs'),
    qO = Ra(),
    MO = require('path'),
    By = ga();
  BO.exports = (t, e, i) => {
    typeof t == 'function' ? ((i = t), (e = null), (t = {})) : Array.isArray(t) && ((e = t), (t = {})),
      typeof e == 'function' && ((i = e), (e = null)),
      e ? (e = Array.from(e)) : (e = []);
    let n = Uz(t);
    if (n.sync && typeof i == 'function') throw new TypeError('callback not supported for sync tar functions');
    if (!n.file && typeof i == 'function') throw new TypeError('callback only supported with file option');
    return e.length && qz(n, e), n.file && n.sync ? Bz(n) : n.file ? Hz(n, i) : n.sync ? Gz(n) : zz(n);
  };
  var qz = (t, e) => {
      let i = new Map(e.map((s) => [By(s), !0])),
        n = t.filter,
        r = (s, o) => {
          let c = o || MO.parse(s).root || '.',
            u = s === c ? !1 : i.has(s) ? i.get(s) : r(MO.dirname(s), c);
          return i.set(s, u), u;
        };
      t.filter = n ? (s, o) => n(s, o) && r(By(s)) : (s) => r(By(s));
    },
    Bz = (t) => {
      let e = new Df.Sync(t),
        i = t.file,
        n = UO.statSync(i),
        r = t.maxReadSize || 16 * 1024 * 1024;
      new qO.ReadStreamSync(i, { readSize: r, size: n.size }).pipe(e);
    },
    Hz = (t, e) => {
      let i = new Df(t),
        n = t.maxReadSize || 16 * 1024 * 1024,
        r = t.file,
        s = new Promise((o, c) => {
          i.on('error', c),
            i.on('close', o),
            UO.stat(r, (u, l) => {
              if (u) c(u);
              else {
                let p = new qO.ReadStream(r, { readSize: n, size: l.size });
                p.on('error', c), p.pipe(i);
              }
            });
        });
      return e ? s.then(e, e) : s;
    },
    Gz = (t) => new Df.Sync(t),
    zz = (t) => new Df(t);
});
var GO = P((jt) => {
  'use strict';
  jt.c = jt.create = S1();
  jt.r = jt.replace = Ey();
  jt.t = jt.list = _f();
  jt.u = jt.update = P1();
  jt.x = jt.extract = HO();
  jt.Pack = nf();
  jt.Unpack = qy();
  jt.Parse = Ef();
  jt.ReadEntry = Up();
  jt.WriteEntry = Vx();
  jt.Header = ma();
  jt.Pax = Bp();
  jt.types = Tx();
});
var Xt = P((Hy) => {
  'use strict';
  Hy.fromCallback = function (t) {
    return Object.defineProperty(
      function (...e) {
        if (typeof e[e.length - 1] == 'function') t.apply(this, e);
        else
          return new Promise((i, n) => {
            t.call(this, ...e, (r, s) => (r != null ? n(r) : i(s)));
          });
      },
      'name',
      { value: t.name }
    );
  };
  Hy.fromPromise = function (t) {
    return Object.defineProperty(
      function (...e) {
        let i = e[e.length - 1];
        if (typeof i != 'function') return t.apply(this, e);
        t.apply(this, e.slice(0, -1)).then((n) => i(null, n), i);
      },
      'name',
      { value: t.name }
    );
  };
});
var VO = P((Hse, zO) => {
  'use strict';
  var ss = require('constants'),
    Vz = process.cwd,
    Ff = null,
    $z = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function () {
    return Ff || (Ff = Vz.call(process)), Ff;
  };
  try {
    process.cwd();
  } catch {}
  typeof process.chdir == 'function' &&
    ((Gy = process.chdir),
    (process.chdir = function (t) {
      (Ff = null), Gy.call(process, t);
    }),
    Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, Gy));
  var Gy;
  zO.exports = Wz;
  function Wz(t) {
    ss.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && e(t),
      t.lutimes || i(t),
      (t.chown = s(t.chown)),
      (t.fchown = s(t.fchown)),
      (t.lchown = s(t.lchown)),
      (t.chmod = n(t.chmod)),
      (t.fchmod = n(t.fchmod)),
      (t.lchmod = n(t.lchmod)),
      (t.chownSync = o(t.chownSync)),
      (t.fchownSync = o(t.fchownSync)),
      (t.lchownSync = o(t.lchownSync)),
      (t.chmodSync = r(t.chmodSync)),
      (t.fchmodSync = r(t.fchmodSync)),
      (t.lchmodSync = r(t.lchmodSync)),
      (t.stat = c(t.stat)),
      (t.fstat = c(t.fstat)),
      (t.lstat = c(t.lstat)),
      (t.statSync = u(t.statSync)),
      (t.fstatSync = u(t.fstatSync)),
      (t.lstatSync = u(t.lstatSync)),
      t.chmod &&
        !t.lchmod &&
        ((t.lchmod = function (p, d, x) {
          x && process.nextTick(x);
        }),
        (t.lchmodSync = function () {})),
      t.chown &&
        !t.lchown &&
        ((t.lchown = function (p, d, x, b) {
          b && process.nextTick(b);
        }),
        (t.lchownSync = function () {})),
      $z === 'win32' &&
        (t.rename =
          typeof t.rename != 'function'
            ? t.rename
            : (function (p) {
                function d(x, b, g) {
                  var y = Date.now(),
                    h = 0;
                  p(x, b, function v(C) {
                    if (
                      C &&
                      (C.code === 'EACCES' || C.code === 'EPERM' || C.code === 'EBUSY') &&
                      Date.now() - y < 6e4
                    ) {
                      setTimeout(function () {
                        t.stat(b, function (_, m) {
                          _ && _.code === 'ENOENT' ? p(x, b, v) : g(C);
                        });
                      }, h),
                        h < 100 && (h += 10);
                      return;
                    }
                    g && g(C);
                  });
                }
                return Object.setPrototypeOf && Object.setPrototypeOf(d, p), d;
              })(t.rename)),
      (t.read =
        typeof t.read != 'function'
          ? t.read
          : (function (p) {
              function d(x, b, g, y, h, v) {
                var C;
                if (v && typeof v == 'function') {
                  var _ = 0;
                  C = function (m, O, N) {
                    if (m && m.code === 'EAGAIN' && _ < 10) return _++, p.call(t, x, b, g, y, h, C);
                    v.apply(this, arguments);
                  };
                }
                return p.call(t, x, b, g, y, h, C);
              }
              return Object.setPrototypeOf && Object.setPrototypeOf(d, p), d;
            })(t.read)),
      (t.readSync =
        typeof t.readSync != 'function'
          ? t.readSync
          : (function (p) {
              return function (d, x, b, g, y) {
                for (var h = 0; ; )
                  try {
                    return p.call(t, d, x, b, g, y);
                  } catch (v) {
                    if (v.code === 'EAGAIN' && h < 10) {
                      h++;
                      continue;
                    }
                    throw v;
                  }
              };
            })(t.readSync));
    function e(p) {
      (p.lchmod = function (d, x, b) {
        p.open(d, ss.O_WRONLY | ss.O_SYMLINK, x, function (g, y) {
          if (g) {
            b && b(g);
            return;
          }
          p.fchmod(y, x, function (h) {
            p.close(y, function (v) {
              b && b(h || v);
            });
          });
        });
      }),
        (p.lchmodSync = function (d, x) {
          var b = p.openSync(d, ss.O_WRONLY | ss.O_SYMLINK, x),
            g = !0,
            y;
          try {
            (y = p.fchmodSync(b, x)), (g = !1);
          } finally {
            if (g)
              try {
                p.closeSync(b);
              } catch {}
            else p.closeSync(b);
          }
          return y;
        });
    }
    function i(p) {
      ss.hasOwnProperty('O_SYMLINK') && p.futimes
        ? ((p.lutimes = function (d, x, b, g) {
            p.open(d, ss.O_SYMLINK, function (y, h) {
              if (y) {
                g && g(y);
                return;
              }
              p.futimes(h, x, b, function (v) {
                p.close(h, function (C) {
                  g && g(v || C);
                });
              });
            });
          }),
          (p.lutimesSync = function (d, x, b) {
            var g = p.openSync(d, ss.O_SYMLINK),
              y,
              h = !0;
            try {
              (y = p.futimesSync(g, x, b)), (h = !1);
            } finally {
              if (h)
                try {
                  p.closeSync(g);
                } catch {}
              else p.closeSync(g);
            }
            return y;
          }))
        : p.futimes &&
          ((p.lutimes = function (d, x, b, g) {
            g && process.nextTick(g);
          }),
          (p.lutimesSync = function () {}));
    }
    function n(p) {
      return (
        p &&
        function (d, x, b) {
          return p.call(t, d, x, function (g) {
            l(g) && (g = null), b && b.apply(this, arguments);
          });
        }
      );
    }
    function r(p) {
      return (
        p &&
        function (d, x) {
          try {
            return p.call(t, d, x);
          } catch (b) {
            if (!l(b)) throw b;
          }
        }
      );
    }
    function s(p) {
      return (
        p &&
        function (d, x, b, g) {
          return p.call(t, d, x, b, function (y) {
            l(y) && (y = null), g && g.apply(this, arguments);
          });
        }
      );
    }
    function o(p) {
      return (
        p &&
        function (d, x, b) {
          try {
            return p.call(t, d, x, b);
          } catch (g) {
            if (!l(g)) throw g;
          }
        }
      );
    }
    function c(p) {
      return (
        p &&
        function (d, x, b) {
          typeof x == 'function' && ((b = x), (x = null));
          function g(y, h) {
            h && (h.uid < 0 && (h.uid += 4294967296), h.gid < 0 && (h.gid += 4294967296)),
              b && b.apply(this, arguments);
          }
          return x ? p.call(t, d, x, g) : p.call(t, d, g);
        }
      );
    }
    function u(p) {
      return (
        p &&
        function (d, x) {
          var b = x ? p.call(t, d, x) : p.call(t, d);
          return b && (b.uid < 0 && (b.uid += 4294967296), b.gid < 0 && (b.gid += 4294967296)), b;
        }
      );
    }
    function l(p) {
      if (!p || p.code === 'ENOSYS') return !0;
      var d = !process.getuid || process.getuid() !== 0;
      return !!(d && (p.code === 'EINVAL' || p.code === 'EPERM'));
    }
  }
});
var KO = P((Gse, WO) => {
  'use strict';
  var $O = require('stream').Stream;
  WO.exports = Kz;
  function Kz(t) {
    return { ReadStream: e, WriteStream: i };
    function e(n, r) {
      if (!(this instanceof e)) return new e(n, r);
      $O.call(this);
      var s = this;
      (this.path = n),
        (this.fd = null),
        (this.readable = !0),
        (this.paused = !1),
        (this.flags = 'r'),
        (this.mode = 438),
        (this.bufferSize = 64 * 1024),
        (r = r || {});
      for (var o = Object.keys(r), c = 0, u = o.length; c < u; c++) {
        var l = o[c];
        this[l] = r[l];
      }
      if ((this.encoding && this.setEncoding(this.encoding), this.start !== void 0)) {
        if (typeof this.start != 'number') throw TypeError('start must be a Number');
        if (this.end === void 0) this.end = 1 / 0;
        else if (typeof this.end != 'number') throw TypeError('end must be a Number');
        if (this.start > this.end) throw new Error('start must be <= end');
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function () {
          s._read();
        });
        return;
      }
      t.open(this.path, this.flags, this.mode, function (p, d) {
        if (p) {
          s.emit('error', p), (s.readable = !1);
          return;
        }
        (s.fd = d), s.emit('open', d), s._read();
      });
    }
    function i(n, r) {
      if (!(this instanceof i)) return new i(n, r);
      $O.call(this),
        (this.path = n),
        (this.fd = null),
        (this.writable = !0),
        (this.flags = 'w'),
        (this.encoding = 'binary'),
        (this.mode = 438),
        (this.bytesWritten = 0),
        (r = r || {});
      for (var s = Object.keys(r), o = 0, c = s.length; o < c; o++) {
        var u = s[o];
        this[u] = r[u];
      }
      if (this.start !== void 0) {
        if (typeof this.start != 'number') throw TypeError('start must be a Number');
        if (this.start < 0) throw new Error('start must be >= zero');
        this.pos = this.start;
      }
      (this.busy = !1),
        (this._queue = []),
        this.fd === null &&
          ((this._open = t.open),
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]),
          this.flush());
    }
  }
});
var YO = P((zse, XO) => {
  'use strict';
  XO.exports = Yz;
  var Xz =
    Object.getPrototypeOf ||
    function (t) {
      return t.__proto__;
    };
  function Yz(t) {
    if (t === null || typeof t != 'object') return t;
    if (t instanceof Object) var e = { __proto__: Xz(t) };
    else var e = Object.create(null);
    return (
      Object.getOwnPropertyNames(t).forEach(function (i) {
        Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(t, i));
      }),
      e
    );
  }
});
var Pa = P((Vse, $y) => {
  'use strict';
  var ht = require('fs'),
    Jz = VO(),
    Zz = KO(),
    Qz = YO(),
    jf = require('util'),
    ii,
    Uf;
  typeof Symbol == 'function' && typeof Symbol.for == 'function'
    ? ((ii = Symbol.for('graceful-fs.queue')), (Uf = Symbol.for('graceful-fs.previous')))
    : ((ii = '___graceful-fs.queue'), (Uf = '___graceful-fs.previous'));
  function eV() {}
  function QO(t, e) {
    Object.defineProperty(t, ii, {
      get: function () {
        return e;
      },
    });
  }
  var co = eV;
  jf.debuglog
    ? (co = jf.debuglog('gfs4'))
    : /\bgfs4\b/i.test(process.env.NODE_DEBUG || '') &&
      (co = function () {
        var t = jf.format.apply(jf, arguments);
        (t =
          'GFS4: ' +
          t.split(/\n/).join(`
GFS4: `)),
          console.error(t);
      });
  ht[ii] ||
    ((JO = global[ii] || []),
    QO(ht, JO),
    (ht.close = (function (t) {
      function e(i, n) {
        return t.call(ht, i, function (r) {
          r || ZO(), typeof n == 'function' && n.apply(this, arguments);
        });
      }
      return Object.defineProperty(e, Uf, { value: t }), e;
    })(ht.close)),
    (ht.closeSync = (function (t) {
      function e(i) {
        t.apply(ht, arguments), ZO();
      }
      return Object.defineProperty(e, Uf, { value: t }), e;
    })(ht.closeSync)),
    /\bgfs4\b/i.test(process.env.NODE_DEBUG || '') &&
      process.on('exit', function () {
        co(ht[ii]), require('assert').equal(ht[ii].length, 0);
      }));
  var JO;
  global[ii] || QO(global, ht[ii]);
  $y.exports = zy(Qz(ht));
  process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !ht.__patched && (($y.exports = zy(ht)), (ht.__patched = !0));
  function zy(t) {
    Jz(t), (t.gracefulify = zy), (t.createReadStream = O), (t.createWriteStream = N);
    var e = t.readFile;
    t.readFile = i;
    function i(H, F, ne) {
      return typeof F == 'function' && ((ne = F), (F = null)), pe(H, F, ne);
      function pe(le, V, W, K) {
        return e(le, V, function (q) {
          q && (q.code === 'EMFILE' || q.code === 'ENFILE')
            ? Na([pe, [le, V, W], q, K || Date.now(), Date.now()])
            : typeof W == 'function' && W.apply(this, arguments);
        });
      }
    }
    var n = t.writeFile;
    t.writeFile = r;
    function r(H, F, ne, pe) {
      return typeof ne == 'function' && ((pe = ne), (ne = null)), le(H, F, ne, pe);
      function le(V, W, K, q, B) {
        return n(V, W, K, function (ee) {
          ee && (ee.code === 'EMFILE' || ee.code === 'ENFILE')
            ? Na([le, [V, W, K, q], ee, B || Date.now(), Date.now()])
            : typeof q == 'function' && q.apply(this, arguments);
        });
      }
    }
    var s = t.appendFile;
    s && (t.appendFile = o);
    function o(H, F, ne, pe) {
      return typeof ne == 'function' && ((pe = ne), (ne = null)), le(H, F, ne, pe);
      function le(V, W, K, q, B) {
        return s(V, W, K, function (ee) {
          ee && (ee.code === 'EMFILE' || ee.code === 'ENFILE')
            ? Na([le, [V, W, K, q], ee, B || Date.now(), Date.now()])
            : typeof q == 'function' && q.apply(this, arguments);
        });
      }
    }
    var c = t.copyFile;
    c && (t.copyFile = u);
    function u(H, F, ne, pe) {
      return typeof ne == 'function' && ((pe = ne), (ne = 0)), le(H, F, ne, pe);
      function le(V, W, K, q, B) {
        return c(V, W, K, function (ee) {
          ee && (ee.code === 'EMFILE' || ee.code === 'ENFILE')
            ? Na([le, [V, W, K, q], ee, B || Date.now(), Date.now()])
            : typeof q == 'function' && q.apply(this, arguments);
        });
      }
    }
    var l = t.readdir;
    t.readdir = d;
    var p = /^v[0-5]\./;
    function d(H, F, ne) {
      typeof F == 'function' && ((ne = F), (F = null));
      var pe = p.test(process.version)
        ? function (W, K, q, B) {
            return l(W, le(W, K, q, B));
          }
        : function (W, K, q, B) {
            return l(W, K, le(W, K, q, B));
          };
      return pe(H, F, ne);
      function le(V, W, K, q) {
        return function (B, ee) {
          B && (B.code === 'EMFILE' || B.code === 'ENFILE')
            ? Na([pe, [V, W, K], B, q || Date.now(), Date.now()])
            : (ee && ee.sort && ee.sort(), typeof K == 'function' && K.call(this, B, ee));
        };
      }
    }
    if (process.version.substr(0, 4) === 'v0.8') {
      var x = Zz(t);
      (v = x.ReadStream), (_ = x.WriteStream);
    }
    var b = t.ReadStream;
    b && ((v.prototype = Object.create(b.prototype)), (v.prototype.open = C));
    var g = t.WriteStream;
    g && ((_.prototype = Object.create(g.prototype)), (_.prototype.open = m)),
      Object.defineProperty(t, 'ReadStream', {
        get: function () {
          return v;
        },
        set: function (H) {
          v = H;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(t, 'WriteStream', {
        get: function () {
          return _;
        },
        set: function (H) {
          _ = H;
        },
        enumerable: !0,
        configurable: !0,
      });
    var y = v;
    Object.defineProperty(t, 'FileReadStream', {
      get: function () {
        return y;
      },
      set: function (H) {
        y = H;
      },
      enumerable: !0,
      configurable: !0,
    });
    var h = _;
    Object.defineProperty(t, 'FileWriteStream', {
      get: function () {
        return h;
      },
      set: function (H) {
        h = H;
      },
      enumerable: !0,
      configurable: !0,
    });
    function v(H, F) {
      return this instanceof v ? (b.apply(this, arguments), this) : v.apply(Object.create(v.prototype), arguments);
    }
    function C() {
      var H = this;
      z(H.path, H.flags, H.mode, function (F, ne) {
        F ? (H.autoClose && H.destroy(), H.emit('error', F)) : ((H.fd = ne), H.emit('open', ne), H.read());
      });
    }
    function _(H, F) {
      return this instanceof _ ? (g.apply(this, arguments), this) : _.apply(Object.create(_.prototype), arguments);
    }
    function m() {
      var H = this;
      z(H.path, H.flags, H.mode, function (F, ne) {
        F ? (H.destroy(), H.emit('error', F)) : ((H.fd = ne), H.emit('open', ne));
      });
    }
    function O(H, F) {
      return new t.ReadStream(H, F);
    }
    function N(H, F) {
      return new t.WriteStream(H, F);
    }
    var D = t.open;
    t.open = z;
    function z(H, F, ne, pe) {
      return typeof ne == 'function' && ((pe = ne), (ne = null)), le(H, F, ne, pe);
      function le(V, W, K, q, B) {
        return D(V, W, K, function (ee, xe) {
          ee && (ee.code === 'EMFILE' || ee.code === 'ENFILE')
            ? Na([le, [V, W, K, q], ee, B || Date.now(), Date.now()])
            : typeof q == 'function' && q.apply(this, arguments);
        });
      }
    }
    return t;
  }
  function Na(t) {
    co('ENQUEUE', t[0].name, t[1]), ht[ii].push(t), Vy();
  }
  var Mf;
  function ZO() {
    for (var t = Date.now(), e = 0; e < ht[ii].length; ++e)
      ht[ii][e].length > 2 && ((ht[ii][e][3] = t), (ht[ii][e][4] = t));
    Vy();
  }
  function Vy() {
    if ((clearTimeout(Mf), (Mf = void 0), ht[ii].length !== 0)) {
      var t = ht[ii].shift(),
        e = t[0],
        i = t[1],
        n = t[2],
        r = t[3],
        s = t[4];
      if (r === void 0) co('RETRY', e.name, i), e.apply(null, i);
      else if (Date.now() - r >= 6e4) {
        co('TIMEOUT', e.name, i);
        var o = i.pop();
        typeof o == 'function' && o.call(null, n);
      } else {
        var c = Date.now() - s,
          u = Math.max(s - r, 1),
          l = Math.min(u * 1.2, 100);
        c >= l ? (co('RETRY', e.name, i), e.apply(null, i.concat([r]))) : ht[ii].push(t);
      }
      Mf === void 0 && (Mf = setTimeout(Vy, 0));
    }
  }
});
var gi = P((br) => {
  'use strict';
  var ek = Xt().fromCallback,
    mi = Pa(),
    tV = [
      'access',
      'appendFile',
      'chmod',
      'chown',
      'close',
      'copyFile',
      'fchmod',
      'fchown',
      'fdatasync',
      'fstat',
      'fsync',
      'ftruncate',
      'futimes',
      'lchmod',
      'lchown',
      'link',
      'lstat',
      'mkdir',
      'mkdtemp',
      'open',
      'opendir',
      'readdir',
      'readFile',
      'readlink',
      'realpath',
      'rename',
      'rm',
      'rmdir',
      'stat',
      'symlink',
      'truncate',
      'unlink',
      'utimes',
      'writeFile',
    ].filter((t) => typeof mi[t] == 'function');
  Object.assign(br, mi);
  tV.forEach((t) => {
    br[t] = ek(mi[t]);
  });
  br.exists = function (t, e) {
    return typeof e == 'function' ? mi.exists(t, e) : new Promise((i) => mi.exists(t, i));
  };
  br.read = function (t, e, i, n, r, s) {
    return typeof s == 'function'
      ? mi.read(t, e, i, n, r, s)
      : new Promise((o, c) => {
          mi.read(t, e, i, n, r, (u, l, p) => {
            if (u) return c(u);
            o({ bytesRead: l, buffer: p });
          });
        });
  };
  br.write = function (t, e, ...i) {
    return typeof i[i.length - 1] == 'function'
      ? mi.write(t, e, ...i)
      : new Promise((n, r) => {
          mi.write(t, e, ...i, (s, o, c) => {
            if (s) return r(s);
            n({ bytesWritten: o, buffer: c });
          });
        });
  };
  br.readv = function (t, e, ...i) {
    return typeof i[i.length - 1] == 'function'
      ? mi.readv(t, e, ...i)
      : new Promise((n, r) => {
          mi.readv(t, e, ...i, (s, o, c) => {
            if (s) return r(s);
            n({ bytesRead: o, buffers: c });
          });
        });
  };
  br.writev = function (t, e, ...i) {
    return typeof i[i.length - 1] == 'function'
      ? mi.writev(t, e, ...i)
      : new Promise((n, r) => {
          mi.writev(t, e, ...i, (s, o, c) => {
            if (s) return r(s);
            n({ bytesWritten: o, buffers: c });
          });
        });
  };
  typeof mi.realpath.native == 'function'
    ? (br.realpath.native = ek(mi.realpath.native))
    : process.emitWarning(
        'fs.realpath.native is not a function. Is fs being monkey-patched?',
        'Warning',
        'fs-extra-WARN0003'
      );
});
var ik = P((Wse, tk) => {
  'use strict';
  var iV = require('path');
  tk.exports.checkPath = function (e) {
    if (process.platform === 'win32' && /[<>:"|?*]/.test(e.replace(iV.parse(e).root, ''))) {
      let n = new Error(`Path contains invalid characters: ${e}`);
      throw ((n.code = 'EINVAL'), n);
    }
  };
});
var ok = P((Kse, Wy) => {
  'use strict';
  var nk = gi(),
    { checkPath: rk } = ik(),
    sk = (t) => {
      let e = { mode: 511 };
      return typeof t == 'number' ? t : { ...e, ...t }.mode;
    };
  Wy.exports.makeDir = async (t, e) => (rk(t), nk.mkdir(t, { mode: sk(e), recursive: !0 }));
  Wy.exports.makeDirSync = (t, e) => (rk(t), nk.mkdirSync(t, { mode: sk(e), recursive: !0 }));
});
var yn = P((Xse, ak) => {
  'use strict';
  var nV = Xt().fromPromise,
    { makeDir: rV, makeDirSync: Ky } = ok(),
    Xy = nV(rV);
  ak.exports = { mkdirs: Xy, mkdirsSync: Ky, mkdirp: Xy, mkdirpSync: Ky, ensureDir: Xy, ensureDirSync: Ky };
});
var os = P((Yse, uk) => {
  'use strict';
  var sV = Xt().fromPromise,
    ck = gi();
  function oV(t) {
    return ck
      .access(t)
      .then(() => !0)
      .catch(() => !1);
  }
  uk.exports = { pathExists: sV(oV), pathExistsSync: ck.existsSync };
});
var Yy = P((Jse, lk) => {
  'use strict';
  var La = gi(),
    aV = Xt().fromPromise;
  async function cV(t, e, i) {
    let n = await La.open(t, 'r+'),
      r = null;
    try {
      await La.futimes(n, e, i);
    } finally {
      try {
        await La.close(n);
      } catch (s) {
        r = s;
      }
    }
    if (r) throw r;
  }
  function uV(t, e, i) {
    let n = La.openSync(t, 'r+');
    return La.futimesSync(n, e, i), La.closeSync(n);
  }
  lk.exports = { utimesMillis: aV(cV), utimesMillisSync: uV };
});
var uo = P((Zse, hk) => {
  'use strict';
  var Da = gi(),
    Yt = require('path'),
    pk = Xt().fromPromise;
  function lV(t, e, i) {
    let n = i.dereference ? (r) => Da.stat(r, { bigint: !0 }) : (r) => Da.lstat(r, { bigint: !0 });
    return Promise.all([
      n(t),
      n(e).catch((r) => {
        if (r.code === 'ENOENT') return null;
        throw r;
      }),
    ]).then(([r, s]) => ({ srcStat: r, destStat: s }));
  }
  function pV(t, e, i) {
    let n,
      r = i.dereference ? (o) => Da.statSync(o, { bigint: !0 }) : (o) => Da.lstatSync(o, { bigint: !0 }),
      s = r(t);
    try {
      n = r(e);
    } catch (o) {
      if (o.code === 'ENOENT') return { srcStat: s, destStat: null };
      throw o;
    }
    return { srcStat: s, destStat: n };
  }
  async function fV(t, e, i, n) {
    let { srcStat: r, destStat: s } = await lV(t, e, n);
    if (s) {
      if (vu(r, s)) {
        let o = Yt.basename(t),
          c = Yt.basename(e);
        if (i === 'move' && o !== c && o.toLowerCase() === c.toLowerCase())
          return { srcStat: r, destStat: s, isChangingCase: !0 };
        throw new Error('Source and destination must not be the same.');
      }
      if (r.isDirectory() && !s.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`);
      if (!r.isDirectory() && s.isDirectory())
        throw new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`);
    }
    if (r.isDirectory() && Jy(t, e)) throw new Error(qf(t, e, i));
    return { srcStat: r, destStat: s };
  }
  function dV(t, e, i, n) {
    let { srcStat: r, destStat: s } = pV(t, e, n);
    if (s) {
      if (vu(r, s)) {
        let o = Yt.basename(t),
          c = Yt.basename(e);
        if (i === 'move' && o !== c && o.toLowerCase() === c.toLowerCase())
          return { srcStat: r, destStat: s, isChangingCase: !0 };
        throw new Error('Source and destination must not be the same.');
      }
      if (r.isDirectory() && !s.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`);
      if (!r.isDirectory() && s.isDirectory())
        throw new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`);
    }
    if (r.isDirectory() && Jy(t, e)) throw new Error(qf(t, e, i));
    return { srcStat: r, destStat: s };
  }
  async function fk(t, e, i, n) {
    let r = Yt.resolve(Yt.dirname(t)),
      s = Yt.resolve(Yt.dirname(i));
    if (s === r || s === Yt.parse(s).root) return;
    let o;
    try {
      o = await Da.stat(s, { bigint: !0 });
    } catch (c) {
      if (c.code === 'ENOENT') return;
      throw c;
    }
    if (vu(e, o)) throw new Error(qf(t, i, n));
    return fk(t, e, s, n);
  }
  function dk(t, e, i, n) {
    let r = Yt.resolve(Yt.dirname(t)),
      s = Yt.resolve(Yt.dirname(i));
    if (s === r || s === Yt.parse(s).root) return;
    let o;
    try {
      o = Da.statSync(s, { bigint: !0 });
    } catch (c) {
      if (c.code === 'ENOENT') return;
      throw c;
    }
    if (vu(e, o)) throw new Error(qf(t, i, n));
    return dk(t, e, s, n);
  }
  function vu(t, e) {
    return e.ino && e.dev && e.ino === t.ino && e.dev === t.dev;
  }
  function Jy(t, e) {
    let i = Yt.resolve(t)
        .split(Yt.sep)
        .filter((r) => r),
      n = Yt.resolve(e)
        .split(Yt.sep)
        .filter((r) => r);
    return i.every((r, s) => n[s] === r);
  }
  function qf(t, e, i) {
    return `Cannot ${i} '${t}' to a subdirectory of itself, '${e}'.`;
  }
  hk.exports = {
    checkPaths: pk(fV),
    checkPathsSync: dV,
    checkParentPaths: pk(fk),
    checkParentPathsSync: dk,
    isSrcSubdir: Jy,
    areIdentical: vu,
  };
});
var bk = P((Qse, yk) => {
  'use strict';
  var fi = gi(),
    wu = require('path'),
    { mkdirs: hV } = yn(),
    { pathExists: mV } = os(),
    { utimesMillis: gV } = Yy(),
    Eu = uo();
  async function xV(t, e, i = {}) {
    typeof i == 'function' && (i = { filter: i }),
      (i.clobber = 'clobber' in i ? !!i.clobber : !0),
      (i.overwrite = 'overwrite' in i ? !!i.overwrite : i.clobber),
      i.preserveTimestamps &&
        process.arch === 'ia32' &&
        process.emitWarning(
          `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
          'Warning',
          'fs-extra-WARN0001'
        );
    let { srcStat: n, destStat: r } = await Eu.checkPaths(t, e, 'copy', i);
    if ((await Eu.checkParentPaths(t, n, e, 'copy'), !(await gk(t, e, i)))) return;
    let o = wu.dirname(e);
    (await mV(o)) || (await hV(o)), await xk(r, t, e, i);
  }
  async function gk(t, e, i) {
    return i.filter ? i.filter(t, e) : !0;
  }
  async function xk(t, e, i, n) {
    let s = await (n.dereference ? fi.stat : fi.lstat)(e);
    if (s.isDirectory()) return wV(s, t, e, i, n);
    if (s.isFile() || s.isCharacterDevice() || s.isBlockDevice()) return yV(s, t, e, i, n);
    if (s.isSymbolicLink()) return EV(t, e, i, n);
    throw s.isSocket()
      ? new Error(`Cannot copy a socket file: ${e}`)
      : s.isFIFO()
      ? new Error(`Cannot copy a FIFO pipe: ${e}`)
      : new Error(`Unknown file: ${e}`);
  }
  async function yV(t, e, i, n, r) {
    if (!e) return mk(t, i, n, r);
    if (r.overwrite) return await fi.unlink(n), mk(t, i, n, r);
    if (r.errorOnExist) throw new Error(`'${n}' already exists`);
  }
  async function mk(t, e, i, n) {
    if ((await fi.copyFile(e, i), n.preserveTimestamps)) {
      bV(t.mode) && (await vV(i, t.mode));
      let r = await fi.stat(e);
      await gV(i, r.atime, r.mtime);
    }
    return fi.chmod(i, t.mode);
  }
  function bV(t) {
    return (t & 128) === 0;
  }
  function vV(t, e) {
    return fi.chmod(t, e | 128);
  }
  async function wV(t, e, i, n, r) {
    e || (await fi.mkdir(n));
    let s = await fi.readdir(i);
    await Promise.all(
      s.map(async (o) => {
        let c = wu.join(i, o),
          u = wu.join(n, o);
        if (!(await gk(c, u, r))) return;
        let { destStat: p } = await Eu.checkPaths(c, u, 'copy', r);
        return xk(p, c, u, r);
      })
    ),
      e || (await fi.chmod(n, t.mode));
  }
  async function EV(t, e, i, n) {
    let r = await fi.readlink(e);
    if ((n.dereference && (r = wu.resolve(process.cwd(), r)), !t)) return fi.symlink(r, i);
    let s = null;
    try {
      s = await fi.readlink(i);
    } catch (o) {
      if (o.code === 'EINVAL' || o.code === 'UNKNOWN') return fi.symlink(r, i);
      throw o;
    }
    if ((n.dereference && (s = wu.resolve(process.cwd(), s)), Eu.isSrcSubdir(r, s)))
      throw new Error(`Cannot copy '${r}' to a subdirectory of itself, '${s}'.`);
    if (Eu.isSrcSubdir(s, r)) throw new Error(`Cannot overwrite '${s}' with '${r}'.`);
    return await fi.unlink(i), fi.symlink(r, i);
  }
  yk.exports = xV;
});
var Sk = P((eoe, _k) => {
  'use strict';
  var xi = Pa(),
    _u = require('path'),
    _V = yn().mkdirsSync,
    SV = Yy().utimesMillisSync,
    Su = uo();
  function CV(t, e, i) {
    typeof i == 'function' && (i = { filter: i }),
      (i = i || {}),
      (i.clobber = 'clobber' in i ? !!i.clobber : !0),
      (i.overwrite = 'overwrite' in i ? !!i.overwrite : i.clobber),
      i.preserveTimestamps &&
        process.arch === 'ia32' &&
        process.emitWarning(
          `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
          'Warning',
          'fs-extra-WARN0002'
        );
    let { srcStat: n, destStat: r } = Su.checkPathsSync(t, e, 'copy', i);
    if ((Su.checkParentPathsSync(t, n, e, 'copy'), i.filter && !i.filter(t, e))) return;
    let s = _u.dirname(e);
    return xi.existsSync(s) || _V(s), vk(r, t, e, i);
  }
  function vk(t, e, i, n) {
    let s = (n.dereference ? xi.statSync : xi.lstatSync)(e);
    if (s.isDirectory()) return NV(s, t, e, i, n);
    if (s.isFile() || s.isCharacterDevice() || s.isBlockDevice()) return RV(s, t, e, i, n);
    if (s.isSymbolicLink()) return DV(t, e, i, n);
    throw s.isSocket()
      ? new Error(`Cannot copy a socket file: ${e}`)
      : s.isFIFO()
      ? new Error(`Cannot copy a FIFO pipe: ${e}`)
      : new Error(`Unknown file: ${e}`);
  }
  function RV(t, e, i, n, r) {
    return e ? TV(t, i, n, r) : wk(t, i, n, r);
  }
  function TV(t, e, i, n) {
    if (n.overwrite) return xi.unlinkSync(i), wk(t, e, i, n);
    if (n.errorOnExist) throw new Error(`'${i}' already exists`);
  }
  function wk(t, e, i, n) {
    return xi.copyFileSync(e, i), n.preserveTimestamps && OV(t.mode, e, i), Zy(i, t.mode);
  }
  function OV(t, e, i) {
    return kV(t) && AV(i, t), IV(e, i);
  }
  function kV(t) {
    return (t & 128) === 0;
  }
  function AV(t, e) {
    return Zy(t, e | 128);
  }
  function Zy(t, e) {
    return xi.chmodSync(t, e);
  }
  function IV(t, e) {
    let i = xi.statSync(t);
    return SV(e, i.atime, i.mtime);
  }
  function NV(t, e, i, n, r) {
    return e ? Ek(i, n, r) : PV(t.mode, i, n, r);
  }
  function PV(t, e, i, n) {
    return xi.mkdirSync(i), Ek(e, i, n), Zy(i, t);
  }
  function Ek(t, e, i) {
    xi.readdirSync(t).forEach((n) => LV(n, t, e, i));
  }
  function LV(t, e, i, n) {
    let r = _u.join(e, t),
      s = _u.join(i, t);
    if (n.filter && !n.filter(r, s)) return;
    let { destStat: o } = Su.checkPathsSync(r, s, 'copy', n);
    return vk(o, r, s, n);
  }
  function DV(t, e, i, n) {
    let r = xi.readlinkSync(e);
    if ((n.dereference && (r = _u.resolve(process.cwd(), r)), t)) {
      let s;
      try {
        s = xi.readlinkSync(i);
      } catch (o) {
        if (o.code === 'EINVAL' || o.code === 'UNKNOWN') return xi.symlinkSync(r, i);
        throw o;
      }
      if ((n.dereference && (s = _u.resolve(process.cwd(), s)), Su.isSrcSubdir(r, s)))
        throw new Error(`Cannot copy '${r}' to a subdirectory of itself, '${s}'.`);
      if (Su.isSrcSubdir(s, r)) throw new Error(`Cannot overwrite '${s}' with '${r}'.`);
      return FV(r, i);
    } else return xi.symlinkSync(r, i);
  }
  function FV(t, e) {
    return xi.unlinkSync(e), xi.symlinkSync(t, e);
  }
  _k.exports = CV;
});
var Bf = P((toe, Ck) => {
  'use strict';
  var jV = Xt().fromPromise;
  Ck.exports = { copy: jV(bk()), copySync: Sk() };
});
var Cu = P((ioe, Tk) => {
  'use strict';
  var Rk = Pa(),
    MV = Xt().fromCallback;
  function UV(t, e) {
    Rk.rm(t, { recursive: !0, force: !0 }, e);
  }
  function qV(t) {
    Rk.rmSync(t, { recursive: !0, force: !0 });
  }
  Tk.exports = { remove: MV(UV), removeSync: qV };
});
var Dk = P((noe, Lk) => {
  'use strict';
  var BV = Xt().fromPromise,
    Ak = gi(),
    Ik = require('path'),
    Nk = yn(),
    Pk = Cu(),
    Ok = BV(async function (e) {
      let i;
      try {
        i = await Ak.readdir(e);
      } catch {
        return Nk.mkdirs(e);
      }
      return Promise.all(i.map((n) => Pk.remove(Ik.join(e, n))));
    });
  function kk(t) {
    let e;
    try {
      e = Ak.readdirSync(t);
    } catch {
      return Nk.mkdirsSync(t);
    }
    e.forEach((i) => {
      (i = Ik.join(t, i)), Pk.removeSync(i);
    });
  }
  Lk.exports = { emptyDirSync: kk, emptydirSync: kk, emptyDir: Ok, emptydir: Ok };
});
var Uk = P((roe, Mk) => {
  'use strict';
  var HV = Xt().fromPromise,
    Fk = require('path'),
    vr = gi(),
    jk = yn();
  async function GV(t) {
    let e;
    try {
      e = await vr.stat(t);
    } catch {}
    if (e && e.isFile()) return;
    let i = Fk.dirname(t),
      n = null;
    try {
      n = await vr.stat(i);
    } catch (r) {
      if (r.code === 'ENOENT') {
        await jk.mkdirs(i), await vr.writeFile(t, '');
        return;
      } else throw r;
    }
    n.isDirectory() ? await vr.writeFile(t, '') : await vr.readdir(i);
  }
  function zV(t) {
    let e;
    try {
      e = vr.statSync(t);
    } catch {}
    if (e && e.isFile()) return;
    let i = Fk.dirname(t);
    try {
      vr.statSync(i).isDirectory() || vr.readdirSync(i);
    } catch (n) {
      if (n && n.code === 'ENOENT') jk.mkdirsSync(i);
      else throw n;
    }
    vr.writeFileSync(t, '');
  }
  Mk.exports = { createFile: HV(GV), createFileSync: zV };
});
var zk = P((soe, Gk) => {
  'use strict';
  var VV = Xt().fromPromise,
    qk = require('path'),
    as = gi(),
    Bk = yn(),
    { pathExists: $V } = os(),
    { areIdentical: Hk } = uo();
  async function WV(t, e) {
    let i;
    try {
      i = await as.lstat(e);
    } catch {}
    let n;
    try {
      n = await as.lstat(t);
    } catch (o) {
      throw ((o.message = o.message.replace('lstat', 'ensureLink')), o);
    }
    if (i && Hk(n, i)) return;
    let r = qk.dirname(e);
    (await $V(r)) || (await Bk.mkdirs(r)), await as.link(t, e);
  }
  function KV(t, e) {
    let i;
    try {
      i = as.lstatSync(e);
    } catch {}
    try {
      let s = as.lstatSync(t);
      if (i && Hk(s, i)) return;
    } catch (s) {
      throw ((s.message = s.message.replace('lstat', 'ensureLink')), s);
    }
    let n = qk.dirname(e);
    return as.existsSync(n) || Bk.mkdirsSync(n), as.linkSync(t, e);
  }
  Gk.exports = { createLink: VV(WV), createLinkSync: KV };
});
var $k = P((ooe, Vk) => {
  'use strict';
  var cs = require('path'),
    Ru = gi(),
    { pathExists: XV } = os(),
    YV = Xt().fromPromise;
  async function JV(t, e) {
    if (cs.isAbsolute(t)) {
      try {
        await Ru.lstat(t);
      } catch (s) {
        throw ((s.message = s.message.replace('lstat', 'ensureSymlink')), s);
      }
      return { toCwd: t, toDst: t };
    }
    let i = cs.dirname(e),
      n = cs.join(i, t);
    if (await XV(n)) return { toCwd: n, toDst: t };
    try {
      await Ru.lstat(t);
    } catch (s) {
      throw ((s.message = s.message.replace('lstat', 'ensureSymlink')), s);
    }
    return { toCwd: t, toDst: cs.relative(i, t) };
  }
  function ZV(t, e) {
    if (cs.isAbsolute(t)) {
      if (!Ru.existsSync(t)) throw new Error('absolute srcpath does not exist');
      return { toCwd: t, toDst: t };
    }
    let i = cs.dirname(e),
      n = cs.join(i, t);
    if (Ru.existsSync(n)) return { toCwd: n, toDst: t };
    if (!Ru.existsSync(t)) throw new Error('relative srcpath does not exist');
    return { toCwd: t, toDst: cs.relative(i, t) };
  }
  Vk.exports = { symlinkPaths: YV(JV), symlinkPathsSync: ZV };
});
var Xk = P((aoe, Kk) => {
  'use strict';
  var Wk = gi(),
    QV = Xt().fromPromise;
  async function e$(t, e) {
    if (e) return e;
    let i;
    try {
      i = await Wk.lstat(t);
    } catch {
      return 'file';
    }
    return i && i.isDirectory() ? 'dir' : 'file';
  }
  function t$(t, e) {
    if (e) return e;
    let i;
    try {
      i = Wk.lstatSync(t);
    } catch {
      return 'file';
    }
    return i && i.isDirectory() ? 'dir' : 'file';
  }
  Kk.exports = { symlinkType: QV(e$), symlinkTypeSync: t$ };
});
var Qk = P((coe, Zk) => {
  'use strict';
  var i$ = Xt().fromPromise,
    Yk = require('path'),
    Hn = gi(),
    { mkdirs: n$, mkdirsSync: r$ } = yn(),
    { symlinkPaths: s$, symlinkPathsSync: o$ } = $k(),
    { symlinkType: a$, symlinkTypeSync: c$ } = Xk(),
    { pathExists: u$ } = os(),
    { areIdentical: Jk } = uo();
  async function l$(t, e, i) {
    let n;
    try {
      n = await Hn.lstat(e);
    } catch {}
    if (n && n.isSymbolicLink()) {
      let [c, u] = await Promise.all([Hn.stat(t), Hn.stat(e)]);
      if (Jk(c, u)) return;
    }
    let r = await s$(t, e);
    t = r.toDst;
    let s = await a$(r.toCwd, i),
      o = Yk.dirname(e);
    return (await u$(o)) || (await n$(o)), Hn.symlink(t, e, s);
  }
  function p$(t, e, i) {
    let n;
    try {
      n = Hn.lstatSync(e);
    } catch {}
    if (n && n.isSymbolicLink()) {
      let c = Hn.statSync(t),
        u = Hn.statSync(e);
      if (Jk(c, u)) return;
    }
    let r = o$(t, e);
    (t = r.toDst), (i = c$(r.toCwd, i));
    let s = Yk.dirname(e);
    return Hn.existsSync(s) || r$(s), Hn.symlinkSync(t, e, i);
  }
  Zk.exports = { createSymlink: i$(l$), createSymlinkSync: p$ };
});
var aA = P((uoe, oA) => {
  'use strict';
  var { createFile: eA, createFileSync: tA } = Uk(),
    { createLink: iA, createLinkSync: nA } = zk(),
    { createSymlink: rA, createSymlinkSync: sA } = Qk();
  oA.exports = {
    createFile: eA,
    createFileSync: tA,
    ensureFile: eA,
    ensureFileSync: tA,
    createLink: iA,
    createLinkSync: nA,
    ensureLink: iA,
    ensureLinkSync: nA,
    createSymlink: rA,
    createSymlinkSync: sA,
    ensureSymlink: rA,
    ensureSymlinkSync: sA,
  };
});
var Hf = P((loe, cA) => {
  'use strict';
  function f$(
    t,
    {
      EOL: e = `
`,
      finalEOL: i = !0,
      replacer: n = null,
      spaces: r,
    } = {}
  ) {
    let s = i ? e : '';
    return JSON.stringify(t, n, r).replace(/\n/g, e) + s;
  }
  function d$(t) {
    return Buffer.isBuffer(t) && (t = t.toString('utf8')), t.replace(/^\uFEFF/, '');
  }
  cA.exports = { stringify: f$, stripBom: d$ };
});
var fA = P((poe, pA) => {
  'use strict';
  var Fa;
  try {
    Fa = Pa();
  } catch {
    Fa = require('fs');
  }
  var Gf = Xt(),
    { stringify: uA, stripBom: lA } = Hf();
  async function h$(t, e = {}) {
    typeof e == 'string' && (e = { encoding: e });
    let i = e.fs || Fa,
      n = 'throws' in e ? e.throws : !0,
      r = await Gf.fromCallback(i.readFile)(t, e);
    r = lA(r);
    let s;
    try {
      s = JSON.parse(r, e ? e.reviver : null);
    } catch (o) {
      if (n) throw ((o.message = `${t}: ${o.message}`), o);
      return null;
    }
    return s;
  }
  var m$ = Gf.fromPromise(h$);
  function g$(t, e = {}) {
    typeof e == 'string' && (e = { encoding: e });
    let i = e.fs || Fa,
      n = 'throws' in e ? e.throws : !0;
    try {
      let r = i.readFileSync(t, e);
      return (r = lA(r)), JSON.parse(r, e.reviver);
    } catch (r) {
      if (n) throw ((r.message = `${t}: ${r.message}`), r);
      return null;
    }
  }
  async function x$(t, e, i = {}) {
    let n = i.fs || Fa,
      r = uA(e, i);
    await Gf.fromCallback(n.writeFile)(t, r, i);
  }
  var y$ = Gf.fromPromise(x$);
  function b$(t, e, i = {}) {
    let n = i.fs || Fa,
      r = uA(e, i);
    return n.writeFileSync(t, r, i);
  }
  var v$ = { readFile: m$, readFileSync: g$, writeFile: y$, writeFileSync: b$ };
  pA.exports = v$;
});
var hA = P((foe, dA) => {
  'use strict';
  var zf = fA();
  dA.exports = {
    readJson: zf.readFile,
    readJsonSync: zf.readFileSync,
    writeJson: zf.writeFile,
    writeJsonSync: zf.writeFileSync,
  };
});
var Vf = P((doe, xA) => {
  'use strict';
  var w$ = Xt().fromPromise,
    Qy = gi(),
    mA = require('path'),
    gA = yn(),
    E$ = os().pathExists;
  async function _$(t, e, i = 'utf-8') {
    let n = mA.dirname(t);
    return (await E$(n)) || (await gA.mkdirs(n)), Qy.writeFile(t, e, i);
  }
  function S$(t, ...e) {
    let i = mA.dirname(t);
    Qy.existsSync(i) || gA.mkdirsSync(i), Qy.writeFileSync(t, ...e);
  }
  xA.exports = { outputFile: w$(_$), outputFileSync: S$ };
});
var bA = P((hoe, yA) => {
  'use strict';
  var { stringify: C$ } = Hf(),
    { outputFile: R$ } = Vf();
  async function T$(t, e, i = {}) {
    let n = C$(e, i);
    await R$(t, n, i);
  }
  yA.exports = T$;
});
var wA = P((moe, vA) => {
  'use strict';
  var { stringify: O$ } = Hf(),
    { outputFileSync: k$ } = Vf();
  function A$(t, e, i) {
    let n = O$(e, i);
    k$(t, n, i);
  }
  vA.exports = A$;
});
var _A = P((goe, EA) => {
  'use strict';
  var I$ = Xt().fromPromise,
    yi = hA();
  yi.outputJson = I$(bA());
  yi.outputJsonSync = wA();
  yi.outputJSON = yi.outputJson;
  yi.outputJSONSync = yi.outputJsonSync;
  yi.writeJSON = yi.writeJson;
  yi.writeJSONSync = yi.writeJsonSync;
  yi.readJSON = yi.readJson;
  yi.readJSONSync = yi.readJsonSync;
  EA.exports = yi;
});
var OA = P((xoe, TA) => {
  'use strict';
  var N$ = gi(),
    SA = require('path'),
    { copy: P$ } = Bf(),
    { remove: RA } = Cu(),
    { mkdirp: L$ } = yn(),
    { pathExists: D$ } = os(),
    CA = uo();
  async function F$(t, e, i = {}) {
    let n = i.overwrite || i.clobber || !1,
      { srcStat: r, isChangingCase: s = !1 } = await CA.checkPaths(t, e, 'move', i);
    await CA.checkParentPaths(t, r, e, 'move');
    let o = SA.dirname(e);
    return SA.parse(o).root !== o && (await L$(o)), j$(t, e, n, s);
  }
  async function j$(t, e, i, n) {
    if (!n) {
      if (i) await RA(e);
      else if (await D$(e)) throw new Error('dest already exists.');
    }
    try {
      await N$.rename(t, e);
    } catch (r) {
      if (r.code !== 'EXDEV') throw r;
      await M$(t, e, i);
    }
  }
  async function M$(t, e, i) {
    return await P$(t, e, { overwrite: i, errorOnExist: !0, preserveTimestamps: !0 }), RA(t);
  }
  TA.exports = F$;
});
var PA = P((yoe, NA) => {
  'use strict';
  var AA = Pa(),
    tb = require('path'),
    U$ = Bf().copySync,
    IA = Cu().removeSync,
    q$ = yn().mkdirpSync,
    kA = uo();
  function B$(t, e, i) {
    i = i || {};
    let n = i.overwrite || i.clobber || !1,
      { srcStat: r, isChangingCase: s = !1 } = kA.checkPathsSync(t, e, 'move', i);
    return kA.checkParentPathsSync(t, r, e, 'move'), H$(e) || q$(tb.dirname(e)), G$(t, e, n, s);
  }
  function H$(t) {
    let e = tb.dirname(t);
    return tb.parse(e).root === e;
  }
  function G$(t, e, i, n) {
    if (n) return eb(t, e, i);
    if (i) return IA(e), eb(t, e, i);
    if (AA.existsSync(e)) throw new Error('dest already exists.');
    return eb(t, e, i);
  }
  function eb(t, e, i) {
    try {
      AA.renameSync(t, e);
    } catch (n) {
      if (n.code !== 'EXDEV') throw n;
      return z$(t, e, i);
    }
  }
  function z$(t, e, i) {
    return U$(t, e, { overwrite: i, errorOnExist: !0, preserveTimestamps: !0 }), IA(t);
  }
  NA.exports = B$;
});
var DA = P((boe, LA) => {
  'use strict';
  var V$ = Xt().fromPromise;
  LA.exports = { move: V$(OA()), moveSync: PA() };
});
var Tu = P((voe, FA) => {
  'use strict';
  FA.exports = { ...gi(), ...Bf(), ...Dk(), ...aA(), ..._A(), ...yn(), ...DA(), ...Vf(), ...os(), ...Cu() };
});
var MA = P((woe, jA) => {
  'use strict';
  jA.exports = typeof queueMicrotask == 'function' ? queueMicrotask : (t) => Promise.resolve().then(t);
});
var qA = P((Eoe, UA) => {
  'use strict';
  UA.exports = typeof process < 'u' && typeof process.nextTick == 'function' ? process.nextTick.bind(process) : MA();
});
var HA = P((Soe, BA) => {
  'use strict';
  BA.exports = class {
    constructor(e) {
      if (!(e > 0) || (e - 1) & e) throw new Error('Max size for a FixedFIFO should be a power of two');
      (this.buffer = new Array(e)), (this.mask = e - 1), (this.top = 0), (this.btm = 0), (this.next = null);
    }
    clear() {
      (this.top = this.btm = 0), (this.next = null), this.buffer.fill(void 0);
    }
    push(e) {
      return this.buffer[this.top] !== void 0
        ? !1
        : ((this.buffer[this.top] = e), (this.top = (this.top + 1) & this.mask), !0);
    }
    shift() {
      let e = this.buffer[this.btm];
      if (e !== void 0) return (this.buffer[this.btm] = void 0), (this.btm = (this.btm + 1) & this.mask), e;
    }
    peek() {
      return this.buffer[this.btm];
    }
    isEmpty() {
      return this.buffer[this.btm] === void 0;
    }
  };
});
var ib = P((Roe, zA) => {
  'use strict';
  var GA = HA();
  zA.exports = class {
    constructor(e) {
      (this.hwm = e || 16), (this.head = new GA(this.hwm)), (this.tail = this.head), (this.length = 0);
    }
    clear() {
      (this.head = this.tail), this.head.clear(), (this.length = 0);
    }
    push(e) {
      if ((this.length++, !this.head.push(e))) {
        let i = this.head;
        (this.head = i.next = new GA(2 * this.head.buffer.length)), this.head.push(e);
      }
    }
    shift() {
      this.length !== 0 && this.length--;
      let e = this.tail.shift();
      if (e === void 0 && this.tail.next) {
        let i = this.tail.next;
        return (this.tail.next = null), (this.tail = i), this.tail.shift();
      }
      return e;
    }
    peek() {
      let e = this.tail.peek();
      return e === void 0 && this.tail.next ? this.tail.next.peek() : e;
    }
    isEmpty() {
      return this.length === 0;
    }
  };
});
var ja = P((Toe, VA) => {
  'use strict';
  function $$(t) {
    return Buffer.isBuffer(t) || t instanceof Uint8Array;
  }
  function W$(t) {
    return Buffer.isEncoding(t);
  }
  function K$(t, e, i) {
    return Buffer.alloc(t, e, i);
  }
  function X$(t) {
    return Buffer.allocUnsafe(t);
  }
  function Y$(t) {
    return Buffer.allocUnsafeSlow(t);
  }
  function J$(t, e) {
    return Buffer.byteLength(t, e);
  }
  function Z$(t, e) {
    return Buffer.compare(t, e);
  }
  function Q$(t, e) {
    return Buffer.concat(t, e);
  }
  function e8(t, e, i, n, r) {
    return Pt(t).copy(e, i, n, r);
  }
  function t8(t, e) {
    return Pt(t).equals(e);
  }
  function i8(t, e, i, n, r) {
    return Pt(t).fill(e, i, n, r);
  }
  function n8(t, e, i) {
    return Buffer.from(t, e, i);
  }
  function r8(t, e, i, n) {
    return Pt(t).includes(e, i, n);
  }
  function s8(t, e, i, n) {
    return Pt(t).indexOf(e, i, n);
  }
  function o8(t, e, i, n) {
    return Pt(t).lastIndexOf(e, i, n);
  }
  function a8(t) {
    return Pt(t).swap16();
  }
  function c8(t) {
    return Pt(t).swap32();
  }
  function u8(t) {
    return Pt(t).swap64();
  }
  function Pt(t) {
    return Buffer.isBuffer(t) ? t : Buffer.from(t.buffer, t.byteOffset, t.byteLength);
  }
  function l8(t, e, i, n) {
    return Pt(t).toString(e, i, n);
  }
  function p8(t, e, i, n, r) {
    return Pt(t).write(e, i, n, r);
  }
  function f8(t, e, i) {
    return Pt(t).writeDoubleLE(e, i);
  }
  function d8(t, e, i) {
    return Pt(t).writeFloatLE(e, i);
  }
  function h8(t, e, i) {
    return Pt(t).writeUInt32LE(e, i);
  }
  function m8(t, e, i) {
    return Pt(t).writeInt32LE(e, i);
  }
  function g8(t, e) {
    return Pt(t).readDoubleLE(e);
  }
  function x8(t, e) {
    return Pt(t).readFloatLE(e);
  }
  function y8(t, e) {
    return Pt(t).readUInt32LE(e);
  }
  function b8(t, e) {
    return Pt(t).readInt32LE(e);
  }
  VA.exports = {
    isBuffer: $$,
    isEncoding: W$,
    alloc: K$,
    allocUnsafe: X$,
    allocUnsafeSlow: Y$,
    byteLength: J$,
    compare: Z$,
    concat: Q$,
    copy: e8,
    equals: t8,
    fill: i8,
    from: n8,
    includes: r8,
    indexOf: s8,
    lastIndexOf: o8,
    swap16: a8,
    swap32: c8,
    swap64: u8,
    toBuffer: Pt,
    toString: l8,
    write: p8,
    writeDoubleLE: f8,
    writeFloatLE: d8,
    writeUInt32LE: h8,
    writeInt32LE: m8,
    readDoubleLE: g8,
    readFloatLE: x8,
    readUInt32LE: y8,
    readInt32LE: b8,
  };
});
var WA = P((koe, $A) => {
  'use strict';
  var v8 = ja();
  $A.exports = class {
    constructor(e) {
      this.encoding = e;
    }
    decode(e) {
      return v8.toString(e, this.encoding);
    }
    flush() {
      return '';
    }
  };
});
var XA = P((Ioe, KA) => {
  'use strict';
  var w8 = ja();
  KA.exports = class {
    constructor() {
      (this.codePoint = 0),
        (this.bytesSeen = 0),
        (this.bytesNeeded = 0),
        (this.lowerBoundary = 128),
        (this.upperBoundary = 191);
    }
    decode(e) {
      if (this.bytesNeeded === 0) {
        let n = !0;
        for (let r = Math.max(0, e.byteLength - 4), s = e.byteLength; r < s && n; r++) n = e[r] <= 127;
        if (n) return w8.toString(e, 'utf8');
      }
      let i = '';
      for (let n = 0, r = e.byteLength; n < r; n++) {
        let s = e[n];
        if (this.bytesNeeded === 0) {
          s <= 127
            ? (i += String.fromCharCode(s))
            : s >= 194 && s <= 223
            ? ((this.bytesNeeded = 1), (this.codePoint = s & 31))
            : s >= 224 && s <= 239
            ? (s === 224 ? (this.lowerBoundary = 160) : s === 237 && (this.upperBoundary = 159),
              (this.bytesNeeded = 2),
              (this.codePoint = s & 15))
            : s >= 240 && s <= 244
            ? (s === 240 && (this.lowerBoundary = 144),
              s === 244 && (this.upperBoundary = 143),
              (this.bytesNeeded = 3),
              (this.codePoint = s & 7))
            : (i += '\uFFFD');
          continue;
        }
        if (s < this.lowerBoundary || s > this.upperBoundary) {
          (this.codePoint = 0),
            (this.bytesNeeded = 0),
            (this.bytesSeen = 0),
            (this.lowerBoundary = 128),
            (this.upperBoundary = 191),
            (i += '\uFFFD');
          continue;
        }
        (this.lowerBoundary = 128),
          (this.upperBoundary = 191),
          (this.codePoint = (this.codePoint << 6) | (s & 63)),
          this.bytesSeen++,
          this.bytesSeen === this.bytesNeeded &&
            ((i += String.fromCodePoint(this.codePoint)),
            (this.codePoint = 0),
            (this.bytesNeeded = 0),
            (this.bytesSeen = 0));
      }
      return i;
    }
    flush() {
      let e = this.bytesNeeded > 0 ? '\uFFFD' : '';
      return (
        (this.codePoint = 0),
        (this.bytesNeeded = 0),
        (this.bytesSeen = 0),
        (this.lowerBoundary = 128),
        (this.upperBoundary = 191),
        e
      );
    }
  };
});
var JA = P((Poe, YA) => {
  'use strict';
  var E8 = WA(),
    _8 = XA();
  YA.exports = class {
    constructor(e = 'utf8') {
      switch (((this.encoding = S8(e)), this.encoding)) {
        case 'utf8':
          this.decoder = new _8();
          break;
        case 'utf16le':
        case 'base64':
          throw new Error('Unsupported encoding: ' + this.encoding);
        default:
          this.decoder = new E8(this.encoding);
      }
    }
    push(e) {
      return typeof e == 'string' ? e : this.decoder.decode(e);
    }
    write(e) {
      return this.push(e);
    }
    end(e) {
      let i = '';
      return e && (i = this.push(e)), (i += this.decoder.flush()), i;
    }
  };
  function S8(t) {
    switch (((t = t.toLowerCase()), t)) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return t;
      default:
        throw new Error('Unknown encoding: ' + t);
    }
  }
});
var yb = P((Loe, wI) => {
  'use strict';
  var { EventEmitter: C8 } = require('events'),
    Jf = new Error('Stream was destroyed'),
    nb = new Error('Premature close'),
    iI = qA(),
    nI = ib(),
    R8 = JA(),
    mt = (1 << 29) - 1,
    mo = 1,
    lb = 2,
    lo = 4,
    Ou = 8,
    rI = mt ^ mo,
    T8 = mt ^ lb,
    Lu = 16,
    ku = 32,
    Ha = 64,
    us = 128,
    Du = 256,
    pb = 512,
    po = 1024,
    rb = 2048,
    fb = 4096,
    db = 8192,
    bn = 16384,
    Ma = 32768,
    Zf = 65536,
    fo = 131072,
    sI = Du | pb,
    O8 = Lu | Zf,
    k8 = Ha | Lu,
    A8 = fb | us,
    hb = Du | fo,
    I8 = mt ^ Lu,
    N8 = mt ^ Ha,
    P8 = mt ^ (Ha | Zf),
    L8 = mt ^ Zf,
    D8 = mt ^ Du,
    F8 = mt ^ (us | db),
    j8 = mt ^ po,
    ZA = mt ^ sI,
    oI = mt ^ Ma,
    M8 = mt ^ ku,
    aI = mt ^ fo,
    U8 = mt ^ hb,
    ls = 1 << 18,
    qa = 2 << 18,
    Fu = 4 << 18,
    ho = 8 << 18,
    ju = 16 << 18,
    go = 32 << 18,
    sb = 64 << 18,
    Ua = 128 << 18,
    mb = 256 << 18,
    Ba = 512 << 18,
    Qf = 1024 << 18,
    cI = mt ^ (ls | mb),
    uI = mt ^ Fu,
    q8 = mt ^ Ba,
    B8 = mt ^ ju,
    H8 = mt ^ ho,
    lI = mt ^ Ua,
    G8 = mt ^ qa,
    pI = mt ^ Qf,
    Au = Lu | ls,
    fI = mt ^ Au,
    gb = bn | go,
    wr = lo | Ou | lb,
    zi = wr | mo,
    dI = wr | gb,
    z8 = uI & N8,
    xb = Ua | Ma,
    V8 = xb & fI,
    hI = zi | V8,
    $8 = zi | po | bn,
    QA = zi | bn | us,
    W8 = zi | po | us,
    K8 = zi | fb | us | db,
    X8 = zi | Lu | po | bn | Zf | fo,
    Y8 = wr | po | bn,
    J8 = ku | zi | Ma | Ha,
    Z8 = zi | Ba | go,
    Q8 = ho | ju,
    mI = ho | ls,
    e5 = ho | ju | zi | ls,
    eI = zi | ls | ho | Qf,
    t5 = Fu | ls,
    i5 = ls | mb,
    n5 = zi | Ba | mI | go,
    r5 = ju | wr | Ba | go,
    s5 = qa | zi | Ua | Fu,
    $f = Symbol.asyncIterator || Symbol('asyncIterator'),
    Wf = class {
      constructor(
        e,
        { highWaterMark: i = 16384, map: n = null, mapWritable: r, byteLength: s, byteLengthWritable: o } = {}
      ) {
        (this.stream = e),
          (this.queue = new nI()),
          (this.highWaterMark = i),
          (this.buffered = 0),
          (this.error = null),
          (this.pipeline = null),
          (this.drains = null),
          (this.byteLength = o || s || vI),
          (this.map = r || n),
          (this.afterWrite = c5.bind(this)),
          (this.afterUpdateNextTick = p5.bind(this));
      }
      get ended() {
        return (this.stream._duplexState & go) !== 0;
      }
      push(e) {
        return (
          this.map !== null && (e = this.map(e)),
          (this.buffered += this.byteLength(e)),
          this.queue.push(e),
          this.buffered < this.highWaterMark
            ? ((this.stream._duplexState |= ho), !0)
            : ((this.stream._duplexState |= Q8), !1)
        );
      }
      shift() {
        let e = this.queue.shift();
        return (this.buffered -= this.byteLength(e)), this.buffered === 0 && (this.stream._duplexState &= H8), e;
      }
      end(e) {
        typeof e == 'function' ? this.stream.once('finish', e) : e != null && this.push(e),
          (this.stream._duplexState = (this.stream._duplexState | Ba) & uI);
      }
      autoBatch(e, i) {
        let n = [],
          r = this.stream;
        for (n.push(e); (r._duplexState & eI) === mI; ) n.push(r._writableState.shift());
        if (r._duplexState & zi) return i(null);
        r._writev(n, i);
      }
      update() {
        let e = this.stream;
        e._duplexState |= qa;
        do {
          for (; (e._duplexState & eI) === ho; ) {
            let i = this.shift();
            (e._duplexState |= i5), e._write(i, this.afterWrite);
          }
          e._duplexState & t5 || this.updateNonPrimary();
        } while (this.continueUpdate() === !0);
        e._duplexState &= G8;
      }
      updateNonPrimary() {
        let e = this.stream;
        if ((e._duplexState & n5) === Ba) {
          (e._duplexState = (e._duplexState | ls) & q8), e._final(a5.bind(this));
          return;
        }
        if ((e._duplexState & wr) === lo) {
          e._duplexState & xb || ((e._duplexState |= Au), e._destroy(gI.bind(this)));
          return;
        }
        (e._duplexState & hI) === mo && ((e._duplexState = (e._duplexState | Au) & rI), e._open(xI.bind(this)));
      }
      continueUpdate() {
        return this.stream._duplexState & Ua ? ((this.stream._duplexState &= lI), !0) : !1;
      }
      updateCallback() {
        (this.stream._duplexState & s5) === Fu ? this.update() : this.updateNextTick();
      }
      updateNextTick() {
        this.stream._duplexState & Ua ||
          ((this.stream._duplexState |= Ua), this.stream._duplexState & qa || iI(this.afterUpdateNextTick));
      }
    },
    ob = class {
      constructor(
        e,
        { highWaterMark: i = 16384, map: n = null, mapReadable: r, byteLength: s, byteLengthReadable: o } = {}
      ) {
        (this.stream = e),
          (this.queue = new nI()),
          (this.highWaterMark = i === 0 ? 1 : i),
          (this.buffered = 0),
          (this.readAhead = i > 0),
          (this.error = null),
          (this.pipeline = null),
          (this.byteLength = o || s || vI),
          (this.map = r || n),
          (this.pipeTo = null),
          (this.afterRead = u5.bind(this)),
          (this.afterUpdateNextTick = l5.bind(this));
      }
      get ended() {
        return (this.stream._duplexState & bn) !== 0;
      }
      pipe(e, i) {
        if (this.pipeTo !== null) throw new Error('Can only pipe to one destination');
        if (
          (typeof i != 'function' && (i = null),
          (this.stream._duplexState |= pb),
          (this.pipeTo = e),
          (this.pipeline = new cb(this.stream, e, i)),
          i && this.stream.on('error', tI),
          Pu(e))
        )
          (e._writableState.pipeline = this.pipeline),
            i && e.on('error', tI),
            e.on('finish', this.pipeline.finished.bind(this.pipeline));
        else {
          let n = this.pipeline.done.bind(this.pipeline, e),
            r = this.pipeline.done.bind(this.pipeline, e, null);
          e.on('error', n), e.on('close', r), e.on('finish', this.pipeline.finished.bind(this.pipeline));
        }
        e.on('drain', o5.bind(this)), this.stream.emit('piping', e), e.emit('pipe', this.stream);
      }
      push(e) {
        let i = this.stream;
        return e === null
          ? ((this.highWaterMark = 0), (i._duplexState = (i._duplexState | po) & P8), !1)
          : this.map !== null && ((e = this.map(e)), e === null)
          ? this.buffered < this.highWaterMark
          : ((this.buffered += this.byteLength(e)),
            this.queue.push(e),
            (i._duplexState = (i._duplexState | us) & L8),
            this.buffered < this.highWaterMark);
      }
      shift() {
        let e = this.queue.shift();
        return (this.buffered -= this.byteLength(e)), this.buffered === 0 && (this.stream._duplexState &= F8), e;
      }
      unshift(e) {
        let i = [this.map !== null ? this.map(e) : e];
        for (; this.buffered > 0; ) i.push(this.shift());
        for (let n = 0; n < i.length - 1; n++) {
          let r = i[n];
          (this.buffered += this.byteLength(r)), this.queue.push(r);
        }
        this.push(i[i.length - 1]);
      }
      read() {
        let e = this.stream;
        if ((e._duplexState & QA) === us) {
          let i = this.shift();
          return (
            this.pipeTo !== null && this.pipeTo.write(i) === !1 && (e._duplexState &= ZA),
            e._duplexState & rb && e.emit('data', i),
            i
          );
        }
        return this.readAhead === !1 && ((e._duplexState |= fo), this.updateNextTick()), null;
      }
      drain() {
        let e = this.stream;
        for (; (e._duplexState & QA) === us && e._duplexState & sI; ) {
          let i = this.shift();
          this.pipeTo !== null && this.pipeTo.write(i) === !1 && (e._duplexState &= ZA),
            e._duplexState & rb && e.emit('data', i);
        }
      }
      update() {
        let e = this.stream;
        e._duplexState |= ku;
        do {
          for (this.drain(); this.buffered < this.highWaterMark && (e._duplexState & X8) === fo; )
            (e._duplexState |= O8), e._read(this.afterRead), this.drain();
          (e._duplexState & K8) === A8 && ((e._duplexState |= db), e.emit('readable')),
            e._duplexState & k8 || this.updateNonPrimary();
        } while (this.continueUpdate() === !0);
        e._duplexState &= M8;
      }
      updateNonPrimary() {
        let e = this.stream;
        if (
          ((e._duplexState & W8) === po &&
            ((e._duplexState = (e._duplexState | bn) & j8),
            e.emit('end'),
            (e._duplexState & dI) === gb && (e._duplexState |= lo),
            this.pipeTo !== null && this.pipeTo.end()),
          (e._duplexState & wr) === lo)
        ) {
          e._duplexState & xb || ((e._duplexState |= Au), e._destroy(gI.bind(this)));
          return;
        }
        (e._duplexState & hI) === mo && ((e._duplexState = (e._duplexState | Au) & rI), e._open(xI.bind(this)));
      }
      continueUpdate() {
        return this.stream._duplexState & Ma ? ((this.stream._duplexState &= oI), !0) : !1;
      }
      updateCallback() {
        (this.stream._duplexState & J8) === Ha ? this.update() : this.updateNextTick();
      }
      updateNextTick() {
        this.stream._duplexState & Ma ||
          ((this.stream._duplexState |= Ma), this.stream._duplexState & ku || iI(this.afterUpdateNextTick));
      }
    },
    ab = class {
      constructor(e) {
        (this.data = null), (this.afterTransform = d5.bind(e)), (this.afterFinal = null);
      }
    },
    cb = class {
      constructor(e, i, n) {
        (this.from = e), (this.to = i), (this.afterPipe = n), (this.error = null), (this.pipeToFinished = !1);
      }
      finished() {
        this.pipeToFinished = !0;
      }
      done(e, i) {
        if ((i && (this.error = i), e === this.to && ((this.to = null), this.from !== null))) {
          (!(this.from._duplexState & bn) || !this.pipeToFinished) &&
            this.from.destroy(this.error || new Error('Writable stream closed prematurely'));
          return;
        }
        if (e === this.from && ((this.from = null), this.to !== null)) {
          e._duplexState & bn || this.to.destroy(this.error || new Error('Readable stream closed before ending'));
          return;
        }
        this.afterPipe !== null && this.afterPipe(this.error), (this.to = this.from = this.afterPipe = null);
      }
    };
  function o5() {
    (this.stream._duplexState |= pb), this.updateCallback();
  }
  function a5(t) {
    let e = this.stream;
    t && e.destroy(t),
      e._duplexState & wr || ((e._duplexState |= go), e.emit('finish')),
      (e._duplexState & dI) === gb && (e._duplexState |= lo),
      (e._duplexState &= cI),
      e._duplexState & qa ? this.updateNextTick() : this.update();
  }
  function gI(t) {
    let e = this.stream;
    !t && this.error !== Jf && (t = this.error), t && e.emit('error', t), (e._duplexState |= Ou), e.emit('close');
    let i = e._readableState,
      n = e._writableState;
    if ((i !== null && i.pipeline !== null && i.pipeline.done(e, t), n !== null)) {
      for (; n.drains !== null && n.drains.length > 0; ) n.drains.shift().resolve(!1);
      n.pipeline !== null && n.pipeline.done(e, t);
    }
  }
  function c5(t) {
    let e = this.stream;
    t && e.destroy(t),
      (e._duplexState &= cI),
      this.drains !== null && f5(this.drains),
      (e._duplexState & e5) === ju && ((e._duplexState &= B8), (e._duplexState & sb) === sb && e.emit('drain')),
      this.updateCallback();
  }
  function u5(t) {
    t && this.stream.destroy(t),
      (this.stream._duplexState &= I8),
      this.readAhead === !1 && !(this.stream._duplexState & Du) && (this.stream._duplexState &= aI),
      this.updateCallback();
  }
  function l5() {
    this.stream._duplexState & ku || ((this.stream._duplexState &= oI), this.update());
  }
  function p5() {
    this.stream._duplexState & qa || ((this.stream._duplexState &= lI), this.update());
  }
  function f5(t) {
    for (let e = 0; e < t.length; e++) --t[e].writes === 0 && (t.shift().resolve(!0), e--);
  }
  function xI(t) {
    let e = this.stream;
    t && e.destroy(t),
      e._duplexState & lo ||
        (e._duplexState & $8 || (e._duplexState |= Ha), e._duplexState & Z8 || (e._duplexState |= Fu), e.emit('open')),
      (e._duplexState &= fI),
      e._writableState !== null && e._writableState.updateCallback(),
      e._readableState !== null && e._readableState.updateCallback();
  }
  function d5(t, e) {
    e != null && this.push(e), this._writableState.afterWrite(t);
  }
  function h5(t) {
    this._readableState !== null &&
      (t === 'data' && ((this._duplexState |= rb | hb), this._readableState.updateNextTick()),
      t === 'readable' && ((this._duplexState |= fb), this._readableState.updateNextTick())),
      this._writableState !== null &&
        t === 'drain' &&
        ((this._duplexState |= sb), this._writableState.updateNextTick());
  }
  var Iu = class extends C8 {
      constructor(e) {
        super(),
          (this._duplexState = 0),
          (this._readableState = null),
          (this._writableState = null),
          e &&
            (e.open && (this._open = e.open),
            e.destroy && (this._destroy = e.destroy),
            e.predestroy && (this._predestroy = e.predestroy),
            e.signal && e.signal.addEventListener('abort', w5.bind(this))),
          this.on('newListener', h5);
      }
      _open(e) {
        e(null);
      }
      _destroy(e) {
        e(null);
      }
      _predestroy() {}
      get readable() {
        return this._readableState !== null ? !0 : void 0;
      }
      get writable() {
        return this._writableState !== null ? !0 : void 0;
      }
      get destroyed() {
        return (this._duplexState & Ou) !== 0;
      }
      get destroying() {
        return (this._duplexState & wr) !== 0;
      }
      destroy(e) {
        this._duplexState & wr ||
          (e || (e = Jf),
          (this._duplexState = (this._duplexState | lo) & z8),
          this._readableState !== null && ((this._readableState.highWaterMark = 0), (this._readableState.error = e)),
          this._writableState !== null && ((this._writableState.highWaterMark = 0), (this._writableState.error = e)),
          (this._duplexState |= lb),
          this._predestroy(),
          (this._duplexState &= T8),
          this._readableState !== null && this._readableState.updateNextTick(),
          this._writableState !== null && this._writableState.updateNextTick());
      }
    },
    Kf = class t extends Iu {
      constructor(e) {
        super(e),
          (this._duplexState |= mo | go | fo),
          (this._readableState = new ob(this, e)),
          e &&
            (this._readableState.readAhead === !1 && (this._duplexState &= aI),
            e.read && (this._read = e.read),
            e.eagerOpen && this._readableState.updateNextTick(),
            e.encoding && this.setEncoding(e.encoding));
      }
      setEncoding(e) {
        let i = new R8(e),
          n = this._readableState.map || x5;
        return (this._readableState.map = r), this;
        function r(s) {
          let o = i.push(s);
          return o === '' ? null : n(o);
        }
      }
      _read(e) {
        e(null);
      }
      pipe(e, i) {
        return this._readableState.updateNextTick(), this._readableState.pipe(e, i), e;
      }
      read() {
        return this._readableState.updateNextTick(), this._readableState.read();
      }
      push(e) {
        return this._readableState.updateNextTick(), this._readableState.push(e);
      }
      unshift(e) {
        return this._readableState.updateNextTick(), this._readableState.unshift(e);
      }
      resume() {
        return (this._duplexState |= hb), this._readableState.updateNextTick(), this;
      }
      pause() {
        return (this._duplexState &= this._readableState.readAhead === !1 ? U8 : D8), this;
      }
      static _fromAsyncIterator(e, i) {
        let n,
          r = new t({
            ...i,
            read(o) {
              e.next().then(s).then(o.bind(null, null)).catch(o);
            },
            predestroy() {
              n = e.return();
            },
            destroy(o) {
              if (!n) return o(null);
              n.then(o.bind(null, null)).catch(o);
            },
          });
        return r;
        function s(o) {
          o.done ? r.push(null) : r.push(o.value);
        }
      }
      static from(e, i) {
        if (b5(e)) return e;
        if (e[$f]) return this._fromAsyncIterator(e[$f](), i);
        Array.isArray(e) || (e = e === void 0 ? [] : [e]);
        let n = 0;
        return new t({
          ...i,
          read(r) {
            this.push(n === e.length ? null : e[n++]), r(null);
          },
        });
      }
      static isBackpressured(e) {
        return (e._duplexState & Y8) !== 0 || e._readableState.buffered >= e._readableState.highWaterMark;
      }
      static isPaused(e) {
        return (e._duplexState & Du) === 0;
      }
      [$f]() {
        let e = this,
          i = null,
          n = null,
          r = null;
        return (
          this.on('error', (l) => {
            i = l;
          }),
          this.on('readable', s),
          this.on('close', o),
          {
            [$f]() {
              return this;
            },
            next() {
              return new Promise(function (l, p) {
                (n = l), (r = p);
                let d = e.read();
                d !== null ? c(d) : e._duplexState & Ou && c(null);
              });
            },
            return() {
              return u(null);
            },
            throw(l) {
              return u(l);
            },
          }
        );
        function s() {
          n !== null && c(e.read());
        }
        function o() {
          n !== null && c(null);
        }
        function c(l) {
          r !== null &&
            (i ? r(i) : l === null && !(e._duplexState & bn) ? r(Jf) : n({ value: l, done: l === null }),
            (r = n = null));
        }
        function u(l) {
          return (
            e.destroy(l),
            new Promise((p, d) => {
              if (e._duplexState & Ou) return p({ value: void 0, done: !0 });
              e.once('close', function () {
                l ? d(l) : p({ value: void 0, done: !0 });
              });
            })
          );
        }
      }
    },
    Xf = class extends Iu {
      constructor(e) {
        super(e),
          (this._duplexState |= mo | bn),
          (this._writableState = new Wf(this, e)),
          e &&
            (e.writev && (this._writev = e.writev),
            e.write && (this._write = e.write),
            e.final && (this._final = e.final),
            e.eagerOpen && this._writableState.updateNextTick());
      }
      cork() {
        this._duplexState |= Qf;
      }
      uncork() {
        (this._duplexState &= pI), this._writableState.updateNextTick();
      }
      _writev(e, i) {
        i(null);
      }
      _write(e, i) {
        this._writableState.autoBatch(e, i);
      }
      _final(e) {
        e(null);
      }
      static isBackpressured(e) {
        return (e._duplexState & r5) !== 0;
      }
      static drained(e) {
        if (e.destroyed) return Promise.resolve(!1);
        let i = e._writableState,
          r = (E5(e) ? Math.min(1, i.queue.length) : i.queue.length) + (e._duplexState & mb ? 1 : 0);
        return r === 0
          ? Promise.resolve(!0)
          : (i.drains === null && (i.drains = []),
            new Promise((s) => {
              i.drains.push({ writes: r, resolve: s });
            }));
      }
      write(e) {
        return this._writableState.updateNextTick(), this._writableState.push(e);
      }
      end(e) {
        return this._writableState.updateNextTick(), this._writableState.end(e), this;
      }
    },
    Nu = class extends Kf {
      constructor(e) {
        super(e),
          (this._duplexState = mo | (this._duplexState & fo)),
          (this._writableState = new Wf(this, e)),
          e &&
            (e.writev && (this._writev = e.writev),
            e.write && (this._write = e.write),
            e.final && (this._final = e.final));
      }
      cork() {
        this._duplexState |= Qf;
      }
      uncork() {
        (this._duplexState &= pI), this._writableState.updateNextTick();
      }
      _writev(e, i) {
        i(null);
      }
      _write(e, i) {
        this._writableState.autoBatch(e, i);
      }
      _final(e) {
        e(null);
      }
      write(e) {
        return this._writableState.updateNextTick(), this._writableState.push(e);
      }
      end(e) {
        return this._writableState.updateNextTick(), this._writableState.end(e), this;
      }
    },
    Yf = class extends Nu {
      constructor(e) {
        super(e),
          (this._transformState = new ab(this)),
          e && (e.transform && (this._transform = e.transform), e.flush && (this._flush = e.flush));
      }
      _write(e, i) {
        this._readableState.buffered >= this._readableState.highWaterMark
          ? (this._transformState.data = e)
          : this._transform(e, this._transformState.afterTransform);
      }
      _read(e) {
        if (this._transformState.data !== null) {
          let i = this._transformState.data;
          (this._transformState.data = null), e(null), this._transform(i, this._transformState.afterTransform);
        } else e(null);
      }
      destroy(e) {
        super.destroy(e),
          this._transformState.data !== null &&
            ((this._transformState.data = null), this._transformState.afterTransform());
      }
      _transform(e, i) {
        i(null, e);
      }
      _flush(e) {
        e(null);
      }
      _final(e) {
        (this._transformState.afterFinal = e), this._flush(m5.bind(this));
      }
    },
    ub = class extends Yf {};
  function m5(t, e) {
    let i = this._transformState.afterFinal;
    if (t) return i(t);
    e != null && this.push(e), this.push(null), i(null);
  }
  function g5(...t) {
    return new Promise((e, i) =>
      yI(...t, (n) => {
        if (n) return i(n);
        e();
      })
    );
  }
  function yI(t, ...e) {
    let i = Array.isArray(t) ? [...t, ...e] : [t, ...e],
      n = i.length && typeof i[i.length - 1] == 'function' ? i.pop() : null;
    if (i.length < 2) throw new Error('Pipeline requires at least 2 streams');
    let r = i[0],
      s = null,
      o = null;
    for (let l = 1; l < i.length; l++) (s = i[l]), Pu(r) ? r.pipe(s, u) : (c(r, !0, l > 1, u), r.pipe(s)), (r = s);
    if (n) {
      let l = !1,
        p = Pu(s) || !!(s._writableState && s._writableState.autoDestroy);
      s.on('error', (d) => {
        o === null && (o = d);
      }),
        s.on('finish', () => {
          (l = !0), p || n(o);
        }),
        p && s.on('close', () => n(o || (l ? null : nb)));
    }
    return s;
    function c(l, p, d, x) {
      l.on('error', x), l.on('close', b);
      function b() {
        if ((p && l._readableState && !l._readableState.ended) || (d && l._writableState && !l._writableState.ended))
          return x(nb);
      }
    }
    function u(l) {
      if (!(!l || o)) {
        o = l;
        for (let p of i) p.destroy(l);
      }
    }
  }
  function x5(t) {
    return t;
  }
  function bI(t) {
    return !!t._readableState || !!t._writableState;
  }
  function Pu(t) {
    return typeof t._duplexState == 'number' && bI(t);
  }
  function y5(t) {
    let e = (t._readableState && t._readableState.error) || (t._writableState && t._writableState.error);
    return e === Jf ? null : e;
  }
  function b5(t) {
    return Pu(t) && t.readable;
  }
  function v5(t) {
    return typeof t == 'object' && t !== null && typeof t.byteLength == 'number';
  }
  function vI(t) {
    return v5(t) ? t.byteLength : 1024;
  }
  function tI() {}
  function w5() {
    this.destroy(new Error('Stream aborted.'));
  }
  function E5(t) {
    return t._writev !== Xf.prototype._writev && t._writev !== Nu.prototype._writev;
  }
  wI.exports = {
    pipeline: yI,
    pipelinePromise: g5,
    isStream: bI,
    isStreamx: Pu,
    getStreamError: y5,
    Stream: Iu,
    Writable: Xf,
    Readable: Kf,
    Duplex: Nu,
    Transform: Yf,
    PassThrough: ub,
  };
});
var wb = P((za) => {
  'use strict';
  var $e = ja(),
    _5 = '0000000000000000000',
    S5 = '7777777777777777777',
    ed = 48,
    EI = $e.from([117, 115, 116, 97, 114, 0]),
    C5 = $e.from([ed, ed]),
    R5 = $e.from([117, 115, 116, 97, 114, 32]),
    T5 = $e.from([32, 0]),
    O5 = 4095,
    Mu = 257,
    vb = 263;
  za.decodeLongPath = function (e, i) {
    return Ga(e, 0, e.length, i);
  };
  za.encodePax = function (e) {
    let i = '';
    e.name &&
      (i += bb(
        ' path=' +
          e.name +
          `
`
      )),
      e.linkname &&
        (i += bb(
          ' linkpath=' +
            e.linkname +
            `
`
        ));
    let n = e.pax;
    if (n)
      for (let r in n)
        i += bb(
          ' ' +
            r +
            '=' +
            n[r] +
            `
`
        );
    return $e.from(i);
  };
  za.decodePax = function (e) {
    let i = {};
    for (; e.length; ) {
      let n = 0;
      for (; n < e.length && e[n] !== 32; ) n++;
      let r = parseInt($e.toString(e.subarray(0, n)), 10);
      if (!r) return i;
      let s = $e.toString(e.subarray(n + 1, r - 1)),
        o = s.indexOf('=');
      if (o === -1) return i;
      (i[s.slice(0, o)] = s.slice(o + 1)), (e = e.subarray(r));
    }
    return i;
  };
  za.encode = function (e) {
    let i = $e.alloc(512),
      n = e.name,
      r = '';
    if ((e.typeflag === 5 && n[n.length - 1] !== '/' && (n += '/'), $e.byteLength(n) !== n.length)) return null;
    for (; $e.byteLength(n) > 100; ) {
      let s = n.indexOf('/');
      if (s === -1) return null;
      (r += r ? '/' + n.slice(0, s) : n.slice(0, s)), (n = n.slice(s + 1));
    }
    return $e.byteLength(n) > 100 || $e.byteLength(r) > 155 || (e.linkname && $e.byteLength(e.linkname) > 100)
      ? null
      : ($e.write(i, n),
        $e.write(i, fs(e.mode & O5, 6), 100),
        $e.write(i, fs(e.uid, 6), 108),
        $e.write(i, fs(e.gid, 6), 116),
        D5(e.size, i, 124),
        $e.write(i, fs((e.mtime.getTime() / 1e3) | 0, 11), 136),
        (i[156] = ed + P5(e.type)),
        e.linkname && $e.write(i, e.linkname, 157),
        $e.copy(EI, i, Mu),
        $e.copy(C5, i, vb),
        e.uname && $e.write(i, e.uname, 265),
        e.gname && $e.write(i, e.gname, 297),
        $e.write(i, fs(e.devmajor || 0, 6), 329),
        $e.write(i, fs(e.devminor || 0, 6), 337),
        r && $e.write(i, r, 345),
        $e.write(i, fs(SI(i), 6), 148),
        i);
  };
  za.decode = function (e, i, n) {
    let r = e[156] === 0 ? 0 : e[156] - ed,
      s = Ga(e, 0, 100, i),
      o = ps(e, 100, 8),
      c = ps(e, 108, 8),
      u = ps(e, 116, 8),
      l = ps(e, 124, 12),
      p = ps(e, 136, 12),
      d = N5(r),
      x = e[157] === 0 ? null : Ga(e, 157, 100, i),
      b = Ga(e, 265, 32),
      g = Ga(e, 297, 32),
      y = ps(e, 329, 8),
      h = ps(e, 337, 8),
      v = SI(e);
    if (v === 8 * 32) return null;
    if (v !== ps(e, 148, 8))
      throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?');
    if (k5(e)) e[345] && (s = Ga(e, 345, 155, i) + '/' + s);
    else if (!A5(e)) {
      if (!n) throw new Error('Invalid tar header: unknown format.');
    }
    return (
      r === 0 && s && s[s.length - 1] === '/' && (r = 5),
      {
        name: s,
        mode: o,
        uid: c,
        gid: u,
        size: l,
        mtime: new Date(1e3 * p),
        type: d,
        linkname: x,
        uname: b,
        gname: g,
        devmajor: y,
        devminor: h,
        pax: null,
      }
    );
  };
  function k5(t) {
    return $e.equals(EI, t.subarray(Mu, Mu + 6));
  }
  function A5(t) {
    return $e.equals(R5, t.subarray(Mu, Mu + 6)) && $e.equals(T5, t.subarray(vb, vb + 2));
  }
  function I5(t, e, i) {
    return typeof t != 'number' ? i : ((t = ~~t), t >= e ? e : t >= 0 || ((t += e), t >= 0) ? t : 0);
  }
  function N5(t) {
    switch (t) {
      case 0:
        return 'file';
      case 1:
        return 'link';
      case 2:
        return 'symlink';
      case 3:
        return 'character-device';
      case 4:
        return 'block-device';
      case 5:
        return 'directory';
      case 6:
        return 'fifo';
      case 7:
        return 'contiguous-file';
      case 72:
        return 'pax-header';
      case 55:
        return 'pax-global-header';
      case 27:
        return 'gnu-long-link-path';
      case 28:
      case 30:
        return 'gnu-long-path';
    }
    return null;
  }
  function P5(t) {
    switch (t) {
      case 'file':
        return 0;
      case 'link':
        return 1;
      case 'symlink':
        return 2;
      case 'character-device':
        return 3;
      case 'block-device':
        return 4;
      case 'directory':
        return 5;
      case 'fifo':
        return 6;
      case 'contiguous-file':
        return 7;
      case 'pax-header':
        return 72;
    }
    return 0;
  }
  function _I(t, e, i, n) {
    for (; i < n; i++) if (t[i] === e) return i;
    return n;
  }
  function SI(t) {
    let e = 256;
    for (let i = 0; i < 148; i++) e += t[i];
    for (let i = 156; i < 512; i++) e += t[i];
    return e;
  }
  function fs(t, e) {
    return (t = t.toString(8)), t.length > e ? S5.slice(0, e) + ' ' : _5.slice(0, e - t.length) + t + ' ';
  }
  function L5(t, e, i) {
    e[i] = 128;
    for (let n = 11; n > 0; n--) (e[i + n] = t & 255), (t = Math.floor(t / 256));
  }
  function D5(t, e, i) {
    t.toString(8).length > 11 ? L5(t, e, i) : $e.write(e, fs(t, 11), i);
  }
  function F5(t) {
    let e;
    if (t[0] === 128) e = !0;
    else if (t[0] === 255) e = !1;
    else return null;
    let i = [],
      n;
    for (n = t.length - 1; n > 0; n--) {
      let o = t[n];
      e ? i.push(o) : i.push(255 - o);
    }
    let r = 0,
      s = i.length;
    for (n = 0; n < s; n++) r += i[n] * Math.pow(256, n);
    return e ? r : -1 * r;
  }
  function ps(t, e, i) {
    if (((t = t.subarray(e, e + i)), (e = 0), t[e] & 128)) return F5(t);
    {
      for (; e < t.length && t[e] === 32; ) e++;
      let n = I5(_I(t, 32, e, t.length), t.length, t.length);
      for (; e < n && t[e] === 0; ) e++;
      return n === e ? 0 : parseInt($e.toString(t.subarray(e, n)), 8);
    }
  }
  function Ga(t, e, i, n) {
    return $e.toString(t.subarray(e, _I(t, 0, e, e + i)), n);
  }
  function bb(t) {
    let e = $e.byteLength(t),
      i = Math.floor(Math.log(e) / Math.log(10)) + 1;
    return e + i >= Math.pow(10, i) && i++, e + i + t;
  }
});
var kI = P((Foe, OI) => {
  'use strict';
  var { Writable: j5, Readable: M5, getStreamError: CI } = yb(),
    U5 = ib(),
    RI = ja(),
    Va = wb(),
    q5 = RI.alloc(0),
    _b = class {
      constructor() {
        (this.buffered = 0), (this.shifted = 0), (this.queue = new U5()), (this._offset = 0);
      }
      push(e) {
        (this.buffered += e.byteLength), this.queue.push(e);
      }
      shiftFirst(e) {
        return this._buffered === 0 ? null : this._next(e);
      }
      shift(e) {
        if (e > this.buffered) return null;
        if (e === 0) return q5;
        let i = this._next(e);
        if (e === i.byteLength) return i;
        let n = [i];
        for (; (e -= i.byteLength) > 0; ) (i = this._next(e)), n.push(i);
        return RI.concat(n);
      }
      _next(e) {
        let i = this.queue.peek(),
          n = i.byteLength - this._offset;
        if (e >= n) {
          let r = this._offset ? i.subarray(this._offset, i.byteLength) : i;
          return this.queue.shift(), (this._offset = 0), (this.buffered -= n), (this.shifted += n), r;
        }
        return (this.buffered -= e), (this.shifted += e), i.subarray(this._offset, (this._offset += e));
      }
    },
    Sb = class extends M5 {
      constructor(e, i, n) {
        super(), (this.header = i), (this.offset = n), (this._parent = e);
      }
      _read(e) {
        this.header.size === 0 && this.push(null), this._parent._stream === this && this._parent._update(), e(null);
      }
      _predestroy() {
        this._parent.destroy(CI(this));
      }
      _detach() {
        this._parent._stream === this &&
          ((this._parent._stream = null), (this._parent._missing = TI(this.header.size)), this._parent._update());
      }
      _destroy(e) {
        this._detach(), e(null);
      }
    },
    Cb = class extends j5 {
      constructor(e) {
        super(e),
          e || (e = {}),
          (this._buffer = new _b()),
          (this._offset = 0),
          (this._header = null),
          (this._stream = null),
          (this._missing = 0),
          (this._longHeader = !1),
          (this._callback = Eb),
          (this._locked = !1),
          (this._finished = !1),
          (this._pax = null),
          (this._paxGlobal = null),
          (this._gnuLongPath = null),
          (this._gnuLongLinkPath = null),
          (this._filenameEncoding = e.filenameEncoding || 'utf-8'),
          (this._allowUnknownFormat = !!e.allowUnknownFormat),
          (this._unlockBound = this._unlock.bind(this));
      }
      _unlock(e) {
        if (((this._locked = !1), e)) {
          this.destroy(e), this._continueWrite(e);
          return;
        }
        this._update();
      }
      _consumeHeader() {
        if (this._locked) return !1;
        this._offset = this._buffer.shifted;
        try {
          this._header = Va.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
        } catch (e) {
          return this._continueWrite(e), !1;
        }
        if (!this._header) return !0;
        switch (this._header.type) {
          case 'gnu-long-path':
          case 'gnu-long-link-path':
          case 'pax-global-header':
          case 'pax-header':
            return (this._longHeader = !0), (this._missing = this._header.size), !0;
        }
        return (
          (this._locked = !0),
          this._applyLongHeaders(),
          this._header.size === 0 || this._header.type === 'directory'
            ? (this.emit('entry', this._header, this._createStream(), this._unlockBound), !0)
            : ((this._stream = this._createStream()),
              (this._missing = this._header.size),
              this.emit('entry', this._header, this._stream, this._unlockBound),
              !0)
        );
      }
      _applyLongHeaders() {
        this._gnuLongPath && ((this._header.name = this._gnuLongPath), (this._gnuLongPath = null)),
          this._gnuLongLinkPath && ((this._header.linkname = this._gnuLongLinkPath), (this._gnuLongLinkPath = null)),
          this._pax &&
            (this._pax.path && (this._header.name = this._pax.path),
            this._pax.linkpath && (this._header.linkname = this._pax.linkpath),
            this._pax.size && (this._header.size = parseInt(this._pax.size, 10)),
            (this._header.pax = this._pax),
            (this._pax = null));
      }
      _decodeLongHeader(e) {
        switch (this._header.type) {
          case 'gnu-long-path':
            this._gnuLongPath = Va.decodeLongPath(e, this._filenameEncoding);
            break;
          case 'gnu-long-link-path':
            this._gnuLongLinkPath = Va.decodeLongPath(e, this._filenameEncoding);
            break;
          case 'pax-global-header':
            this._paxGlobal = Va.decodePax(e);
            break;
          case 'pax-header':
            this._pax =
              this._paxGlobal === null ? Va.decodePax(e) : Object.assign({}, this._paxGlobal, Va.decodePax(e));
            break;
        }
      }
      _consumeLongHeader() {
        (this._longHeader = !1), (this._missing = TI(this._header.size));
        let e = this._buffer.shift(this._header.size);
        try {
          this._decodeLongHeader(e);
        } catch (i) {
          return this._continueWrite(i), !1;
        }
        return !0;
      }
      _consumeStream() {
        let e = this._buffer.shiftFirst(this._missing);
        if (e === null) return !1;
        this._missing -= e.byteLength;
        let i = this._stream.push(e);
        return this._missing === 0
          ? (this._stream.push(null), i && this._stream._detach(), i && this._locked === !1)
          : i;
      }
      _createStream() {
        return new Sb(this, this._header, this._offset);
      }
      _update() {
        for (; this._buffer.buffered > 0 && !this.destroying; ) {
          if (this._missing > 0) {
            if (this._stream !== null) {
              if (this._consumeStream() === !1) return;
              continue;
            }
            if (this._longHeader === !0) {
              if (this._missing > this._buffer.buffered) break;
              if (this._consumeLongHeader() === !1) return !1;
              continue;
            }
            let e = this._buffer.shiftFirst(this._missing);
            e !== null && (this._missing -= e.byteLength);
            continue;
          }
          if (this._buffer.buffered < 512) break;
          if (this._stream !== null || this._consumeHeader() === !1) return;
        }
        this._continueWrite(null);
      }
      _continueWrite(e) {
        let i = this._callback;
        (this._callback = Eb), i(e);
      }
      _write(e, i) {
        (this._callback = i), this._buffer.push(e), this._update();
      }
      _final(e) {
        (this._finished = this._missing === 0 && this._buffer.buffered === 0),
          e(this._finished ? null : new Error('Unexpected end of data'));
      }
      _predestroy() {
        this._continueWrite(null);
      }
      _destroy(e) {
        this._stream && this._stream.destroy(CI(this)), e(null);
      }
      [Symbol.asyncIterator]() {
        let e = null,
          i = null,
          n = null,
          r = null,
          s = null,
          o = this;
        return (
          this.on('entry', l),
          this.on('error', (x) => {
            e = x;
          }),
          this.on('close', p),
          {
            [Symbol.asyncIterator]() {
              return this;
            },
            next() {
              return new Promise(u);
            },
            return() {
              return d(null);
            },
            throw(x) {
              return d(x);
            },
          }
        );
        function c(x) {
          if (!s) return;
          let b = s;
          (s = null), b(x);
        }
        function u(x, b) {
          if (e) return b(e);
          if (r) {
            x({ value: r, done: !1 }), (r = null);
            return;
          }
          (i = x), (n = b), c(null), o._finished && i && (i({ value: void 0, done: !0 }), (i = n = null));
        }
        function l(x, b, g) {
          (s = g), b.on('error', Eb), i ? (i({ value: b, done: !1 }), (i = n = null)) : (r = b);
        }
        function p() {
          c(e), i && (e ? n(e) : i({ value: void 0, done: !0 }), (i = n = null));
        }
        function d(x) {
          return (
            o.destroy(x),
            c(x),
            new Promise((b, g) => {
              if (o.destroyed) return b({ value: void 0, done: !0 });
              o.once('close', function () {
                x ? g(x) : b({ value: void 0, done: !0 });
              });
            })
          );
        }
      }
    };
  OI.exports = function (e) {
    return new Cb(e);
  };
  function Eb() {}
  function TI(t) {
    return (t &= 511), t && 512 - t;
  }
});
var II = P((joe, Rb) => {
  'use strict';
  var AI = { S_IFMT: 61440, S_IFDIR: 16384, S_IFCHR: 8192, S_IFBLK: 24576, S_IFIFO: 4096, S_IFLNK: 40960 };
  try {
    Rb.exports = require('fs').constants || AI;
  } catch {
    Rb.exports = AI;
  }
});
var FI = P((Moe, DI) => {
  'use strict';
  var { Readable: B5, Writable: H5, getStreamError: NI } = yb(),
    xo = ja(),
    $a = II(),
    td = wb(),
    G5 = 493,
    z5 = 420,
    PI = xo.alloc(1024),
    Ob = class extends H5 {
      constructor(e, i, n) {
        super({ mapWritable: $5, eagerOpen: !0 }),
          (this.written = 0),
          (this.header = i),
          (this._callback = n),
          (this._linkname = null),
          (this._isLinkname = i.type === 'symlink' && !i.linkname),
          (this._isVoid = i.type !== 'file' && i.type !== 'contiguous-file'),
          (this._finished = !1),
          (this._pack = e),
          (this._openCallback = null),
          this._pack._stream === null ? (this._pack._stream = this) : this._pack._pending.push(this);
      }
      _open(e) {
        (this._openCallback = e), this._pack._stream === this && this._continueOpen();
      }
      _continuePack(e) {
        if (this._callback === null) return;
        let i = this._callback;
        (this._callback = null), i(e);
      }
      _continueOpen() {
        this._pack._stream === null && (this._pack._stream = this);
        let e = this._openCallback;
        if (((this._openCallback = null), e !== null)) {
          if (this._pack.destroying) return e(new Error('pack stream destroyed'));
          if (this._pack._finalized) return e(new Error('pack stream is already finalized'));
          (this._pack._stream = this),
            this._isLinkname || this._pack._encode(this.header),
            this._isVoid && (this._finish(), this._continuePack(null)),
            e(null);
        }
      }
      _write(e, i) {
        if (this._isLinkname) return (this._linkname = this._linkname ? xo.concat([this._linkname, e]) : e), i(null);
        if (this._isVoid) return e.byteLength > 0 ? i(new Error('No body allowed for this entry')) : i();
        if (((this.written += e.byteLength), this._pack.push(e))) return i();
        this._pack._drain = i;
      }
      _finish() {
        this._finished ||
          ((this._finished = !0),
          this._isLinkname &&
            ((this.header.linkname = this._linkname ? xo.toString(this._linkname, 'utf-8') : ''),
            this._pack._encode(this.header)),
          LI(this._pack, this.header.size),
          this._pack._done(this));
      }
      _final(e) {
        if (this.written !== this.header.size) return e(new Error('Size mismatch'));
        this._finish(), e(null);
      }
      _getError() {
        return NI(this) || new Error('tar entry destroyed');
      }
      _predestroy() {
        this._pack.destroy(this._getError());
      }
      _destroy(e) {
        this._pack._done(this), this._continuePack(this._finished ? null : this._getError()), e();
      }
    },
    kb = class extends B5 {
      constructor(e) {
        super(e),
          (this._drain = Tb),
          (this._finalized = !1),
          (this._finalizing = !1),
          (this._pending = []),
          (this._stream = null);
      }
      entry(e, i, n) {
        if (this._finalized || this.destroying) throw new Error('already finalized or destroyed');
        typeof i == 'function' && ((n = i), (i = null)),
          n || (n = Tb),
          (!e.size || e.type === 'symlink') && (e.size = 0),
          e.type || (e.type = V5(e.mode)),
          e.mode || (e.mode = e.type === 'directory' ? G5 : z5),
          e.uid || (e.uid = 0),
          e.gid || (e.gid = 0),
          e.mtime || (e.mtime = new Date()),
          typeof i == 'string' && (i = xo.from(i));
        let r = new Ob(this, e, n);
        return xo.isBuffer(i) ? ((e.size = i.byteLength), r.write(i), r.end(), r) : (r._isVoid, r);
      }
      finalize() {
        if (this._stream || this._pending.length > 0) {
          this._finalizing = !0;
          return;
        }
        this._finalized || ((this._finalized = !0), this.push(PI), this.push(null));
      }
      _done(e) {
        e === this._stream &&
          ((this._stream = null),
          this._finalizing && this.finalize(),
          this._pending.length && this._pending.shift()._continueOpen());
      }
      _encode(e) {
        if (!e.pax) {
          let i = td.encode(e);
          if (i) {
            this.push(i);
            return;
          }
        }
        this._encodePax(e);
      }
      _encodePax(e) {
        let i = td.encodePax({ name: e.name, linkname: e.linkname, pax: e.pax }),
          n = {
            name: 'PaxHeader',
            mode: e.mode,
            uid: e.uid,
            gid: e.gid,
            size: i.byteLength,
            mtime: e.mtime,
            type: 'pax-header',
            linkname: e.linkname && 'PaxHeader',
            uname: e.uname,
            gname: e.gname,
            devmajor: e.devmajor,
            devminor: e.devminor,
          };
        this.push(td.encode(n)),
          this.push(i),
          LI(this, i.byteLength),
          (n.size = e.size),
          (n.type = e.type),
          this.push(td.encode(n));
      }
      _doDrain() {
        let e = this._drain;
        (this._drain = Tb), e();
      }
      _predestroy() {
        let e = NI(this);
        for (this._stream && this._stream.destroy(e); this._pending.length; ) {
          let i = this._pending.shift();
          i.destroy(e), i._continueOpen();
        }
        this._doDrain();
      }
      _read(e) {
        this._doDrain(), e();
      }
    };
  DI.exports = function (e) {
    return new kb(e);
  };
  function V5(t) {
    switch (t & $a.S_IFMT) {
      case $a.S_IFBLK:
        return 'block-device';
      case $a.S_IFCHR:
        return 'character-device';
      case $a.S_IFDIR:
        return 'directory';
      case $a.S_IFIFO:
        return 'fifo';
      case $a.S_IFLNK:
        return 'symlink';
    }
    return 'file';
  }
  function Tb() {}
  function LI(t, e) {
    (e &= 511), e && t.push(PI.subarray(0, 512 - e));
  }
  function $5(t) {
    return xo.isBuffer(t) ? t : xo.from(t);
  }
});
var jI = P((Ab) => {
  'use strict';
  Ab.extract = kI();
  Ab.pack = FI();
});
function qI(t, e) {
  return new Nb(t, e);
}
async function BI(t, e, i, n) {
  let r = (0, Uu.pack)(),
    s = (0, Mt.join)(e, t),
    o = [];
  r.entry({ name: (0, Mt.join)(t, 'outputs'), type: 'directory' }),
    await GI(s, (l) => {
      o.push(l);
    });
  let c = o.map(async (l) => {
      let p = (0, Mt.join)(s, l),
        d = await (0, Wa.readFile)(p);
      return { path: (0, Mt.join)(t, 'outputs', l), fileContents: d };
    }),
    u = [
      { path: (0, Mt.join)(t, 'terminalOutput'), fileContents: i },
      { path: (0, Mt.join)(t, 'code'), fileContents: n.toString() },
      ...(await Promise.all(c)),
    ];
  for (let { path: l, fileContents: p } of u) r.entry({ name: l }, p);
  return r.finalize(), r;
}
async function HI(t, e) {
  let i = (0, Uu.pack)();
  return i.entry({ name: (0, Mt.join)('terminalOutputs', t) }, e), i.finalize(), i;
}
async function GI(t, e) {
  let i = await (0, Wa.readdir)(t);
  await Promise.all(
    i.map(async (n) => {
      let r = (0, Mt.join)(t, n);
      (await (0, Wa.stat)(r)).isDirectory()
        ? await GI(r, (o) => {
            e((0, Mt.join)(n, o));
          })
        : e(n);
    })
  );
}
var MI,
  Ib,
  Wa,
  UI,
  Mt,
  Uu,
  Nb,
  zI = te(() => {
    'use strict';
    (MI = require('fs')),
      (Ib = je(Tu())),
      (Wa = require('fs/promises')),
      (UI = require('stream')),
      (Mt = require('path')),
      (Uu = je(jI()));
    Nb = class extends UI.Transform {
      constructor(i, n) {
        super();
        this.destination = i;
        this.hash = n;
        this.tarExtractStream = (0, Uu.extract)();
        this.outputFiles = [];
        this.terminalOutput = '';
        this.finished = new Promise((i) => {
          this.finish = i;
        });
        this.setupListeners();
      }
      setupListeners() {
        this.on('finish', () => {
          var i;
          (i = this.finish) == null || i.call(this);
        }),
          this.tarExtractStream.on('entry', (i, n, r) => {
            if (
              i.name === 'terminalOutput' ||
              i.name === (0, Mt.join)(this.hash, 'terminalOutput') ||
              i.name === (0, Mt.join)('terminalOutputs', this.hash) ||
              i.name === (0, Mt.join)(this.hash, 'terminalOutputs')
            )
              n.on('data', (s) => {
                this.terminalOutput += s;
              }),
                n.on('end', () => {
                  r();
                });
            else if (i.name === 'code' || i.name === (0, Mt.join)(this.hash, 'code')) {
              let s = '';
              n.on('data', (o) => {
                s += o;
              }),
                n.on('end', () => {
                  (this.code = +s), r();
                });
            } else
              this.outputFiles.push(
                new Promise(async (s) => {
                  let o = i.name,
                    c = (0, Mt.relative)(o.startsWith(this.hash) ? `${this.hash}/outputs` : 'outputs', o),
                    u = (0, Mt.join)(this.destination, c);
                  i.type === 'directory'
                    ? (0, Ib.ensureDir)(u).then(() => {
                        s(), r();
                      })
                    : (0, Ib.ensureDir)((0, Mt.dirname)(u)).then(() => {
                        let l = (0, MI.createWriteStream)(u);
                        n.pipe(l),
                          n.on('end', () => {
                            r();
                          }),
                          l.on('close', () => {
                            s();
                          });
                      });
                })
              );
          }),
          this.tarExtractStream.on('finish', () => {
            this.emit('finish');
          });
      }
      _transform(i, n, r) {
        this.tarExtractStream.write(i, n) ? r() : this.tarExtractStream.once('drain', r);
      }
      _flush(i) {
        this.tarExtractStream.end(i);
      }
      async getResult() {
        return (
          await this.finished,
          await Promise.all(this.outputFiles),
          { code: this.code, terminalOutput: this.terminalOutput, outputsPath: this.destination }
        );
      }
    };
  });
var VI,
  di,
  vn,
  qu,
  Lb,
  $I,
  Bu,
  id,
  Pb,
  ni,
  Ai,
  yo = te(() => {
    'use strict';
    (VI = require('crypto')), (di = require('fs')), (vn = je(require('path'))), (qu = require('path'));
    mn();
    Le();
    Pn();
    (Lb = require('stream')), ($I = require('stream/promises')), (Bu = je(GO())), (id = require('zlib'));
    zI();
    (Pb = Ug()),
      ({ output: ni } = Ae()),
      (Ai = class {
        constructor(e, i, n, r) {
          this.encryption = e;
          this.errorReporter = i;
          this.context = r;
          this.storedHashes = [];
          this.axiosConfigBuilder = (e) => e;
          if (n.customProxyConfigPath) {
            let { fileServerProxyConfig: s } = require((0, qu.join)(process.cwd(), n.customProxyConfigPath));
            this.axiosConfigBuilder = s ?? this.axiosConfigBuilder;
          }
        }
        async retrieve(e, i, n, r) {
          process.env.NX_CLOUD_DEBUG_URLS == 'true' &&
            ni.note({
              title: `Nx Cloud: Downloading ${e} ${n.fileType}`,
              bodyLines: [`RETRIEVAL URL: ${n.remoteUrl}`],
            });
          try {
            let s = null,
              o = this.createCommitFilePath(e, i, n);
            if (r) {
              let c = this.createFileName(e, i, n);
              await this.extractTarV1(n, c, o);
            } else s = await this.extractTarV2(n, (0, qu.join)(i, e), o, e);
            return this.createCommitFile(o), ie && ni.note({ title: `Nx Cloud: Downloaded ${e}` }), s;
          } catch (s) {
            let o = s.message || s.toString(),
              c;
            throw (
              (o.includes('zlib') || o.includes('gzip') || o.includes('TAR_BAD_ARCHIVE') || o.includes('header')
                ? (c = `Failed to untar cached artifacts. The artifact may be corrupted. (Reference hash: ${e})`)
                : o.includes('decrypt')
                ? (c = `Failed to decrypt artifact. Please review your encryption key. (Reference hash: ${e})`)
                : (c = `Failed to download cached artifacts. Enable NX_VERBOSE_LOGGING for more details. (Reference hash: ${e})`),
              ie &&
                ni.note({
                  title: `${c}`,
                  bodyLines: [`- ${s.message}`, `- Affected artifact: ${e} in context ${this.context}.`],
                }),
              (this.context === 'dte-agent' || this.context === 'dte-main') &&
                (ni.note({
                  title: `An error occurred while trying to retrieve artifacts in the ${this.context} context. Hash: ${e}.`,
                  bodyLines: [
                    '- Please update the nx-cloud package to the latest version.',
                    '- Please update the nx package to 15.8.9 or higher. You can do it without updating the plugins.',
                    '- If you are not able to update the nx package, and you are passing --configuration to a run-many or an affected command, define that configuration for all the projects.',
                  ],
                }),
                process.env.NX_CLOUD_DEBUG_URLS == 'true' && ni.note({ title: `URL: ${e}` })),
              await this.errorReporter.reportError(c),
              new Error(c))
            );
          }
        }
        async store(e, i, n, r, s = !0) {
          ie && ni.note({ title: `Nx Cloud: Storing ${e} with storeV1` }),
            process.env.NX_CLOUD_DEBUG_URLS == 'true' &&
              ni.note({ title: `Nx Cloud: Storing ${e} ${r.join(', ')}`, bodyLines: [`STORAGE URL: ${n.remoteUrl}`] });
          let o = await this.createTarFile(e, i, r, n);
          await this.uploadFile(n.remoteUrl, o),
            s && this.storedHashes.push(e),
            ie && ni.note({ title: `Nx Cloud: Stored ${e} ${r.join(', ')}` });
        }
        async storeV2(e, i, n, r, s, o = !0) {
          ie && ni.note({ title: `Nx Cloud: Storing ${e} with storeV2` });
          let c = [];
          n.fileType === 'artifact'
            ? (c = [(0, qu.join)(i, e, 'outputs')])
            : (c = [(0, qu.join)(i, 'terminalOutput', e)]),
            process.env.NX_CLOUD_DEBUG_URLS == 'true' &&
              ni.note({ title: `Nx Cloud: Storing ${e} ${c.join(', ')}`, bodyLines: [`STORAGE URL: ${n.remoteUrl}`] });
          let u;
          n.fileType === 'artifact' ? (u = await BI(e, i, r, s)) : (u = await HI(e, r));
          let l = u
            .pipe((0, id.createGzip)())
            .pipe(
              this.encryption.hasEncryption() && n.fileType === 'artifact'
                ? this.encryption.encryptFileStream()
                : new Lb.PassThrough()
            );
          await this.uploadFileStream(n.remoteUrl, l),
            o && this.storedHashes.push(e),
            ie && ni.note({ title: `Nx Cloud: Stored ${e} ${c.join(', ')}` });
        }
        createFileName(e, i, n) {
          switch (n.fileType) {
            case 'artifact':
              return vn.join(i, `${e}.tar.gz`);
            case 'terminalOutput':
              return vn.join(i, `${e}-logs.tar.gz`);
          }
        }
        async downloadFile(e) {
          let i;
          try {
            let n = new URL(e.remoteUrl),
              r = n.origin + n.pathname,
              s = {};
            for (let [o, c] of n.searchParams.entries()) s[o] = c;
            i = await tt(() =>
              Pb(
                r,
                this.axiosConfigBuilder({
                  method: 'GET',
                  responseType: 'stream',
                  maxContentLength: ji ? qs : Bs,
                  maxBodyLength: ji ? qs : Bs,
                  timeout: ji ? $o : 6e4,
                  params: s,
                })
              )
            );
          } catch (n) {
            throw n;
          }
          return i;
        }
        async extractTarV1(e, i, n) {
          ie && ni.note({ title: 'FileStorage: Extracting tar file to disk' });
          let r = await this.downloadFile(e);
          if ((0, di.existsSync)(i)) {
            let s = 0;
            for (; s++ < 50; ) {
              if ((0, di.existsSync)(n)) return;
              await wt(500);
            }
          }
          if (this.encryption.hasEncryption() && e.fileType === 'artifact') {
            await new Promise((o) => {
              r.data.pipe((0, di.createWriteStream)(i)).on('close', () => o(null));
            }),
              this.encryption.decryptFile(i);
            let s = (0, di.createReadStream)(i).pipe(Bu.x({ cwd: vn.dirname(i), sync: !0, noChmod: !0 }));
            return this.convertStreamIntoPromise(s);
          } else {
            let s = r.data.pipe(Bu.x({ cwd: vn.dirname(i), sync: !0, noChmod: !0 }));
            return this.convertStreamIntoPromise(s);
          }
        }
        convertStreamIntoPromise(e) {
          return new Promise((i, n) => {
            e.on('error', (r) => {
              r.tarCode === 'TAR_ABORT' && r.message.indexOf('incorrect header check') > -1
                ? (console.warn('FileStorage: Decompression OK, Trailing garbage ignored.'), i(null))
                : n(r);
            }),
              e.on('finish', () => i(null));
          });
        }
        async extractTarV2(e, i, n, r) {
          if ((ie && ni.note({ title: 'FileStorage: streaming and extracting tar file' }), (0, di.existsSync)(n)))
            return (
              ie &&
                ni.note({ title: `FileStorage: Commit file found for ${n}`, bodyLines: ['Skipping download stream'] }),
              null
            );
          let s = await this.downloadFile(e),
            o = qI(i, r);
          return (
            await (0, $I.pipeline)(
              s.data,
              this.encryption.hasEncryption() && e.fileType === 'artifact'
                ? this.encryption.decryptFileStream()
                : new Lb.PassThrough(),
              (0, id.createGunzip)(),
              o
            ),
            o.getResult()
          );
        }
        createCommitFile(e) {
          (0, di.writeFileSync)(e, 'true');
        }
        createCommitFilePath(e, i, n) {
          return n.fileType === 'terminalOutput'
            ? vn.join(i, 'terminalOutputs', `${e}.commit`)
            : vn.join(i, `${e}.commit`);
        }
        async createTarFile(e, i, n, r) {
          let s = this.createFileName(e, i, r);
          try {
            (0, di.unlinkSync)(vn.join(i, e, 'source'));
          } catch {}
          return (
            (0, di.existsSync)(vn.join(i, e, 'terminalOutput')) ||
              (ie &&
                ni.note({
                  title: `FileStorage: terminalOutput does not exist. Creating terminalOutput directory for ${e}`,
                }),
              (0, di.writeFileSync)(vn.join(i, e, 'terminalOutput'), 'No terminal output.')),
            Bu.c({ gzip: !0, sync: !0, file: s, cwd: i }, n),
            this.encryption.hasEncryption() && r.fileType === 'artifact' && this.encryption.encryptFile(s),
            s
          );
        }
        async uploadFile(e, i) {
          process.env.NX_CLOUD_ECONNABORTED_LOGGING == 'true' &&
            ni.note({ title: `Attempting to upload file with path: ${i}` });
          let n = (0, di.readFileSync)(i),
            r = this.generateMD5(n),
            s = this.getFileUploadHeaders(e, r);
          try {
            let o = await tt(() =>
              Pb(
                e,
                this.axiosConfigBuilder({
                  method: 'PUT',
                  data: n,
                  headers: s,
                  maxContentLength: ji ? qs : Bs,
                  maxBodyLength: ji ? qs : Bs,
                  timeout: ji ? $o : 12e4,
                })
              )
            );
          } catch (o) {
            if (o.message && o.message.includes('RetentionPolicyNotMet')) return;
            throw o;
          }
        }
        async uploadFileStream(e, i) {
          process.env.NX_CLOUD_ECONNABORTED_LOGGING == 'true' &&
            ni.note({ title: `Attempting to upload file with path: ${i}` });
          let n = this.getFileUploadHeaders(e, '');
          try {
            let r = await tt(() =>
              Pb(
                e,
                this.axiosConfigBuilder({
                  method: 'PUT',
                  data: i,
                  headers: { ...n, 'Transfer-Encoding': 'chunked' },
                  maxContentLength: ji ? qs : Bs,
                  maxBodyLength: ji ? qs : Bs,
                  timeout: ji ? $o : 12e4,
                })
              )
            );
          } catch (r) {
            if (r.message && r.message.includes('RetentionPolicyNotMet')) return;
            throw r;
          }
        }
        generateMD5(e) {
          let i = (0, VI.createHash)('md5');
          return i.update(e), i.digest('base64');
        }
        getFileUploadHeaders(e, i) {
          let n = e.includes('/file/'),
            r = { 'Content-Type': 'application/octet-stream', 'x-ms-blob-type': 'BlockBlob' };
          return n && (r['Content-MD5'] = i), r;
        }
      });
  });
function hs(t, e) {
  return e == 0 ? 'N/A' : t == 0 ? '0%' : t == e ? '100%' : ((t / e) * 100).toFixed(2) + '%';
}
function Hu(t, e) {
  if (t === void 0 || e === void 0) return 'N/A';
  let i = e - t,
    n = Math.floor((i % (1e3 * 60 * 60)) / (1e3 * 60)),
    r = Math.floor((i % (1e3 * 60)) / 1e3);
  return n == 0 ? `${r}s` : `${n}m ${r}s`;
}
function rd(t) {
  return t == 0 ? '\u2714' : '\u2716';
}
var ue,
  nd,
  ut,
  ds,
  Db = te(() => {
    'use strict';
    (ue = {
      topLeftCorner: '\u250C',
      topMiddleCorner: '\u252C',
      topRightCorner: '\u2510',
      middleLeftCorner: '\u251C',
      middleCorner: '\u253C',
      middleRightCorner: '\u2524',
      bottomLeftCorner: '\u2514',
      bottomMiddleCorner: '\u2534',
      bottomRightCorner: '\u2518',
      verticalEdge: '\u2502',
      horizontalEdge: '\u2500',
    }),
      (nd = 100),
      (ut = class {
        constructor(e, i = 'left', n = !1, r) {
          (this.header = e),
            (this.columnLength = r || Math.max(e.length + 2, 3)),
            (this.textAlign = i),
            (this.autoSize = n);
        }
        resize(e) {
          this.columnLength = e;
        }
        truncateTextToFitColumn(e) {
          let i = ` ${e} `;
          return i.length > this.columnLength ? ` ${e.substring(0, this.columnLength - 3)}\u2026 ` : i;
        }
        formatHeaderText() {
          return this.formatText(this.header, 'center');
        }
        formatText(e, i = this.textAlign) {
          let n = this.truncateTextToFitColumn(e);
          switch (i) {
            case 'left':
              return n.padEnd(this.columnLength);
            case 'center':
              let r = Math.floor((this.columnLength - n.length) / 2);
              return ' '.repeat(r) + n.padEnd(this.columnLength - r);
            case 'right':
              return n.padStart(this.columnLength);
          }
        }
      }),
      (ds = class {
        constructor(e, i = nd) {
          (this.terminalSize = this.getTerminalSize(i)),
            (this.columnSettings = this.autoSizeToTerminalWidth(e)),
            (this.tableRowBorderCount = this.columnSettings.length + 1),
            (this.tableContentLength = e.reduce((n, r) => n + r.columnLength, 0)),
            (this.tableTotalLength = this.tableContentLength + this.tableRowBorderCount);
        }
        getTerminalSize(e) {
          let i = e === 0,
            n = e > nd;
          return i || n ? nd : e;
        }
        autoSizeToTerminalWidth(e) {
          let i = Math.min(this.terminalSize, nd);
          if (this.tableTotalLength > i)
            throw new Error(`Table too large for viewport ${i}, please increase the size of your terminal.`);
          let n = e.length + 1,
            s = e.reduce((p, d) => p + d.columnLength, 0) + n,
            o = i - s,
            c = e.reduce((p, d) => p + (d.autoSize ? 1 : 0), 0),
            u = Math.floor(o / c),
            l = o % c;
          for (let p of e)
            if (p.autoSize) {
              let d = u;
              l > 0 && ((d += 1), (l -= 1)), p.resize(p.columnLength + d);
            }
          return e;
        }
        printHeaders() {
          let e = this.columnSettings.map((i) => i.formatHeaderText()).join(ue.verticalEdge);
          console.log(ue.verticalEdge + e + ue.verticalEdge);
        }
        printTableBorderRow(e, i, n) {
          let r = this.columnSettings.map((o) => ue.horizontalEdge.repeat(o.columnLength)).join(i),
            s = e + r + n;
          console.log(s);
        }
        printTableContentRow(e, i = this.columnSettings, n = ue.verticalEdge) {
          if (e.length !== i.length)
            throw Error('Invalid table configuration, cardinality of data and columns do not match');
          let r = [];
          for (let s = 0; s < e.length; s++) {
            let c = i[s].formatText(e[s]);
            r.push(c);
          }
          console.log(ue.verticalEdge + r.join(n) + ue.verticalEdge);
        }
        printTableCustomBorder(e, i) {
          if (e.length !== i.length + 1)
            throw Error('Invalid table configuration, there should be one edge char for each column edge');
          if (i.length !== this.columnSettings.length)
            throw Error('Invalid table configuration, there should be one border char for each column');
          let n = e[0],
            r = e.slice(1);
          for (let s = 0; s < r.length; s++) {
            let o = i[s].repeat(this.columnSettings[s].columnLength);
            (n += o), (n += r[s]);
          }
          console.log(n);
        }
        printTitleRow(e) {
          let n = new ut(e, 'center', !0, this.tableTotalLength - 2);
          console.log(ue.verticalEdge + n.formatText(e) + ue.verticalEdge);
        }
      });
  });
var W5,
  K5,
  sd,
  WI = te(() => {
    'use strict';
    Le();
    Jl();
    Uc();
    Db();
    (W5 = 50),
      (K5 = 10),
      (sd = class {
        constructor(e, i, n) {
          this.runContext = e;
          this.taskExecutions = i;
          this.distributedExecutionId = n;
        }
        printEndOfRunMessage() {
          let e = process.stdout.columns;
          Fr() && (!e || e >= W5) ? this.printSummaryTables(e) : this.printCacheHitsMessage();
        }
        printSummaryTables(e) {
          if (Zt(this.distributedExecutionId) || !this.runContext.runUrl) return;
          let i = new ds(
            [
              new ut('Status', 'center', !1),
              new ut('Task', 'left', !0),
              new ut('Duration', 'center', !1),
              new ut('Cache Status', 'center', !1, 20),
            ],
            e
          );
          this.buildTaskTable(i);
          let n = [
              new ut('', 'left', !1, 8),
              new ut('', 'left', !0),
              new ut('', 'left', !1, 8),
              new ut('', 'left', !0),
            ],
            r = new ds(n, e);
          this.buildSummaryTable(r);
        }
        buildTaskTable(e) {
          let i = e.autoSizeToTerminalWidth([new ut('', 'center', !1, 8), new ut('', 'left', !0)]);
          e.printTableBorderRow(ue.topLeftCorner, ue.horizontalEdge, ue.topRightCorner),
            e.printTitleRow(`Tasks run for command: ${wi()}`),
            e.printTableBorderRow(ue.middleLeftCorner, ue.horizontalEdge, ue.middleRightCorner),
            e.printTableBorderRow(ue.middleLeftCorner, ue.topMiddleCorner, ue.middleRightCorner),
            e.printHeaders(),
            e.printTableBorderRow(ue.middleLeftCorner, ue.middleCorner, ue.middleRightCorner);
          let { successfulTasks: n, failedTasks: r } = this.taskExecutions.reduce(
            (s, o) => (o.status === 0 ? s.successfulTasks.push(o) : s.failedTasks.push(o), s),
            { successfulTasks: [], failedTasks: [] }
          );
          if (
            (n.forEach((s) => {
              e.printTableContentRow(this.getRowDataFromTask(s));
            }),
            r.length > 0)
          ) {
            e.printTableCustomBorder(
              [
                ue.verticalEdge,
                ue.bottomLeftCorner,
                ue.bottomMiddleCorner,
                ue.bottomMiddleCorner,
                ue.middleRightCorner,
              ],
              [' ', ue.horizontalEdge, ue.horizontalEdge, ue.horizontalEdge]
            ),
              r.forEach((s) => {
                let o = ` > Logs: ${this.runContext.runUrl}/task/${encodeURIComponent(s.taskId)}`,
                  c = o.length <= e.tableContentLength - K5 ? o : ' > See the URL below for failure logs.';
                e.printTableContentRow(this.getRowDataFromTask(s), void 0, ' '),
                  e.printTableContentRow(['', c], i, ' ');
              }),
              e.printTableBorderRow(ue.bottomLeftCorner, ue.horizontalEdge, ue.bottomRightCorner);
            return;
          }
          e.printTableBorderRow(ue.bottomLeftCorner, ue.bottomMiddleCorner, ue.bottomRightCorner);
        }
        buildSummaryTable(e) {
          let i = this.taskExecutions.reduce((d, x) => d + (x.cacheStatus !== 'cache-miss' ? 1 : 0), 0),
            n = this.taskExecutions.reduce((d, x) => d + (x.status === 0 ? 1 : 0), 0),
            r = this.taskExecutions.reduce((d, x) => d + (x.status !== 0 ? 1 : 0), 0),
            s = this.taskExecutions.length,
            o = hs(i, s),
            c = hs(n, s),
            u = hs(r, s),
            l = this.taskExecutions.reduce(
              ({ min: d, max: x }, b) => {
                let g = new Date(b.startTime).getTime(),
                  y = new Date(b.endTime).getTime();
                return { min: Math.min(d, g), max: Math.max(x, y) };
              },
              { min: 1 / 0, max: -1 / 0 }
            ),
            p = Hu(l.min, l.max);
          e.printTableBorderRow(ue.topLeftCorner, ue.horizontalEdge, ue.topRightCorner),
            e.printTitleRow('Nx Cloud Task Runner Report'),
            e.printTableBorderRow(ue.middleLeftCorner, ue.horizontalEdge, ue.middleRightCorner),
            e.printTableBorderRow(ue.middleLeftCorner, ue.topMiddleCorner, ue.middleRightCorner),
            e.printTableContentRow([n.toString(), 'Successful Tasks', c, 'Success Percentage']),
            e.printTableContentRow([r.toString(), 'Failed Tasks', u, 'Failure Percentage']),
            e.printTableBorderRow(ue.middleLeftCorner, ue.middleCorner, ue.middleRightCorner),
            e.printTableContentRow([i.toString(), 'Cached Tasks', o, 'Cache Hit Percentage']),
            e.printTableContentRow([s.toString(), 'Total Executed Tasks', p, 'Run Duration']),
            e.printTableBorderRow(ue.middleLeftCorner, ue.bottomMiddleCorner, ue.middleRightCorner),
            e.printTitleRow(`See run details: ${this.runContext.runUrl}`),
            e.printTableBorderRow(ue.bottomLeftCorner, ue.horizontalEdge, ue.bottomRightCorner);
        }
        getRowDataFromTask(e) {
          var s;
          let i = rd(e.status),
            n = Hu(new Date(e.startTime).getTime(), new Date(e.endTime).getTime()),
            r =
              ((s = e.cacheStatus) == null
                ? void 0
                : s
                    .split('-')
                    .map((o) => o.charAt(0).toUpperCase() + o.slice(1))
                    .join(' ')) ?? 'N/A';
          return [i, e.taskId, n, r];
        }
        printCacheHitsMessage() {
          if (Zt(this.distributedExecutionId) || !this.runContext.runUrl) return;
          let e = !!this.taskExecutions.find((s) => s.status !== 0),
            i = !!this.taskExecutions.find((s) => s.cacheStatus === 'cache-miss'),
            n = this.taskExecutions
              .filter((s) => this.runContext.statuses[s.hash] === 'remote-cache-hit')
              .map((s) => s.projectName),
            r = [];
          if (e) r.push(`View structured, searchable error logs at ${this.runContext.runUrl}`);
          else if (i) r.push(`View logs and investigate cache misses at ${this.runContext.runUrl}`);
          else if (n.length > 0) {
            let s = n.length === 1 ? n[0] : `${n.length} tasks`;
            r.push(`Nx Cloud made it possible to reuse ${s}: ${this.runContext.runUrl}`);
          } else this.runContext.runUrl && r.push(`View logs and run details at ${this.runContext.runUrl}`);
          r.length > 0 && Yo(r.join('. '));
        }
      });
  });
var ri = P((ct) => {
  'use strict';
  var Fb = require('path');
  Pc();
  try {
    try {
      let t;
      try {
        t = He('nx/src/utils/app-root').workspaceRoot;
      } catch {
        t = He('nx/src/utils/workspace-root').workspaceRoot;
      }
      let { getDependencyConfigs: e } = He('nx/src/tasks-runner/utils'),
        i = He('nx/tasks-runners/default').default,
        { CompositeLifeCycle: n } = He('nx/src/tasks-runner/life-cycle'),
        r = null;
      try {
        r = He('nx/src/index').initTasksRunner;
      } catch {}
      let s;
      try {
        s = He('nx/src/devkit-exports').cacheDir;
      } catch {
        try {
          s = He('nx/src/utils/cache-directory').cacheDir;
        } catch {
          s = (0, Fb.join)(t, './node_modules/.cache/nx');
        }
      }
      let o;
      try {
        o = He('nx/src/utils/cache-directory').workspaceDataDirectory ?? s;
      } catch {
        o = s;
      }
      let c = He('nx/src/tasks-runner/utils').isCacheableTask,
        u,
        l,
        p;
      try {
        (u = He('nx/src/devkit-exports').getPackageManagerCommand),
          (l = He('nx/src/devkit-exports').detectPackageManager),
          (p = He('nx/src/devkit-exports').writeJsonFile);
      } catch {
        (u = He('nx/src/utils/package-manager').getPackageManagerCommand),
          (l = He('nx/src/utils/package-manager').detectPackageManager),
          (p = He('nx/src/utils/fileutils').writeJsonFile);
      }
      let d;
      try {
        d = He('nx/src/tasks-runner/cache').getCache;
      } catch {}
      (ct.cacheDirectory = s),
        (ct.runnerReturnsPromise = !0),
        (ct.tasksRunner = i),
        (ct.CompositeLifeCycle = n),
        (ct.getDependencyConfigs = e),
        (ct.initTasksRunner = r),
        (ct.isCacheableTask = c),
        (ct.getPackageManagerCommand = u),
        (ct.detectPackageManager = l),
        (ct.writeJsonFile = p),
        (ct.workspaceDataDirectory = o),
        (ct.getCache = d);
    } catch {
      let { appRootPath: e, workspaceRoot: i } = He('@nrwl/tao/src/utils/app-root'),
        n = e ?? i,
        { getDependencyConfigs: r } = He('@nrwl/workspace/src/tasks-runner/utils'),
        { tasksRunnerV2: s } = He('@nrwl/workspace/src/tasks-runner/tasks-runner-v2'),
        o;
      try {
        o = He('@nrwl/workspace/src/tasks-runner/life-cycle').CompositeLifeCycle;
      } catch {}
      let c = He('@nrwl/workspace/src/tasks-runner/utils').isCacheableTask,
        u = He('@nrwl/devkit/index').getPackageManagerCommand,
        l = He('@nrwl/devkit/index').detectPackageManager,
        p = He('@nrwl/devkit/index').writeJsonFile;
      (ct.cacheDirectory = (0, Fb.join)(n, './node_modules/.cache/nx')),
        (ct.runnerReturnsPromise = !1),
        (ct.tasksRunner = s),
        (ct.CompositeLifeCycle = o),
        (ct.getDependencyConfigs = r),
        (ct.initTasksRunner = null),
        (ct.isCacheableTask = c),
        (ct.workspaceDataDirectory = ct.cacheDirectory),
        (ct.getPackageManagerCommand = u),
        (ct.detectPackageManager = l),
        (ct.writeJsonFile = p),
        (ct.getCache = void 0);
    }
  } catch (t) {
    process.env.NX_VERBOSE_LOGGING === 'true' && console.log(t),
      console.error('NX CLOUD ERROR'),
      console.error('---------------------------------------'),
      console.error(
        'This version of Nx Cloud is incompatible with the @nrwl/* and @nx/* packages in your workspace, or Nx was not installed properly.'
      ),
      console.error(''),
      console.error('Verify your install step was successful, and if it was,'),
      console.error(
        'match your @nrwl/nx-cloud version to the same major version of your @nx/* and @nrwl/* packages and try again.'
      ),
      console.error('---------------------------------------'),
      process.exit(1);
  }
});
var KI,
  XI,
  jb,
  Mb,
  Ka,
  Ub = te(() => {
    'use strict';
    (KI = require('fs')), (XI = require('path'));
    Le();
    Uc();
    ({ output: jb } = Ae()),
      ({ cacheDirectory: Mb } = ri()),
      (Ka = class {
        constructor(e) {
          this.options = e;
          this.cacheError = null;
          this.apiError = null;
          this.message = null;
          this.isAgentRunningInDte = Zt(process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID);
        }
        get anyErrors() {
          return this.cacheError || this.apiError;
        }
        printMessages() {
          if (this.anyErrors) {
            let e = [];
            this.cacheError && e.push(`- ${this.cacheError}`),
              this.apiError && this.apiError !== this.cacheError && e.push(`- ${this.apiError}`),
              jb.warn({ title: 'Nx Cloud Problems', bodyLines: e });
          }
          this.message && Yo(this.message), this.isAgentRunningInDte && this.setErrorMessageForAgent();
        }
        extractErrorMessage(e, i) {
          if (e.code === 'ECONNABORTED')
            return (
              process.env.NX_CLOUD_ECONNABORTED_LOGGING == 'true' &&
                (console.log('[NX CLOUD DEBUG] Request config without `data`'),
                delete e.config.data,
                console.log(JSON.stringify(e.config, null, 2))),
              `Cannot connect to Nx Cloud (scope: ${i}, code: ${e.code}). Try invoking the command with the NX_CLOUD_NO_TIMEOUTS env variable set to 'true'.`
            );
          if (e.code === 'ECONNREFUSED' || e.code === 'EAI_AGAIN' || e.code === 'ENOTFOUND' || e.code === 'EPROTO')
            return `Cannot connect to Nx Cloud (scope: ${i}, code: ${e.code}).`;
          if (e.response && e.response.status === 401)
            return e.response.data.message ? e.response.data.message : e.response.data;
          if (e.response && e.response.status === 402)
            return this.options.showUsageWarnings === !1 || this.options.showUsageWarnings === void 0
              ? null
              : e.response.data.message
              ? e.response.data.message
              : e.response.data;
          {
            let n = '';
            e.response && e.response.data && e.response.data.message
              ? (n = `. ${e.response.data.message}`)
              : e.response && e.response.data && (n = `. ${e.response.data}`);
            let r = e.code ? ` (code: ${e.code})` : '';
            return `${e.message}${n}${r}`;
          }
        }
        setErrorMessageForAgent() {
          let e =
            this.cacheError ||
            this.apiError ||
            'Unexpected failure in agent. If the issue persists, please contact support at cloud-support@nrwl.io';
          if (process.env.NX_CLOUD_INVOKED_WITH_RUN_MANY === 'true') {
            ie && jb.note({ title: `Writing error message to ${Mb}`, bodyLines: [e] });
            try {
              let i = (0, XI.join)(Mb, Dc);
              (0, KI.writeFileSync)(i, e, { encoding: 'utf-8' });
            } catch {
              ie && jb.note({ title: `Failed to write error message to ${Mb}` });
            }
          } else OS(e);
        }
      });
  });
var ms,
  od = te(() => {
    'use strict';
    ms = class {
      constructor(e = []) {
        this.normalizedMaskedProperties = [];
        this.normalizedMaskedProperties = Array.from(new Set(e)).map(this.toCamelCase);
      }
      obfuscate(e) {
        return (
          this.normalizedMaskedProperties.length &&
            (this.normalizedMaskedProperties.forEach((n) => {
              let r = new RegExp(`(--${n}=)[\\S]*`, 'g');
              e = e.replaceAll(r, '$1********');
            }),
            this.normalizedMaskedProperties
              .filter((n) => n in process.env)
              .map((n) => process.env[n])
              .forEach((n) => {
                e = e.replaceAll(n, '********');
              })),
          e
        );
      }
      toCamelCase(e) {
        return e.indexOf('-') > 1 ? e.toLowerCase().replace(/-(.)/g, (i, n) => n.toUpperCase()) : e;
      }
    };
  });
function Xa(t) {
  return t.overrides.__overrides_unparsed__ ? t.overrides.__overrides_unparsed__.join(' ') : qb(t.overrides).join(' ');
}
function qb(t) {
  let e = [];
  for (let i of Object.keys(t)) {
    let n = t[i];
    YI(i, n, e);
  }
  return e;
}
function YI(t, e, i) {
  if (t === '_') i.push(...e);
  else if (e === !0) i.push(`--${t}`);
  else if (e === !1) i.push(`--no-${t}`);
  else if (Array.isArray(e)) e.forEach((n) => YI(t, n, i));
  else if (typeof e == 'string' && X5(e)) {
    let n = e.replace(/"/g, String.raw`\"`);
    i.push(`--${t}="${n}"`);
  } else e != null && i.push(`--${t}=${e}`);
}
function X5(t) {
  return t.includes(' ') || t.includes('{') || t.includes('"');
}
var Gu = te(() => {
  'use strict';
});
function ZI(t, e, i, n, r) {
  let s;
  t
    ? t.startsWith('./')
      ? (s = (0, Gb.join)(JI, t))
      : (s = t)
    : (s = (0, Gb.join)(JI, 'node_modules', '.cache', 'nx'));
  try {
    let o = Q5(s, i),
      c = e.obfuscate(o);
    if (bS) return c;
    let u = n === 'cache-miss' ? (r === 0 ? J5 : Y5) : Z5;
    return c.length > u
      ? `TRUNCATED

${c.slice(c.length - u)}`
      : c;
  } catch (o) {
    return process.env.NX_VERBOSE_LOGGING === 'true' && console.error(o), '';
  }
}
function Q5(t, e) {
  try {
    return (0, Bb.readFileSync)(Hb.join(t, 'terminalOutputs', e)).toString();
  } catch {
    try {
      return (0, Bb.readFileSync)(Hb.join(t, e, 'terminalOutput')).toString();
    } catch {
      return '';
    }
  }
}
var Bb,
  Hb,
  Gb,
  JI,
  Y5,
  J5,
  Z5,
  QI = te(() => {
    'use strict';
    (Bb = require('fs')), (Hb = je(require('path'))), (Gb = require('path'));
    Le();
    ({ workspaceRoot: JI } = Ae()), (Y5 = 2e5), (J5 = 2e4), (Z5 = 2e4);
  });
var eN,
  ad,
  cd,
  tN = te(() => {
    'use strict';
    eN = require('crypto');
    Gu();
    QI();
    (ad = class {
      constructor(e) {
        this.lifeCycles = e;
      }
      startCommand() {}
      scheduleTask(e) {
        for (let i of this.lifeCycles) i.scheduleTask && i.scheduleTask(e);
      }
      async startTasks(e) {
        for (let i of this.lifeCycles)
          i.startTasks ? await i.startTasks(e) : i.startTask && e.forEach((n) => i.startTask(n));
      }
      async endTasks(e) {
        for (let i of this.lifeCycles)
          i.endTasks ? await i.endTasks(e) : i.endTask && e.forEach((n) => i.endTask(n.task, n.code));
      }
      printTaskTerminalOutput(e, i, n) {}
      endCommand() {}
    }),
      (cd = class {
        constructor(e, i, n, r, s) {
          this.runContext = e;
          this.cacheDirectory = i;
          this.cacheableOperations = n;
          this.outputObfuscator = r;
          this.tasks = s;
        }
        scheduleTask(e) {
          this.runContext.scheduledTasks.push(e);
        }
        startCommand() {}
        printTaskTerminalOutput(e, i, n) {}
        startTasks(e) {
          for (let i of e) this.startTask(i);
        }
        startTask(e) {
          this.tasks.push({
            taskId: e.id,
            startTime: new Date().toISOString(),
            target: e.target.target,
            projectName: e.target.project,
            hash: e.hash,
            hashDetails: this.cleanUpHashDetails(e.hashDetails),
            params: Xa(e),
            uploadedToStorage: !1,
            terminalOutputUploadedToFileStorage: !1,
            isCacheable: e.cache,
            parallelism: e.parallelism,
          });
        }
        endTasks(e) {
          for (let i of e) {
            let n,
              r = i.status === 'remote-cache',
              s = i.status === 'cache',
              o = i.status === 'local-cache' || i.status === 'local-cache-kept-existing' || s;
            this.runContext.statuses[i.task.hash]
              ? (n = this.runContext.statuses[i.task.hash])
              : r
              ? (n = 'remote-cache-hit')
              : o
              ? (n = 'local-cache-hit')
              : (n = 'cache-miss');
            let c = this.runContext.allTasks.find((u) => u.id === i.task.id);
            c && (c.terminalOutput = i.terminalOutput), this.updateStartedTask(i, n);
          }
        }
        endCommand() {}
        updateStartedTask(e, i) {
          let n = this.tasks.find((r) => r.taskId === e.task.id);
          if (!n) throw new Error(`Cannot find task ${e.task.id}`);
          e != null && e.startTime && e != null && e.endTime
            ? ((n.startTime = new Date(e.startTime).toISOString()), (n.endTime = new Date(e.endTime).toISOString()))
            : (n.endTime = new Date().toISOString()),
            (n.status = e.code),
            (n.params = this.outputObfuscator.obfuscate(n.params)),
            (n.cacheStatus = i),
            (n.terminalOutput = '');
        }
        getTerminalOutput(e, i, n) {
          return ZI(this.cacheDirectory, this.outputObfuscator, e, i, n);
        }
        cleanUpHashDetails(e) {
          let i = {},
            n = [];
          for (let r of Object.keys(e.nodes)) r.startsWith('npm:') ? n.push(e.nodes[r]) : (i[r] = e.nodes[r]);
          if ((n.sort(), n.length > 0)) {
            let r = (0, eN.createHash)('md5');
            r.update(n.join('|')), (i.npmDependencies = r.digest('base64'));
          }
          return { nodes: i, runtime: e.runtime, implicitDeps: e.implicitDeps };
        }
      });
  });
var rN = {};
Ft(rN, { CloudRemoteCache: () => ud, default: () => Gn });
var bo,
  nN,
  wn,
  iN,
  ud,
  e9,
  Gn,
  zb = te(() => {
    'use strict';
    (bo = require('fs')), (nN = require('fs/promises')), (wn = je(require('path')));
    Le();
    ({ output: iN } = Ae()),
      (ud = class {
        constructor() {
          this.storeRequests = [];
          this.delayedStoreRequests = [];
          this.useV1Cache = !1;
        }
        instantiate(e, i, n, r, s, o) {
          (this.messages = e),
            (this.api = i),
            (this.runContext = n),
            (this.fileStorage = r),
            (this.distributedExecutionId = s),
            (this.storeInCurrentProcess = o);
        }
        async retrieve(e, i) {
          if (this.messages.cacheError) return null;
          let n = await this.getArtifactUploadLocations(e),
            r = n == null ? void 0 : n.artifactUrls,
            s = n == null ? void 0 : n.terminalOutputUrls;
          if (!r || !r.get)
            return (
              ie && iN.note({ title: `Nx Cloud: Cache miss ${e}.` }), (this.runContext.statuses[e] = 'cache-miss'), null
            );
          let o = [{ remoteUrl: r.get, fileType: 'artifact' }];
          return (
            s && s.get && o.push({ remoteUrl: s.get, fileType: 'terminalOutput' }), this.retrieveFilesFromCache(e, i, o)
          );
        }
        async store(e, i, n, r) {
          if (this.messages.cacheError) return !1;
          let s = new Promise(async (o, c) => {
            let u = await this.getArtifactUploadLocations(e),
              l = [],
              p = u == null ? void 0 : u.artifactUrls,
              d = u == null ? void 0 : u.terminalOutputUrls;
            return (
              d &&
                d.put &&
                (l.push({ remoteUrl: d.put, fileType: 'terminalOutput' }),
                this.setTerminalOutputAsUploadedToStorage(e, !0)),
              !p && !d
                ? o(!1)
                : (p && p.put
                    ? l.push({ remoteUrl: p.put, fileType: 'artifact' })
                    : ie &&
                      iN.note({
                        title: `Nx Cloud: Skipping storing ${e}.`,
                        bodyLines: [
                          'There are several reasons why this can happen.',
                          "Maybe you don't have the necessary permissions to perform this action or the artifact has already been uploaded.",
                        ],
                      }),
                  this.storeInCurrentProcess
                    ? o(await this.storeFilesInCache(e, i, l, n, r))
                    : (this.delayedStoreRequests.push(
                        ...l.map((x) => ({
                          hash: e,
                          cacheFile: x,
                          cacheDirectory: i,
                          terminalOutput: n,
                          code: r,
                          useV1Cache: this.useV1Cache,
                        }))
                      ),
                      o(!0)))
            );
          });
          return this.storeRequests.push(s), s;
        }
        async retrieveFilesFromCache(e, i, n) {
          try {
            let r = null,
              s = null;
            for (let o of n)
              switch (o.fileType) {
                case 'artifact':
                  r = await this.fileStorage.retrieve(e, i, o, this.useV1Cache);
                  break;
                case 'terminalOutput':
                  s = await this.fileStorage.retrieve(e, i, o, this.useV1Cache);
                  break;
              }
            return (
              (this.runContext.statuses[e] = 'remote-cache-hit'),
              r && s
                ? { code: r.code, terminalOutput: s.terminalOutput, outputsPath: r.outputsPath }
                : r
                ? { code: r.code, terminalOutput: r.terminalOutput, outputsPath: r.outputsPath }
                : null
            );
          } catch (r) {
            let s = r.axiosException ?? r;
            return (
              (this.messages.cacheError = this.messages.extractErrorMessage(s, 'storage')),
              (this.runContext.statuses[e] = 'cache-miss'),
              null
            );
          }
        }
        async storeFilesInCache(e, i, n, r, s) {
          try {
            return (
              await Promise.all(
                n.map(async (o) => {
                  switch (o.fileType) {
                    case 'artifact':
                      r != null && s != null
                        ? await this.fileStorage.storeV2(e, i, o, r, s)
                        : await this.fileStorage.store(e, i, o, [
                            wn.join(e, 'outputs'),
                            wn.join(e, 'code'),
                            wn.join(e, 'terminalOutput'),
                          ]);
                      break;
                    case 'terminalOutput':
                      if (r != null && s != null) await this.fileStorage.storeV2(e, i, o, r, s);
                      else {
                        let c = (0, bo.existsSync)(wn.join(i, 'terminalOutputs', e))
                          ? wn.join('terminalOutputs', e)
                          : wn.join(e, 'terminalOutput');
                        await this.fileStorage.store(e, i, o, [c]);
                      }
                      break;
                  }
                })
              ),
              !0
            );
          } catch (o) {
            let c = o.axiosException ?? o;
            return (this.messages.cacheError = this.messages.extractErrorMessage(c, 'storage')), !1;
          }
        }
        async storeTerminalOutputsInCache(e, i, n, r) {
          if (this.messages.cacheError) return !1;
          let s = Promise.resolve().then(async () => {
            let o = await this.getArtifactUploadLocations(e),
              c = o == null ? void 0 : o.terminalOutputUrls,
              u;
            if (
              (c &&
                c.put &&
                ((u = { remoteUrl: c.put, fileType: 'terminalOutput' }),
                this.setTerminalOutputAsUploadedToStorage(e, !0)),
              u === void 0)
            )
              return !0;
            if (n == null) {
              if (!(0, bo.existsSync)(wn.join(i, 'terminalOutputs', e))) {
                let l = '',
                  p = Fm(),
                  d = +p[1],
                  x = p[2] ? +p[2] : 9999,
                  b = d === 17 && x >= 3,
                  g = d === 18 && x <= 2;
                (b || g) &&
                  (l =
                    'There is a known bug with this version of Nx when generating terminal outputs. Update to at least 18.3 to resolve this issue');
                let y = wn.join(i, 'terminalOutputs');
                (0, bo.mkdirSync)(y, { recursive: !0 }), (0, bo.writeFileSync)(wn.join(y, e), l);
              }
              n = (await (0, nN.readFile)(wn.join(i, 'terminalOutputs', e))).toString();
            }
            if (!this.storeInCurrentProcess)
              return (
                this.delayedStoreRequests.push({ hash: e, cacheFile: u, cacheDirectory: i, terminalOutput: n }), !0
              );
            try {
              return await this.fileStorage.storeV2(e, i, u, n, r ?? 1, !1), !0;
            } catch (l) {
              let p = l.axiosException ?? l;
              return (this.messages.cacheError = this.messages.extractErrorMessage(p, 'storage')), !1;
            }
          });
          return this.storeRequests.push(s), s;
        }
        async getArtifactUploadLocations(e) {
          if (e in this.runContext.requests) {
            let i = (await this.runContext.requests[e])[e];
            return this.setTaskArtifactIdOnRunContext(e, i == null ? void 0 : i.artifactId), i;
          } else {
            let i = this.runContext.scheduledTasks.filter((s) => !this.runContext.requests[s.hash]).map((s) => s.hash);
            i.indexOf(e) === -1 && i.push(e);
            let n = this.api.startRun(this.distributedExecutionId, i);
            i.forEach((s) => {
              this.runContext.requests[s] = n;
            });
            let r = (await n)[e];
            return this.setTaskArtifactIdOnRunContext(e, r == null ? void 0 : r.artifactId), r;
          }
        }
        async waitForStoreRequestsToComplete() {
          if (!(await Promise.all(this.storeRequests).then((i) => i.reduce((n, r) => n && r, !0))))
            throw new Error('Error when storing artifacts');
        }
        setTaskArtifactIdOnRunContext(e, i) {
          let n = this.runContext.allTasks.find((r) => r.hash === e);
          if (n === void 0) throw Error(`Could not find task with hash ${e}`);
          n.artifactId = i;
        }
        setTerminalOutputAsUploadedToStorage(e, i) {
          let n = this.runContext.allTasks.find((r) => r.hash === e);
          if (n === void 0) throw Error(`Could not find task with hash ${e}`);
          n.terminalOutputUploadedToFileStorage = i;
        }
      }),
      (e9 = new ud()),
      (Gn = e9);
  });
var Vb = P((dae, sN) => {
  'use strict';
  var t9 = require('crypto');
  sN.exports = function () {
    return t9.randomBytes(16);
  };
});
var $b = P((hae, aN) => {
  'use strict';
  var oN = [];
  for (zu = 0; zu < 256; ++zu) oN[zu] = (zu + 256).toString(16).substr(1);
  var zu;
  function i9(t, e) {
    var i = e || 0,
      n = oN;
    return [
      n[t[i++]],
      n[t[i++]],
      n[t[i++]],
      n[t[i++]],
      '-',
      n[t[i++]],
      n[t[i++]],
      '-',
      n[t[i++]],
      n[t[i++]],
      '-',
      n[t[i++]],
      n[t[i++]],
      '-',
      n[t[i++]],
      n[t[i++]],
      n[t[i++]],
      n[t[i++]],
      n[t[i++]],
      n[t[i++]],
    ].join('');
  }
  aN.exports = i9;
});
var lN = P((mae, uN) => {
  'use strict';
  var n9 = Vb(),
    r9 = $b(),
    cN,
    Wb,
    Kb = 0,
    Xb = 0;
  function s9(t, e, i) {
    var n = (e && i) || 0,
      r = e || [];
    t = t || {};
    var s = t.node || cN,
      o = t.clockseq !== void 0 ? t.clockseq : Wb;
    if (s == null || o == null) {
      var c = n9();
      s == null && (s = cN = [c[0] | 1, c[1], c[2], c[3], c[4], c[5]]),
        o == null && (o = Wb = ((c[6] << 8) | c[7]) & 16383);
    }
    var u = t.msecs !== void 0 ? t.msecs : new Date().getTime(),
      l = t.nsecs !== void 0 ? t.nsecs : Xb + 1,
      p = u - Kb + (l - Xb) / 1e4;
    if (
      (p < 0 && t.clockseq === void 0 && (o = (o + 1) & 16383),
      (p < 0 || u > Kb) && t.nsecs === void 0 && (l = 0),
      l >= 1e4)
    )
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    (Kb = u), (Xb = l), (Wb = o), (u += 122192928e5);
    var d = ((u & 268435455) * 1e4 + l) % 4294967296;
    (r[n++] = (d >>> 24) & 255), (r[n++] = (d >>> 16) & 255), (r[n++] = (d >>> 8) & 255), (r[n++] = d & 255);
    var x = ((u / 4294967296) * 1e4) & 268435455;
    (r[n++] = (x >>> 8) & 255),
      (r[n++] = x & 255),
      (r[n++] = ((x >>> 24) & 15) | 16),
      (r[n++] = (x >>> 16) & 255),
      (r[n++] = (o >>> 8) | 128),
      (r[n++] = o & 255);
    for (var b = 0; b < 6; ++b) r[n + b] = s[b];
    return e || r9(r);
  }
  uN.exports = s9;
});
var fN = P((gae, pN) => {
  'use strict';
  var o9 = Vb(),
    a9 = $b();
  function c9(t, e, i) {
    var n = (e && i) || 0;
    typeof t == 'string' && ((e = t === 'binary' ? new Array(16) : null), (t = null)), (t = t || {});
    var r = t.random || (t.rng || o9)();
    if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), e)) for (var s = 0; s < 16; ++s) e[n + s] = r[s];
    return e || a9(r);
  }
  pN.exports = c9;
});
var Vu = P((xae, hN) => {
  'use strict';
  var u9 = lN(),
    dN = fN(),
    Yb = dN;
  Yb.v1 = u9;
  Yb.v4 = dN;
  hN.exports = Yb;
});
async function vo() {
  let t = p9();
  ie && console.log('[Nx Cloud Debug] Attempting to acquire filesystem lock with path: ', t);
  try {
    (0, Er.mkdirSync)(t), ie && console.log('[Nx Cloud Debug] Successfully created folder lock at path:', t);
  } catch {
    return ie && console.log('[Nx Cloud Debug] Failed to create folder lock at path:', t), await f9(t);
  }
  return yN(t);
}
function p9() {
  return (0, ld.join)((0, mN.tmpdir)(), 'client-instance-id.lock');
}
function yN(t) {
  try {
    ie && console.log('[Nx Cloud Debug] Attempting to write client instance id into lockfile');
    let e = gN.default.v4();
    return (
      (0, Er.writeFileSync)((0, ld.join)(t, xN), e, { encoding: 'utf-8' }),
      ie && console.log('[Nx Cloud Debug] Successfully wrote client instance id into lockfile'),
      e
    );
  } catch {
    throw new Error('Skipped writing client instance id into lockfile');
  }
}
async function f9(t) {
  try {
    let e = (0, ld.join)(t, xN);
    return (0, Er.existsSync)(e) || (await wt(250), (0, Er.existsSync)(e) || yN(t)), (0, Er.readFileSync)(e, 'utf-8');
  } catch {
    return ie && console.log('[Nx Cloud Debug] Failed to read client id lockfile, returning default value'), l9;
  }
}
var Er,
  mN,
  ld,
  gN,
  xN,
  l9,
  pd = te(() => {
    'use strict';
    (Er = require('fs')), (mN = require('os')), (ld = require('path')), (gN = je(Vu()));
    Le();
    Pn();
    (xN = 'client-instance-id.uuid'), (l9 = '00000000-0000-0000-0000-000000000000');
  });
function wN() {
  return Math.floor(Math.random() * 100) + 1 <= (Dm ? 100 : d9) ? h9() : null;
}
function h9() {
  try {
    let t = (0, bN.execSync)('git log --since="30 days ago" --format="%ae %an"', {
        stdio: 'pipe',
        windowsHide: !0,
        encoding: 'utf-8',
      }).trim().split(`
`),
      e = Array.from(new Set(t)),
      i = {};
    for (let r of e) {
      let [s, ...o] = r.split(' '),
        c = m9(s);
      i[c] || (i[c] = o.join(' '));
    }
    let n = {};
    for (let [r, s] of Object.entries(i)) n[s] || (n[s] = r);
    return Object.values(n);
  } catch {
    return null;
  }
}
function m9(t) {
  let e = (0, vN.createHash)('md5');
  return e.update(t), e.digest('base64');
}
var bN,
  vN,
  d9,
  EN = te(() => {
    'use strict';
    (bN = require('child_process')), (vN = require('crypto'));
    Le();
    d9 = 5;
  });
function fd(t) {
  if (t == null) return null;
  let e = Buffer.from(t),
    i = (0, _N.createHash)('sha256');
  return i.update(e), i.digest('hex');
}
var _N,
  Jb = te(() => {
    'use strict';
    _N = require('crypto');
  });
function Ya(t) {
  if (!t) return null;
  let e = {};
  Object.entries(t.nodes).forEach(([n, r]) => {
    r.type !== 'npm' &&
      (e[n] = {
        type: r.type,
        name: r.name,
        data: { root: r.data.root, sourceRoot: r.data.sourceRoot, metadata: r.data.metadata, targets: r.data.targets },
      });
  });
  let i = {};
  return (
    Object.entries(t.dependencies).forEach(([n, r]) => {
      n.startsWith('npm:') || (i[n] = r);
    }),
    { nodes: e, dependencies: i }
  );
}
var dd = te(() => {
  'use strict';
});
var SN,
  CN,
  RN,
  $u,
  Ja,
  Zb = te(() => {
    'use strict';
    (SN = require('fs')), (CN = require('util')), (RN = require('zlib'));
    pd();
    mn();
    EN();
    Jb();
    Le();
    sa();
    dd();
    ({ output: $u } = Ae()),
      (Ja = class {
        constructor(e, i, n, r) {
          this.messages = e;
          this.runContext = i;
          this.machineInfo = r;
          (this.apiAxiosInstance = zt(n)),
            process.env.NX_CLOUD_CLIENT_INSTANCE_ID
              ? ((this.clientInstanceId = process.env.NX_CLOUD_CLIENT_INSTANCE_ID),
                (this.clientInstanceSource = 'DTE_AGENT'))
              : (this.clientInstanceSource = 'CLOUD_RUNNER');
        }
        async startRun(e, i) {
          if (this.messages.apiError) return {};
          this.clientInstanceId || (this.clientInstanceId = await vo());
          try {
            let n = {
              meta: { nxCloudVersion: this.nxCloudVersion() },
              branch: It(),
              runGroup: Ct(),
              ciExecutionId: At(),
              ciExecutionEnv: kt(),
              distributedExecutionId: e,
              hashes: i,
              machineInfo: this.machineInfo,
              vcsContext: qi(),
              clientInstanceSource: this.clientInstanceSource,
              clientInstanceId: this.clientInstanceId,
            };
            ie &&
              $u.note({
                title: 'RunStart',
                bodyLines: [
                  `
` + JSON.stringify(n, null, 2),
                ],
              });
            let r = await Hg('RunStart duration', () =>
              tt(() => this.apiAxiosInstance.post('/nx-cloud/v2/runs/start', n))
            );
            return (
              r.data && r.data.message && (this.messages.message = r.data.message),
              !r.data || !r.data.artifacts
                ? ((this.messages.apiError = `Invalid Nx Cloud response: ${JSON.stringify(r.data)}`), {})
                : r.data.artifacts
            );
          } catch (n) {
            return (this.messages.apiError = this.messages.extractErrorMessage(n, 'api')), {};
          }
        }
        createEndRunReqBody(e, i, n, r, s, o) {
          let c = Ya(r),
            u = {
              meta: { nxCloudVersion: this.nxCloudVersion(), ...s },
              tasks: i,
              run: e,
              linkId: o,
              ...n,
              projectGraph: c,
              projectGraphSha: c == null ? null : fd(JSON.stringify(c)),
              machineInfo: this.machineInfo,
              vcsContext: qi(),
              hashedContributors: wN(),
              clientInstanceSource: this.clientInstanceSource,
              clientInstanceId: this.clientInstanceId,
            };
          return JSON.stringify(u);
        }
        async endRun(e, i, n, r, s, o) {
          if (this.messages.apiError) return !1;
          this.clientInstanceId || (this.clientInstanceId = await vo()), (e.runGroup = null), (e.branch = null);
          let c = this.createEndRunReqBody(e, i, n, r, s, o);
          c.length > 20 * 1e3 * 1e3 &&
            (c = this.createEndRunReqBody(
              e,
              i.map((p) => ({ ...p, hashDetails: void 0 })),
              n,
              r,
              s,
              o
            ));
          let u = Buffer.from(c),
            l = await (0, CN.promisify)(RN.gzip)(u);
          try {
            if (ie) {
              let d = i.map((x) => ({
                ...x,
                terminalOutput: x.terminalOutput ? `${x.terminalOutput.slice(0, 20)}...` : void 0,
              }));
              $u.note({
                title: 'RunEnd. Completed tasks',
                bodyLines: [
                  `
` + JSON.stringify(d, null, 2),
                ],
              });
            }
            let p = await Hg('RunEnd duration', () =>
              tt(() =>
                this.apiAxiosInstance.post('/nx-cloud/runs/end', l, {
                  headers: {
                    ...this.apiAxiosInstance.defaults.headers,
                    'Content-Encoding': 'gzip',
                    'Content-Type': 'application/octet-stream',
                  },
                })
              )
            );
            if (p) {
              if (p.data && p.data.runUrl && p.data.status === 'success')
                return (this.runContext.runUrl = p.data.runUrl), !0;
              p.data && p.data.status
                ? (this.messages.apiError = `Invalid end run response: ${JSON.stringify(p.data.message)}`)
                : p.data && typeof p.data == 'string'
                ? p.data !== 'success' &&
                  (this.messages.apiError = `Invalid end run response: ${JSON.stringify(p.data)}`)
                : (this.messages.apiError = `Invalid end run response: ${JSON.stringify(p.data)}`),
                ie && $u.note({ title: 'Invalid end run response', bodyLines: [JSON.stringify(p.data, null, 2)] });
            } else
              $u.error({
                title: 'Nx Cloud: Unknown Error Occurred',
                bodyLines: [
                  'Run completion responded with `undefined`.',
                  'Run Details:',
                  JSON.stringify(e, null, 2),
                  'Stack Trace:',
                  JSON.stringify(new Error().stack, null, 2),
                ],
              });
            return !1;
          } catch (p) {
            let d = p.axiosException ?? p;
            return (this.messages.apiError = this.messages.extractErrorMessage(d, 'api')), !1;
          }
        }
        async endRunIfWorkspaceNotEnabled() {
          try {
            await tt(() => this.apiAxiosInstance.get('/nx-cloud/runs/workspace-status'));
          } catch (e) {
            $u.error({ title: 'Nx Cloud: Workspace is disabled', bodyLines: e.bodyLines }), process.exit(1);
          }
        }
        async getEndRunSplashMessage() {
          try {
            return this.apiAxiosInstance.get('/nx-cloud/runs/splash').then((e) => e.data);
          } catch {
            return;
          }
        }
        async getWorkspaceSettings() {
          try {
            return this.apiAxiosInstance.get('/nx-cloud/runs/workspace-settings').then((e) => e.data);
          } catch {
            return;
          }
        }
        nxCloudVersion() {
          try {
            let e = JSON.parse((0, SN.readFileSync)('package.json').toString());
            return e.devDependencies['nx-cloud'] || e.devDependencies['@nrwl/nx-cloud'];
          } catch {
            return 'unknown';
          }
        }
      });
  });
function hd() {
  let t = '';
  for (let e = 0; e < 10; ++e) t += TN[Math.floor(Math.random() * TN.length)];
  return t;
}
var ON,
  g9,
  x9,
  TN,
  Qb = te(() => {
    'use strict';
    (ON = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'), (g9 = '0123456789'), (x9 = ON.toLowerCase()), (TN = ON + x9 + g9);
  });
var tv = P((ev) => {
  'use strict';
  Object.defineProperty(ev, '__esModule', { value: !0 });
  function y9(t) {
    return typeof t == 'function';
  }
  ev.isFunction = y9;
});
var md = P((nv) => {
  'use strict';
  Object.defineProperty(nv, '__esModule', { value: !0 });
  var iv = !1;
  nv.config = {
    Promise: void 0,
    set useDeprecatedSynchronousErrorHandling(t) {
      if (t) {
        var e = new Error();
        console.warn(
          `DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: 
` + e.stack
        );
      } else iv && console.log('RxJS: Back to a better error behavior. Thank you. <3');
      iv = t;
    },
    get useDeprecatedSynchronousErrorHandling() {
      return iv;
    },
  };
});
var gd = P((rv) => {
  'use strict';
  Object.defineProperty(rv, '__esModule', { value: !0 });
  function b9(t) {
    setTimeout(function () {
      throw t;
    }, 0);
  }
  rv.hostReportError = b9;
});
var ov = P((sv) => {
  'use strict';
  Object.defineProperty(sv, '__esModule', { value: !0 });
  var v9 = md(),
    w9 = gd();
  sv.empty = {
    closed: !0,
    next: function (t) {},
    error: function (t) {
      if (v9.config.useDeprecatedSynchronousErrorHandling) throw t;
      w9.hostReportError(t);
    },
    complete: function () {},
  };
});
var kN = P((av) => {
  'use strict';
  Object.defineProperty(av, '__esModule', { value: !0 });
  av.isArray = (function () {
    return (
      Array.isArray ||
      function (t) {
        return t && typeof t.length == 'number';
      }
    );
  })();
});
var uv = P((cv) => {
  'use strict';
  Object.defineProperty(cv, '__esModule', { value: !0 });
  function E9(t) {
    return t !== null && typeof t == 'object';
  }
  cv.isObject = E9;
});
var AN = P((lv) => {
  'use strict';
  Object.defineProperty(lv, '__esModule', { value: !0 });
  var _9 = (function () {
    function t(e) {
      return (
        Error.call(this),
        (this.message = e
          ? e.length +
            ` errors occurred during unsubscription:
` +
            e.map(function (i, n) {
              return n + 1 + ') ' + i.toString();
            }).join(`
  `)
          : ''),
        (this.name = 'UnsubscriptionError'),
        (this.errors = e),
        this
      );
    }
    return (t.prototype = Object.create(Error.prototype)), t;
  })();
  lv.UnsubscriptionError = _9;
});
var gs = P((pv) => {
  'use strict';
  Object.defineProperty(pv, '__esModule', { value: !0 });
  var S9 = kN(),
    C9 = uv(),
    R9 = tv(),
    xd = AN(),
    T9 = (function () {
      function t(e) {
        (this.closed = !1), (this._parentOrParents = null), (this._subscriptions = null), e && (this._unsubscribe = e);
      }
      return (
        (t.prototype.unsubscribe = function () {
          var e;
          if (!this.closed) {
            var i = this,
              n = i._parentOrParents,
              r = i._unsubscribe,
              s = i._subscriptions;
            if (((this.closed = !0), (this._parentOrParents = null), (this._subscriptions = null), n instanceof t))
              n.remove(this);
            else if (n !== null)
              for (var o = 0; o < n.length; ++o) {
                var c = n[o];
                c.remove(this);
              }
            if (R9.isFunction(r))
              try {
                r.call(this);
              } catch (p) {
                e = p instanceof xd.UnsubscriptionError ? IN(p.errors) : [p];
              }
            if (S9.isArray(s))
              for (var o = -1, u = s.length; ++o < u; ) {
                var l = s[o];
                if (C9.isObject(l))
                  try {
                    l.unsubscribe();
                  } catch (d) {
                    (e = e || []), d instanceof xd.UnsubscriptionError ? (e = e.concat(IN(d.errors))) : e.push(d);
                  }
              }
            if (e) throw new xd.UnsubscriptionError(e);
          }
        }),
        (t.prototype.add = function (e) {
          var i = e;
          if (!e) return t.EMPTY;
          switch (typeof e) {
            case 'function':
              i = new t(e);
            case 'object':
              if (i === this || i.closed || typeof i.unsubscribe != 'function') return i;
              if (this.closed) return i.unsubscribe(), i;
              if (!(i instanceof t)) {
                var n = i;
                (i = new t()), (i._subscriptions = [n]);
              }
              break;
            default:
              throw new Error('unrecognized teardown ' + e + ' added to Subscription.');
          }
          var r = i._parentOrParents;
          if (r === null) i._parentOrParents = this;
          else if (r instanceof t) {
            if (r === this) return i;
            i._parentOrParents = [r, this];
          } else if (r.indexOf(this) === -1) r.push(this);
          else return i;
          var s = this._subscriptions;
          return s === null ? (this._subscriptions = [i]) : s.push(i), i;
        }),
        (t.prototype.remove = function (e) {
          var i = this._subscriptions;
          if (i) {
            var n = i.indexOf(e);
            n !== -1 && i.splice(n, 1);
          }
        }),
        (t.EMPTY = (function (e) {
          return (e.closed = !0), e;
        })(new t())),
        t
      );
    })();
  pv.Subscription = T9;
  function IN(t) {
    return t.reduce(function (e, i) {
      return e.concat(i instanceof xd.UnsubscriptionError ? i.errors : i);
    }, []);
  }
});
var yd = P((Wu) => {
  'use strict';
  Object.defineProperty(Wu, '__esModule', { value: !0 });
  Wu.rxSubscriber = (function () {
    return typeof Symbol == 'function' ? Symbol('rxSubscriber') : '@@rxSubscriber_' + Math.random();
  })();
  Wu.$$rxSubscriber = Wu.rxSubscriber;
});
var wo = P((Qa) => {
  'use strict';
  var PN =
    (Qa && Qa.__extends) ||
    (function () {
      var t = function (e, i) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, r) {
                n.__proto__ = r;
              }) ||
            function (n, r) {
              for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);
            }),
          t(e, i)
        );
      };
      return function (e, i) {
        t(e, i);
        function n() {
          this.constructor = e;
        }
        e.prototype = i === null ? Object.create(i) : ((n.prototype = i.prototype), new n());
      };
    })();
  Object.defineProperty(Qa, '__esModule', { value: !0 });
  var NN = tv(),
    fv = ov(),
    O9 = gs(),
    k9 = yd(),
    Za = md(),
    bd = gd(),
    LN = (function (t) {
      PN(e, t);
      function e(i, n, r) {
        var s = t.call(this) || this;
        switch (
          ((s.syncErrorValue = null),
          (s.syncErrorThrown = !1),
          (s.syncErrorThrowable = !1),
          (s.isStopped = !1),
          arguments.length)
        ) {
          case 0:
            s.destination = fv.empty;
            break;
          case 1:
            if (!i) {
              s.destination = fv.empty;
              break;
            }
            if (typeof i == 'object') {
              i instanceof e
                ? ((s.syncErrorThrowable = i.syncErrorThrowable), (s.destination = i), i.add(s))
                : ((s.syncErrorThrowable = !0), (s.destination = new dv(s, i)));
              break;
            }
          default:
            (s.syncErrorThrowable = !0), (s.destination = new dv(s, i, n, r));
            break;
        }
        return s;
      }
      return (
        (e.prototype[k9.rxSubscriber] = function () {
          return this;
        }),
        (e.create = function (i, n, r) {
          var s = new e(i, n, r);
          return (s.syncErrorThrowable = !1), s;
        }),
        (e.prototype.next = function (i) {
          this.isStopped || this._next(i);
        }),
        (e.prototype.error = function (i) {
          this.isStopped || ((this.isStopped = !0), this._error(i));
        }),
        (e.prototype.complete = function () {
          this.isStopped || ((this.isStopped = !0), this._complete());
        }),
        (e.prototype.unsubscribe = function () {
          this.closed || ((this.isStopped = !0), t.prototype.unsubscribe.call(this));
        }),
        (e.prototype._next = function (i) {
          this.destination.next(i);
        }),
        (e.prototype._error = function (i) {
          this.destination.error(i), this.unsubscribe();
        }),
        (e.prototype._complete = function () {
          this.destination.complete(), this.unsubscribe();
        }),
        (e.prototype._unsubscribeAndRecycle = function () {
          var i = this._parentOrParents;
          return (
            (this._parentOrParents = null),
            this.unsubscribe(),
            (this.closed = !1),
            (this.isStopped = !1),
            (this._parentOrParents = i),
            this
          );
        }),
        e
      );
    })(O9.Subscription);
  Qa.Subscriber = LN;
  var dv = (function (t) {
    PN(e, t);
    function e(i, n, r, s) {
      var o = t.call(this) || this;
      o._parentSubscriber = i;
      var c,
        u = o;
      return (
        NN.isFunction(n)
          ? (c = n)
          : n &&
            ((c = n.next),
            (r = n.error),
            (s = n.complete),
            n !== fv.empty &&
              ((u = Object.create(n)),
              NN.isFunction(u.unsubscribe) && o.add(u.unsubscribe.bind(u)),
              (u.unsubscribe = o.unsubscribe.bind(o)))),
        (o._context = u),
        (o._next = c),
        (o._error = r),
        (o._complete = s),
        o
      );
    }
    return (
      (e.prototype.next = function (i) {
        if (!this.isStopped && this._next) {
          var n = this._parentSubscriber;
          !Za.config.useDeprecatedSynchronousErrorHandling || !n.syncErrorThrowable
            ? this.__tryOrUnsub(this._next, i)
            : this.__tryOrSetError(n, this._next, i) && this.unsubscribe();
        }
      }),
      (e.prototype.error = function (i) {
        if (!this.isStopped) {
          var n = this._parentSubscriber,
            r = Za.config.useDeprecatedSynchronousErrorHandling;
          if (this._error)
            !r || !n.syncErrorThrowable
              ? (this.__tryOrUnsub(this._error, i), this.unsubscribe())
              : (this.__tryOrSetError(n, this._error, i), this.unsubscribe());
          else if (n.syncErrorThrowable)
            r ? ((n.syncErrorValue = i), (n.syncErrorThrown = !0)) : bd.hostReportError(i), this.unsubscribe();
          else {
            if ((this.unsubscribe(), r)) throw i;
            bd.hostReportError(i);
          }
        }
      }),
      (e.prototype.complete = function () {
        var i = this;
        if (!this.isStopped) {
          var n = this._parentSubscriber;
          if (this._complete) {
            var r = function () {
              return i._complete.call(i._context);
            };
            !Za.config.useDeprecatedSynchronousErrorHandling || !n.syncErrorThrowable
              ? (this.__tryOrUnsub(r), this.unsubscribe())
              : (this.__tryOrSetError(n, r), this.unsubscribe());
          } else this.unsubscribe();
        }
      }),
      (e.prototype.__tryOrUnsub = function (i, n) {
        try {
          i.call(this._context, n);
        } catch (r) {
          if ((this.unsubscribe(), Za.config.useDeprecatedSynchronousErrorHandling)) throw r;
          bd.hostReportError(r);
        }
      }),
      (e.prototype.__tryOrSetError = function (i, n, r) {
        if (!Za.config.useDeprecatedSynchronousErrorHandling) throw new Error('bad call');
        try {
          n.call(this._context, r);
        } catch (s) {
          return Za.config.useDeprecatedSynchronousErrorHandling
            ? ((i.syncErrorValue = s), (i.syncErrorThrown = !0), !0)
            : (bd.hostReportError(s), !0);
        }
        return !1;
      }),
      (e.prototype._unsubscribe = function () {
        var i = this._parentSubscriber;
        (this._context = null), (this._parentSubscriber = null), i.unsubscribe();
      }),
      e
    );
  })(LN);
  Qa.SafeSubscriber = dv;
});
var DN = P((hv) => {
  'use strict';
  Object.defineProperty(hv, '__esModule', { value: !0 });
  var A9 = wo();
  function I9(t) {
    for (; t; ) {
      var e = t,
        i = e.closed,
        n = e.destination,
        r = e.isStopped;
      if (i || r) return !1;
      n && n instanceof A9.Subscriber ? (t = n) : (t = null);
    }
    return !0;
  }
  hv.canReportError = I9;
});
var jN = P((gv) => {
  'use strict';
  Object.defineProperty(gv, '__esModule', { value: !0 });
  var mv = wo(),
    FN = yd(),
    N9 = ov();
  function P9(t, e, i) {
    if (t) {
      if (t instanceof mv.Subscriber) return t;
      if (t[FN.rxSubscriber]) return t[FN.rxSubscriber]();
    }
    return !t && !e && !i ? new mv.Subscriber(N9.empty) : new mv.Subscriber(t, e, i);
  }
  gv.toSubscriber = P9;
});
var ec = P((xv) => {
  'use strict';
  Object.defineProperty(xv, '__esModule', { value: !0 });
  xv.observable = (function () {
    return (typeof Symbol == 'function' && Symbol.observable) || '@@observable';
  })();
});
var MN = P((yv) => {
  'use strict';
  Object.defineProperty(yv, '__esModule', { value: !0 });
  function L9(t) {
    return t;
  }
  yv.identity = L9;
});
var qN = P((vd) => {
  'use strict';
  Object.defineProperty(vd, '__esModule', { value: !0 });
  var D9 = MN();
  function F9() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return UN(t);
  }
  vd.pipe = F9;
  function UN(t) {
    return t.length === 0
      ? D9.identity
      : t.length === 1
      ? t[0]
      : function (i) {
          return t.reduce(function (n, r) {
            return r(n);
          }, i);
        };
  }
  vd.pipeFromArray = UN;
});
var xs = P((bv) => {
  'use strict';
  Object.defineProperty(bv, '__esModule', { value: !0 });
  var j9 = DN(),
    M9 = jN(),
    U9 = ec(),
    q9 = qN(),
    wd = md(),
    B9 = (function () {
      function t(e) {
        (this._isScalar = !1), e && (this._subscribe = e);
      }
      return (
        (t.prototype.lift = function (e) {
          var i = new t();
          return (i.source = this), (i.operator = e), i;
        }),
        (t.prototype.subscribe = function (e, i, n) {
          var r = this.operator,
            s = M9.toSubscriber(e, i, n);
          if (
            (r
              ? s.add(r.call(s, this.source))
              : s.add(
                  this.source || (wd.config.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable)
                    ? this._subscribe(s)
                    : this._trySubscribe(s)
                ),
            wd.config.useDeprecatedSynchronousErrorHandling &&
              s.syncErrorThrowable &&
              ((s.syncErrorThrowable = !1), s.syncErrorThrown))
          )
            throw s.syncErrorValue;
          return s;
        }),
        (t.prototype._trySubscribe = function (e) {
          try {
            return this._subscribe(e);
          } catch (i) {
            wd.config.useDeprecatedSynchronousErrorHandling && ((e.syncErrorThrown = !0), (e.syncErrorValue = i)),
              j9.canReportError(e) ? e.error(i) : console.warn(i);
          }
        }),
        (t.prototype.forEach = function (e, i) {
          var n = this;
          return (
            (i = BN(i)),
            new i(function (r, s) {
              var o;
              o = n.subscribe(
                function (c) {
                  try {
                    e(c);
                  } catch (u) {
                    s(u), o && o.unsubscribe();
                  }
                },
                s,
                r
              );
            })
          );
        }),
        (t.prototype._subscribe = function (e) {
          var i = this.source;
          return i && i.subscribe(e);
        }),
        (t.prototype[U9.observable] = function () {
          return this;
        }),
        (t.prototype.pipe = function () {
          for (var e = [], i = 0; i < arguments.length; i++) e[i] = arguments[i];
          return e.length === 0 ? this : q9.pipeFromArray(e)(this);
        }),
        (t.prototype.toPromise = function (e) {
          var i = this;
          return (
            (e = BN(e)),
            new e(function (n, r) {
              var s;
              i.subscribe(
                function (o) {
                  return (s = o);
                },
                function (o) {
                  return r(o);
                },
                function () {
                  return n(s);
                }
              );
            })
          );
        }),
        (t.create = function (e) {
          return new t(e);
        }),
        t
      );
    })();
  bv.Observable = B9;
  function BN(t) {
    if ((t || (t = wd.config.Promise || Promise), !t)) throw new Error('no Promise impl found');
    return t;
  }
});
var HN = P((vv) => {
  'use strict';
  Object.defineProperty(vv, '__esModule', { value: !0 });
  var H9 = (function () {
    function t() {
      return Error.call(this), (this.message = 'object unsubscribed'), (this.name = 'ObjectUnsubscribedError'), this;
    }
    return (t.prototype = Object.create(Error.prototype)), t;
  })();
  vv.ObjectUnsubscribedError = H9;
});
var GN = P((Ku) => {
  'use strict';
  var G9 =
    (Ku && Ku.__extends) ||
    (function () {
      var t = function (e, i) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, r) {
                n.__proto__ = r;
              }) ||
            function (n, r) {
              for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);
            }),
          t(e, i)
        );
      };
      return function (e, i) {
        t(e, i);
        function n() {
          this.constructor = e;
        }
        e.prototype = i === null ? Object.create(i) : ((n.prototype = i.prototype), new n());
      };
    })();
  Object.defineProperty(Ku, '__esModule', { value: !0 });
  var z9 = gs(),
    V9 = (function (t) {
      G9(e, t);
      function e(i, n) {
        var r = t.call(this) || this;
        return (r.subject = i), (r.subscriber = n), (r.closed = !1), r;
      }
      return (
        (e.prototype.unsubscribe = function () {
          if (!this.closed) {
            this.closed = !0;
            var i = this.subject,
              n = i.observers;
            if (((this.subject = null), !(!n || n.length === 0 || i.isStopped || i.closed))) {
              var r = n.indexOf(this.subscriber);
              r !== -1 && n.splice(r, 1);
            }
          }
        }),
        e
      );
    })(z9.Subscription);
  Ku.SubjectSubscription = V9;
});
var WN = P((Eo) => {
  'use strict';
  var _v =
    (Eo && Eo.__extends) ||
    (function () {
      var t = function (e, i) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, r) {
                n.__proto__ = r;
              }) ||
            function (n, r) {
              for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);
            }),
          t(e, i)
        );
      };
      return function (e, i) {
        t(e, i);
        function n() {
          this.constructor = e;
        }
        e.prototype = i === null ? Object.create(i) : ((n.prototype = i.prototype), new n());
      };
    })();
  Object.defineProperty(Eo, '__esModule', { value: !0 });
  var zN = xs(),
    $9 = wo(),
    wv = gs(),
    Xu = HN(),
    W9 = GN(),
    K9 = yd(),
    VN = (function (t) {
      _v(e, t);
      function e(i) {
        var n = t.call(this, i) || this;
        return (n.destination = i), n;
      }
      return e;
    })($9.Subscriber);
  Eo.SubjectSubscriber = VN;
  var $N = (function (t) {
    _v(e, t);
    function e() {
      var i = t.call(this) || this;
      return (i.observers = []), (i.closed = !1), (i.isStopped = !1), (i.hasError = !1), (i.thrownError = null), i;
    }
    return (
      (e.prototype[K9.rxSubscriber] = function () {
        return new VN(this);
      }),
      (e.prototype.lift = function (i) {
        var n = new Ev(this, this);
        return (n.operator = i), n;
      }),
      (e.prototype.next = function (i) {
        if (this.closed) throw new Xu.ObjectUnsubscribedError();
        if (!this.isStopped) for (var n = this.observers, r = n.length, s = n.slice(), o = 0; o < r; o++) s[o].next(i);
      }),
      (e.prototype.error = function (i) {
        if (this.closed) throw new Xu.ObjectUnsubscribedError();
        (this.hasError = !0), (this.thrownError = i), (this.isStopped = !0);
        for (var n = this.observers, r = n.length, s = n.slice(), o = 0; o < r; o++) s[o].error(i);
        this.observers.length = 0;
      }),
      (e.prototype.complete = function () {
        if (this.closed) throw new Xu.ObjectUnsubscribedError();
        this.isStopped = !0;
        for (var i = this.observers, n = i.length, r = i.slice(), s = 0; s < n; s++) r[s].complete();
        this.observers.length = 0;
      }),
      (e.prototype.unsubscribe = function () {
        (this.isStopped = !0), (this.closed = !0), (this.observers = null);
      }),
      (e.prototype._trySubscribe = function (i) {
        if (this.closed) throw new Xu.ObjectUnsubscribedError();
        return t.prototype._trySubscribe.call(this, i);
      }),
      (e.prototype._subscribe = function (i) {
        if (this.closed) throw new Xu.ObjectUnsubscribedError();
        return this.hasError
          ? (i.error(this.thrownError), wv.Subscription.EMPTY)
          : this.isStopped
          ? (i.complete(), wv.Subscription.EMPTY)
          : (this.observers.push(i), new W9.SubjectSubscription(this, i));
      }),
      (e.prototype.asObservable = function () {
        var i = new zN.Observable();
        return (i.source = this), i;
      }),
      (e.create = function (i, n) {
        return new Ev(i, n);
      }),
      e
    );
  })(zN.Observable);
  Eo.Subject = $N;
  var Ev = (function (t) {
    _v(e, t);
    function e(i, n) {
      var r = t.call(this) || this;
      return (r.destination = i), (r.source = n), r;
    }
    return (
      (e.prototype.next = function (i) {
        var n = this.destination;
        n && n.next && n.next(i);
      }),
      (e.prototype.error = function (i) {
        var n = this.destination;
        n && n.error && this.destination.error(i);
      }),
      (e.prototype.complete = function () {
        var i = this.destination;
        i && i.complete && this.destination.complete();
      }),
      (e.prototype._subscribe = function (i) {
        var n = this.source;
        return n ? this.source.subscribe(i) : wv.Subscription.EMPTY;
      }),
      e
    );
  })($N);
  Eo.AnonymousSubject = Ev;
});
function J9(t, e, i) {
  let n = Hs();
  return new Ja(t, i, e, n);
}
function Z9(t, e, i) {
  let n = JSON.stringify(t.map((r) => ({ taskId: r.taskId, hash: r.hash, code: r.status })));
  ie && _r.note({ title: `Executed tasks with hashes: ${n}` }),
    (0, KN.writeFileSync)(XN.join(e, `tasks-hashes-${i}`), n);
}
function Q9(t, e, i) {
  t.filter((r) => r.cacheStatus === 'local-cache-hit')
    .map((r) => r.hash)
    .forEach((r) => e.store(r, i));
}
async function Sv({
  daemon: t,
  options: e,
  fileStorage: i,
  remoteCache: n,
  api: r,
  outputObfuscator: s,
  runStartTime: o,
  messages: c,
  endOfRunMessage: u,
  taskExecutions: l,
  versionOfNxBefore133: p,
  inner: d,
  encryptionKey: x,
  storeInCurrentProcess: b,
  distributedExecutionId: g,
  runContext: y,
  projectGraph: h,
}) {
  let v = new Date().toISOString(),
    C = It(),
    _ = {
      command: s.obfuscate(wi()),
      startTime: o,
      endTime: v,
      distributedExecutionId: g,
      branch: C,
      runGroup: Ct(),
      sha: C ? Qt() : void 0,
      inner: d,
    },
    m = { branch: C, runGroup: Ct(), ciExecutionId: At(), ciExecutionEnv: kt() };
  if (!Zt(g))
    for (let O of l) {
      let N = y.allTasks.find((H) => H.hash === O.hash),
        D = (N == null ? void 0 : N.cache) ?? !1,
        z = O.status != 0;
      N &&
        (!D || z) &&
        (N.terminalOutputUploadedToFileStorage ||
          (ie && _r.note({ title: `Storing terminal outputs for ${O.taskId} with hash ${O.hash}` }),
          await n.storeTerminalOutputsInCache(O.hash, Yu, N.terminalOutput, O.status)));
    }
  if (b) {
    Zt(g) && (Z9(l, Yu, g), Q9(l, n, Yu));
    try {
      await n.waitForStoreRequestsToComplete();
    } catch {
      return _r.error({ title: "Nx Cloud wasn't able to store artifacts." }), c.printMessages(), !1;
    }
    for (let O of i.storedHashes) {
      let N = l.find((D) => D.hash === O);
      if (!N) throw new Error(`Task with hash ${O} isn't recorded`);
      N.uploadedToStorage = !0;
    }
    l.forEach((O) => {
      let N = y.allTasks.find((D) => D.hash === O.hash);
      (O.artifactId = N == null ? void 0 : N.artifactId),
        (O.terminalOutputUploadedToFileStorage = (N == null ? void 0 : N.terminalOutputUploadedToFileStorage) ?? !1),
        IR(h.nodes, O);
    });
    try {
      await r.endRun(_, l, m, h, wp(h.nodes, y.allTasks));
    } catch {
      return _r.error({ title: "Nx Cloud wasn't able to record its run." }), c.printMessages(), !1;
    }
  } else
    try {
      let O = Zn ? Zn : e.accessToken,
        N = hd(),
        D = require.resolve('./lib/daemon/process-run-end');
      await t.processInBackground(D, {
        encryptionKey: x,
        runnerOptions: { ...e, accessToken: O },
        delayedStoreRequests: n.delayedStoreRequests,
        ciExecutionContext: m,
        runEnd: { runData: _, taskExecutions: l, allTasks: y.allTasks, linkId: N },
        projectGraph: h,
        lightRunnerResolutionPaths: JSON.parse(process.env.NX_CLOUD_LIGHT_CLIENT_RESOLUTION_PATHS),
      }),
        (y.runUrl = `${Ep(e.url || 'https://nx.app')}/runs/${N}`);
    } catch (O) {
      return _r.warn({ title: 'Nx Cloud Problems', bodyLines: [O.message || O.toString()] }), !1;
    }
  return (
    p
      ? setTimeout(() => {
          c.printMessages(),
            y.splashMessage && y.splashMessage.title && _r.note(y.splashMessage),
            !c.anyErrors && !d && u.printEndOfRunMessage();
        }, 0)
      : (c.printMessages(),
        y.splashMessage && y.splashMessage.title && _r.note(y.splashMessage),
        !c.anyErrors && !d && u.printEndOfRunMessage()),
    !0
  );
}
function e7(t, e, i, n) {
  let r = new cd(t, Yu, e.cacheableOperations || [], i, n);
  try {
    if (!t.showTerminalOutput && Fr())
      return (
        Zt(process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID) ||
          _r.note({ title: 'Nx is executing your tasks and will print a summary upon completion.' }),
        new ad([r, e.lifeCycle])
      );
    let { CompositeLifeCycle: s } = ri();
    return s ? new s([e.lifeCycle, r]) : r;
  } catch {
    return r;
  }
}
async function t7(t, e, i, n, r) {
  if (n.skipNxCache) return;
  let s = i.map((u) => u.hash).filter((u) => !!u),
    o = await Promise.all(
      s.map((u) => {
        let l = (0, YN.join)(Yu, `${u}.commit`);
        return Y9(l);
      })
    ),
    c = [];
  for (let u = 0; u < o.length; ++u) o[u] || c.push(s[u]);
  if (c.length > 0) {
    let u = t.startRun(r, c);
    for (let l of c) e.requests[l] = u;
  }
}
async function i7(t, e) {
  try {
    e.splashMessage = await t.getEndRunSplashMessage();
  } catch {}
}
async function n7(t, e) {
  try {
    let i = await t.getWorkspaceSettings(),
      n = (i && i.showTerminalOutput) ?? !0;
    ie &&
      _r.note({ title: 'Retrieved workspace settings for run', bodyLines: [`Show terminal outputs for DTE: ${n}`] }),
      n || (e.showTerminalOutput = n);
  } catch {}
}
async function Ju(t, e, i, n = !1) {
  var m;
  let r = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID,
    s = { statuses: {}, scheduledTasks: [], requests: {}, allTasks: t, nxArgs: {}, showTerminalOutput: !0 },
    o = e.lifeCycle === void 0,
    c = [],
    u = new Ka(e),
    l = J9(u, e, s);
  Fr() && (await l.endRunIfWorkspaceNotEnabled(), await n7(l, s));
  let p = new sd(s, c, r),
    d = new ms(e.maskedProperties),
    x = new Date().toISOString(),
    b = e7(s, e, d, c),
    g = Fi || e.encryptionKey,
    y = new Ci(g),
    h = new Si(e),
    v = Zt(r) || !((m = i.daemon) != null && m.enabled()),
    C = new Ai(y, h, e, 'cloud-enabled-runner');
  Gn.instantiate(u, l, s, C, r, v),
    t7(l, s, t, e, r),
    i7(l, s),
    Fr() && i.initiatingProject && (i.initiatingProject = '__internal__'),
    delete process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID;
  let _ = X9(
    t,
    {
      ...e,
      remoteCache: {
        store(O, N) {
          return (Gn.useV1Cache = !0), Gn.store(O, N);
        },
        retrieve(O, N) {
          return (Gn.useV1Cache = !0), Gn.retrieve(O, N);
        },
      },
      lifeCycle: b,
    },
    i
  );
  if (_.subscribe) {
    let { Subject: O } = WN(),
      N = new O();
    return (
      _.subscribe({
        next: (D) => N.next(D),
        error: (D) => N.error(D),
        complete: async () => {
          !(await Sv({
            daemon: i.daemon,
            options: e,
            fileStorage: C,
            remoteCache: Gn,
            api: l,
            outputObfuscator: d,
            runStartTime: x,
            messages: u,
            endOfRunMessage: p,
            taskExecutions: c,
            versionOfNxBefore133: o,
            inner: n,
            encryptionKey: g,
            storeInCurrentProcess: v,
            runContext: s,
            distributedExecutionId: r,
            projectGraph: i.projectGraph,
          })) &&
            Zt(r) &&
            (process.env.NX_CLOUD_INVOKED_WITH_RUN_MANY === 'true'
              ? process.exit(jr)
              : (process.env.NX_CLOUD_CRITICAL_ERROR = 'true')),
            N.complete();
        },
      }),
      N
    );
  } else
    return _.then(
      async (O) => (
        !(await Sv({
          daemon: i.daemon,
          options: e,
          fileStorage: C,
          remoteCache: Gn,
          api: l,
          outputObfuscator: d,
          runStartTime: x,
          messages: u,
          endOfRunMessage: p,
          taskExecutions: c,
          versionOfNxBefore133: o,
          inner: n,
          encryptionKey: g,
          storeInCurrentProcess: v,
          runContext: s,
          distributedExecutionId: r,
          projectGraph: i.projectGraph,
        })) &&
          Zt(r) &&
          (process.env.NX_CLOUD_INVOKED_WITH_RUN_MANY === 'true'
            ? process.exit(jr)
            : (process.env.NX_CLOUD_CRITICAL_ERROR = 'true')),
        O
      )
    ).catch(async (O) => {
      throw (
        (!(await Sv({
          daemon: i.daemon,
          options: e,
          fileStorage: C,
          remoteCache: Gn,
          api: l,
          outputObfuscator: d,
          runStartTime: x,
          messages: u,
          endOfRunMessage: p,
          taskExecutions: c,
          versionOfNxBefore133: o,
          inner: n,
          encryptionKey: g,
          storeInCurrentProcess: v,
          runContext: s,
          distributedExecutionId: r,
          projectGraph: i.projectGraph,
        })) &&
          Zt(r) &&
          (process.env.NX_CLOUD_INVOKED_WITH_RUN_MANY === 'true'
            ? process.exit(jr)
            : (process.env.NX_CLOUD_CRITICAL_ERROR = 'true')),
        O)
      );
    });
}
var KN,
  XN,
  YN,
  _r,
  X9,
  Yu,
  mce,
  Y9,
  JN = te(() => {
    'use strict';
    (KN = require('fs')), (XN = je(require('path'))), (YN = require('path'));
    Le();
    Jl();
    Vg();
    $g();
    Ks();
    Xs();
    yo();
    WI();
    Ub();
    od();
    tN();
    zb();
    Zb();
    Qb();
    ({ output: _r } = Ae()),
      ({ tasksRunner: X9, cacheDirectory: Yu, workspaceDataDirectory: mce } = ri()),
      ({ pathExists: Y9 } = Tu());
  });
function Qu(t) {
  return (0, Zu.join)((0, ZN.tmpdir)(), `run-group-${t}-marker.lock`);
}
function Cv(t) {
  try {
    return process.kill(t, 0), !0;
  } catch {
    return !1;
  }
}
function r7(t) {
  try {
    let e = (0, Ii.readFileSync)((0, Zu.join)(t, 'owner.pid'), { encoding: 'utf-8' });
    return Number(e);
  } catch {
    return;
  }
}
function s7(t, e) {
  return (0, Zu.join)(t, `elect-owner-${e}`);
}
function QN(t) {
  let e;
  try {
    (0, Ii.mkdirSync)(t), ie && console.log('[Nx Cloud Debug] Successfully created folder lock at path:', t);
  } catch {
    ie && console.log('[Nx Cloud Debug] Failed to create folder lock at path:', t);
    let n = r7(t);
    if (n !== void 0) {
      if ((ie && console.log('[Nx Cloud Debug] Found previous owner pid:', n), n === process.pid)) {
        ie && console.log('[Nx Cloud Debug] We are the previous owner, lock acquired');
        return;
      }
      if (Cv(n))
        throw (
          (ie && console.log('[Nx Cloud Debug] Previous owner process is still alive'),
          new Error(`Current heartbeat owner (${n}) is still alive`))
        );
    }
    try {
      (e = s7(t, n)),
        ie && console.log('[Nx Cloud Debug] Attempting to secure ownership with lock path:', e),
        (0, Ii.mkdirSync)(e);
    } catch {
      throw (
        (ie && console.log('[Nx Cloud Debug] Failed to secure ownership lock'),
        new Error('Did not become new heartbeat process owner'))
      );
    }
  }
  try {
    ie && console.log('[Nx Cloud Debug] Attempting to write current PID to owner file:', process.pid),
      (0, Ii.writeFileSync)((0, Zu.join)(t, 'owner.pid'), process.pid.toString(), { encoding: 'utf-8' }),
      ie && console.log('[Nx Cloud Debug] Successfully acquired lock');
    return;
  } catch {
    throw (
      (e !== void 0 && (0, Ii.existsSync)(e) && (0, Ii.rmdirSync)(e),
      new Error(`Failed to write self process id (${process.pid}) to owner lockfile`))
    );
  }
}
function eP(t, e) {
  if (e === void 0) return;
  let i = Qu(t);
  (0, Ii.existsSync)(i) || (0, Ii.mkdirSync)(i, { recursive: !0 }), (0, Ii.writeFileSync)(`${i}/pid`, e.toString());
}
var Ii,
  ZN,
  Zu,
  tP = te(() => {
    'use strict';
    (Ii = require('fs')), (ZN = require('os')), (Zu = require('path'));
    Le();
  });
async function o7(t, e) {
  let i = Qu(e);
  ie && console.log('[Nx Cloud Debug] Attempting to acquire filesystem lock with path: ', i),
    QN(i),
    await a7(t, e).catch(() => {
      tl.error({
        title: 'Took longer than 3 seconds to hear from heartbeat process',
        bodyLines: [
          'The heartbeat process may have not started properly. This CIPE could have inconsistent status reporting.',
        ],
      });
    });
}
async function Tv(t) {
  if (It() == null) return !1;
  let e = Ct();
  ie && tl.note({ title: `Trying to create heartbeat background process for run group: ${e}` });
  try {
    return await o7(t, e), !0;
  } catch {
    let n = await c7(e);
    return n === void 0
      ? (ie && console.log('[Nx Cloud Debug] Was not able to locate a heartbeat process'), !1)
      : (nP(t, e, n), !1);
  }
}
async function a7(t, e) {
  let i = process.env.NX_CLOUD_HEARTBEAT_INHERIT_STDIO == 'true' ? 'inherit' : 'pipe';
  return new Promise((n, r) => {
    let s = (0, iP.spawn)(process.execPath, [require.resolve('./lib/heartbeat/heartbeat-process.js')], {
      detached: !0,
      windowsHide: !0,
      stdio: i,
    });
    i === 'pipe'
      ? (s.stdout.on('data', (o) => {
          try {
            o == 'heartbeat-ready' &&
              (ie && tl.note({ title: `Heartbeat process started successfully with PID ${s.pid}` }),
              eP(e, s.pid),
              nP(t, e, s.pid),
              s.unref(),
              n());
          } catch (c) {
            ie && console.log('[Nx Cloud Debug] Error:', JSON.stringify(c)), r();
          }
        }),
        setTimeout(() => r(), 5e3))
      : n();
  });
}
async function c7(t) {
  let e = Qu(t);
  for (let i = 0; i < 3; i++) {
    try {
      let n = (0, Rv.readFileSync)(`${e}/pid`, { encoding: 'utf-8' });
      if (Cv(Number(n))) return Number(n);
    } catch {}
    await wt(1e3);
  }
}
function nP(t, e, i) {
  i !== void 0 &&
    (Ed ||
      ((Ed = setInterval(async () => {
        if (!u7(i)) {
          let n = Qu(e),
            r;
          try {
            r = (0, Rv.readFileSync)(`${n}/logs.txt`, { encoding: 'utf-8' });
          } catch {
            r = 'Unable to find shutdown logs, likely the heartbeat process was sent a SIGKILL';
          }
          el(),
            ie &&
              tl.error({
                title: 'Nx Cloud Heartbeat missing',
                bodyLines: [
                  `Expected to find process with PID ${i} but none was found.`,
                  'Output:',
                  ...r.split(`
`),
                ],
              }),
            (await Tv(t)) &&
              (ie && console.log('[Nx Cloud Debug] Sending heartbeat logs'),
              await t.sendHeartbeatLogs(r, At(), e).catch((o) => {
                ie &&
                  tl.note({
                    title: 'Nx Cloud Unable to Upload Heartbeat Diagnostics',
                    bodyLines: [
                      'An error occurred while uploading diagnostics from the Nx Cloud heartbeat process.',
                      'This will not affect your run. To hide this message, disable verbose logging for future runs.',
                      'Output:',
                      JSON.stringify(o),
                    ],
                  });
              }));
        }
      }, 1e3)),
      process.on('SIGINT', el),
      process.on('SIGTERM', el),
      process.on('uncaughtException', el),
      process.on('exit', el)));
}
function el() {
  clearInterval(Ed), (Ed = void 0);
}
function u7(t) {
  try {
    return process.kill(t, 0), !0;
  } catch {
    return !1;
  }
}
var iP,
  Rv,
  tl,
  Ed,
  rP = te(() => {
    'use strict';
    (iP = require('child_process')), (Rv = require('fs'));
    Le();
    Pn();
    tP();
    ({ output: tl } = Ae());
  });
function oP() {
  (0, _d.writeFileSync)(il, 'true');
}
function Ov(t, e) {
  if (t === !0) return !0;
  if (t === !1) return !1;
  if (e === !0) return !0;
  if (e === !1) return !1;
  let i = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION;
  if (i === 'false' || i === 'FALSE' || i === '0') return !1;
  if (i === 'true' || i === 'TRUE' || i === '1') return !0;
  try {
    return (0, _d.readFileSync)(il), !0;
  } catch {
    return !1;
  }
}
var _d,
  sP,
  Sd,
  il,
  Cd = te(() => {
    'use strict';
    (_d = require('fs')),
      (sP = require('os')),
      (Sd = require('path')),
      (il = (0, Sd.join)((0, sP.tmpdir)(), `NX_CLOUD_DISTRIBUTED_EXECUTION-${(0, Sd.basename)(process.cwd())}`));
  });
async function _o(t) {
  let e = zt(t);
  return await tt(() => e.get('/nx-cloud/executions/workspace-status'));
}
var Rd = te(() => {
  'use strict';
  mn();
});
var aP = P((kv) => {
  'use strict';
  Object.defineProperty(kv, '__esModule', { value: !0 });
  kv.subscribeToArray = function (t) {
    return function (e) {
      for (var i = 0, n = t.length; i < n && !e.closed; i++) e.next(t[i]);
      e.complete();
    };
  };
});
var cP = P((Av) => {
  'use strict';
  Object.defineProperty(Av, '__esModule', { value: !0 });
  var l7 = gd();
  Av.subscribeToPromise = function (t) {
    return function (e) {
      return (
        t
          .then(
            function (i) {
              e.closed || (e.next(i), e.complete());
            },
            function (i) {
              return e.error(i);
            }
          )
          .then(null, l7.hostReportError),
        e
      );
    };
  };
});
var nl = P((tc) => {
  'use strict';
  Object.defineProperty(tc, '__esModule', { value: !0 });
  function uP() {
    return typeof Symbol != 'function' || !Symbol.iterator ? '@@iterator' : Symbol.iterator;
  }
  tc.getSymbolIterator = uP;
  tc.iterator = uP();
  tc.$$iterator = tc.iterator;
});
var lP = P((Iv) => {
  'use strict';
  Object.defineProperty(Iv, '__esModule', { value: !0 });
  var p7 = nl();
  Iv.subscribeToIterable = function (t) {
    return function (e) {
      var i = t[p7.iterator]();
      do {
        var n = i.next();
        if (n.done) {
          e.complete();
          break;
        }
        if ((e.next(n.value), e.closed)) break;
      } while (!0);
      return (
        typeof i.return == 'function' &&
          e.add(function () {
            i.return && i.return();
          }),
        e
      );
    };
  };
});
var pP = P((Nv) => {
  'use strict';
  Object.defineProperty(Nv, '__esModule', { value: !0 });
  var f7 = ec();
  Nv.subscribeToObservable = function (t) {
    return function (e) {
      var i = t[f7.observable]();
      if (typeof i.subscribe != 'function')
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
      return i.subscribe(e);
    };
  };
});
var Lv = P((Pv) => {
  'use strict';
  Object.defineProperty(Pv, '__esModule', { value: !0 });
  Pv.isArrayLike = function (t) {
    return t && typeof t.length == 'number' && typeof t != 'function';
  };
});
var Fv = P((Dv) => {
  'use strict';
  Object.defineProperty(Dv, '__esModule', { value: !0 });
  function d7(t) {
    return !!t && typeof t.subscribe != 'function' && typeof t.then == 'function';
  }
  Dv.isPromise = d7;
});
var Mv = P((jv) => {
  'use strict';
  Object.defineProperty(jv, '__esModule', { value: !0 });
  var h7 = aP(),
    m7 = cP(),
    g7 = lP(),
    x7 = pP(),
    y7 = Lv(),
    b7 = Fv(),
    v7 = uv(),
    w7 = nl(),
    E7 = ec();
  jv.subscribeTo = function (t) {
    if (t && typeof t[E7.observable] == 'function') return x7.subscribeToObservable(t);
    if (y7.isArrayLike(t)) return h7.subscribeToArray(t);
    if (b7.isPromise(t)) return m7.subscribeToPromise(t);
    if (t && typeof t[w7.iterator] == 'function') return g7.subscribeToIterable(t);
    var e = v7.isObject(t) ? 'an invalid object' : "'" + t + "'",
      i =
        'You provided ' +
        e +
        ' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.';
    throw new TypeError(i);
  };
});
var fP = P((Uv) => {
  'use strict';
  Object.defineProperty(Uv, '__esModule', { value: !0 });
  var _7 = xs(),
    S7 = gs(),
    C7 = ec();
  function R7(t, e) {
    return new _7.Observable(function (i) {
      var n = new S7.Subscription();
      return (
        n.add(
          e.schedule(function () {
            var r = t[C7.observable]();
            n.add(
              r.subscribe({
                next: function (s) {
                  n.add(
                    e.schedule(function () {
                      return i.next(s);
                    })
                  );
                },
                error: function (s) {
                  n.add(
                    e.schedule(function () {
                      return i.error(s);
                    })
                  );
                },
                complete: function () {
                  n.add(
                    e.schedule(function () {
                      return i.complete();
                    })
                  );
                },
              })
            );
          })
        ),
        n
      );
    });
  }
  Uv.scheduleObservable = R7;
});
var dP = P((qv) => {
  'use strict';
  Object.defineProperty(qv, '__esModule', { value: !0 });
  var T7 = xs(),
    O7 = gs();
  function k7(t, e) {
    return new T7.Observable(function (i) {
      var n = new O7.Subscription();
      return (
        n.add(
          e.schedule(function () {
            return t.then(
              function (r) {
                n.add(
                  e.schedule(function () {
                    i.next(r),
                      n.add(
                        e.schedule(function () {
                          return i.complete();
                        })
                      );
                  })
                );
              },
              function (r) {
                n.add(
                  e.schedule(function () {
                    return i.error(r);
                  })
                );
              }
            );
          })
        ),
        n
      );
    });
  }
  qv.schedulePromise = k7;
});
var hP = P((Bv) => {
  'use strict';
  Object.defineProperty(Bv, '__esModule', { value: !0 });
  var A7 = xs(),
    I7 = gs();
  function N7(t, e) {
    return new A7.Observable(function (i) {
      var n = new I7.Subscription(),
        r = 0;
      return (
        n.add(
          e.schedule(function () {
            if (r === t.length) {
              i.complete();
              return;
            }
            i.next(t[r++]), i.closed || n.add(this.schedule());
          })
        ),
        n
      );
    });
  }
  Bv.scheduleArray = N7;
});
var mP = P((Hv) => {
  'use strict';
  Object.defineProperty(Hv, '__esModule', { value: !0 });
  var P7 = xs(),
    L7 = gs(),
    D7 = nl();
  function F7(t, e) {
    if (!t) throw new Error('Iterable cannot be null');
    return new P7.Observable(function (i) {
      var n = new L7.Subscription(),
        r;
      return (
        n.add(function () {
          r && typeof r.return == 'function' && r.return();
        }),
        n.add(
          e.schedule(function () {
            (r = t[D7.iterator]()),
              n.add(
                e.schedule(function () {
                  if (!i.closed) {
                    var s, o;
                    try {
                      var c = r.next();
                      (s = c.value), (o = c.done);
                    } catch (u) {
                      i.error(u);
                      return;
                    }
                    o ? i.complete() : (i.next(s), this.schedule());
                  }
                })
              );
          })
        ),
        n
      );
    });
  }
  Hv.scheduleIterable = F7;
});
var gP = P((Gv) => {
  'use strict';
  Object.defineProperty(Gv, '__esModule', { value: !0 });
  var j7 = ec();
  function M7(t) {
    return t && typeof t[j7.observable] == 'function';
  }
  Gv.isInteropObservable = M7;
});
var xP = P((zv) => {
  'use strict';
  Object.defineProperty(zv, '__esModule', { value: !0 });
  var U7 = nl();
  function q7(t) {
    return t && typeof t[U7.iterator] == 'function';
  }
  zv.isIterable = q7;
});
var yP = P((Vv) => {
  'use strict';
  Object.defineProperty(Vv, '__esModule', { value: !0 });
  var B7 = fP(),
    H7 = dP(),
    G7 = hP(),
    z7 = mP(),
    V7 = gP(),
    $7 = Fv(),
    W7 = Lv(),
    K7 = xP();
  function X7(t, e) {
    if (t != null) {
      if (V7.isInteropObservable(t)) return B7.scheduleObservable(t, e);
      if ($7.isPromise(t)) return H7.schedulePromise(t, e);
      if (W7.isArrayLike(t)) return G7.scheduleArray(t, e);
      if (K7.isIterable(t) || typeof t == 'string') return z7.scheduleIterable(t, e);
    }
    throw new TypeError(((t !== null && typeof t) || t) + ' is not observable');
  }
  Vv.scheduled = X7;
});
var Wv = P(($v) => {
  'use strict';
  Object.defineProperty($v, '__esModule', { value: !0 });
  var bP = xs(),
    Y7 = Mv(),
    J7 = yP();
  function Z7(t, e) {
    return e ? J7.scheduled(t, e) : t instanceof bP.Observable ? t : new bP.Observable(Y7.subscribeTo(t));
  }
  $v.from = Z7;
});
var vP = P((rl) => {
  'use strict';
  var Q7 =
    (rl && rl.__extends) ||
    (function () {
      var t = function (e, i) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, r) {
                n.__proto__ = r;
              }) ||
            function (n, r) {
              for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);
            }),
          t(e, i)
        );
      };
      return function (e, i) {
        t(e, i);
        function n() {
          this.constructor = e;
        }
        e.prototype = i === null ? Object.create(i) : ((n.prototype = i.prototype), new n());
      };
    })();
  Object.defineProperty(rl, '__esModule', { value: !0 });
  var eW = wo(),
    tW = (function (t) {
      Q7(e, t);
      function e() {
        return (t !== null && t.apply(this, arguments)) || this;
      }
      return (
        (e.prototype.notifyNext = function (i, n, r, s, o) {
          this.destination.next(n);
        }),
        (e.prototype.notifyError = function (i, n) {
          this.destination.error(i);
        }),
        (e.prototype.notifyComplete = function (i) {
          this.destination.complete();
        }),
        e
      );
    })(eW.Subscriber);
  rl.OuterSubscriber = tW;
});
var Kv = P((sl) => {
  'use strict';
  var iW =
    (sl && sl.__extends) ||
    (function () {
      var t = function (e, i) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, r) {
                n.__proto__ = r;
              }) ||
            function (n, r) {
              for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);
            }),
          t(e, i)
        );
      };
      return function (e, i) {
        t(e, i);
        function n() {
          this.constructor = e;
        }
        e.prototype = i === null ? Object.create(i) : ((n.prototype = i.prototype), new n());
      };
    })();
  Object.defineProperty(sl, '__esModule', { value: !0 });
  var nW = wo(),
    rW = (function (t) {
      iW(e, t);
      function e(i, n, r) {
        var s = t.call(this) || this;
        return (s.parent = i), (s.outerValue = n), (s.outerIndex = r), (s.index = 0), s;
      }
      return (
        (e.prototype._next = function (i) {
          this.parent.notifyNext(this.outerValue, i, this.outerIndex, this.index++, this);
        }),
        (e.prototype._error = function (i) {
          this.parent.notifyError(i, this), this.unsubscribe();
        }),
        (e.prototype._complete = function () {
          this.parent.notifyComplete(this), this.unsubscribe();
        }),
        e
      );
    })(nW.Subscriber);
  sl.InnerSubscriber = rW;
});
var wP = P((Xv) => {
  'use strict';
  Object.defineProperty(Xv, '__esModule', { value: !0 });
  var sW = Kv(),
    oW = Mv(),
    aW = xs();
  function cW(t, e, i, n, r) {
    if ((r === void 0 && (r = new sW.InnerSubscriber(t, i, n)), !r.closed))
      return e instanceof aW.Observable ? e.subscribe(r) : oW.subscribeTo(e)(r);
  }
  Xv.subscribeToResult = cW;
});
var _P = P((ic) => {
  'use strict';
  var uW =
    (ic && ic.__extends) ||
    (function () {
      var t = function (e, i) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, r) {
                n.__proto__ = r;
              }) ||
            function (n, r) {
              for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);
            }),
          t(e, i)
        );
      };
      return function (e, i) {
        t(e, i);
        function n() {
          this.constructor = e;
        }
        e.prototype = i === null ? Object.create(i) : ((n.prototype = i.prototype), new n());
      };
    })();
  Object.defineProperty(ic, '__esModule', { value: !0 });
  var lW = wo();
  function pW(t, e) {
    return function (n) {
      if (typeof t != 'function') throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
      return n.lift(new EP(t, e));
    };
  }
  ic.map = pW;
  var EP = (function () {
    function t(e, i) {
      (this.project = e), (this.thisArg = i);
    }
    return (
      (t.prototype.call = function (e, i) {
        return i.subscribe(new fW(e, this.project, this.thisArg));
      }),
      t
    );
  })();
  ic.MapOperator = EP;
  var fW = (function (t) {
    uW(e, t);
    function e(i, n, r) {
      var s = t.call(this, i) || this;
      return (s.project = n), (s.count = 0), (s.thisArg = r || s), s;
    }
    return (
      (e.prototype._next = function (i) {
        var n;
        try {
          n = this.project.call(this.thisArg, i, this.count++);
        } catch (r) {
          this.destination.error(r);
          return;
        }
        this.destination.next(n);
      }),
      e
    );
  })(lW.Subscriber);
});
var CP = P((ol) => {
  'use strict';
  var dW =
    (ol && ol.__extends) ||
    (function () {
      var t = function (e, i) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, r) {
                n.__proto__ = r;
              }) ||
            function (n, r) {
              for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);
            }),
          t(e, i)
        );
      };
      return function (e, i) {
        t(e, i);
        function n() {
          this.constructor = e;
        }
        e.prototype = i === null ? Object.create(i) : ((n.prototype = i.prototype), new n());
      };
    })();
  Object.defineProperty(ol, '__esModule', { value: !0 });
  var hW = vP(),
    mW = Kv(),
    gW = wP(),
    xW = _P(),
    yW = Wv();
  function SP(t, e) {
    return typeof e == 'function'
      ? function (i) {
          return i.pipe(
            SP(function (n, r) {
              return yW.from(t(n, r)).pipe(
                xW.map(function (s, o) {
                  return e(n, s, r, o);
                })
              );
            })
          );
        }
      : function (i) {
          return i.lift(new bW(t));
        };
  }
  ol.switchMap = SP;
  var bW = (function () {
      function t(e) {
        this.project = e;
      }
      return (
        (t.prototype.call = function (e, i) {
          return i.subscribe(new vW(e, this.project));
        }),
        t
      );
    })(),
    vW = (function (t) {
      dW(e, t);
      function e(i, n) {
        var r = t.call(this, i) || this;
        return (r.project = n), (r.index = 0), r;
      }
      return (
        (e.prototype._next = function (i) {
          var n,
            r = this.index++;
          try {
            n = this.project(i, r);
          } catch (s) {
            this.destination.error(s);
            return;
          }
          this._innerSub(n, i, r);
        }),
        (e.prototype._innerSub = function (i, n, r) {
          var s = this.innerSubscription;
          s && s.unsubscribe();
          var o = new mW.InnerSubscriber(this, n, r),
            c = this.destination;
          c.add(o),
            (this.innerSubscription = gW.subscribeToResult(this, i, void 0, void 0, o)),
            this.innerSubscription !== o && c.add(this.innerSubscription);
        }),
        (e.prototype._complete = function () {
          var i = this.innerSubscription;
          (!i || i.closed) && t.prototype._complete.call(this), this.unsubscribe();
        }),
        (e.prototype._unsubscribe = function () {
          this.innerSubscription = null;
        }),
        (e.prototype.notifyComplete = function (i) {
          var n = this.destination;
          n.remove(i), (this.innerSubscription = null), this.isStopped && t.prototype._complete.call(this);
        }),
        (e.prototype.notifyNext = function (i, n, r, s, o) {
          this.destination.next(n);
        }),
        e
      );
    })(hW.OuterSubscriber);
});
var OP,
  nc,
  RP,
  wW,
  TP,
  Kce,
  Td,
  Od,
  Yv,
  zn,
  al = te(() => {
    'use strict';
    (OP = je(Tu())), (nc = require('path'));
    Le();
    ({ readFile: RP, copy: wW, mkdirSync: TP, remove: Kce } = Tu()),
      ({ output: Td, workspaceRoot: Od } = Ae()),
      ({ getCache: Yv } = ri()),
      (zn = class {
        constructor(e, i) {
          this.fileStorage = e;
          this.cacheDirectory = i;
          this.nxCache = Yv == null ? void 0 : Yv({});
          TP(i, { recursive: !0 }), TP((0, nc.join)(i, 'terminalOutputs'), { recursive: !0 });
        }
        get isDbCacheAvailable() {
          var e;
          return ((e = this.nxCache) == null ? void 0 : e.applyRemoteCacheResult) !== void 0;
        }
        async retrieveAndExtract(e, i) {
          var c, u;
          process.env.NX_CLOUD_DEBUG_URLS == 'true' &&
            Td.note({ title: `Retrieving artifacts from ${i.map((l) => l.remoteUrl).join(', ')}` }),
            ie && Td.note({ title: 'DTE Extracting artifacts', bodyLines: [`to: ${Od}`] });
          let n = null,
            r = null;
          for (let l of i)
            switch (l.fileType) {
              case 'artifact':
                n = await this.fileStorage.retrieve(e, this.cacheDirectory, l, !this.isDbCacheAvailable);
                break;
              case 'terminalOutput':
                (r = await this.fileStorage.retrieve(e, this.cacheDirectory, l, !this.isDbCacheAvailable)),
                  (r == null ? void 0 : r.terminalOutput) !== void 0 &&
                    (await (0, OP.writeFile)(
                      (0, nc.join)(this.cacheDirectory, 'terminalOutputs', e),
                      r.terminalOutput
                    ));
                break;
            }
          let s = (n == null ? void 0 : n.outputsPath) ?? (0, nc.join)(this.cacheDirectory, e, 'outputs');
          ie && Td.note({ title: 'DTE: Extracting artifacts', bodyLines: [`from: ${s}`, `to: ${Od}`] }),
            await wW(s, Od),
            ie && Td.note({ title: 'DTE: Finished extracting artifacts', bodyLines: [`from: ${s}`, `to: ${Od}`] });
          let o = r == null ? void 0 : r.terminalOutput;
          if (o === void 0)
            try {
              o = await RP((0, nc.join)(this.cacheDirectory, 'terminalOutputs', e));
            } catch {
              o = await RP((0, nc.join)(this.cacheDirectory, e, 'terminalOutput'));
            }
          return (
            this.isDbCacheAvailable &&
              ((u = (c = this.nxCache) == null ? void 0 : c.applyRemoteCacheResult) == null ||
                u.call(c, e, { code: (n == null ? void 0 : n.code) ?? 1, terminalOutput: o, outputsPath: s })),
            o
          );
        }
      });
  });
function rn(t, e) {
  return !!t || !!e;
}
function sn() {
  EW.error({
    title: 'Unable to determine the context for running Nx in CI',
    bodyLines: [
      "- Nx tried to determine the context automatically but wasn't able to do it.",
      '- Use the NX_CI_EXECUTION_ID env variable to set it manually.',
      '- NX_CI_EXECUTION_ID must be a unique value for every CI execution/run.',
    ],
  });
}
var EW,
  So = te(() => {
    'use strict';
    ({ output: EW } = Ae());
  });
function AP(t, e, i) {
  let n = JSON.parse(Gs((0, kP.readFileSync)(`${_W}/nx.json`).toString(), { trailingCommas: !0 }));
  return new Jv(e, CW(n, t)).createTaskGraph(i);
}
function CW(t, e) {
  let i = t.targetDependencies ?? {},
    n = e ? e.strictlyOrderedTargets ?? ['build'] : [];
  for (let r of n) (i[r] = i[r] || []), i[r].push({ target: r, projects: 'dependencies' });
  return i;
}
var kP,
  _W,
  SW,
  Jv,
  IP = te(() => {
    'use strict';
    kP = require('fs');
    ip();
    ({ workspaceRoot: _W } = Ae()), ({ getDependencyConfigs: SW } = ri());
    Jv = class {
      constructor(e, i) {
        this.projectGraph = e;
        this.defaultTargetDependencies = i;
      }
      createTaskGraph(e) {
        let i = { roots: [], tasks: {}, dependencies: {} };
        for (let n of e) {
          this.addTaskToGraph(n, i);
          let r = SW(n.target, this.defaultTargetDependencies, this.projectGraph);
          r && this.addTaskDependencies(n, r, e, i);
        }
        return (i.roots = Object.keys(i.dependencies).filter((n) => i.dependencies[n].length === 0)), i;
      }
      addTaskDependencies(e, i, n, r) {
        for (let s of i)
          if (s.projects === 'self')
            for (let o of n)
              o.target.project === e.target.project && o.target.target === s.target && r.dependencies[e.id].push(o.id);
          else if (s.projects === 'dependencies') {
            let o = new Set();
            this.addDependencies(e.target.project, s.target, n, r, e.id, o);
          }
      }
      addDependencies(e, i, n, r, s, o) {
        o.add(e);
        let c = this.projectGraph.dependencies[e];
        if (c) {
          let u = c.map((l) => l.target);
          for (let l of u) {
            if (o.has(l)) continue;
            let p = this.findTask({ project: l, target: i }, n);
            p
              ? r.dependencies[s].indexOf(p.id) === -1 && r.dependencies[s].push(p.id)
              : this.addDependencies(l, i, n, r, s, o);
          }
        }
      }
      findTask({ project: e, target: i }, n) {
        return n.find((r) => r.target.project === e && r.target.target === i);
      }
      addTaskToGraph(e, i) {
        (i.tasks[e.id] = e), (i.dependencies[e.id] = []);
      }
    };
  });
function kd(t, e, i, n, r) {
  process.on('SIGINT', async () => {
    await t.completeRunGroupWithError(e, i, n, r, 'Main job was terminated via SIGINT'), process.exit(1);
  }),
    process.on('SIGTERM', async () => {
      await t.completeRunGroupWithError(e, i, n, r, 'Main job was terminated via SIGTERM'), process.exit(1);
    });
}
function Zv(t) {
  return t.parallel === 'false' || t.parallel === !1
    ? 1
    : t.parallel === 'true' || t.parallel === !0
    ? Number(t.maxParallel || 3)
    : t.parallel === void 0
    ? t.maxParallel
      ? Number(t.maxParallel)
      : 3
    : Number(t.parallel) || 3;
}
function NP(t) {
  for (let e of Object.values(t.tasks)) delete e.hashDetails;
}
function Ad(t, e, i) {
  if (t.taskGraph) return NP(t.taskGraph), t.taskGraph;
  {
    let n = AP(i, t.projectGraph, e);
    return NP(n), n;
  }
}
function Id(t) {
  var i;
  let e = (i = t == null ? void 0 : t.nxArgs) == null ? void 0 : i.runner;
  return e == null || e === 'default' ? null : e;
}
var rc,
  Nd = te(() => {
    'use strict';
    IP();
    rc = class {
      scheduleTask(e) {}
      startTask(e) {}
      endTasks(e) {}
    };
  });
function DP(t, e, i, n, r, s, o, c, u, l, p) {
  let d = r.map((b) =>
      b.map((g) => ({
        taskId: g.id,
        hash: g.hash,
        projectName: g.target.project,
        target: g.target.target,
        configuration: g.target.configuration || null,
        params: Xa(g),
        projectRoot: g.projectRoot,
        cache: g.cache,
        outputs: g.outputs,
      }))
    ),
    x = {
      command: wi(),
      branch: t,
      runGroup: e,
      ciExecutionId: i,
      ciExecutionEnv: n,
      tasks: d,
      maxParallel: Zv(s),
      clientInstanceId: o,
      commitSha: c,
      projectGraph: u,
      taskRunnerConfiguration: l,
      meta: p,
    };
  return Lc && (x.agentCount = Lc), Lm || (x.stopAgentsOnFailure = !1), x;
}
function FP(t, e, i, n, r, s, o, c = null, u = null, l, p, d) {
  let x = {
    command: wi(),
    branch: t,
    runGroup: e,
    ciExecutionId: i,
    ciExecutionEnv: n,
    projectGraph: r,
    taskGraph: s,
    maxParallel: Zv(o),
    commitSha: c,
    taskRunnerConfiguration: u,
    retryFlakyTasks: wS,
    clientInstanceId: l,
    meta: p,
    nxBail: d,
    projectGraphSha: fd(JSON.stringify(r)),
  };
  return Lc && (x.agentCount = Lc), Lm || (x.stopAgentsOnFailure = !1), x;
}
var PP,
  LP,
  Co,
  ys,
  Pd = te(() => {
    'use strict';
    (PP = require('util')), (LP = require('zlib'));
    mn();
    Jb();
    Le();
    sa();
    Gu();
    Nd();
    ({ output: Co } = Ae()),
      (ys = class {
        constructor(e) {
          this.apiAxiosInstance = zt(e, null, 6e4);
        }
        async summary(e, i) {
          try {
            let n = { executionId: e, runGroup: i };
            return (await tt(() => this.apiAxiosInstance.post('/nx-cloud/v2/executions/summary', n))).data;
          } catch (n) {
            Co.error({ title: n.message, bodyLines: [JSON.stringify(n)] }), process.exit(1);
          }
        }
        async start(e) {
          let i;
          ie && Co.note({ title: 'Starting a distributed execution', bodyLines: [JSON.stringify(e, null, 2)] });
          try {
            i = await tt(() => this.apiAxiosInstance.post('/nx-cloud/executions/start', e));
          } catch (n) {
            throw n;
          }
          if (!i.data.enabled) throw new Error('Workspace is disabled. Cannot perform distributed task executions.');
          if (i.data.error) throw new Error(i.data.error);
          return i.data.id;
        }
        async status(e, i) {
          try {
            return (
              await tt(() => this.apiAxiosInstance.post('/nx-cloud/executions/status', { id: e, prevUpdatedAt: i }))
            ).data;
          } catch (n) {
            Co.error({ title: n.message }), process.exit(1);
          }
        }
        async completeRunGroupWithError(e, i, n, r, s) {
          ie &&
            Co.note({
              title: 'Completing with an error',
              bodyLines: [`ciExecutionId: ${n}`, `ciExecutionEnv: ${r}`, `runGroup: ${i}`, `error: ${s}`],
            });
          try {
            let o = await tt(
              () =>
                this.apiAxiosInstance.post('/nx-cloud/executions/complete-run-group', {
                  branch: e,
                  runGroup: i,
                  ciExecutionId: n,
                  ciExecutionEnv: r,
                  criticalErrorMessage: s,
                  vcsContext: qi(),
                }),
              3
            );
          } catch (o) {
            Co.error({ title: o.message });
          }
        }
        async startV2(e) {
          if (ie) {
            let r = {
              command: e.command,
              branch: e.branch,
              runGroup: e.runGroup,
              ciExecutionId: e.ciExecutionId,
              ciExecutionEnv: e.ciExecutionEnv,
              stopAgentsOnFailure: e.stopAgentsOnFailure,
              retryFlakyTasks: e.retryFlakyTasks,
              maxParallel: e.maxParallel,
              agentCount: e.agentCount,
              nxBail: e.nxBail,
            };
            Co.note({ title: 'Starting a distributed execution', bodyLines: [JSON.stringify(r, null, 2)] });
          }
          let i = await this.compressRequestBody(e),
            n = await Gg(() =>
              this.apiAxiosInstance.post('/nx-cloud/v2/executions/start', i, {
                headers: {
                  ...this.apiAxiosInstance.defaults.headers,
                  'Content-Encoding': 'gzip',
                  'Content-Type': 'application/octet-stream',
                },
              })
            );
          if (!n.data.enabled) throw new Error('Workspace is disabled. Cannot perform distributed task executions.');
          if (n.data.error) throw new Error(n.data.error);
          return n.data;
        }
        async statusV2(e, i) {
          try {
            return (
              await tt(() => this.apiAxiosInstance.post('/nx-cloud/v2/executions/status', { id: e, prevUpdatedAt: i }))
            ).data;
          } catch (n) {
            Co.error({ title: n.message }), process.exit(1);
          }
        }
        async compressRequestBody(e) {
          let i = JSON.stringify(e),
            n = Buffer.from(i);
          return (0, PP.promisify)(LP.gzip)(n);
        }
      });
  });
function bs(t) {
  let e = new Object(),
    i;
  return (n) => {
    e !== n
      ? ((e = n), (i = new Date()))
      : new Date().getTime() - i.getTime() > t.timeout && (RW.error({ title: t.title }), process.exit(1));
  };
}
var RW,
  cl = te(() => {
    'use strict';
    ({ output: RW } = Ae());
  });
async function Ld(t, e, i, n) {
  ie && Qv.note({ title: `Processing task ${i.taskId}` });
  let r = e.find((c) => i.taskId === c.id);
  if (!r) throw new Error(`Found unknown task: ${i.taskId}`);
  let s = [{ remoteUrl: i.url, fileType: 'artifact' }];
  i.terminalOutputUrl && s.push({ remoteUrl: i.terminalOutputUrl, fileType: 'terminalOutput' });
  let o = await t.retrieveAndExtract(i.hash, s);
  n && (Qv.logCommand(TW(r)), process.stdout.write(o), Qv.addVerticalSeparator());
}
function TW(t) {
  let e = t.target.configuration ? `:${t.target.configuration}` : '';
  return ['nx', 'run', `${t.target.project}:${t.target.target}${e}`, Xa(t)].join(' ');
}
var Qv,
  e0 = te(() => {
    'use strict';
    Le();
    Gu();
    ({ output: Qv } = Ae());
  });
async function jP(t, e, i, n) {
  let r = null,
    s = {},
    o = bs({ title: `No new completed tasks after ${Ko / 1e3} seconds.`, timeout: Ko });
  for (await wt(1e3); ; ) {
    ie && t0.note({ title: 'Waiting...' });
    let c = await t.status(i, r);
    ie &&
      t0.note({
        title: 'Status update',
        bodyLines: [
          `executionId: ${i}`,
          `executionStatus: ${c.executionStatus}`,
          `number of completed tasks: ${c.completedTasks.length}`,
          `error: ${c.criticalErrorMessage}`,
        ],
      }),
      c.criticalErrorMessage &&
        (t0.error({ title: 'Distributed Execution Terminated', bodyLines: ['Error:', c.criticalErrorMessage] }),
        process.exit(1)),
      c.updatedAt || (await wt(5e3)),
      (r = c.updatedAt),
      o(c.completedTasks.length);
    for (let u of c.completedTasks) s[u.taskId] || (await Ld(e, n, u, !0), (s[u.taskId] = !0));
    if (c.executionStatus === 'COMPLETED') return { commandStatus: c.commandStatus, runUrl: c.runUrl };
  }
}
var t0,
  MP = te(() => {
    'use strict';
    cl();
    Le();
    Pn();
    e0();
    ({ output: t0 } = Ae());
  });
function UP(t) {
  let e = [],
    i = new Set(Object.values(t.tasks).map((r) => r.id)),
    n = 0;
  for (; i.size > 0; ) {
    let r = (e[n] = []);
    for (let s of i) {
      let o = !0;
      for (let u of t.dependencies[s])
        if (i.has(u)) {
          o = !1;
          break;
        }
      if (!o) continue;
      let c = t.tasks[s];
      r.push(c);
    }
    for (let s of r) i.delete(s.id);
    n++;
  }
  return e;
}
var qP = te(() => {
  'use strict';
});
var i0 = {};
Ft(i0, { nxCloudDistributedTasksRunner: () => kW });
async function AW(t, e, i, n, r, s, o, c, u, l, p, d) {
  let x = await vo(),
    b = await t.start(DP(n, r, s, o, UP(c), e, x, l, u, d));
  return await jP(t, i, b, Object.values(c.tasks));
}
var ul,
  OW,
  kW,
  n0 = te(() => {
    'use strict';
    pd();
    al();
    Le();
    dd();
    Ks();
    So();
    Xs();
    yo();
    Pd();
    Nd();
    MP();
    qP();
    ({ output: ul } = Ae()),
      ({ cacheDirectory: OW } = ri()),
      (kW = async (t, e, i) => {
        e.skipNxCache &&
          ul.warn({
            title: '--skip-nx-cache is ignored when using distributed tasks execution (DTE).',
            bodyLine: ['DTE needs the cache to share files between agents.'],
          }),
          ie && ul.note({ title: 'Starting distributed command execution' }),
          (e.lifeCycle = new rc());
        let n = It(),
          r = Ct(),
          s = At(),
          o = kt(),
          c = Qt(),
          u = ep();
        rn(r, s) || (sn(), process.exit(1));
        let l = new Ci(Fi || e.encryptionKey),
          p = new Si(e),
          d = new zn(new Ai(l, p, e, 'dte-main'), OW),
          x = new ys(e);
        kd(x, n, r, s, o);
        try {
          let b = Ad(i, t, e),
            g = Id(i),
            y = await AW(x, e, d, n, r, s, o, b, Ya(i.projectGraph), c, u, g);
          y.commandStatus === 0
            ? ul.success({
                title: 'Successfully completed running the command.',
                bodyLines: [`See run details at ${y.runUrl}`],
              })
            : ul.error({ title: 'Command execution failed.', bodyLines: [`See run details at ${y.runUrl}`] }),
            process.exit(y.commandStatus);
        } catch (b) {
          let g = [b.message];
          b.bodyLines && g.push(b.bodyLines), ul.error({ title: 'Unable to complete a run.', bodyLines: g });
          try {
            await x.completeRunGroupWithError(n, r, s, o, `Main job terminated with an error: "${b.message}"`);
          } finally {
            process.exit(1);
          }
        }
      });
  });
async function HP(t, e, i, n) {
  let r = await t.summary(e, i),
    s = `${n}/runs/${e}`,
    o = new ds([
      new ut('Status', 'center', !1),
      new ut('Task', 'left', !0),
      new ut('Duration', 'center', !1),
      new ut('Cache Status', 'center', !1, 20),
    ]);
  IW(o, r.completedTasks);
  let c = [new ut('', 'left', !1, 8), new ut('', 'left', !0), new ut('', 'left', !1, 8), new ut('', 'left', !0)],
    u = new ds(c);
  NW(u, r.completedTasks, r.agentCount, s);
}
function IW(t, e) {
  let i = t.autoSizeToTerminalWidth([new ut('', 'center', !1, 8), new ut('', 'left', !0)]);
  t.printTableBorderRow(ue.topLeftCorner, ue.horizontalEdge, ue.topRightCorner),
    t.printTitleRow(`Tasks run for command: ${wi()}`),
    t.printTableBorderRow(ue.middleLeftCorner, ue.horizontalEdge, ue.middleRightCorner),
    t.printTableBorderRow(ue.middleLeftCorner, ue.topMiddleCorner, ue.middleRightCorner),
    t.printHeaders(),
    t.printTableBorderRow(ue.middleLeftCorner, ue.middleCorner, ue.middleRightCorner);
  let { successfulTasks: n, failedTasks: r } = e.reduce(
    (s, o) => (o.status === 0 ? s.successfulTasks.push(o) : s.failedTasks.push(o), s),
    { successfulTasks: [], failedTasks: [] }
  );
  if (
    (n.forEach((s) => {
      t.printTableContentRow(BP(s));
    }),
    r.length > 0)
  ) {
    t.printTableCustomBorder(
      [ue.verticalEdge, ue.bottomLeftCorner, ue.bottomMiddleCorner, ue.bottomMiddleCorner, ue.middleRightCorner],
      [' ', ue.horizontalEdge, ue.horizontalEdge, ue.horizontalEdge]
    ),
      r.forEach((s) => {
        t.printTableContentRow(BP(s), void 0, ' '), t.printTableContentRow(['', ` > Task logs: ${s.taskUrl}`], i, ' ');
      }),
      t.printTableBorderRow(ue.bottomLeftCorner, ue.horizontalEdge, ue.bottomRightCorner);
    return;
  }
  t.printTableBorderRow(ue.bottomLeftCorner, ue.bottomMiddleCorner, ue.bottomRightCorner);
}
function NW(t, e, i, n) {
  let r = e.reduce((d, x) => d + (x.cacheStatus !== 'cache-miss' ? 1 : 0), 0),
    s = e.reduce((d, x) => d + (x.status === 0 && x.cacheStatus !== 'remote-cache-hit' ? 1 : 0), 0),
    o = e.reduce((d, x) => d + (x.status !== 0 ? 1 : 0), 0),
    c = e.length,
    u = hs(r, c),
    l = hs(s, c),
    p = hs(o, c);
  t.printTableBorderRow(ue.topLeftCorner, ue.horizontalEdge, ue.topRightCorner),
    t.printTitleRow('Distributed Execution Summary Report'),
    t.printTableBorderRow(ue.middleLeftCorner, ue.horizontalEdge, ue.middleRightCorner),
    t.printTableBorderRow(ue.middleLeftCorner, ue.topMiddleCorner, ue.middleRightCorner),
    t.printTableContentRow([s.toString(), 'Successful Tasks', l, 'Success Percentage']),
    t.printTableContentRow([o.toString(), 'Failed Tasks', p, 'Failure Percentage']),
    t.printTableBorderRow(ue.middleLeftCorner, ue.middleCorner, ue.middleRightCorner),
    t.printTableContentRow([r.toString(), 'Cached Tasks', u, 'Cache Hit Percentage']),
    t.printTableContentRow([c.toString(), 'Total Executed Tasks', i.toString(), 'Number of Agents']),
    t.printTableBorderRow(ue.middleLeftCorner, ue.bottomMiddleCorner, ue.middleRightCorner),
    t.printTitleRow(`See run details: ${n}`),
    t.printTableBorderRow(ue.bottomLeftCorner, ue.horizontalEdge, ue.bottomRightCorner);
}
function BP(t) {
  let e = rd(t.status),
    i = Hu(new Date(t.startTime).getTime(), new Date(t.endTime).getTime()),
    n = t.cacheStatus
      .split('-')
      .map((r) => r.charAt(0).toUpperCase() + r.slice(1))
      .join(' ');
  return [e, t.taskId, i, n];
}
var GP = te(() => {
  'use strict';
  Le();
  Db();
});
async function zP(t, e, i, n, r, s) {
  let o = null,
    c = {},
    u = bs({ title: `No new completed tasks after ${Ko / 1e3} seconds.`, timeout: Ko }),
    l = new Date().getTime(),
    p = 1e3 * 60 * 8;
  for (;;) {
    let d = new Date().getTime();
    d - l > p &&
      ((l = d),
      Dd.note({
        title: 'Distributed Execution In Progress...',
        bodyLines: [`Command: ${wi()} is still executing.`, `See the in progress run at: ${s}/runs/${i}`],
      }));
    try {
      ie && Dd.note({ title: 'Waiting...' });
      let x = await t.statusV2(i, o);
      ie &&
        Dd.note({
          title: 'Status update',
          bodyLines: [
            `executionId: ${i}`,
            `executionStatus: ${x.executionStatus}`,
            `number of completed tasks: ${x.completedTasks.length}`,
            `error: ${x.criticalErrorMessage}`,
          ],
        }),
        x.criticalErrorMessage &&
          (Dd.error({ title: 'Distributed Execution Terminated', bodyLines: ['Error:', x.criticalErrorMessage] }),
          process.exit(1)),
        x.updatedAt || (await wt(5e3)),
        (o = x.updatedAt),
        u(x.completedTasks.length);
      for (let b of x.completedTasks) c[b.taskId] || (await Ld(e, n, b, r), (c[b.taskId] = !0));
      if (x.executionStatus === 'COMPLETED')
        return { commandStatus: x.commandStatus, runUrl: x.runUrl, executionId: i };
    } catch (x) {
      console.log(x);
    }
  }
}
var Dd,
  VP = te(() => {
    'use strict';
    cl();
    Le();
    Pn();
    e0();
    ({ output: Dd } = Ae());
  });
var r0 = {};
Ft(r0, { nxCloudDistributedV2TasksRunner: () => LW });
async function DW(t, e, i, n, r, s, o, c, u, l, p, d, x, b) {
  let g = await vo(),
    { executionId: y, showDteTerminalOutput: h } = await e.startV2(FP(r, s, o, c, l, u, i, p, d, g, x, b));
  return (
    Fd.note({
      title: 'Distributed Execution Started',
      bodyLines: [`Command "${wi()}" is being executed.`, `View the progress of your run at ${t}/runs/${y}`],
    }),
    await zP(e, n, y, Object.values(u.tasks), h, t)
  );
}
var Fd,
  PW,
  Que,
  LW,
  s0 = te(() => {
    'use strict';
    pd();
    al();
    Le();
    $i();
    Vg();
    dd();
    Ks();
    So();
    Xs();
    yo();
    Pd();
    Nd();
    GP();
    VP();
    ({ output: Fd } = Ae()),
      ({ cacheDirectory: PW, workspaceDataDirectory: Que } = ri()),
      (LW = async (t, e, i) => {
        var y;
        e.skipNxCache &&
          Fd.warn({
            title: '--skip-nx-cache is ignored when using distributed tasks execution (DTE).',
            bodyLine: ['DTE needs the cache to share files between agents.'],
          }),
          (e.lifeCycle = new rc());
        let { nxJson: n, nxCloudOptions: r } = vt('default'),
          s = process.env.NX_CLOUD_API || r.url || 'https://cloud.nx.app',
          o = It(),
          c = Ct(),
          u = At(),
          l = kt(),
          p = Qt();
        rn(c, u) || (sn(), process.exit(1));
        let d = new Ci(Fi || e.encryptionKey),
          x = new Si(e),
          b = new zn(new Ai(d, x, e, 'dte-main'), PW),
          g = new ys(e);
        kd(g, o, c, u, l);
        try {
          let h = await DW(
            s,
            g,
            e,
            b,
            o,
            c,
            u,
            l,
            Ad(i, t, e),
            Ya(i.projectGraph),
            p,
            Id(i),
            wp(i.projectGraph.nodes, t),
            (y = i == null ? void 0 : i.nxArgs) == null ? void 0 : y.nxBail
          );
          Fd.note({
            title: 'Distributed Execution Completed',
            bodyLines: [`Command "${wi()}" is now finished.`, 'View the report below to see details about your tasks.'],
          }),
            await HP(g, h.executionId, c, s),
            process.exit(h.commandStatus);
        } catch (h) {
          let v = [h.message];
          h.bodyLines && v.push(h.bodyLines), Fd.error({ title: 'Unable to complete a run.', bodyLines: v });
          try {
            await g.completeRunGroupWithError(o, c, u, l, `Main job terminated with an error: "${h.message}"`);
          } finally {
            process.exit(1);
          }
        }
      });
  });
var $P = {};
Ft($P, { default: () => zW });
function MW(t, e, i) {
  let { from: n } = Wv(),
    { switchMap: r } = CP();
  return n(_o(e)).pipe(
    r((s) =>
      s.data.enabled
        ? process.env.NX_CLOUD_DTE_V1 === 'true'
          ? (n0(), Ke(i0)).nxCloudDistributedTasksRunner(t, e, i)
          : (s0(), Ke(r0)).nxCloudDistributedV2TasksRunner(t, e, i)
        : (Sr.warn({
            title: 'Nx Cloud: Workspace Disabled',
            bodyLines: [
              'This run and following runs will not use distributed task execution until',
              'the outstanding balance is paid or additional coupons are added for this',
              'workspace. If you believe you are receiving this message in error, please',
              'contact support at cloud-support@nrwl.io.',
              '',
              'Execution will now continue using this machine only.',
            ],
          }),
          (process.env.NX_INVOKED_BY_RUNNER = 'true'),
          Ju(t, e, i))
    )
  );
}
async function UW(t, e, i) {
  return (await _o(e)).data.enabled
    ? process.env.NX_CLOUD_DTE_V1 === 'true'
      ? (n0(), Ke(i0)).nxCloudDistributedTasksRunner(t, e, i)
      : (s0(), Ke(r0)).nxCloudDistributedV2TasksRunner(t, e, i)
    : (Sr.warn({
        title: 'Nx Cloud: Workspace Disabled',
        bodyLines: [
          'This run and following runs will not use distributed task execution until',
          'the outstanding balance is paid.',
          '',
          'If you believe you are receiving this message in error, please',
          'contact support at cloud-support@nrwl.io.',
          '',
          'Execution will now continue using this machine only.',
        ],
      }),
      (process.env.NX_INVOKED_BY_RUNNER = 'true'),
      Ju(t, e, i));
}
function qW(t, e) {
  let i = e.cacheableOperations || [];
  return t.some((n) => a0(n, { cacheableOperations: i }));
}
function BW(t, e) {
  let i = e.cacheableOperations || [];
  for (let n of t)
    a0(n, { cacheableOperations: i }) ||
      (Sr.error({
        title: 'Distributed task execution only works for cacheable targets',
        bodyLines: [
          `Target '${n.target.project}:${n.target.target}' cannot be executed.`,
          'To be able to replay the output of the target, distributed task execution only supports cacheable targets.',
          `You can verify that '${n.target.target}' is part of the list of cacheable targets in the 'nx.json' file.`,
          'You can invoke this command without distribution by doing "NX_CLOUD_DISTRIBUTED_EXECUTION=false nx ...".',
        ],
      }),
      (n.status = 'NOT_EXECUTABLE'));
}
function HW(t, e) {
  let i = e.cacheableOperations || [];
  for (let n of t)
    a0(n, { cacheableOperations: i }) ||
      (Sr.error({
        title: 'Distributed task execution only works for cacheable targets',
        bodyLines: [
          `Target ${n.target.project}:${n.target.target} cannot be executed.`,
          'To be able to replay the output of the target, distributed task execution only supports cacheable targets.',
          `You can still invoke "nx ${n.target.target} ${n.target.project}" from within a cacheable target when using "nx:run-commands".`,
        ],
      }),
      process.exit(jr));
}
function GW(t, e = {}) {
  if (!e) return;
  let i = (o) => {
      var c, u, l, p, d, x, b;
      return (b =
        (x =
          (d =
            (p =
              (l = (u = (c = e.projectGraph) == null ? void 0 : c.nodes) == null ? void 0 : u[o.target.project]) == null
                ? void 0
                : l.data) == null
              ? void 0
              : p.targets) == null
            ? void 0
            : d[o.target.target]) == null
          ? void 0
          : x.metadata) == null
        ? void 0
        : b.nonAtomizedTarget;
    },
    n = Object.values(t).filter((o) => i(o) !== void 0);
  if (n.length === 0) return;
  let r = n.map((o) => `"${i(o)}"`).filter((o, c, u) => u.indexOf(o) === c),
    s = [
      `Please enable Nx Agents or use the slower ${r.join(',')} task${r.length > 1 ? 's' : ''}.`,
      'Learn more at https://nx.dev/ci/features/split-e2e-tasks#nx-cloud-is-required-to-run-atomized-tasks',
    ];
  n.length === 1
    ? Sr.error({ title: `The ${n[0].id} task should only be run with Nx Agents.`, bodyLines: [...s] })
    : Sr.error({
        title: 'The following tasks should only be run with Nx Agents:',
        bodyLines: [...n.map((o) => `  - ${o.id}`), '', ...s],
      }),
    process.exit(1);
}
var Sr,
  o0,
  FW,
  a0,
  jW,
  zW,
  WP = te(() => {
    'use strict';
    vp();
    JN();
    rP();
    Cd();
    Le();
    Rd();
    ({ output: Sr } = Ae()),
      ({ tasksRunner: o0, runnerReturnsPromise: FW, isCacheableTask: a0 } = ri()),
      (jW = async (t, e, i = {}) => {
        let n = i.nxArgs || {},
          r = !Zn && !e.accessToken && !e.nxCloudId,
          s = n.cloud === !1 || vS;
        if (r || s || e.skipNxCache)
          return r
            ? (Sr.warn({
                title: 'Unable to authenticate with Nx Cloud',
                bodyLines: [
                  'Nx will continue running, but nothing will be written or read from the remote cache.',
                  'If you wish to use Nx Cloud, please connect your workspace to Nx Cloud to define a valid Nx Cloud ID.',
                  'If you are in a CI context, please set the NX_CLOUD_ACCESS_TOKEN environment variable or define an access token in your nx.json.',
                ],
              }),
              o0(t, e, i))
            : (s &&
                Sr.warn({
                  title: 'Nx Cloud manually disabled',
                  bodyLines: [
                    'Nx will continue running, but nothing will be written or read from the remote cache.',
                    'Run details will also not be available in the Nx Cloud UI.',
                    '',
                    "If this wasn't intentional, check for the NX_NO_CLOUD environment variable, the --no-cloud flag",
                  ],
                }),
              e.skipNxCache &&
                Sr.warn({
                  title: '--skip-nx-cache disables the connection to Nx Cloud for the current run.',
                  bodyLines: ['The remote cache will not be read from or written to during this run.'],
                }),
              o0(t, e, i));
        if (ES()) return qW(t, e) ? Ju(t, e, i, !0) : o0(t, e, i);
        if (
          (!Zt(process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID) && !Ov(n.dte, n.useAgents) && GW(t, i),
          Zt(process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID))
        )
          HW(t, e);
        else {
          let o = new Gr(e);
          await Tv(o);
        }
        return Ov(n.dte, n.useAgents) && !Zt(process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID)
          ? (BW(t, e), FW ? UW(t, e, i) : MW(t, e, i))
          : ((process.env.NX_INVOKED_BY_RUNNER = 'true'), Ju(t, e, i));
      });
    zW = jW;
  });
var c0 = {};
Ft(c0, { cleanUpAgents: () => WW });
async function WW() {
  let t = `${$W}/lockfiles`;
  return (
    ie && VW.note({ title: 'Cleaning up agent metadata for this workspace.' }),
    (0, KP.rm)(t, { recursive: !0, force: !0 }, (e) => {
      if (e) throw e;
    })
  );
}
var KP,
  VW,
  $W,
  u0 = te(() => {
    'use strict';
    KP = require('fs');
    Le();
    ({ output: VW } = Ae()), ({ cacheDirectory: $W } = ri());
  });
function XP(t) {
  return t === 'default' || t === null || t === void 0;
}
function KW(t, e) {
  return XP(t) && XP(e) ? !0 : t === e;
}
function jd(t, e) {
  KW(t, e) ||
    (console.error('[Nx Cloud] Task runner configuration must match between agents and main jobs.'),
    console.error('[Nx Cloud] Agent is using configuration:', t),
    console.error('[Nx Cloud] Main job is using configuration:', e),
    console.error(
      '[Nx Cloud] To set runner configurations, use the `--runner` argument, the NX_TASKS_RUNNER env variable, or the NX_RUNNER env variable on your commands.'
    ),
    process.exit(1));
}
function sc(t) {
  for (let e of t) if (e.includes('--runner=')) return e.slice(9);
  return null;
}
var oc = te(() => {
  'use strict';
});
var l0 = {};
Ft(l0, { runCommandAndStoreInCloud: () => YW });
async function YW() {
  var D, z, H;
  let t = sc(process.argv) ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? 'default',
    { nxCloudOptions: e } = vt(t),
    i = zt(e),
    n = new ys(e),
    r = new ms(e.maskedProperties),
    s = It(),
    o = Ct(),
    c = At(),
    u = kt(),
    l = JW(process.argv),
    [p, ...d] = l,
    x = new Date().toISOString(),
    { statusCode: b, terminalOutput: g } = await ZW(p, d),
    y = new Date().toISOString(),
    h = Fi || e.encryptionKey,
    v = new Ci(h),
    C = new Si(e),
    _ = new Ai(v, C, e, 'record-output'),
    m = {
      statusCode: b,
      terminalOutput: g,
      userCommandAndArgsString: l.join(' '),
      startTime: x,
      endTime: y,
      branch: s,
      runGroup: o,
      ciExecutionId: c,
      ciExecutionEnv: u,
      hash: `record-output-${QP.default.v4()}`,
      artifactId: null,
      uploadedToStorage: !1,
      terminalOutputUploadedToFileStorage: !1,
    },
    O = await eK(i, m);
  m.artifactId = (D = O[m.hash]) == null ? void 0 : D.artifactId;
  let N = (H = (z = O[m.hash]) == null ? void 0 : z.terminalOutputUrls) == null ? void 0 : H.put;
  if (N)
    try {
      await tK(_, m.hash, g, b, N), (m.uploadedToStorage = !0), (m.terminalOutputUploadedToFileStorage = !0);
    } catch (F) {
      ac.error({ title: 'Failed to store terminal output to file storage.', bodyLines: [F.message] });
    }
  await iK(i, r, e, m, n), process.exit(b);
}
function JW(t) {
  let e = t.findIndex((n) => n === 'record') + 1,
    i;
  if (e < process.argv.length) {
    let n = process.argv[e] === '--' ? 1 : 0;
    i = process.argv.slice(e + n);
  } else console.log('Invalid command. Use `nx-cloud record [my command] [my arg1] [my arg...]`'), process.exit(1);
  return i;
}
function ZW(t, e) {
  return new Promise((i, n) => {
    try {
      let r = JP.spawn(t, e, { stdio: ['inherit', 'pipe', 'pipe', 'ipc'] }),
        s = [];
      r.stdout.on('data', (o) => {
        process.stdout.write(o), s.push(o.toString());
      }),
        r.stderr.on('data', (o) => {
          process.stderr.write(o), s.push(o.toString());
        }),
        r.on('exit', (o, c) => {
          let u = o ?? rK(c || ''),
            l = s.join('');
          i({ statusCode: u, terminalOutput: l });
        });
    } catch (r) {
      n(r);
    }
  });
}
function QW(t, e) {
  let i = t.obfuscate(e.terminalOutput),
    n =
      i.length > YP
        ? `TRUNCATED

${i.slice(i.length - YP)}`
        : i;
  return {
    taskId: 'nx-cloud-tasks-runner:record-command',
    target: 'record-command',
    projectName: 'nx-cloud-tasks-runner',
    hash: e.hash,
    startTime: e.startTime,
    endTime: e.endTime,
    hashDetails: {},
    params: e.userCommandAndArgsString,
    cacheStatus: 'n/a',
    status: e.statusCode,
    artifactId: e.artifactId,
    uploadedToStorage: e.uploadedToStorage,
    terminalOutput: n,
    terminalOutputUploadedToFileStorage: e.terminalOutputUploadedToFileStorage,
  };
}
async function eK(t, e) {
  let i = {
    branch: e.branch,
    runGroup: e.runGroup,
    ciExecutionId: e.ciExecutionId,
    ciExecutionEnv: e.ciExecutionEnv,
    vcsContext: qi(),
    machineInfo: Hs(),
    hashes: [e.hash],
    distributedExecutionId: null,
  };
  try {
    return (await tt(() => t.post('/nx-cloud/v2/runs/start', i))).data.artifacts;
  } catch (n) {
    return ac.error({ title: n.message }), {};
  }
}
async function tK(t, e, i, n, r) {
  let s = { remoteUrl: r, fileType: 'terminalOutput' };
  ie && ac.note({ title: 'Uploading terminal output to file storage' }),
    await t.storeV2(e, XW, s, i, n),
    ie && ac.note({ title: 'Successfully uploaded terminal output to file storage' });
}
async function iK(t, e, i, n, r) {
  let s = `nx-cloud record -- ${n.userCommandAndArgsString}`,
    o = {
      meta: { nxCloudVersion: '0.0.0' },
      tasks: [QW(e, n)],
      run: {
        command: s,
        startTime: n.startTime,
        endTime: n.endTime,
        branch: n.branch,
        runGroup: n.runGroup,
        sha: n.branch ? Qt() : void 0,
      },
      branch: n.branch,
      runGroup: n.runGroup,
      ciExecutionId: n.ciExecutionId,
      ciExecutionEnv: n.ciExecutionEnv,
      machineInfo: Hs(),
      vcsContext: qi(),
    },
    c = Buffer.from(JSON.stringify(o)),
    u = await (0, ZP.promisify)(eL.gzip)(c),
    l = await tt(() =>
      t.post('/nx-cloud/runs/end', u, {
        headers: { ...t.defaults.headers, 'Content-Encoding': 'gzip', 'Content-Type': 'application/octet-stream' },
      })
    );
  process.env.NX_CLOUD_SILENT_RECORD !== 'true' && nK(l.data.runUrl),
    n.statusCode !== 0 &&
      (n.ciExecutionId || n.runGroup) &&
      (await r.completeRunGroupWithError(n.branch, n.runGroup, n.ciExecutionId, n.ciExecutionEnv, null));
}
function nK(t) {
  ac.addVerticalSeparator(),
    ac.note({ title: 'Nx Cloud: Successfully recorded command output' }),
    Yo(`You can view or share your output by visiting ${t}`);
}
function rK(t) {
  return t === 'SIGHUP' ? 129 : t === 'SIGINT' ? 130 : t === 'SIGTERM' ? 143 : 128;
}
var JP,
  ZP,
  QP,
  eL,
  XW,
  ac,
  YP,
  p0 = te(() => {
    'use strict';
    (JP = je(require('child_process'))), (ZP = require('util')), (QP = je(Vu())), (eL = require('zlib'));
    mn();
    Le();
    $i();
    sa();
    Uc();
    oc();
    Ks();
    Xs();
    yo();
    Pd();
    od();
    ({ cacheDirectory: XW } = ri()), ({ output: ac } = Ae()), (YP = 2e5);
  });
function Md() {
  return process.env.NX_AGENT_NAME !== void 0
    ? process.env.NX_AGENT_NAME
    : process.env.CIRCLECI !== void 0 && process.env.CIRCLE_STAGE
    ? process.env.CIRCLE_STAGE
    : process.env.CIRCLECI !== void 0 && process.env.CIRCLE_JOB
    ? process.env.CIRCLE_JOB
    : `Agent ${Math.floor(Math.random() * 1e5)}`;
}
function Ud() {
  return process.env.NX_AGENT_LAUNCH_TEMPLATE ?? null;
}
function qd(t, e, i) {
  let n = `${sK}/lockfiles`,
    r = `${n}/${i}.lock`;
  (0, En.existsSync)(n) || (0, En.mkdirSync)(n, { recursive: !0 });
  let s = (0, En.readdirSync)(n);
  s.length &&
    (s.includes(`${i}.lock`) &&
      (tL.error({
        title: 'Duplicate Agent ID Detected',
        bodyLines: [
          'We have detected another agent with this ID running in this workspace. This should not happen.',
          '',
          'End all currently running agents, run "npx nx-cloud clean-up-agents", and try again.',
        ],
      }),
      process.exit(1)),
    tL.warn({
      title: 'Other Nx Cloud Agents Detected',
      bodyLines: [
        'We have detected other agents running in this workspace. This can cause unexpected behavior.',
        '',
        'This can also be a false positive caused by agents that did not shut down correctly.',
        'If you believe this is the case, run "npx nx-cloud clean-up-agents".',
      ],
    })),
    (0, En.writeFileSync)(r, ''),
    process.on('exit', (o) => {
      f0(r, o);
    }),
    process.on('SIGTERM', async () => {
      await t.completeRunGroupWithError('Agent was terminated via SIGTERM'), f0(r, 1);
    }),
    process.on('SIGINT', async () => {
      await t.completeRunGroupWithError('Agent was terminated via SIGINT'), f0(r, 1);
    });
}
function f0(t, e) {
  (0, En.existsSync)(t) && ((0, En.unlinkSync)(t), process.exit(e));
}
var En,
  tL,
  sK,
  d0 = te(() => {
    'use strict';
    (En = require('fs')), ({ output: tL, cacheDirectory: sK } = Ae());
  });
var iL,
  cc,
  h0 = te(() => {
    'use strict';
    mn();
    Le();
    ({ output: iL } = Ae()),
      (cc = class {
        constructor(e, i, n, r, s, o, c) {
          this.branch = i;
          this.runGroup = n;
          this.ciExecutionId = r;
          this.ciExecutionEnv = s;
          this.agentName = o;
          this.agentLaunchTemplate = c;
          this.apiAxiosInstance = zt(e, null, 6e4);
        }
        async tasks(e, i, n, r) {
          try {
            return (
              await tt(() =>
                this.apiAxiosInstance.post('/nx-cloud/executions/tasks', {
                  runGroup: this.runGroup,
                  ciExecutionId: this.ciExecutionId,
                  ciExecutionEnv: this.ciExecutionEnv,
                  agentName: this.agentName,
                  executionId: e,
                  statusCode: i,
                  completedTasks: n,
                  targets: r,
                  clientInstanceId: process.env.NX_CLOUD_CLIENT_INSTANCE_ID,
                })
              )
            ).data;
          } catch (s) {
            throw s;
          }
        }
        async tasksV2(e, i, n, r, s) {
          return (
            await tt(() =>
              this.apiAxiosInstance.post('/nx-cloud/v2/executions/tasks', {
                runGroup: this.runGroup,
                ciExecutionId: this.ciExecutionId,
                ciExecutionEnv: this.ciExecutionEnv,
                agentName: this.agentName,
                agentLaunchTemplate: this.agentLaunchTemplate,
                executionId: e,
                statusCode: i,
                completedTasks: n,
                targets: s,
                forceDownloadAllArtifacts: r,
                clientInstanceId: process.env.NX_CLOUD_CLIENT_INSTANCE_ID,
              })
            )
          ).data;
        }
        async completeRunGroupWithError(e) {
          ie &&
            iL.note({
              title: 'Completing with an error',
              bodyLines: [
                `ciExecutionId: ${this.ciExecutionId}`,
                `ciExecutionEnv: ${this.ciExecutionEnv}`,
                `runGroup: ${this.runGroup}`,
                `error: ${e}`,
              ],
            });
          try {
            let i = await tt(() =>
              this.apiAxiosInstance.post('/nx-cloud/executions/complete-run-group', {
                branch: this.branch,
                runGroup: this.runGroup,
                ciExecutionId: this.ciExecutionId,
                ciExecutionEnv: this.ciExecutionEnv,
                agentName: this.agentName,
                criticalErrorMessage: e,
              })
            );
            ie && iL.note({ title: 'Completed run group with an error' });
          } catch (i) {
            console.error(i);
          }
        }
      });
  });
async function Bd(t, e, i) {
  let n = await oK(t);
  return async (r, s, o, c) => {
    jd(i, c),
      (process.env.NX_CACHE_FAILURES = 'true'),
      (process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID = r),
      (process.env.NX_STREAM_OUTPUT = 'true'),
      (process.env.NX_PREFIX_OUTPUT = 'true');
    let u = await n.invoke({ tasks: s, parallel: o });
    if (process.env.NX_CLOUD_CRITICAL_ERROR === 'true') {
      let p = TS();
      throw new Error(p);
    }
    return {
      completedTasks: Object.values(u.taskGraph.tasks).map((p) => {
        var d, x;
        return {
          taskId: p.id,
          hash: p.hash,
          code: ((x = (d = u.taskResults) == null ? void 0 : d[p.id]) == null ? void 0 : x.code) ?? aK(e, p.hash),
        };
      }),
      completedStatusCode: u.status,
    };
  };
}
function aK(t, e) {
  try {
    let i = (0, nL.readFileSync)((0, rL.join)(t, e, 'code'), { encoding: 'utf-8' });
    return Number(i);
  } catch (i) {
    throw (console.error(`Unable to read status code for hash ${e} from cache directory ${t}`), i);
  }
}
var nL,
  rL,
  oK,
  m0 = te(() => {
    'use strict';
    (nL = require('fs')), (rL = require('path'));
    Le();
    oc();
    ({ initTasksRunner: oK } = ri());
  });
async function zd(t) {
  let e = uK();
  return async function (n, r, s, o) {
    jd(t, o);
    let c = 0,
      u = [];
    for (let l of cK(r)) {
      let p = l.configuration ? `--configuration=${l.configuration}` : '',
        d = s > 1 ? ` --parallel --max-parallel=${s}` : '',
        x = (g) => (g == null ? '' : `--runner=${g}`),
        b = `npx nx run-many --target=${l.target} ${p} --projects=${l.projects.join(',')} ${l.params}${d} ${x(o)}`;
      ie && oL.note({ title: `Executing: '${b}'` });
      try {
        (0, sL.execSync)(b, {
          stdio: ['ignore', 'inherit', 'inherit'],
          env: {
            ...process.env,
            NX_CACHE_FAILURES: 'true',
            NX_CLOUD_DISTRIBUTED_EXECUTION_ID: n,
            NX_STREAM_OUTPUT: 'true',
            NX_PREFIX_OUTPUT: 'true',
            NX_CLOUD_INVOKED_WITH_RUN_MANY: 'true',
          },
        }),
          u.push(...e(n));
      } catch (g) {
        if (g.status === jr) throw ((g.message = lK() ?? g.message), g);
        (c = 1), u.push(...e(n));
      }
    }
    return { completedStatusCode: c, completedTasks: u };
  };
}
function cK(t) {
  let e = [];
  return (
    t.forEach((i) => {
      let n = e.find((r) => r.target === i.target.target && r.configuration === i.target.configuration);
      n
        ? n.projects.push(i.target.project)
        : e.push({
            target: i.target.target,
            projects: [i.target.project],
            params: i.overrides.__overrides_unparsed__ ?? [].join(' '),
            configuration: i.target.configuration,
          });
    }),
    e
  );
}
function uK() {
  return (t) => {
    let e = `Command execution failed (distributed task execution: ${t}). Tasks hashes haven't been recorded.`,
      i;
    try {
      let n = (0, Gd.join)(Hd, `tasks-hashes-${t}`);
      (i = JSON.parse((0, Ro.readFileSync)(n).toString())), (0, Ro.unlinkSync)(n);
    } catch {
      throw new Error(e);
    }
    if (i.length == 0) throw new Error(e);
    return i;
  };
}
function lK() {
  try {
    if ((0, Ro.existsSync)((0, Gd.join)(Hd, Dc))) return (0, Ro.readFileSync)((0, Gd.join)(Hd, Dc)).toString();
  } catch {
    ie && oL.note({ title: `Could not read critical error message from ${Hd}` });
  }
  return null;
}
var sL,
  Ro,
  Gd,
  oL,
  Hd,
  g0 = te(() => {
    'use strict';
    (sL = require('child_process')), (Ro = require('fs')), (Gd = require('path'));
    Le();
    oc();
    ({ output: oL } = Ae()), ({ cacheDirectory: Hd } = ri());
  });
function To(t) {
  if (
    ((t !== t.toLowerCase() && t !== t.toUpperCase()) || (t = t.toLowerCase()),
    t.indexOf('-') === -1 && t.indexOf('_') === -1)
  )
    return t;
  {
    let i = '',
      n = !1,
      r = t.match(/^-+/);
    for (let s = r ? r[0].length : 0; s < t.length; s++) {
      let o = t.charAt(s);
      n && ((n = !1), (o = o.toUpperCase())),
        s !== 0 && (o === '-' || o === '_') ? (n = !0) : o !== '-' && o !== '_' && (i += o);
    }
    return i;
  }
}
function Vd(t, e) {
  let i = t.toLowerCase();
  e = e || '-';
  let n = '';
  for (let r = 0; r < t.length; r++) {
    let s = i.charAt(r),
      o = t.charAt(r);
    s !== o && r > 0 ? (n += `${e}${i.charAt(r)}`) : (n += o);
  }
  return n;
}
function $d(t) {
  return t == null
    ? !1
    : typeof t == 'number' || /^0x[0-9a-f]+$/i.test(t)
    ? !0
    : /^0[^.]/.test(t)
    ? !1
    : /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(t);
}
var x0 = te(() => {
  'use strict';
});
function aL(t) {
  if (Array.isArray(t)) return t.map((o) => (typeof o != 'string' ? o + '' : o));
  t = t.trim();
  let e = 0,
    i = null,
    n = null,
    r = null,
    s = [];
  for (let o = 0; o < t.length; o++) {
    if (((i = n), (n = t.charAt(o)), n === ' ' && !r)) {
      i !== ' ' && e++;
      continue;
    }
    n === r ? (r = null) : (n === "'" || n === '"') && !r && (r = n), s[e] || (s[e] = ''), (s[e] += n);
  }
  return s;
}
var cL = te(() => {
  'use strict';
});
var on,
  uL = te(() => {
    'use strict';
    (function (t) {
      (t.BOOLEAN = 'boolean'), (t.STRING = 'string'), (t.NUMBER = 'number'), (t.ARRAY = 'array');
    })(on || (on = {}));
  });
function pK(t) {
  let e = [],
    i = Object.create(null),
    n = !0;
  for (
    Object.keys(t).forEach(function (r) {
      e.push([].concat(t[r], r));
    });
    n;

  ) {
    n = !1;
    for (let r = 0; r < e.length; r++)
      for (let s = r + 1; s < e.length; s++)
        if (
          e[r].filter(function (c) {
            return e[s].indexOf(c) !== -1;
          }).length
        ) {
          (e[r] = e[r].concat(e[s])), e.splice(s, 1), (n = !0);
          break;
        }
  }
  return (
    e.forEach(function (r) {
      r = r.filter(function (o, c, u) {
        return u.indexOf(o) === c;
      });
      let s = r.pop();
      s !== void 0 && typeof s == 'string' && (i[s] = r);
    }),
    i
  );
}
function y0(t) {
  return t !== void 0 ? t + 1 : 1;
}
function lL(t) {
  return t === '__proto__' ? '___proto___' : t;
}
function fK(t) {
  return typeof t == 'string' && (t[0] === "'" || t[0] === '"') && t[t.length - 1] === t[0]
    ? t.substring(1, t.length - 1)
    : t;
}
var Cr,
  Wd,
  pL = te(() => {
    'use strict';
    cL();
    uL();
    x0();
    Wd = class {
      constructor(e) {
        Cr = e;
      }
      parse(e, i) {
        let n = Object.assign(
            {
              alias: void 0,
              array: void 0,
              boolean: void 0,
              config: void 0,
              configObjects: void 0,
              configuration: void 0,
              coerce: void 0,
              count: void 0,
              default: void 0,
              envPrefix: void 0,
              narg: void 0,
              normalize: void 0,
              string: void 0,
              number: void 0,
              __: void 0,
              key: void 0,
            },
            i
          ),
          r = aL(e),
          s = typeof e == 'string',
          o = pK(Object.assign(Object.create(null), n.alias)),
          c = Object.assign(
            {
              'boolean-negation': !0,
              'camel-case-expansion': !0,
              'combine-arrays': !1,
              'dot-notation': !0,
              'duplicate-arguments-array': !0,
              'flatten-duplicate-arrays': !0,
              'greedy-arrays': !0,
              'halt-at-non-option': !1,
              'nargs-eats-options': !1,
              'negation-prefix': 'no-',
              'parse-numbers': !0,
              'parse-positional-numbers': !0,
              'populate--': !1,
              'set-placeholder-key': !1,
              'short-option-groups': !0,
              'strip-aliased': !1,
              'strip-dashed': !1,
              'unknown-options-as-args': !1,
            },
            n.configuration
          ),
          u = Object.assign(Object.create(null), n.default),
          l = n.configObjects || [],
          p = n.envPrefix,
          d = c['populate--'],
          x = d ? '--' : '_',
          b = Object.create(null),
          g = Object.create(null),
          y = n.__ || Cr.format,
          h = {
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: [],
          },
          v = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/,
          C = new RegExp('^--' + c['negation-prefix'] + '(.+)');
        []
          .concat(n.array || [])
          .filter(Boolean)
          .forEach(function (R) {
            let w = typeof R == 'object' ? R.key : R,
              A = Object.keys(R)
                .map(function (k) {
                  return { boolean: 'bools', string: 'strings', number: 'numbers' }[k];
                })
                .filter(Boolean)
                .pop();
            A && (h[A][w] = !0), (h.arrays[w] = !0), h.keys.push(w);
          }),
          []
            .concat(n.boolean || [])
            .filter(Boolean)
            .forEach(function (R) {
              (h.bools[R] = !0), h.keys.push(R);
            }),
          []
            .concat(n.string || [])
            .filter(Boolean)
            .forEach(function (R) {
              (h.strings[R] = !0), h.keys.push(R);
            }),
          []
            .concat(n.number || [])
            .filter(Boolean)
            .forEach(function (R) {
              (h.numbers[R] = !0), h.keys.push(R);
            }),
          []
            .concat(n.count || [])
            .filter(Boolean)
            .forEach(function (R) {
              (h.counts[R] = !0), h.keys.push(R);
            }),
          []
            .concat(n.normalize || [])
            .filter(Boolean)
            .forEach(function (R) {
              (h.normalize[R] = !0), h.keys.push(R);
            }),
          typeof n.narg == 'object' &&
            Object.entries(n.narg).forEach(([R, w]) => {
              typeof w == 'number' && ((h.nargs[R] = w), h.keys.push(R));
            }),
          typeof n.coerce == 'object' &&
            Object.entries(n.coerce).forEach(([R, w]) => {
              typeof w == 'function' && ((h.coercions[R] = w), h.keys.push(R));
            }),
          typeof n.config < 'u' &&
            (Array.isArray(n.config) || typeof n.config == 'string'
              ? []
                  .concat(n.config)
                  .filter(Boolean)
                  .forEach(function (R) {
                    h.configs[R] = !0;
                  })
              : typeof n.config == 'object' &&
                Object.entries(n.config).forEach(([R, w]) => {
                  (typeof w == 'boolean' || typeof w == 'function') && (h.configs[R] = w);
                })),
          oe(n.key, o, n.default, h.arrays),
          Object.keys(u).forEach(function (R) {
            (h.aliases[R] || []).forEach(function (w) {
              u[w] = u[R];
            });
          });
        let _ = null;
        ze();
        let m = [],
          O = Object.assign(Object.create(null), { _: [] }),
          N = {};
        for (let R = 0; R < r.length; R++) {
          let w = r[R],
            A = w.replace(/^-{3,}/, '---'),
            k,
            S,
            M,
            j,
            U,
            re;
          if (w !== '--' && /^-/.test(w) && ce(w)) D(w);
          else if (A.match(/^---+(=|$)/)) {
            D(w);
            continue;
          } else if (w.match(/^--.+=/) || (!c['short-option-groups'] && w.match(/^-.+=/)))
            (j = w.match(/^--?([^=]+)=([\s\S]*)$/)),
              j !== null &&
                Array.isArray(j) &&
                j.length >= 3 &&
                (I(j[1], h.arrays)
                  ? (R = H(R, j[1], r, j[2]))
                  : I(j[1], h.nargs) !== !1
                  ? (R = z(R, j[1], r, j[2]))
                  : F(j[1], j[2], !0));
          else if (w.match(C) && c['boolean-negation'])
            (j = w.match(C)),
              j !== null && Array.isArray(j) && j.length >= 2 && ((S = j[1]), F(S, I(S, h.arrays) ? [!1] : !1));
          else if (w.match(/^--.+/) || (!c['short-option-groups'] && w.match(/^-[^-]+/)))
            (j = w.match(/^--?(.+)/)),
              j !== null &&
                Array.isArray(j) &&
                j.length >= 2 &&
                ((S = j[1]),
                I(S, h.arrays)
                  ? (R = H(R, S, r))
                  : I(S, h.nargs) !== !1
                  ? (R = z(R, S, r))
                  : ((U = r[R + 1]),
                    (U !== void 0 && (!U.match(/^-/) || U.match(v)) && !I(S, h.bools) && !I(S, h.counts)) ||
                    /^(true|false)$/.test(U)
                      ? (F(S, U), R++)
                      : F(S, ve(S))));
          else if (w.match(/^-.\..+=/))
            (j = w.match(/^-([^=]+)=([\s\S]*)$/)), j !== null && Array.isArray(j) && j.length >= 3 && F(j[1], j[2]);
          else if (w.match(/^-.\..+/) && !w.match(v))
            (U = r[R + 1]),
              (j = w.match(/^-(.\..+)/)),
              j !== null &&
                Array.isArray(j) &&
                j.length >= 2 &&
                ((S = j[1]),
                U !== void 0 && !U.match(/^-/) && !I(S, h.bools) && !I(S, h.counts) ? (F(S, U), R++) : F(S, ve(S)));
          else if (w.match(/^-[^-]+/) && !w.match(v)) {
            (M = w.slice(1, -1).split('')), (k = !1);
            for (let se = 0; se < M.length; se++) {
              if (((U = w.slice(se + 2)), M[se + 1] && M[se + 1] === '=')) {
                (re = w.slice(se + 3)),
                  (S = M[se]),
                  I(S, h.arrays) ? (R = H(R, S, r, re)) : I(S, h.nargs) !== !1 ? (R = z(R, S, r, re)) : F(S, re),
                  (k = !0);
                break;
              }
              if (U === '-') {
                F(M[se], U);
                continue;
              }
              if (/[A-Za-z]/.test(M[se]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(U) && I(U, h.bools) === !1) {
                F(M[se], U), (k = !0);
                break;
              }
              if (M[se + 1] && M[se + 1].match(/\W/)) {
                F(M[se], U), (k = !0);
                break;
              } else F(M[se], ve(M[se]));
            }
            (S = w.slice(-1)[0]),
              !k &&
                S !== '-' &&
                (I(S, h.arrays)
                  ? (R = H(R, S, r))
                  : I(S, h.nargs) !== !1
                  ? (R = z(R, S, r))
                  : ((U = r[R + 1]),
                    (U !== void 0 && (!/^(-|--)[^-]/.test(U) || U.match(v)) && !I(S, h.bools) && !I(S, h.counts)) ||
                    /^(true|false)$/.test(U)
                      ? (F(S, U), R++)
                      : F(S, ve(S))));
          } else if (w.match(/^-[0-9]$/) && w.match(v) && I(w.slice(1), h.bools)) (S = w.slice(1)), F(S, ve(S));
          else if (w === '--') {
            m = r.slice(R + 1);
            break;
          } else if (c['halt-at-non-option']) {
            m = r.slice(R);
            break;
          } else D(w);
        }
        q(O, !0),
          q(O, !1),
          V(O),
          K(),
          xe(O, h.aliases, u, !0),
          B(O),
          c['set-placeholder-key'] && ee(O),
          Object.keys(h.counts).forEach(function (R) {
            de(O, R.split('.')) || F(R, 0);
          }),
          d && m.length && (O[x] = []),
          m.forEach(function (R) {
            O[x].push(R);
          }),
          c['camel-case-expansion'] &&
            c['strip-dashed'] &&
            Object.keys(O)
              .filter((R) => R !== '--' && R.includes('-'))
              .forEach((R) => {
                delete O[R];
              }),
          c['strip-aliased'] &&
            [].concat(...Object.keys(o).map((R) => o[R])).forEach((R) => {
              c['camel-case-expansion'] &&
                R.includes('-') &&
                delete O[
                  R.split('.')
                    .map((w) => To(w))
                    .join('.')
                ],
                delete O[R];
            });
        function D(R) {
          let w = le('_', R);
          (typeof w == 'string' || typeof w == 'number') && O._.push(w);
        }
        function z(R, w, A, k) {
          let S,
            M = I(w, h.nargs);
          if (((M = typeof M != 'number' || isNaN(M) ? 1 : M), M === 0))
            return ke(k) || (_ = Error(y('Argument unexpected for: %s', w))), F(w, ve(w)), R;
          let j = ke(k) ? 0 : 1;
          if (c['nargs-eats-options'])
            A.length - (R + 1) + j < M && (_ = Error(y('Not enough arguments following: %s', w))), (j = M);
          else {
            for (S = R + 1; S < A.length && (!A[S].match(/^-[^0-9]/) || A[S].match(v) || ce(A[S])); S++) j++;
            j < M && (_ = Error(y('Not enough arguments following: %s', w)));
          }
          let U = Math.min(j, M);
          for (!ke(k) && U > 0 && (F(w, k), U--), S = R + 1; S < U + R + 1; S++) F(w, A[S]);
          return R + U;
        }
        function H(R, w, A, k) {
          let S = [],
            M = k || A[R + 1],
            j = I(w, h.nargs);
          if (I(w, h.bools) && !/^(true|false)$/.test(M)) S.push(!0);
          else if (ke(M) || (ke(k) && /^-/.test(M) && !v.test(M) && !ce(M))) {
            if (u[w] !== void 0) {
              let U = u[w];
              S = Array.isArray(U) ? U : [U];
            }
          } else {
            ke(k) || S.push(pe(w, k, !0));
            for (
              let U = R + 1;
              U < A.length &&
              !(
                (!c['greedy-arrays'] && S.length > 0) ||
                (j && typeof j == 'number' && S.length >= j) ||
                ((M = A[U]), /^-/.test(M) && !v.test(M) && !ce(M))
              );
              U++
            )
              (R = U), S.push(pe(w, M, s));
          }
          return (
            typeof j == 'number' &&
              ((j && S.length < j) || (isNaN(j) && S.length === 0)) &&
              (_ = Error(y('Not enough arguments following: %s', w))),
            F(w, S),
            R
          );
        }
        function F(R, w, A = s) {
          if (/-/.test(R) && c['camel-case-expansion']) {
            let M = R.split('.')
              .map(function (j) {
                return To(j);
              })
              .join('.');
            ne(R, M);
          }
          let k = pe(R, w, A),
            S = R.split('.');
          Z(O, S, k),
            h.aliases[R] &&
              h.aliases[R].forEach(function (M) {
                let j = M.split('.');
                Z(O, j, k);
              }),
            S.length > 1 &&
              c['dot-notation'] &&
              (h.aliases[S[0]] || []).forEach(function (M) {
                let j = M.split('.'),
                  U = [].concat(S);
                U.shift(), (j = j.concat(U)), (h.aliases[R] || []).includes(j.join('.')) || Z(O, j, k);
              }),
            I(R, h.normalize) &&
              !I(R, h.arrays) &&
              [R].concat(h.aliases[R] || []).forEach(function (j) {
                Object.defineProperty(N, j, {
                  enumerable: !0,
                  get() {
                    return w;
                  },
                  set(U) {
                    w = typeof U == 'string' ? Cr.normalize(U) : U;
                  },
                });
              });
        }
        function ne(R, w) {
          (h.aliases[R] && h.aliases[R].length) || ((h.aliases[R] = [w]), (b[w] = !0)),
            (h.aliases[w] && h.aliases[w].length) || ne(w, R);
        }
        function pe(R, w, A) {
          A && (w = fK(w)), (I(R, h.bools) || I(R, h.counts)) && typeof w == 'string' && (w = w === 'true');
          let k = Array.isArray(w)
            ? w.map(function (S) {
                return le(R, S);
              })
            : le(R, w);
          return (
            I(R, h.counts) && (ke(k) || typeof k == 'boolean') && (k = y0()),
            I(R, h.normalize) &&
              I(R, h.arrays) &&
              (Array.isArray(w) ? (k = w.map((S) => Cr.normalize(S))) : (k = Cr.normalize(w))),
            k
          );
        }
        function le(R, w) {
          return (
            (!c['parse-positional-numbers'] && R === '_') ||
              (!I(R, h.strings) &&
                !I(R, h.bools) &&
                !Array.isArray(w) &&
                (($d(w) && c['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat(`${w}`)))) ||
                  (!ke(w) && I(R, h.numbers))) &&
                (w = Number(w))),
            w
          );
        }
        function V(R) {
          let w = Object.create(null);
          xe(w, h.aliases, u),
            Object.keys(h.configs).forEach(function (A) {
              let k = R[A] || w[A];
              if (k)
                try {
                  let S = null,
                    M = Cr.resolve(Cr.cwd(), k),
                    j = h.configs[A];
                  if (typeof j == 'function') {
                    try {
                      S = j(M);
                    } catch (U) {
                      S = U;
                    }
                    if (S instanceof Error) {
                      _ = S;
                      return;
                    }
                  } else S = Cr.require(M);
                  W(S);
                } catch (S) {
                  S.name === 'PermissionDenied' ? (_ = S) : R[A] && (_ = Error(y('Invalid JSON config file: %s', k)));
                }
            });
        }
        function W(R, w) {
          Object.keys(R).forEach(function (A) {
            let k = R[A],
              S = w ? w + '.' + A : A;
            typeof k == 'object' && k !== null && !Array.isArray(k) && c['dot-notation']
              ? W(k, S)
              : (!de(O, S.split('.')) || (I(S, h.arrays) && c['combine-arrays'])) && F(S, k);
          });
        }
        function K() {
          typeof l < 'u' &&
            l.forEach(function (R) {
              W(R);
            });
        }
        function q(R, w) {
          if (typeof p > 'u') return;
          let A = typeof p == 'string' ? p : '',
            k = Cr.env();
          Object.keys(k).forEach(function (S) {
            if (A === '' || S.lastIndexOf(A, 0) === 0) {
              let M = S.split('__').map(function (j, U) {
                return U === 0 && (j = j.substring(A.length)), To(j);
              });
              ((w && h.configs[M.join('.')]) || !w) && !de(R, M) && F(M.join('.'), k[S]);
            }
          });
        }
        function B(R) {
          let w,
            A = new Set();
          Object.keys(R).forEach(function (k) {
            if (!A.has(k) && ((w = I(k, h.coercions)), typeof w == 'function'))
              try {
                let S = le(k, w(R[k]));
                [].concat(h.aliases[k] || [], k).forEach((M) => {
                  A.add(M), (R[M] = S);
                });
              } catch (S) {
                _ = S;
              }
          });
        }
        function ee(R) {
          return (
            h.keys.forEach((w) => {
              ~w.indexOf('.') || (typeof R[w] > 'u' && (R[w] = void 0));
            }),
            R
          );
        }
        function xe(R, w, A, k = !1) {
          Object.keys(A).forEach(function (S) {
            de(R, S.split('.')) ||
              (Z(R, S.split('.'), A[S]),
              k && (g[S] = !0),
              (w[S] || []).forEach(function (M) {
                de(R, M.split('.')) || Z(R, M.split('.'), A[S]);
              }));
          });
        }
        function de(R, w) {
          let A = R;
          c['dot-notation'] || (w = [w.join('.')]),
            w.slice(0, -1).forEach(function (S) {
              A = A[S] || {};
            });
          let k = w[w.length - 1];
          return typeof A != 'object' ? !1 : k in A;
        }
        function Z(R, w, A) {
          let k = R;
          c['dot-notation'] || (w = [w.join('.')]),
            w.slice(0, -1).forEach(function (re) {
              (re = lL(re)),
                typeof k == 'object' && k[re] === void 0 && (k[re] = {}),
                typeof k[re] != 'object' || Array.isArray(k[re])
                  ? (Array.isArray(k[re]) ? k[re].push({}) : (k[re] = [k[re], {}]), (k = k[re][k[re].length - 1]))
                  : (k = k[re]);
            });
          let S = lL(w[w.length - 1]),
            M = I(w.join('.'), h.arrays),
            j = Array.isArray(A),
            U = c['duplicate-arguments-array'];
          !U &&
            I(S, h.nargs) &&
            ((U = !0),
            ((!ke(k[S]) && h.nargs[S] === 1) || (Array.isArray(k[S]) && k[S].length === h.nargs[S])) &&
              (k[S] = void 0)),
            A === y0()
              ? (k[S] = y0(k[S]))
              : Array.isArray(k[S])
              ? U && M && j
                ? (k[S] = c['flatten-duplicate-arrays']
                    ? k[S].concat(A)
                    : (Array.isArray(k[S][0]) ? k[S] : [k[S]]).concat([A]))
                : !U && !!M == !!j
                ? (k[S] = A)
                : (k[S] = k[S].concat([A]))
              : k[S] === void 0 && M
              ? (k[S] = j ? A : [A])
              : U && !(k[S] === void 0 || I(S, h.counts) || I(S, h.bools))
              ? (k[S] = [k[S], A])
              : (k[S] = A);
        }
        function oe(...R) {
          R.forEach(function (w) {
            Object.keys(w || {}).forEach(function (A) {
              h.aliases[A] ||
                ((h.aliases[A] = [].concat(o[A] || [])),
                h.aliases[A].concat(A).forEach(function (k) {
                  if (/-/.test(k) && c['camel-case-expansion']) {
                    let S = To(k);
                    S !== A && h.aliases[A].indexOf(S) === -1 && (h.aliases[A].push(S), (b[S] = !0));
                  }
                }),
                h.aliases[A].concat(A).forEach(function (k) {
                  if (k.length > 1 && /[A-Z]/.test(k) && c['camel-case-expansion']) {
                    let S = Vd(k, '-');
                    S !== A && h.aliases[A].indexOf(S) === -1 && (h.aliases[A].push(S), (b[S] = !0));
                  }
                }),
                h.aliases[A].forEach(function (k) {
                  h.aliases[k] = [A].concat(
                    h.aliases[A].filter(function (S) {
                      return k !== S;
                    })
                  );
                }));
            });
          });
        }
        function I(R, w) {
          let A = [].concat(h.aliases[R] || [], R),
            k = Object.keys(w),
            S = A.find((M) => k.includes(M));
          return S ? w[S] : !1;
        }
        function X(R) {
          let w = Object.keys(h);
          return [].concat(w.map((k) => h[k])).some(function (k) {
            return Array.isArray(k) ? k.includes(R) : k[R];
          });
        }
        function Q(R, ...w) {
          return [].concat(...w).some(function (k) {
            let S = R.match(k);
            return S && X(S[1]);
          });
        }
        function ae(R) {
          if (R.match(v) || !R.match(/^-[^-]+/)) return !1;
          let w = !0,
            A,
            k = R.slice(1).split('');
          for (let S = 0; S < k.length; S++) {
            if (((A = R.slice(S + 2)), !X(k[S]))) {
              w = !1;
              break;
            }
            if (
              (k[S + 1] && k[S + 1] === '=') ||
              A === '-' ||
              (/[A-Za-z]/.test(k[S]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(A)) ||
              (k[S + 1] && k[S + 1].match(/\W/))
            )
              break;
          }
          return w;
        }
        function ce(R) {
          return c['unknown-options-as-args'] && ye(R);
        }
        function ye(R) {
          return (
            (R = R.replace(/^-{3,}/, '--')),
            R.match(v) || ae(R)
              ? !1
              : !Q(
                  R,
                  /^-+([^=]+?)=[\s\S]*$/,
                  C,
                  /^-+([^=]+?)$/,
                  /^-+([^=]+?)-$/,
                  /^-+([^=]+?\d+)$/,
                  /^-+([^=]+?)\W+.*$/
                )
          );
        }
        function ve(R) {
          return !I(R, h.bools) && !I(R, h.counts) && `${R}` in u ? u[R] : Ce(Oe(R));
        }
        function Ce(R) {
          return { [on.BOOLEAN]: !0, [on.STRING]: '', [on.NUMBER]: void 0, [on.ARRAY]: [] }[R];
        }
        function Oe(R) {
          let w = on.BOOLEAN;
          return (
            I(R, h.strings)
              ? (w = on.STRING)
              : I(R, h.numbers)
              ? (w = on.NUMBER)
              : I(R, h.bools)
              ? (w = on.BOOLEAN)
              : I(R, h.arrays) && (w = on.ARRAY),
            w
          );
        }
        function ke(R) {
          return R === void 0;
        }
        function ze() {
          Object.keys(h.counts).find((R) =>
            I(R, h.arrays)
              ? ((_ = Error(y('Invalid configuration: %s, opts.count excludes opts.array.', R))), !0)
              : I(R, h.nargs)
              ? ((_ = Error(y('Invalid configuration: %s, opts.count excludes opts.narg.', R))), !0)
              : !1
          );
        }
        return {
          aliases: Object.assign({}, h.aliases),
          argv: Object.assign(N, O),
          configuration: c,
          defaulted: Object.assign({}, g),
          error: _,
          newAliases: Object.assign({}, b),
        };
      }
    };
  });
var hL,
  Kd,
  mL,
  b0,
  v0,
  w0,
  fL,
  dL,
  dK,
  gL,
  ll,
  vs,
  pl = te(() => {
    'use strict';
    (hL = require('util')), (Kd = require('path'));
    x0();
    pL();
    mL = require('fs');
    (fL =
      process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12),
      (dL =
        (v0 = (b0 = process == null ? void 0 : process.versions) === null || b0 === void 0 ? void 0 : b0.node) !==
          null && v0 !== void 0
          ? v0
          : (w0 = process == null ? void 0 : process.version) === null || w0 === void 0
          ? void 0
          : w0.slice(1));
    if (dL && Number(dL.match(/^([^.]+)/)[1]) < fL)
      throw Error(
        `yargs parser supports a minimum Node.js version of ${fL}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`
      );
    (dK = process ? process.env : {}),
      (gL = new Wd({
        cwd: process.cwd,
        env: () => dK,
        format: hL.format,
        normalize: Kd.normalize,
        resolve: Kd.resolve,
        require: (t) => {
          if (typeof require < 'u') return require(t);
          if (t.match(/\.json$/)) return JSON.parse((0, mL.readFileSync)(t, 'utf8'));
          throw Error('only .json config files are supported in ESM');
        },
      })),
      (ll = function (e, i) {
        return gL.parse(e.slice(), i).argv;
      });
    ll.detailed = function (t, e) {
      return gL.parse(t.slice(), e);
    };
    ll.camelCase = To;
    ll.decamelize = Vd;
    ll.looksLikeNumber = $d;
    vs = ll;
  });
async function xL(t, e, i, n, r) {
  let s = 0,
    o = null,
    c = bs({ title: `No new messages received after ${Wo / 1e3} seconds`, timeout: Wo }),
    u = [],
    l = new Date(),
    p = !1,
    d = {};
  for (;;) {
    if (
      (ie && fl.note({ title: `${t} fetching tasks...` }),
      (o = await e.tasks(o ? o.executionId : null, s, u, r)),
      ie &&
        fl.note({
          title: `${t} received an API Response`,
          bodyLines: [
            `completed: ${o.completed}`,
            `status: ${o.status}`,
            `retryDuring: ${o.retryDuring}`,
            `executionId: ${o.executionId}`,
            `number of tasks: ${o.tasks.length}`,
            `error: ${o.criticalErrorMessage}`,
            `maxParallel: ${o.maxParallel}`,
            `taskRunnerConfiguration: ${o.taskRunnerConfiguration}`,
          ],
        }),
      o.criticalErrorMessage &&
        (fl.error({ title: 'Distributed Execution Terminated', bodyLines: ['Error:', o.criticalErrorMessage] }),
        process.exit(1)),
      o != null &&
        o.retryDuring &&
        (o == null ? void 0 : o.retryDuring) !== 0 &&
        !p &&
        new Date().getTime() - l.getTime() > o.retryDuring)
    ) {
      await wt(2e4);
      continue;
    }
    if ((o == null ? void 0 : o.status) !== void 0) {
      if (o.status === 'RUN_GROUP_COMPLETED' || o.status === 'NO_FURTHER_TASKS_TO_RUN') return;
    } else if (o.completed) return;
    if ((c(o.tasks.map((g) => g.taskId).join('')), !o.executionId)) {
      ie && fl.note({ title: `${t} waiting...` }), await wt(5e3), (s = 0), (u = []);
      continue;
    }
    if (((p = !0), o.completedTasks))
      for (let g of o.completedTasks) {
        if (d[g.taskId]) continue;
        fl.note({ title: `${t} downloading artifacts for ${g.taskId} Hash: ${g.hash}}` });
        let y = [{ remoteUrl: g.url, fileType: 'artifact' }];
        g.terminalOutputUrl && y.push({ remoteUrl: g.terminalOutputUrl, fileType: 'terminalOutput' }),
          await i.retrieveAndExtract(g.hash, y),
          (d[g.taskId] = !0);
      }
    let x = o.tasks.map((g) => {
        let y = vs(g.params, { configuration: { 'camel-case-expansion': !1, 'dot-notation': !0 } }),
          h = qb(y);
        return (
          y._.length == 0 && delete y._,
          {
            id: g.taskId,
            target: { project: g.projectName, target: g.target, configuration: g.configuration },
            overrides: { ...y, __overrides_unparsed__: h },
            projectRoot: g.projectRoot,
            cache: g.cache,
            outputs: g.outputs,
          }
        );
      }),
      b = await n(o.executionId, x, o.maxParallel, o.taskRunnerConfiguration);
    for (let g of b.completedTasks) d[g.taskId] = !0;
    (s = b.completedStatusCode), (u = b.completedTasks);
  }
}
var fl,
  yL = te(() => {
    'use strict';
    pl();
    cl();
    Le();
    Gu();
    Pn();
    ({ output: fl } = Ae());
  });
var Xd = P((Vle, RL) => {
  'use strict';
  var hK = require('util'),
    bL = require('path'),
    mK = require('fs');
  function dl(t) {
    if (
      ((t !== t.toLowerCase() && t !== t.toUpperCase()) || (t = t.toLowerCase()),
      t.indexOf('-') === -1 && t.indexOf('_') === -1)
    )
      return t;
    {
      let i = '',
        n = !1,
        r = t.match(/^-+/);
      for (let s = r ? r[0].length : 0; s < t.length; s++) {
        let o = t.charAt(s);
        n && ((n = !1), (o = o.toUpperCase())),
          s !== 0 && (o === '-' || o === '_') ? (n = !0) : o !== '-' && o !== '_' && (i += o);
      }
      return i;
    }
  }
  function _L(t, e) {
    let i = t.toLowerCase();
    e = e || '-';
    let n = '';
    for (let r = 0; r < t.length; r++) {
      let s = i.charAt(r),
        o = t.charAt(r);
      s !== o && r > 0 ? (n += `${e}${i.charAt(r)}`) : (n += o);
    }
    return n;
  }
  function SL(t) {
    return t == null
      ? !1
      : typeof t == 'number' || /^0x[0-9a-f]+$/i.test(t)
      ? !0
      : /^0[^.]/.test(t)
      ? !1
      : /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(t);
  }
  function gK(t) {
    if (Array.isArray(t)) return t.map((o) => (typeof o != 'string' ? o + '' : o));
    t = t.trim();
    let e = 0,
      i = null,
      n = null,
      r = null,
      s = [];
    for (let o = 0; o < t.length; o++) {
      if (((i = n), (n = t.charAt(o)), n === ' ' && !r)) {
        i !== ' ' && e++;
        continue;
      }
      n === r ? (r = null) : (n === "'" || n === '"') && !r && (r = n), s[e] || (s[e] = ''), (s[e] += n);
    }
    return s;
  }
  var _n;
  (function (t) {
    (t.BOOLEAN = 'boolean'), (t.STRING = 'string'), (t.NUMBER = 'number'), (t.ARRAY = 'array');
  })(_n || (_n = {}));
  var Rr,
    R0 = class {
      constructor(e) {
        Rr = e;
      }
      parse(e, i) {
        let n = Object.assign(
            {
              alias: void 0,
              array: void 0,
              boolean: void 0,
              config: void 0,
              configObjects: void 0,
              configuration: void 0,
              coerce: void 0,
              count: void 0,
              default: void 0,
              envPrefix: void 0,
              narg: void 0,
              normalize: void 0,
              string: void 0,
              number: void 0,
              __: void 0,
              key: void 0,
            },
            i
          ),
          r = gK(e),
          s = typeof e == 'string',
          o = xK(Object.assign(Object.create(null), n.alias)),
          c = Object.assign(
            {
              'boolean-negation': !0,
              'camel-case-expansion': !0,
              'combine-arrays': !1,
              'dot-notation': !0,
              'duplicate-arguments-array': !0,
              'flatten-duplicate-arrays': !0,
              'greedy-arrays': !0,
              'halt-at-non-option': !1,
              'nargs-eats-options': !1,
              'negation-prefix': 'no-',
              'parse-numbers': !0,
              'parse-positional-numbers': !0,
              'populate--': !1,
              'set-placeholder-key': !1,
              'short-option-groups': !0,
              'strip-aliased': !1,
              'strip-dashed': !1,
              'unknown-options-as-args': !1,
            },
            n.configuration
          ),
          u = Object.assign(Object.create(null), n.default),
          l = n.configObjects || [],
          p = n.envPrefix,
          d = c['populate--'],
          x = d ? '--' : '_',
          b = Object.create(null),
          g = Object.create(null),
          y = n.__ || Rr.format,
          h = {
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: [],
          },
          v = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/,
          C = new RegExp('^--' + c['negation-prefix'] + '(.+)');
        []
          .concat(n.array || [])
          .filter(Boolean)
          .forEach(function (R) {
            let w = typeof R == 'object' ? R.key : R,
              A = Object.keys(R)
                .map(function (k) {
                  return { boolean: 'bools', string: 'strings', number: 'numbers' }[k];
                })
                .filter(Boolean)
                .pop();
            A && (h[A][w] = !0), (h.arrays[w] = !0), h.keys.push(w);
          }),
          []
            .concat(n.boolean || [])
            .filter(Boolean)
            .forEach(function (R) {
              (h.bools[R] = !0), h.keys.push(R);
            }),
          []
            .concat(n.string || [])
            .filter(Boolean)
            .forEach(function (R) {
              (h.strings[R] = !0), h.keys.push(R);
            }),
          []
            .concat(n.number || [])
            .filter(Boolean)
            .forEach(function (R) {
              (h.numbers[R] = !0), h.keys.push(R);
            }),
          []
            .concat(n.count || [])
            .filter(Boolean)
            .forEach(function (R) {
              (h.counts[R] = !0), h.keys.push(R);
            }),
          []
            .concat(n.normalize || [])
            .filter(Boolean)
            .forEach(function (R) {
              (h.normalize[R] = !0), h.keys.push(R);
            }),
          typeof n.narg == 'object' &&
            Object.entries(n.narg).forEach(([R, w]) => {
              typeof w == 'number' && ((h.nargs[R] = w), h.keys.push(R));
            }),
          typeof n.coerce == 'object' &&
            Object.entries(n.coerce).forEach(([R, w]) => {
              typeof w == 'function' && ((h.coercions[R] = w), h.keys.push(R));
            }),
          typeof n.config < 'u' &&
            (Array.isArray(n.config) || typeof n.config == 'string'
              ? []
                  .concat(n.config)
                  .filter(Boolean)
                  .forEach(function (R) {
                    h.configs[R] = !0;
                  })
              : typeof n.config == 'object' &&
                Object.entries(n.config).forEach(([R, w]) => {
                  (typeof w == 'boolean' || typeof w == 'function') && (h.configs[R] = w);
                })),
          oe(n.key, o, n.default, h.arrays),
          Object.keys(u).forEach(function (R) {
            (h.aliases[R] || []).forEach(function (w) {
              u[w] = u[R];
            });
          });
        let _ = null;
        ze();
        let m = [],
          O = Object.assign(Object.create(null), { _: [] }),
          N = {};
        for (let R = 0; R < r.length; R++) {
          let w = r[R],
            A = w.replace(/^-{3,}/, '---'),
            k,
            S,
            M,
            j,
            U,
            re;
          if (w !== '--' && /^-/.test(w) && ce(w)) D(w);
          else if (A.match(/^---+(=|$)/)) {
            D(w);
            continue;
          } else if (w.match(/^--.+=/) || (!c['short-option-groups'] && w.match(/^-.+=/)))
            (j = w.match(/^--?([^=]+)=([\s\S]*)$/)),
              j !== null &&
                Array.isArray(j) &&
                j.length >= 3 &&
                (I(j[1], h.arrays)
                  ? (R = H(R, j[1], r, j[2]))
                  : I(j[1], h.nargs) !== !1
                  ? (R = z(R, j[1], r, j[2]))
                  : F(j[1], j[2], !0));
          else if (w.match(C) && c['boolean-negation'])
            (j = w.match(C)),
              j !== null && Array.isArray(j) && j.length >= 2 && ((S = j[1]), F(S, I(S, h.arrays) ? [!1] : !1));
          else if (w.match(/^--.+/) || (!c['short-option-groups'] && w.match(/^-[^-]+/)))
            (j = w.match(/^--?(.+)/)),
              j !== null &&
                Array.isArray(j) &&
                j.length >= 2 &&
                ((S = j[1]),
                I(S, h.arrays)
                  ? (R = H(R, S, r))
                  : I(S, h.nargs) !== !1
                  ? (R = z(R, S, r))
                  : ((U = r[R + 1]),
                    (U !== void 0 && (!U.match(/^-/) || U.match(v)) && !I(S, h.bools) && !I(S, h.counts)) ||
                    /^(true|false)$/.test(U)
                      ? (F(S, U), R++)
                      : F(S, ve(S))));
          else if (w.match(/^-.\..+=/))
            (j = w.match(/^-([^=]+)=([\s\S]*)$/)), j !== null && Array.isArray(j) && j.length >= 3 && F(j[1], j[2]);
          else if (w.match(/^-.\..+/) && !w.match(v))
            (U = r[R + 1]),
              (j = w.match(/^-(.\..+)/)),
              j !== null &&
                Array.isArray(j) &&
                j.length >= 2 &&
                ((S = j[1]),
                U !== void 0 && !U.match(/^-/) && !I(S, h.bools) && !I(S, h.counts) ? (F(S, U), R++) : F(S, ve(S)));
          else if (w.match(/^-[^-]+/) && !w.match(v)) {
            (M = w.slice(1, -1).split('')), (k = !1);
            for (let se = 0; se < M.length; se++) {
              if (((U = w.slice(se + 2)), M[se + 1] && M[se + 1] === '=')) {
                (re = w.slice(se + 3)),
                  (S = M[se]),
                  I(S, h.arrays) ? (R = H(R, S, r, re)) : I(S, h.nargs) !== !1 ? (R = z(R, S, r, re)) : F(S, re),
                  (k = !0);
                break;
              }
              if (U === '-') {
                F(M[se], U);
                continue;
              }
              if (/[A-Za-z]/.test(M[se]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(U) && I(U, h.bools) === !1) {
                F(M[se], U), (k = !0);
                break;
              }
              if (M[se + 1] && M[se + 1].match(/\W/)) {
                F(M[se], U), (k = !0);
                break;
              } else F(M[se], ve(M[se]));
            }
            (S = w.slice(-1)[0]),
              !k &&
                S !== '-' &&
                (I(S, h.arrays)
                  ? (R = H(R, S, r))
                  : I(S, h.nargs) !== !1
                  ? (R = z(R, S, r))
                  : ((U = r[R + 1]),
                    (U !== void 0 && (!/^(-|--)[^-]/.test(U) || U.match(v)) && !I(S, h.bools) && !I(S, h.counts)) ||
                    /^(true|false)$/.test(U)
                      ? (F(S, U), R++)
                      : F(S, ve(S))));
          } else if (w.match(/^-[0-9]$/) && w.match(v) && I(w.slice(1), h.bools)) (S = w.slice(1)), F(S, ve(S));
          else if (w === '--') {
            m = r.slice(R + 1);
            break;
          } else if (c['halt-at-non-option']) {
            m = r.slice(R);
            break;
          } else D(w);
        }
        q(O, !0),
          q(O, !1),
          V(O),
          K(),
          xe(O, h.aliases, u, !0),
          B(O),
          c['set-placeholder-key'] && ee(O),
          Object.keys(h.counts).forEach(function (R) {
            de(O, R.split('.')) || F(R, 0);
          }),
          d && m.length && (O[x] = []),
          m.forEach(function (R) {
            O[x].push(R);
          }),
          c['camel-case-expansion'] &&
            c['strip-dashed'] &&
            Object.keys(O)
              .filter((R) => R !== '--' && R.includes('-'))
              .forEach((R) => {
                delete O[R];
              }),
          c['strip-aliased'] &&
            [].concat(...Object.keys(o).map((R) => o[R])).forEach((R) => {
              c['camel-case-expansion'] &&
                R.includes('-') &&
                delete O[
                  R.split('.')
                    .map((w) => dl(w))
                    .join('.')
                ],
                delete O[R];
            });
        function D(R) {
          let w = le('_', R);
          (typeof w == 'string' || typeof w == 'number') && O._.push(w);
        }
        function z(R, w, A, k) {
          let S,
            M = I(w, h.nargs);
          if (((M = typeof M != 'number' || isNaN(M) ? 1 : M), M === 0))
            return ke(k) || (_ = Error(y('Argument unexpected for: %s', w))), F(w, ve(w)), R;
          let j = ke(k) ? 0 : 1;
          if (c['nargs-eats-options'])
            A.length - (R + 1) + j < M && (_ = Error(y('Not enough arguments following: %s', w))), (j = M);
          else {
            for (S = R + 1; S < A.length && (!A[S].match(/^-[^0-9]/) || A[S].match(v) || ce(A[S])); S++) j++;
            j < M && (_ = Error(y('Not enough arguments following: %s', w)));
          }
          let U = Math.min(j, M);
          for (!ke(k) && U > 0 && (F(w, k), U--), S = R + 1; S < U + R + 1; S++) F(w, A[S]);
          return R + U;
        }
        function H(R, w, A, k) {
          let S = [],
            M = k || A[R + 1],
            j = I(w, h.nargs);
          if (I(w, h.bools) && !/^(true|false)$/.test(M)) S.push(!0);
          else if (ke(M) || (ke(k) && /^-/.test(M) && !v.test(M) && !ce(M))) {
            if (u[w] !== void 0) {
              let U = u[w];
              S = Array.isArray(U) ? U : [U];
            }
          } else {
            ke(k) || S.push(pe(w, k, !0));
            for (
              let U = R + 1;
              U < A.length &&
              !(
                (!c['greedy-arrays'] && S.length > 0) ||
                (j && typeof j == 'number' && S.length >= j) ||
                ((M = A[U]), /^-/.test(M) && !v.test(M) && !ce(M))
              );
              U++
            )
              (R = U), S.push(pe(w, M, s));
          }
          return (
            typeof j == 'number' &&
              ((j && S.length < j) || (isNaN(j) && S.length === 0)) &&
              (_ = Error(y('Not enough arguments following: %s', w))),
            F(w, S),
            R
          );
        }
        function F(R, w, A = s) {
          if (/-/.test(R) && c['camel-case-expansion']) {
            let M = R.split('.')
              .map(function (j) {
                return dl(j);
              })
              .join('.');
            ne(R, M);
          }
          let k = pe(R, w, A),
            S = R.split('.');
          Z(O, S, k),
            h.aliases[R] &&
              h.aliases[R].forEach(function (M) {
                let j = M.split('.');
                Z(O, j, k);
              }),
            S.length > 1 &&
              c['dot-notation'] &&
              (h.aliases[S[0]] || []).forEach(function (M) {
                let j = M.split('.'),
                  U = [].concat(S);
                U.shift(), (j = j.concat(U)), (h.aliases[R] || []).includes(j.join('.')) || Z(O, j, k);
              }),
            I(R, h.normalize) &&
              !I(R, h.arrays) &&
              [R].concat(h.aliases[R] || []).forEach(function (j) {
                Object.defineProperty(N, j, {
                  enumerable: !0,
                  get() {
                    return w;
                  },
                  set(U) {
                    w = typeof U == 'string' ? Rr.normalize(U) : U;
                  },
                });
              });
        }
        function ne(R, w) {
          (h.aliases[R] && h.aliases[R].length) || ((h.aliases[R] = [w]), (b[w] = !0)),
            (h.aliases[w] && h.aliases[w].length) || ne(w, R);
        }
        function pe(R, w, A) {
          A && (w = yK(w)), (I(R, h.bools) || I(R, h.counts)) && typeof w == 'string' && (w = w === 'true');
          let k = Array.isArray(w)
            ? w.map(function (S) {
                return le(R, S);
              })
            : le(R, w);
          return (
            I(R, h.counts) && (ke(k) || typeof k == 'boolean') && (k = E0()),
            I(R, h.normalize) &&
              I(R, h.arrays) &&
              (Array.isArray(w) ? (k = w.map((S) => Rr.normalize(S))) : (k = Rr.normalize(w))),
            k
          );
        }
        function le(R, w) {
          return (
            (!c['parse-positional-numbers'] && R === '_') ||
              (!I(R, h.strings) &&
                !I(R, h.bools) &&
                !Array.isArray(w) &&
                ((SL(w) && c['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat(`${w}`)))) ||
                  (!ke(w) && I(R, h.numbers))) &&
                (w = Number(w))),
            w
          );
        }
        function V(R) {
          let w = Object.create(null);
          xe(w, h.aliases, u),
            Object.keys(h.configs).forEach(function (A) {
              let k = R[A] || w[A];
              if (k)
                try {
                  let S = null,
                    M = Rr.resolve(Rr.cwd(), k),
                    j = h.configs[A];
                  if (typeof j == 'function') {
                    try {
                      S = j(M);
                    } catch (U) {
                      S = U;
                    }
                    if (S instanceof Error) {
                      _ = S;
                      return;
                    }
                  } else S = Rr.require(M);
                  W(S);
                } catch (S) {
                  S.name === 'PermissionDenied' ? (_ = S) : R[A] && (_ = Error(y('Invalid JSON config file: %s', k)));
                }
            });
        }
        function W(R, w) {
          Object.keys(R).forEach(function (A) {
            let k = R[A],
              S = w ? w + '.' + A : A;
            typeof k == 'object' && k !== null && !Array.isArray(k) && c['dot-notation']
              ? W(k, S)
              : (!de(O, S.split('.')) || (I(S, h.arrays) && c['combine-arrays'])) && F(S, k);
          });
        }
        function K() {
          typeof l < 'u' &&
            l.forEach(function (R) {
              W(R);
            });
        }
        function q(R, w) {
          if (typeof p > 'u') return;
          let A = typeof p == 'string' ? p : '',
            k = Rr.env();
          Object.keys(k).forEach(function (S) {
            if (A === '' || S.lastIndexOf(A, 0) === 0) {
              let M = S.split('__').map(function (j, U) {
                return U === 0 && (j = j.substring(A.length)), dl(j);
              });
              ((w && h.configs[M.join('.')]) || !w) && !de(R, M) && F(M.join('.'), k[S]);
            }
          });
        }
        function B(R) {
          let w,
            A = new Set();
          Object.keys(R).forEach(function (k) {
            if (!A.has(k) && ((w = I(k, h.coercions)), typeof w == 'function'))
              try {
                let S = le(k, w(R[k]));
                [].concat(h.aliases[k] || [], k).forEach((M) => {
                  A.add(M), (R[M] = S);
                });
              } catch (S) {
                _ = S;
              }
          });
        }
        function ee(R) {
          return (
            h.keys.forEach((w) => {
              ~w.indexOf('.') || (typeof R[w] > 'u' && (R[w] = void 0));
            }),
            R
          );
        }
        function xe(R, w, A, k = !1) {
          Object.keys(A).forEach(function (S) {
            de(R, S.split('.')) ||
              (Z(R, S.split('.'), A[S]),
              k && (g[S] = !0),
              (w[S] || []).forEach(function (M) {
                de(R, M.split('.')) || Z(R, M.split('.'), A[S]);
              }));
          });
        }
        function de(R, w) {
          let A = R;
          c['dot-notation'] || (w = [w.join('.')]),
            w.slice(0, -1).forEach(function (S) {
              A = A[S] || {};
            });
          let k = w[w.length - 1];
          return typeof A != 'object' ? !1 : k in A;
        }
        function Z(R, w, A) {
          let k = R;
          c['dot-notation'] || (w = [w.join('.')]),
            w.slice(0, -1).forEach(function (re) {
              (re = vL(re)),
                typeof k == 'object' && k[re] === void 0 && (k[re] = {}),
                typeof k[re] != 'object' || Array.isArray(k[re])
                  ? (Array.isArray(k[re]) ? k[re].push({}) : (k[re] = [k[re], {}]), (k = k[re][k[re].length - 1]))
                  : (k = k[re]);
            });
          let S = vL(w[w.length - 1]),
            M = I(w.join('.'), h.arrays),
            j = Array.isArray(A),
            U = c['duplicate-arguments-array'];
          !U &&
            I(S, h.nargs) &&
            ((U = !0),
            ((!ke(k[S]) && h.nargs[S] === 1) || (Array.isArray(k[S]) && k[S].length === h.nargs[S])) &&
              (k[S] = void 0)),
            A === E0()
              ? (k[S] = E0(k[S]))
              : Array.isArray(k[S])
              ? U && M && j
                ? (k[S] = c['flatten-duplicate-arrays']
                    ? k[S].concat(A)
                    : (Array.isArray(k[S][0]) ? k[S] : [k[S]]).concat([A]))
                : !U && !!M == !!j
                ? (k[S] = A)
                : (k[S] = k[S].concat([A]))
              : k[S] === void 0 && M
              ? (k[S] = j ? A : [A])
              : U && !(k[S] === void 0 || I(S, h.counts) || I(S, h.bools))
              ? (k[S] = [k[S], A])
              : (k[S] = A);
        }
        function oe(...R) {
          R.forEach(function (w) {
            Object.keys(w || {}).forEach(function (A) {
              h.aliases[A] ||
                ((h.aliases[A] = [].concat(o[A] || [])),
                h.aliases[A].concat(A).forEach(function (k) {
                  if (/-/.test(k) && c['camel-case-expansion']) {
                    let S = dl(k);
                    S !== A && h.aliases[A].indexOf(S) === -1 && (h.aliases[A].push(S), (b[S] = !0));
                  }
                }),
                h.aliases[A].concat(A).forEach(function (k) {
                  if (k.length > 1 && /[A-Z]/.test(k) && c['camel-case-expansion']) {
                    let S = _L(k, '-');
                    S !== A && h.aliases[A].indexOf(S) === -1 && (h.aliases[A].push(S), (b[S] = !0));
                  }
                }),
                h.aliases[A].forEach(function (k) {
                  h.aliases[k] = [A].concat(
                    h.aliases[A].filter(function (S) {
                      return k !== S;
                    })
                  );
                }));
            });
          });
        }
        function I(R, w) {
          let A = [].concat(h.aliases[R] || [], R),
            k = Object.keys(w),
            S = A.find((M) => k.includes(M));
          return S ? w[S] : !1;
        }
        function X(R) {
          let w = Object.keys(h);
          return [].concat(w.map((k) => h[k])).some(function (k) {
            return Array.isArray(k) ? k.includes(R) : k[R];
          });
        }
        function Q(R, ...w) {
          return [].concat(...w).some(function (k) {
            let S = R.match(k);
            return S && X(S[1]);
          });
        }
        function ae(R) {
          if (R.match(v) || !R.match(/^-[^-]+/)) return !1;
          let w = !0,
            A,
            k = R.slice(1).split('');
          for (let S = 0; S < k.length; S++) {
            if (((A = R.slice(S + 2)), !X(k[S]))) {
              w = !1;
              break;
            }
            if (
              (k[S + 1] && k[S + 1] === '=') ||
              A === '-' ||
              (/[A-Za-z]/.test(k[S]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(A)) ||
              (k[S + 1] && k[S + 1].match(/\W/))
            )
              break;
          }
          return w;
        }
        function ce(R) {
          return c['unknown-options-as-args'] && ye(R);
        }
        function ye(R) {
          return (
            (R = R.replace(/^-{3,}/, '--')),
            R.match(v) || ae(R)
              ? !1
              : !Q(
                  R,
                  /^-+([^=]+?)=[\s\S]*$/,
                  C,
                  /^-+([^=]+?)$/,
                  /^-+([^=]+?)-$/,
                  /^-+([^=]+?\d+)$/,
                  /^-+([^=]+?)\W+.*$/
                )
          );
        }
        function ve(R) {
          return !I(R, h.bools) && !I(R, h.counts) && `${R}` in u ? u[R] : Ce(Oe(R));
        }
        function Ce(R) {
          return { [_n.BOOLEAN]: !0, [_n.STRING]: '', [_n.NUMBER]: void 0, [_n.ARRAY]: [] }[R];
        }
        function Oe(R) {
          let w = _n.BOOLEAN;
          return (
            I(R, h.strings)
              ? (w = _n.STRING)
              : I(R, h.numbers)
              ? (w = _n.NUMBER)
              : I(R, h.bools)
              ? (w = _n.BOOLEAN)
              : I(R, h.arrays) && (w = _n.ARRAY),
            w
          );
        }
        function ke(R) {
          return R === void 0;
        }
        function ze() {
          Object.keys(h.counts).find((R) =>
            I(R, h.arrays)
              ? ((_ = Error(y('Invalid configuration: %s, opts.count excludes opts.array.', R))), !0)
              : I(R, h.nargs)
              ? ((_ = Error(y('Invalid configuration: %s, opts.count excludes opts.narg.', R))), !0)
              : !1
          );
        }
        return {
          aliases: Object.assign({}, h.aliases),
          argv: Object.assign(N, O),
          configuration: c,
          defaulted: Object.assign({}, g),
          error: _,
          newAliases: Object.assign({}, b),
        };
      }
    };
  function xK(t) {
    let e = [],
      i = Object.create(null),
      n = !0;
    for (
      Object.keys(t).forEach(function (r) {
        e.push([].concat(t[r], r));
      });
      n;

    ) {
      n = !1;
      for (let r = 0; r < e.length; r++)
        for (let s = r + 1; s < e.length; s++)
          if (
            e[r].filter(function (c) {
              return e[s].indexOf(c) !== -1;
            }).length
          ) {
            (e[r] = e[r].concat(e[s])), e.splice(s, 1), (n = !0);
            break;
          }
    }
    return (
      e.forEach(function (r) {
        r = r.filter(function (o, c, u) {
          return u.indexOf(o) === c;
        });
        let s = r.pop();
        s !== void 0 && typeof s == 'string' && (i[s] = r);
      }),
      i
    );
  }
  function E0(t) {
    return t !== void 0 ? t + 1 : 1;
  }
  function vL(t) {
    return t === '__proto__' ? '___proto___' : t;
  }
  function yK(t) {
    return typeof t == 'string' && (t[0] === "'" || t[0] === '"') && t[t.length - 1] === t[0]
      ? t.substring(1, t.length - 1)
      : t;
  }
  var _0,
    S0,
    C0,
    wL = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12,
    EL =
      (S0 = (_0 = process == null ? void 0 : process.versions) === null || _0 === void 0 ? void 0 : _0.node) !== null &&
      S0 !== void 0
        ? S0
        : (C0 = process == null ? void 0 : process.version) === null || C0 === void 0
        ? void 0
        : C0.slice(1);
  if (EL && Number(EL.match(/^([^.]+)/)[1]) < wL)
    throw Error(
      `yargs parser supports a minimum Node.js version of ${wL}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`
    );
  var bK = process ? process.env : {},
    CL = new R0({
      cwd: process.cwd,
      env: () => bK,
      format: hK.format,
      normalize: bL.normalize,
      resolve: bL.resolve,
      require: (t) => {
        if (typeof require < 'u') return require(t);
        if (t.match(/\.json$/)) return JSON.parse(mK.readFileSync(t, 'utf8'));
        throw Error('only .json config files are supported in ESM');
      },
    }),
    hl = function (e, i) {
      return CL.parse(e.slice(), i).argv;
    };
  hl.detailed = function (t, e) {
    return CL.parse(t.slice(), e);
  };
  hl.camelCase = dl;
  hl.decamelize = _L;
  hl.looksLikeNumber = SL;
  RL.exports = hl;
});
var AL = P((O0, kL) => {
  'use strict';
  var TL = typeof Reflect < 'u' ? Reflect.construct : void 0,
    uc = Object.defineProperty,
    T0 = Error.captureStackTrace;
  T0 === void 0 &&
    (T0 = function (e) {
      var i = new Error();
      uc(e, 'stack', {
        configurable: !0,
        get: function () {
          var r = i.stack;
          return uc(this, 'stack', { configurable: !0, value: r, writable: !0 }), r;
        },
        set: function (r) {
          uc(e, 'stack', { configurable: !0, value: r, writable: !0 });
        },
      });
    });
  function Yd(t) {
    t !== void 0 && uc(this, 'message', { configurable: !0, value: t, writable: !0 });
    var e = this.constructor.name;
    e !== void 0 && e !== this.name && uc(this, 'name', { configurable: !0, value: e, writable: !0 }),
      T0(this, this.constructor);
  }
  Yd.prototype = Object.create(Error.prototype, { constructor: { configurable: !0, value: Yd, writable: !0 } });
  var OL = (function () {
    function t(i, n) {
      return uc(i, 'name', { configurable: !0, value: n });
    }
    try {
      var e = function () {};
      if ((t(e, 'foo'), e.name === 'foo')) return t;
    } catch {}
  })();
  function vK(t, e) {
    if (e == null || e === Error) e = Yd;
    else if (typeof e != 'function') throw new TypeError('super_ should be a function');
    var i;
    if (typeof t == 'string')
      (i = t),
        (t =
          TL !== void 0
            ? function () {
                return TL(e, arguments, this.constructor);
              }
            : function () {
                e.apply(this, arguments);
              }),
        OL !== void 0 && (OL(t, i), (i = void 0));
    else if (typeof t != 'function') throw new TypeError('constructor should be either a string or a function');
    t.super_ = t.super = e;
    var n = { constructor: { configurable: !0, value: t, writable: !0 } };
    return (
      i !== void 0 && (n.name = { configurable: !0, value: i, writable: !0 }),
      (t.prototype = Object.create(e.prototype, n)),
      t
    );
  }
  O0 = kL.exports = vK;
  O0.BaseError = Yd;
});
var jL = P(($le, FL) => {
  'use strict';
  var IL = new Map([
      [5, 0.25],
      [6, 0.25],
      [7, 0.25],
      ['t', 0.75],
      ['y', 1],
      ['u', 0.75],
      ['g', 0.25],
      ['h', 0.25],
      ['j', 0.25],
    ]),
    NL = new Map([
      [2, 0.25],
      [3, 0.25],
      [4, 0.25],
      ['w', 0.75],
      ['e', 1],
      ['r', 0.75],
      ['s', 0.25],
      ['d', 0.25],
      ['f', 0.25],
    ]),
    PL = new Map([
      ['q', 0.25],
      ['w', 0.25],
      ['e', 0.25],
      ['a', 0.75],
      ['s', 1],
      ['d', 0.75],
      ['z', 0.25],
      ['x', 0.25],
      ['c', 0.25],
    ]),
    LL = new Map([
      ['h', 0.25],
      ['j', 0.25],
      ['k', 0.25],
      ['b', 0.75],
      ['n', 1],
      ['m', 0.75],
    ]),
    DL = new Map([
      [9, 0.25],
      [0, 0.25],
      ['i', 0.75],
      ['o', 1],
      ['p', 0.75],
      ['k', 0.25],
      ['l', 0.25],
    ]);
  function wK(t) {
    let [e, i, n] = t,
      r = 0;
    return IL.has(e) && (r += IL.get(e)), NL.has(i) && (r += NL.get(i)), PL.has(n) && (r += PL.get(n)), r;
  }
  function EK(t) {
    let [e, i] = t,
      n = 0;
    return LL.has(e) && (n += LL.get(e)), DL.has(i) && (n += DL.get(i)), n;
  }
  FL.exports = (t, e) => (wK(t) >= 2 ? !0 : EK(t) >= 1.25 ? !1 : e.default);
});
var UL = P((Wle, k0) => {
  'use strict';
  var _K = jL(),
    ML = (t, e) => {
      if (
        ((t = String(t).trim()),
        (e = Object.assign({ lenient: !1, default: null }, e)),
        e.default !== null && typeof e.default != 'boolean')
      )
        throw new TypeError(`Expected the \`default\` option to be of type \`boolean\`, got \`${typeof e.default}\``);
      return /^(?:y|yes|true|1)$/i.test(t)
        ? !0
        : /^(?:n|no|false|0)$/i.test(t)
        ? !1
        : e.lenient === !0
        ? _K(t, e)
        : e.default;
    };
  k0.exports = ML;
  k0.exports.default = ML;
});
var HL = P((Kle, BL) => {
  'use strict';
  var lc = require('module'),
    qL = require('path'),
    SK = require('fs');
  function CK(t) {
    return (
      t || (t = process.cwd()),
      TK(t) && (t = qL.join(t, 'index.js')),
      lc.createRequire ? lc.createRequire(t) : lc.createRequireFromPath ? lc.createRequireFromPath(t) : RK(t)
    );
  }
  function RK(t) {
    let e = new lc.Module(t, null);
    return (
      (e.filename = t),
      (e.paths = lc.Module._nodeModulePaths(qL.dirname(t))),
      e._compile('module.exports = require;', t),
      e.exports
    );
  }
  function TK(t) {
    try {
      return SK.lstatSync(t).isDirectory();
    } catch {
      return !1;
    }
  }
  BL.exports = CK;
});
var XL = P((Xle, I0) => {
  'use strict';
  var Tr = require('module'),
    OK = require('crypto'),
    Es = require('fs'),
    Oo = require('path'),
    GL = require('vm'),
    kK = require('os'),
    ws = Object.prototype.hasOwnProperty,
    Jd = class {
      constructor(e, i) {
        let n = i ? VL(i + '.') : '';
        (this._blobFilename = Oo.join(e, n + 'BLOB')),
          (this._mapFilename = Oo.join(e, n + 'MAP')),
          (this._lockFilename = Oo.join(e, n + 'LOCK')),
          (this._directory = e),
          this._load();
      }
      has(e, i) {
        return ws.call(this._memoryBlobs, e)
          ? this._invalidationKeys[e] === i
          : ws.call(this._storedMap, e)
          ? this._storedMap[e][0] === i
          : !1;
      }
      get(e, i) {
        if (ws.call(this._memoryBlobs, e)) {
          if (this._invalidationKeys[e] === i) return this._memoryBlobs[e];
        } else if (ws.call(this._storedMap, e)) {
          let n = this._storedMap[e];
          if (n[0] === i) return this._storedBlob.slice(n[1], n[2]);
        }
      }
      set(e, i, n) {
        (this._invalidationKeys[e] = i), (this._memoryBlobs[e] = n), (this._dirty = !0);
      }
      delete(e) {
        ws.call(this._memoryBlobs, e) && ((this._dirty = !0), delete this._memoryBlobs[e]),
          ws.call(this._invalidationKeys, e) && ((this._dirty = !0), delete this._invalidationKeys[e]),
          ws.call(this._storedMap, e) && ((this._dirty = !0), delete this._storedMap[e]);
      }
      isDirty() {
        return this._dirty;
      }
      save() {
        let e = this._getDump(),
          i = Buffer.concat(e[0]),
          n = JSON.stringify(e[1]);
        try {
          zL(this._directory), Es.writeFileSync(this._lockFilename, 'LOCK', { flag: 'wx' });
        } catch {
          return !1;
        }
        try {
          Es.writeFileSync(this._blobFilename, i), Es.writeFileSync(this._mapFilename, n);
        } finally {
          Es.unlinkSync(this._lockFilename);
        }
        return !0;
      }
      _load() {
        try {
          (this._storedBlob = Es.readFileSync(this._blobFilename)),
            (this._storedMap = JSON.parse(Es.readFileSync(this._mapFilename)));
        } catch {
          (this._storedBlob = Buffer.alloc(0)), (this._storedMap = {});
        }
        (this._dirty = !1), (this._memoryBlobs = {}), (this._invalidationKeys = {});
      }
      _getDump() {
        let e = [],
          i = {},
          n = 0;
        function r(s, o, c) {
          e.push(c), (i[s] = [o, n, n + c.length]), (n += c.length);
        }
        for (let s of Object.keys(this._memoryBlobs)) {
          let o = this._memoryBlobs[s],
            c = this._invalidationKeys[s];
          r(s, c, o);
        }
        for (let s of Object.keys(this._storedMap)) {
          if (ws.call(i, s)) continue;
          let o = this._storedMap[s],
            c = this._storedBlob.slice(o[1], o[2]);
          r(s, o[0], c);
        }
        return [e, i];
      }
    },
    Zd = class {
      constructor() {
        (this._cacheStore = null), (this._previousModuleCompile = null);
      }
      setCacheStore(e) {
        this._cacheStore = e;
      }
      install() {
        let e = this,
          i = typeof require.resolve.paths == 'function';
        (this._previousModuleCompile = Tr.prototype._compile),
          (Tr.prototype._compile = this._ownModuleCompile = n),
          (e.enabled = !0);
        function n(r, s) {
          if (!e.enabled) return this._previousModuleCompile.apply(this, arguments);
          let o = this;
          function c(x) {
            return o.require(x);
          }
          function u(x, b) {
            return Tr._resolveFilename(x, o, !1, b);
          }
          (c.resolve = u),
            i &&
              (u.paths = function (b) {
                return Tr._resolveLookupPaths(b, o, !0);
              }),
            (c.main = process.mainModule),
            (c.extensions = Tr._extensions),
            (c.cache = Tr._cache);
          let l = Oo.dirname(s),
            p = e._moduleCompile(s, r),
            d = [o.exports, c, o, s, l, process, global, Buffer];
          return p.apply(o.exports, d);
        }
      }
      uninstall() {
        (this.enabled = !1),
          Tr.prototype._compile === this._ownModuleCompile && (Tr.prototype._compile = this._previousModuleCompile);
      }
      _moduleCompile(e, i) {
        var n = i.length;
        if (n >= 2 && i.charCodeAt(0) === 35 && i.charCodeAt(1) === 33)
          if (n === 2) i = '';
          else {
            for (var r = 2; r < n; ++r) {
              var s = i.charCodeAt(r);
              if (s === 10 || s === 13) break;
            }
            r === n ? (i = '') : (i = i.slice(r));
          }
        var o = Tr.wrap(i),
          c = OK.createHash('sha1').update(i, 'utf8').digest('hex'),
          u = this._cacheStore.get(e, c),
          l = new GL.Script(o, { filename: e, lineOffset: 0, displayErrors: !0, cachedData: u, produceCachedData: !0 });
        l.cachedDataProduced
          ? this._cacheStore.set(e, c, l.cachedData)
          : l.cachedDataRejected && this._cacheStore.delete(e);
        var p = l.runInThisContext({ filename: e, lineOffset: 0, columnOffset: 0, displayErrors: !0 });
        return p;
      }
    };
  function zL(t) {
    A0(Oo.resolve(t), 511);
  }
  function A0(t, e) {
    try {
      Es.mkdirSync(t, e);
    } catch (i) {
      if (i.code === 'ENOENT') A0(Oo.dirname(t)), A0(t);
      else
        try {
          if (!Es.statSync(t).isDirectory()) throw i;
        } catch {
          throw i;
        }
    }
  }
  function VL(t) {
    let e = { '\\': 'zB', ':': 'zC', '/': 'zS', '\0': 'z0', z: 'zZ' },
      i = /[\\:/\x00z]/g;
    return t.replace(i, (n) => e[n]);
  }
  function $L() {
    return new GL.Script('""', { produceCachedData: !0 }).cachedDataProduced === !0;
  }
  function WL() {
    let t = process.env.V8_COMPILE_CACHE_CACHE_DIR;
    if (t) return t;
    let e = typeof process.getuid == 'function' ? 'v8-compile-cache-' + process.getuid() : 'v8-compile-cache',
      i =
        typeof process.versions.v8 == 'string'
          ? process.versions.v8
          : typeof process.versions.chakracore == 'string'
          ? 'chakracore-' + process.versions.chakracore
          : 'node-' + process.version;
    return Oo.join(kK.tmpdir(), e, i);
  }
  function KL() {
    return require.main && typeof require.main.filename == 'string' ? require.main.filename : process.cwd();
  }
  function AK(t) {
    if (!process.env.DISABLE_V8_COMPILE_CACHE && $L()) {
      typeof t > 'u' && (t = {});
      let e = t.cacheDir;
      typeof e > 'u' && (e = WL());
      let i = t.prefix;
      typeof i > 'u' && (i = KL());
      let n = new Jd(e, i),
        r = new Zd();
      r.setCacheStore(n), r.install();
      let s = !1,
        o = () => {
          s || ((s = !0), process.removeListener('exit', o), n.isDirty() && n.save(), r.uninstall());
        };
      return process.once('exit', o), { uninstall: o };
    }
  }
  I0.exports.install = AK;
  I0.exports.__TEST__ = {
    FileSystemBlobStore: Jd,
    NativeCompileCache: Zd,
    mkdirpSync: zL,
    slashEscape: VL,
    supportsCachedData: $L,
    getCacheDir: WL,
    getMainName: KL,
  };
});
var Vn = P((nt) => {
  'use strict';
  var N0;
  Object.defineProperty(nt, '__esModule', { value: !0 });
  nt.versionGteLt =
    nt.once =
    nt.getBasePathForProjectLocalDependencyResolution =
    nt.createProjectLocalResolveHelper =
    nt.attemptRequireWithV8CompileCache =
    nt.cachedLookup =
    nt.hasOwnProperty =
    nt.normalizeSlashes =
    nt.parse =
    nt.split =
    nt.assign =
    nt.yn =
    nt.createRequire =
      void 0;
  var Qd = require('module'),
    IK = UL(),
    NK = require('path');
  nt.createRequire =
    (N0 = Qd.createRequire !== null && Qd.createRequire !== void 0 ? Qd.createRequire : Qd.createRequireFromPath) !==
      null && N0 !== void 0
      ? N0
      : HL();
  function PK(t) {
    var e;
    return (e = IK(t)) !== null && e !== void 0 ? e : void 0;
  }
  nt.yn = PK;
  function LK(t, ...e) {
    for (let i of e)
      for (let n of Object.keys(i)) {
        let r = i[n];
        r !== void 0 && (t[n] = r);
      }
    return t;
  }
  nt.assign = LK;
  function DK(t) {
    return typeof t == 'string' ? t.split(/ *, */g).filter((e) => e !== '') : void 0;
  }
  nt.split = DK;
  function FK(t) {
    return typeof t == 'string' ? JSON.parse(t) : void 0;
  }
  nt.parse = FK;
  var jK = '/',
    MK = /\\/g;
  function UK(t) {
    return t.replace(MK, jK);
  }
  nt.normalizeSlashes = UK;
  function qK(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  nt.hasOwnProperty = qK;
  function BK(t) {
    let e = new Map();
    return (i) => {
      if (!e.has(i)) {
        let n = t(i);
        return e.set(i, n), n;
      }
      return e.get(i);
    };
  }
  nt.cachedLookup = BK;
  function HK(t, e) {
    try {
      let i = XL().install();
      try {
        return t(e);
      } finally {
        i == null || i.uninstall();
      }
    } catch {
      return t(e);
    }
  }
  nt.attemptRequireWithV8CompileCache = HK;
  function GK(t) {
    return function (i, n) {
      return require.resolve(i, { paths: n ? [t, __dirname] : [t] });
    };
  }
  nt.createProjectLocalResolveHelper = GK;
  function zK(t, e, i, n) {
    var r;
    return t != null ? (0, NK.dirname)(t) : (r = e ?? i) !== null && r !== void 0 ? r : n;
  }
  nt.getBasePathForProjectLocalDependencyResolution = zK;
  function VK(t) {
    let e,
      i = !1;
    function n(...r) {
      return i || ((e = t(...r)), (i = !0)), e;
    }
    return n;
  }
  nt.once = VK;
  function $K(t, e, i) {
    let [n, r, s, o] = x(t),
      [c, u, l] = x(e),
      p = n > c || (n === c && (r > u || (r === u && s >= l))),
      d = !0;
    if (i) {
      let [b, g, y] = x(i);
      d = n < b || (n === b && (r < g || (r === g && s < y)));
    }
    return p && d;
    function x(b) {
      return b.split(/[\.-]/).map((g) => parseInt(g, 10));
    }
  }
  nt.versionGteLt = $K;
});
var P0 = P((pc) => {
  'use strict';
  Object.defineProperty(pc, '__esModule', { value: !0 });
  pc.getPatternFromSpec = pc.createTsInternals = void 0;
  var eh = require('path'),
    ih = Vn();
  pc.createTsInternals = (0, ih.cachedLookup)(WK);
  function WK(t) {
    let e = t;
    function i(n, r, s, o, c) {
      if (((n = (0, ih.normalizeSlashes)(n)), KK(n) || YL(n, './') || YL(n, '../'))) {
        let l = XK(n, s);
        if (!r.fileExists(l) && !YK(l, e.Extension.Json) && ((l = `${l}.json`), !r.fileExists(l))) {
          o.push(c(e.Diagnostics.File_0_not_found, n));
          return;
        }
        return l;
      }
      let u = e.nodeModuleNameResolver(
        n,
        QL(s, 'tsconfig.json'),
        { moduleResolution: e.ModuleResolutionKind.NodeJs },
        r,
        void 0,
        void 0,
        !0
      );
      if (u.resolvedModule) return u.resolvedModule.resolvedFileName;
      o.push(c(e.Diagnostics.File_0_not_found, n));
    }
    return { getExtendsConfigPath: i };
  }
  function KK(t) {
    return (0, eh.isAbsolute)(t);
  }
  function QL(t, ...e) {
    return (0, ih.normalizeSlashes)((0, eh.resolve)(t, ...e.filter((i) => i)));
  }
  function XK(t, e) {
    return (0, ih.normalizeSlashes)(e != null ? (0, eh.resolve)(e, t) : (0, eh.resolve)(t));
  }
  function YL(t, e) {
    return t.lastIndexOf(e, 0) === 0;
  }
  function YK(t, e) {
    let i = t.length - e.length;
    return i >= 0 && t.indexOf(e, i) === i;
  }
  var JK = /[^\w\s\/]/g;
  function ZK(t, e) {
    let i = t && QK(t, e, eD);
    return i && `^(${i})($|/)`;
  }
  pc.getPatternFromSpec = ZK;
  function QK(t, e, { singleAsteriskRegexFragment: i, doubleAsteriskRegexFragment: n, replaceWildcardCharacter: r }) {
    let s = '',
      o = !1,
      c = eX(t, e),
      u = dX(c);
    (c[0] = aX(c[0])), mX(u) && c.push('**', '*');
    let l = 0;
    for (let p of c) p === '**' ? (s += n) : (o && (s += th), (s += p.replace(JK, r))), (o = !0);
    for (; l > 0; ) (s += ')?'), l--;
    return s;
  }
  var eD = {
    singleAsteriskRegexFragment: '[^/]*',
    doubleAsteriskRegexFragment: '(/.+?)?',
    replaceWildcardCharacter: (t) => hX(t, eD.singleAsteriskRegexFragment),
  };
  function eX(t, e) {
    return iX(tX(t, e));
  }
  function tX(t, e = '') {
    return (t = QL(e, t)), pX(t, nX(t));
  }
  function iX(t) {
    if (!lX(t)) return [];
    let e = [t[0]];
    for (let i = 1; i < t.length; i++) {
      let n = t[i];
      if (n && n !== '.') {
        if (n === '..') {
          if (e.length > 1) {
            if (e[e.length - 1] !== '..') {
              e.pop();
              continue;
            }
          } else if (e[0]) continue;
        }
        e.push(n);
      }
    }
    return e;
  }
  function nX(t) {
    let e = rX(t);
    return e < 0 ? ~e : e;
  }
  function rX(t) {
    if (!t) return 0;
    let e = t.charCodeAt(0);
    if (e === 47 || e === 92) {
      if (t.charCodeAt(1) !== e) return 1;
      let n = t.indexOf(e === 47 ? th : cX, 2);
      return n < 0 ? t.length : n + 1;
    }
    if (ZL(e) && t.charCodeAt(1) === 58) {
      let n = t.charCodeAt(2);
      if (n === 47 || n === 92) return 3;
      if (t.length === 2) return 2;
    }
    let i = t.indexOf(JL);
    if (i !== -1) {
      let n = i + JL.length,
        r = t.indexOf(th, n);
      if (r !== -1) {
        let s = t.slice(0, i),
          o = t.slice(n, r);
        if (s === 'file' && (o === '' || o === 'localhost') && ZL(t.charCodeAt(r + 1))) {
          let c = uX(t, r + 2);
          if (c !== -1) {
            if (t.charCodeAt(c) === 47) return ~(c + 1);
            if (c === t.length) return ~c;
          }
        }
        return ~(r + 1);
      }
      return ~t.length;
    }
    return 0;
  }
  function sX(t) {
    return t.length > 0 && oX(t.charCodeAt(t.length - 1));
  }
  function oX(t) {
    return t === 47 || t === 92;
  }
  function aX(t) {
    return sX(t) ? t.substr(0, t.length - 1) : t;
  }
  var th = '/',
    cX = '\\',
    JL = '://';
  function ZL(t) {
    return (t >= 97 && t <= 122) || (t >= 65 && t <= 90);
  }
  function uX(t, e) {
    let i = t.charCodeAt(e);
    if (i === 58) return e + 1;
    if (i === 37 && t.charCodeAt(e + 1) === 51) {
      let n = t.charCodeAt(e + 2);
      if (n === 97 || n === 65) return e + 3;
    }
    return -1;
  }
  function lX(t, e) {
    if (t)
      if (e) {
        for (let i of t) if (e(i)) return !0;
      } else return t.length > 0;
    return !1;
  }
  function pX(t, e) {
    let i = t.substring(0, e),
      n = t.substring(e).split(th);
    return n.length && !fX(n) && n.pop(), [i, ...n];
  }
  function fX(t) {
    return t.length === 0 ? void 0 : t[t.length - 1];
  }
  function dX(t) {
    return t[t.length - 1];
  }
  function hX(t, e) {
    return t === '*' ? e : t === '?' ? '[^/]' : '\\' + t;
  }
  function mX(t) {
    return !/[.*?]/.test(t);
  }
});
var tD = P((Zle, gX) => {
  gX.exports = {
    $schema: 'https://json.schemastore.org/tsconfig',
    display: 'Node 16',
    compilerOptions: {
      lib: ['es2021'],
      module: 'Node16',
      target: 'es2021',
      strict: !0,
      esModuleInterop: !0,
      skipLibCheck: !0,
      forceConsistentCasingInFileNames: !0,
      moduleResolution: 'node',
    },
  };
});
var iD = P((Qle, xX) => {
  xX.exports = {
    $schema: 'https://json.schemastore.org/tsconfig',
    display: 'Node 14',
    compilerOptions: {
      lib: ['es2020'],
      module: 'commonjs',
      target: 'es2020',
      strict: !0,
      esModuleInterop: !0,
      skipLibCheck: !0,
      forceConsistentCasingInFileNames: !0,
      moduleResolution: 'node',
    },
  };
});
var nD = P((epe, yX) => {
  yX.exports = {
    $schema: 'https://json.schemastore.org/tsconfig',
    display: 'Node 12',
    compilerOptions: {
      lib: ['es2019', 'es2020.promise', 'es2020.bigint', 'es2020.string'],
      module: 'commonjs',
      target: 'es2019',
      strict: !0,
      esModuleInterop: !0,
      skipLibCheck: !0,
      forceConsistentCasingInFileNames: !0,
      moduleResolution: 'node',
    },
  };
});
var rD = P((tpe, bX) => {
  bX.exports = {
    $schema: 'https://json.schemastore.org/tsconfig',
    display: 'Node 10',
    compilerOptions: {
      lib: ['es2018'],
      module: 'commonjs',
      target: 'es2018',
      strict: !0,
      esModuleInterop: !0,
      skipLibCheck: !0,
      forceConsistentCasingInFileNames: !0,
      moduleResolution: 'node',
    },
  };
});
var sD = P((nh) => {
  'use strict';
  Object.defineProperty(nh, '__esModule', { value: !0 });
  nh.getDefaultTsconfigJsonForNodeVersion = void 0;
  var L0 = parseInt(process.versions.node.split('.')[0], 10);
  function vX(t) {
    let e = t;
    if (L0 >= 16) {
      let n = tD();
      if (i(n)) return n;
    }
    if (L0 >= 14) {
      let n = iD();
      if (i(n)) return n;
    }
    if (L0 >= 12) {
      let n = nD();
      if (i(n)) return n;
    }
    return rD();
    function i(n) {
      return (
        typeof t.ScriptTarget[n.compilerOptions.target.toUpperCase()] == 'number' &&
        e.libs &&
        n.compilerOptions.lib.every((r) => e.libs.includes(r))
      );
    }
  }
  nh.getDefaultTsconfigJsonForNodeVersion = vX;
});
var lD = P((bi) => {
  'use strict';
  Object.defineProperty(bi, '__esModule', { value: !0 });
  bi.getTsConfigDefaults =
    bi.ComputeAsCommonRootOfFiles =
    bi.loadCompiler =
    bi.resolveAndLoadCompiler =
    bi.readConfig =
    bi.findAndReadConfig =
      void 0;
  var ko = require('path'),
    _s = fc(),
    wX = P0(),
    EX = sD(),
    Ao = Vn(),
    _X = { sourceMap: !0, inlineSourceMap: !1, inlineSources: !0, declaration: !1, noEmit: !1, outDir: '.ts-node' };
  function SX(t, e) {
    return (
      delete e.options.out,
      delete e.options.outFile,
      delete e.options.composite,
      delete e.options.declarationDir,
      delete e.options.declarationMap,
      delete e.options.emitDeclarationOnly,
      e.options.target === void 0 && (e.options.target = t.ScriptTarget.ES5),
      e.options.module === void 0 && (e.options.module = t.ModuleKind.CommonJS),
      e
    );
  }
  function CX(t) {
    var e, i, n, r, s;
    let o = (0, ko.resolve)(
        (n = (i = (e = t.cwd) !== null && e !== void 0 ? e : t.dir) !== null && i !== void 0 ? i : _s.DEFAULTS.cwd) !==
          null && n !== void 0
          ? n
          : process.cwd()
      ),
      c = (r = t.compiler) !== null && r !== void 0 ? r : _s.DEFAULTS.compiler,
      u = (0, Ao.getBasePathForProjectLocalDependencyResolution)(void 0, t.projectSearchDir, t.project, o),
      { compiler: l, ts: p } = aD(c, u),
      { configFilePath: d, config: x, tsNodeOptionsFromTsconfig: b, optionBasePaths: g } = oD(o, p, t),
      y = (0, Ao.assign)({}, _s.DEFAULTS, b || {}, { optionBasePaths: g }, t);
    return (
      (y.require = [...(b.require || []), ...(t.require || [])]),
      d &&
        ((u = (0, Ao.getBasePathForProjectLocalDependencyResolution)(d, t.projectSearchDir, t.project, o)),
        ({ compiler: l } = cD(y.compiler, (s = g.compiler) !== null && s !== void 0 ? s : u))),
      { options: y, config: x, projectLocalResolveDir: u, optionBasePaths: g, configFilePath: d, cwd: o, compiler: l }
    );
  }
  bi.findAndReadConfig = CX;
  function oD(t, e, i) {
    var n, r, s;
    let o = [],
      c = { compilerOptions: {} },
      u = t,
      l,
      p = (0, ko.resolve)(t, (n = i.projectSearchDir) !== null && n !== void 0 ? n : t),
      {
        fileExists: d = e.sys.fileExists,
        readFile: x = e.sys.readFile,
        skipProject: b = _s.DEFAULTS.skipProject,
        project: g = _s.DEFAULTS.project,
        tsTrace: y = _s.DEFAULTS.tsTrace,
      } = i;
    if (!b) {
      if (g) {
        let N = (0, ko.resolve)(t, g),
          D = (0, ko.join)(N, 'tsconfig.json');
        l = d(D) ? D : N;
      } else l = e.findConfigFile(p, d);
      if (l) {
        let N = l,
          D = (0, wX.createTsInternals)(e),
          z = [];
        for (;;) {
          let H = e.readConfigFile(N, x);
          if (H.error)
            return {
              configFilePath: l,
              config: { errors: [H.error], fileNames: [], options: {} },
              tsNodeOptionsFromTsconfig: {},
              optionBasePaths: {},
            };
          let F = H.config,
            ne = (0, ko.dirname)(N);
          if ((o.push({ config: F, basePath: ne, configPath: N }), F.extends == null)) break;
          let pe = D.getExtendsConfigPath(
            F.extends,
            {
              fileExists: d,
              readDirectory: e.sys.readDirectory,
              readFile: x,
              useCaseSensitiveFileNames: e.sys.useCaseSensitiveFileNames,
              trace: y,
            },
            ne,
            z,
            e.createCompilerDiagnostic
          );
          if (z.length)
            return {
              configFilePath: l,
              config: { errors: z, fileNames: [], options: {} },
              tsNodeOptionsFromTsconfig: {},
              optionBasePaths: {},
            };
          if (pe == null) break;
          N = pe;
        }
        ({ config: c, basePath: u } = o[0]);
      }
    }
    let h = {},
      v = {};
    for (let N = o.length - 1; N >= 0; N--) {
      let { config: D, basePath: z, configPath: H } = o[N],
        F = RX(D['ts-node']).recognized;
      if (F.require) {
        let ne = (0, Ao.createProjectLocalResolveHelper)((0, ko.dirname)(H));
        F.require = F.require.map((pe) => ne(pe, !1));
      }
      F.scopeDir && (F.scopeDir = (0, ko.resolve)(z, F.scopeDir)),
        F.moduleTypes && (v.moduleTypes = z),
        F.transpiler != null && (v.transpiler = z),
        F.compiler != null && (v.compiler = z),
        F.swc != null && (v.swc = z),
        (0, Ao.assign)(h, F);
    }
    let C = (s = (r = i.files) !== null && r !== void 0 ? r : h.files) !== null && s !== void 0 ? s : _s.DEFAULTS.files,
      m = l != null ? void 0 : { ...(0, EX.getDefaultTsconfigJsonForNodeVersion)(e).compilerOptions, types: ['node'] };
    c.compilerOptions = Object.assign(
      {},
      m,
      c.compilerOptions,
      _s.DEFAULTS.compilerOptions,
      h.compilerOptions,
      i.compilerOptions,
      _X
    );
    let O = SX(
      e,
      e.parseJsonConfigFileContent(
        c,
        {
          fileExists: d,
          readFile: x,
          readDirectory: C ? e.sys.readDirectory : () => [],
          useCaseSensitiveFileNames: e.sys.useCaseSensitiveFileNames,
        },
        u,
        void 0,
        l
      )
    );
    return { configFilePath: l, config: O, tsNodeOptionsFromTsconfig: h, optionBasePaths: v };
  }
  bi.readConfig = oD;
  function aD(t, e) {
    let { compiler: i } = cD(t, e),
      n = uD(i);
    return { compiler: i, ts: n };
  }
  bi.resolveAndLoadCompiler = aD;
  function cD(t, e) {
    return { compiler: (0, Ao.createProjectLocalResolveHelper)(e)(t || 'typescript', !0) };
  }
  function uD(t) {
    return (0, Ao.attemptRequireWithV8CompileCache)(require, t);
  }
  bi.loadCompiler = uD;
  function RX(t) {
    if (t == null) return { recognized: {}, unrecognized: {} };
    let {
        compiler: e,
        compilerHost: i,
        compilerOptions: n,
        emit: r,
        files: s,
        ignore: o,
        ignoreDiagnostics: c,
        logError: u,
        preferTsExts: l,
        pretty: p,
        require: d,
        skipIgnore: x,
        transpileOnly: b,
        typeCheck: g,
        transpiler: y,
        scope: h,
        scopeDir: v,
        moduleTypes: C,
        experimentalReplAwait: _,
        swc: m,
        experimentalResolver: O,
        esm: N,
        experimentalSpecifierResolution: D,
        experimentalTsImportSpecifiers: z,
        ...H
      } = t,
      F = {
        compiler: e,
        compilerHost: i,
        compilerOptions: n,
        emit: r,
        experimentalReplAwait: _,
        files: s,
        ignore: o,
        ignoreDiagnostics: c,
        logError: u,
        preferTsExts: l,
        pretty: p,
        require: d,
        skipIgnore: x,
        transpileOnly: b,
        typeCheck: g,
        transpiler: y,
        scope: h,
        scopeDir: v,
        moduleTypes: C,
        swc: m,
        experimentalResolver: O,
        esm: N,
        experimentalSpecifierResolution: D,
        experimentalTsImportSpecifiers: z,
      },
      ne = null,
      pe = null;
    return { recognized: F, unrecognized: H };
  }
  bi.ComputeAsCommonRootOfFiles = Symbol();
  function TX(t, e, i, n, r) {
    let { composite: s = !1 } = t.options,
      o = t.options.rootDir;
    o == null && (s ? (o = e) : (o = bi.ComputeAsCommonRootOfFiles));
    let { outDir: c = o } = t.options;
    return { rootDir: o, outDir: c, include: i ? [] : ['**/*'], files: i ?? [], exclude: r ?? [c], composite: s };
  }
  bi.getTsConfigDefaults = TX;
});
var pD = P((rh) => {
  'use strict';
  Object.defineProperty(rh, '__esModule', { value: !0 });
  rh.createModuleTypeClassifier = void 0;
  var OX = P0(),
    D0 = Vn();
  function kX(t) {
    let { patterns: e, basePath: i } = t,
      n = i !== void 0 ? (0, D0.normalizeSlashes)(i).replace(/\/$/, '') : void 0,
      r = Object.entries(e ?? []).map(([p, d]) => {
        let x = (0, D0.normalizeSlashes)(p);
        return { pattern: AX(n, x), type: d };
      }),
      s = { package: { moduleType: 'auto' }, cjs: { moduleType: 'cjs' }, esm: { moduleType: 'esm' } },
      o = s.package;
    function c(p) {
      let d = IX(r, (x) => x.pattern, p);
      return d ? s[d.type] : o;
    }
    let u = (0, D0.cachedLookup)(c);
    function l(p) {
      return o;
    }
    return { classifyModuleByModuleTypeOverrides: r.length ? u : l };
  }
  rh.createModuleTypeClassifier = kX;
  function AX(t, e) {
    let i = (0, OX.getPatternFromSpec)(e, t);
    return i !== void 0 ? new RegExp(i) : /(?:)/;
  }
  function IX(t, e, i) {
    for (let n = t.length - 1; n >= 0; n--) {
      let r = t[n],
        s = e(r);
      if (s != null && s.test(i)) return r;
    }
  }
});
var fD = P((sh) => {
  'use strict';
  Object.defineProperty(sh, '__esModule', { value: !0 });
  sh.createResolverFunctions = void 0;
  var NX = require('path');
  function PX(t) {
    let {
        host: e,
        ts: i,
        config: n,
        cwd: r,
        getCanonicalFileName: s,
        projectLocalResolveHelper: o,
        options: c,
        extensions: u,
      } = t,
      l = i.createModuleResolutionCache(r, s, n.options),
      p = new Set(),
      d = new Set(),
      x = /.*\/node_modules\/(?:@[^\/]+\/)?[^\/]+\//;
    function b(O) {
      let N = x.exec(O);
      return N ? N[0] : '';
    }
    function g(O) {
      d.add(b(O));
    }
    function y(O) {
      return d.has(b(O));
    }
    function h(O) {
      return p.has(O);
    }
    let v = (O) => {
      let { resolvedFileName: N } = O;
      N !== void 0 &&
        (O.isExternalLibraryImport &&
          ((N.endsWith('.ts') && !N.endsWith('.d.ts')) ||
            (N.endsWith('.cts') && !N.endsWith('.d.cts')) ||
            (N.endsWith('.mts') && !N.endsWith('.d.mts')) ||
            h(N) ||
            y(N)) &&
          (O.isExternalLibraryImport = !1),
        O.isExternalLibraryImport || p.add(N));
    };
    return {
      resolveModuleNames: (O, N, D, z, H, F) =>
        O.map((ne, pe) => {
          var le, V;
          let W = F
              ? (V = (le = i).getModeForResolutionAtIndex) === null || V === void 0
                ? void 0
                : V.call(le, F, pe)
              : void 0,
            { resolvedModule: K } = i.resolveModuleName(ne, N, n.options, e, l, z, W);
          if (!K && c.experimentalTsImportSpecifiers) {
            let q = ne.lastIndexOf('.'),
              B = q >= 0 ? ne.slice(q) : '';
            if (B) {
              let ee = u.tsResolverEquivalents.get(B);
              for (let xe of ee ?? [])
                if (
                  (({ resolvedModule: K } = i.resolveModuleName(ne.slice(0, -B.length) + xe, N, n.options, e, l, z, W)),
                  K)
                )
                  break;
            }
          }
          return K && v(K), K;
        }),
      getResolvedModuleWithFailedLookupLocationsFromCache: (O, N, D) => {
        let z = i.resolveModuleNameFromCache(O, N, l, D);
        return z && z.resolvedModule && v(z.resolvedModule), z;
      },
      resolveTypeReferenceDirectives: (O, N, D, z, H) =>
        O.map((F) => {
          let ne = typeof F == 'string',
            pe = ne ? void 0 : i.getModeForFileReference(F, H),
            le = ne ? F : F.fileName.toLowerCase(),
            { resolvedTypeReferenceDirective: V } = i.resolveTypeReferenceDirective(le, N, n.options, e, D, void 0, pe);
          if (F === 'node' && !V) {
            let W;
            try {
              W = o('@types/node/package.json', !0);
            } catch {}
            if (W) {
              let K = [(0, NX.resolve)(W, '../..')];
              ({ resolvedTypeReferenceDirective: V } = i.resolveTypeReferenceDirective(
                F,
                N,
                { ...n.options, typeRoots: K },
                e,
                D
              ));
            }
          }
          return V && v(V), V;
        }),
      isFileKnownToBeInternal: h,
      markBucketOfFilenameInternal: g,
    };
  }
  sh.createResolverFunctions = PX;
});
var dD = P((oh) => {
  'use strict';
  Object.defineProperty(oh, '__esModule', { value: !0 });
  oh.installCommonjsResolveHooksIfNecessary = void 0;
  function LX(t) {
    let e = require('module'),
      i = e._resolveFilename,
      n = e._findPath;
    if (t.options.experimentalResolver) {
      let c = function (l, p, d, x, ...b) {
          return t.enabled() ? o.call(this, l, p, d, x, ...b) : i.call(this, l, p, d, x, ...b);
        },
        u = function () {
          return t.enabled() ? s.apply(this, arguments) : n.apply(this, arguments);
        },
        { Module_findPath: s, Module_resolveFilename: o } = t.getNodeCjsLoader();
      (e._resolveFilename = c), (e._findPath = u);
    }
  }
  oh.installCommonjsResolveHooksIfNecessary = LX;
});
var Io = P((ape, hD) => {
  'use strict';
  hD.exports = {
    ArrayFrom: Array.from,
    ArrayIsArray: Array.isArray,
    ArrayPrototypeShift: (t) => Array.prototype.shift.call(t),
    ArrayPrototypeForEach: (t, ...e) => Array.prototype.forEach.apply(t, e),
    ArrayPrototypeIncludes: (t, ...e) => Array.prototype.includes.apply(t, e),
    ArrayPrototypeJoin: (t, ...e) => Array.prototype.join.apply(t, e),
    ArrayPrototypePop: (t, ...e) => Array.prototype.pop.apply(t, e),
    ArrayPrototypePush: (t, ...e) => Array.prototype.push.apply(t, e),
    FunctionPrototype: Function.prototype,
    JSONParse: JSON.parse,
    JSONStringify: JSON.stringify,
    ObjectFreeze: Object.freeze,
    ObjectKeys: Object.keys,
    ObjectGetOwnPropertyNames: Object.getOwnPropertyNames,
    ObjectDefineProperty: Object.defineProperty,
    ObjectPrototypeHasOwnProperty: (t, e) => Object.prototype.hasOwnProperty.call(t, e),
    RegExpPrototypeExec: (t, e) => RegExp.prototype.exec.call(t, e),
    RegExpPrototypeTest: (t, e) => RegExp.prototype.test.call(t, e),
    RegExpPrototypeSymbolReplace: (t, ...e) => RegExp.prototype[Symbol.replace].apply(t, e),
    SafeMap: Map,
    SafeSet: Set,
    SafeWeakMap: WeakMap,
    StringPrototypeEndsWith: (t, ...e) => String.prototype.endsWith.apply(t, e),
    StringPrototypeIncludes: (t, ...e) => String.prototype.includes.apply(t, e),
    StringPrototypeLastIndexOf: (t, ...e) => String.prototype.lastIndexOf.apply(t, e),
    StringPrototypeIndexOf: (t, ...e) => String.prototype.indexOf.apply(t, e),
    StringPrototypeRepeat: (t, ...e) => String.prototype.repeat.apply(t, e),
    StringPrototypeReplace: (t, ...e) => String.prototype.replace.apply(t, e),
    StringPrototypeSlice: (t, ...e) => String.prototype.slice.apply(t, e),
    StringPrototypeSplit: (t, ...e) => String.prototype.split.apply(t, e),
    StringPrototypeStartsWith: (t, ...e) => String.prototype.startsWith.apply(t, e),
    StringPrototypeSubstr: (t, ...e) => String.prototype.substr.apply(t, e),
    StringPrototypeCharCodeAt: (t, ...e) => String.prototype.charCodeAt.apply(t, e),
    StringPrototypeMatch: (t, ...e) => String.prototype.match.apply(t, e),
    SyntaxError,
  };
});
var F0 = P((mD) => {
  'use strict';
  var DX = require('module'),
    FX = {
      canBeRequiredByUsers(t) {
        return DX.builtinModules.includes(t);
      },
    };
  mD.NativeModule = FX;
});
var M0 = P((upe, xD) => {
  'use strict';
  var j0 = require('fs'),
    { versionGteLt: gD } = Vn();
  function jX(t) {
    let e;
    try {
      e = j0.readFileSync(t, 'utf8');
    } catch (n) {
      if (n.code === 'ENOENT') return [];
      throw n;
    }
    return [e, !0];
  }
  function MX(t) {
    let e = j0.statSync(t, { throwIfNoEntry: !1 });
    if (!e) return -1;
    if (e.isFile()) return 0;
    if (e.isDirectory()) return 1;
  }
  function UX(t) {
    try {
      let e = j0.statSync(t);
      if (e.isFile()) return 0;
      if (e.isDirectory()) return 1;
    } catch (e) {
      return -e.errno || -1;
    }
  }
  var qX = gD(process.versions.node, '15.3.0') || gD(process.versions.node, '14.17.0', '15.0.0');
  xD.exports = { internalModuleReadJSON: jX, internalModuleStat: qX ? MX : UX };
});
var q0 = P((lpe, yD) => {
  'use strict';
  var { SafeMap: BX } = Io(),
    { internalModuleReadJSON: HX } = M0(),
    { pathToFileURL: GX } = require('url'),
    { toNamespacedPath: zX } = require('path'),
    U0 = new BX(),
    ah;
  function VX(t) {
    if (U0.has(t)) return U0.get(t);
    let [e, i] = HX(zX(t)),
      n = { string: e, containsKeys: i };
    if (e !== void 0 && (ah === void 0 && (ah = null), ah !== null)) {
      let r = GX(t);
      ah.assertIntegrity(r, e);
    }
    return U0.set(t, n), n;
  }
  yD.exports = { read: VX };
});
var vD = P((ppe, bD) => {
  'use strict';
  var B0 = Symbol('arg flag');
  function ch(t, { argv: e = process.argv.slice(2), permissive: i = !1, stopAtPositional: n = !1 } = {}) {
    if (!t) throw new Error('Argument specification object is required');
    let r = { _: [] },
      s = {},
      o = {};
    for (let c of Object.keys(t)) {
      if (!c) throw new TypeError('Argument key cannot be an empty string');
      if (c[0] !== '-') throw new TypeError(`Argument key must start with '-' but found: '${c}'`);
      if (c.length === 1) throw new TypeError(`Argument key must have a name; singular '-' keys are not allowed: ${c}`);
      if (typeof t[c] == 'string') {
        s[c] = t[c];
        continue;
      }
      let u = t[c],
        l = !1;
      if (Array.isArray(u) && u.length === 1 && typeof u[0] == 'function') {
        let [p] = u;
        (u = (d, x, b = []) => (b.push(p(d, x, b[b.length - 1])), b)), (l = p === Boolean || p[B0] === !0);
      } else if (typeof u == 'function') l = u === Boolean || u[B0] === !0;
      else throw new TypeError(`Type missing or not a function or valid array type: ${c}`);
      if (c[1] !== '-' && c.length > 2)
        throw new TypeError(`Short argument keys (with a single hyphen) must have only one character: ${c}`);
      o[c] = [u, l];
    }
    for (let c = 0, u = e.length; c < u; c++) {
      let l = e[c];
      if (n && r._.length > 0) {
        r._ = r._.concat(e.slice(c));
        break;
      }
      if (l === '--') {
        r._ = r._.concat(e.slice(c + 1));
        break;
      }
      if (l.length > 1 && l[0] === '-') {
        let p =
          l[1] === '-' || l.length === 2
            ? [l]
            : l
                .slice(1)
                .split('')
                .map((d) => `-${d}`);
        for (let d = 0; d < p.length; d++) {
          let x = p[d],
            [b, g] = x[1] === '-' ? x.split(/=(.*)/, 2) : [x, void 0],
            y = b;
          for (; y in s; ) y = s[y];
          if (!(y in o))
            if (i) {
              r._.push(x);
              continue;
            } else {
              let C = new Error(`Unknown or unexpected option: ${b}`);
              throw ((C.code = 'ARG_UNKNOWN_OPTION'), C);
            }
          let [h, v] = o[y];
          if (!v && d + 1 < p.length)
            throw new TypeError(`Option requires argument (but was followed by another short argument): ${b}`);
          if (v) r[y] = h(!0, y, r[y]);
          else if (g === void 0) {
            if (
              e.length < c + 2 ||
              (e[c + 1].length > 1 &&
                e[c + 1][0] === '-' &&
                !(e[c + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (h === Number || (typeof BigInt < 'u' && h === BigInt))))
            ) {
              let C = b === y ? '' : ` (alias for ${y})`;
              throw new Error(`Option requires argument: ${b}${C}`);
            }
            (r[y] = h(e[c + 1], y, r[y])), ++c;
          } else r[y] = h(g, y, r[y]);
        }
      } else r._.push(l);
    }
    return r;
  }
  ch.flag = (t) => ((t[B0] = !0), t);
  ch.COUNT = ch.flag((t, e, i) => (i || 0) + 1);
  bD.exports = ch;
});
var ml = P((ED) => {
  'use strict';
  ED.getOptionValue = $X;
  function $X(t) {
    return WX(), H0[t];
  }
  var H0;
  function WX() {
    H0 ||
      (H0 = {
        '--preserve-symlinks': !1,
        '--preserve-symlinks-main': !1,
        '--input-type': void 0,
        '--experimental-specifier-resolution': 'explicit',
        '--experimental-policy': void 0,
        '--conditions': [],
        '--pending-deprecation': !1,
        ...wD(KX()),
        ...wD(process.execArgv),
        ...YX(),
      });
  }
  function wD(t) {
    return vD()(
      {
        '--preserve-symlinks': Boolean,
        '--preserve-symlinks-main': Boolean,
        '--input-type': String,
        '--experimental-specifier-resolution': String,
        '--es-module-specifier-resolution': '--experimental-specifier-resolution',
        '--experimental-policy': String,
        '--conditions': [String],
        '--pending-deprecation': Boolean,
        '--experimental-json-modules': Boolean,
        '--experimental-wasm-modules': Boolean,
      },
      { argv: t, permissive: !0 }
    );
  }
  function KX() {
    let t = [],
      e = XX(process.env.NODE_OPTIONS || '', t);
    return t.length, e;
  }
  function XX(t, e) {
    let i = [],
      n = !1,
      r = !0;
    for (let s = 0; s < t.length; ++s) {
      let o = t[s];
      if (o === '\\' && n) {
        if (s + 1 === t.length)
          return (
            e.push(`invalid value for NODE_OPTIONS (invalid escape)
`),
            i
          );
        o = t[++s];
      } else if (o === ' ' && !n) {
        r = !0;
        continue;
      } else if (o === '"') {
        n = !n;
        continue;
      }
      r ? (i.push(o), (r = !1)) : (i[i.length - 1] += o);
    }
    return (
      n &&
        e.push(`invalid value for NODE_OPTIONS (unterminated string)
`),
      i
    );
  }
  function YX() {
    let t = {};
    return process.env.NODE_PENDING_DEPRECATION === '1' && (t['--pending-deprecation'] = !0), t;
  }
});
var CD = P((G0) => {
  'use strict';
  var {
      ArrayPrototypeForEach: JX,
      ObjectDefineProperty: _D,
      ObjectPrototypeHasOwnProperty: ZX,
      SafeSet: QX,
      StringPrototypeIncludes: eY,
      StringPrototypeStartsWith: tY,
    } = Io(),
    { getOptionValue: SD } = ml(),
    iY = SD('--conditions'),
    nY = SD('--no-addons'),
    rY = nY ? [] : ['node-addons'],
    sY = new QX(['require', 'node', ...rY, ...iY]);
  function oY(t, e) {
    let i = require('module').Module,
      { builtinModules: n } = i,
      r = new i(e);
    JX(n, (s) => {
      if (tY(s, '_') || eY(s, '/') || ZX(t, s)) return;
      let o = (c) => {
        delete t[s], (t[s] = c);
      };
      _D(t, s, {
        get: () => {
          let c = (r.require || require)(s);
          return delete t[s], _D(t, s, { get: () => c, set: o, configurable: !0, enumerable: !1 }), c;
        },
        set: o,
        configurable: !0,
        enumerable: !1,
      });
    });
  }
  G0.addBuiltinLibsToObject = oY;
  G0.cjsConditions = sY;
});
var gl = P((z0) => {
  'use strict';
  var aY = require('path');
  z0.codes = {
    ERR_INPUT_TYPE_NOT_ALLOWED: an(Sn('ERR_INPUT_TYPE_NOT_ALLOWED')),
    ERR_INVALID_ARG_VALUE: an(Sn('ERR_INVALID_ARG_VALUE')),
    ERR_INVALID_MODULE_SPECIFIER: an(Sn('ERR_INVALID_MODULE_SPECIFIER')),
    ERR_INVALID_PACKAGE_CONFIG: an(Sn('ERR_INVALID_PACKAGE_CONFIG')),
    ERR_INVALID_PACKAGE_TARGET: an(Sn('ERR_INVALID_PACKAGE_TARGET')),
    ERR_MANIFEST_DEPENDENCY_MISSING: an(Sn('ERR_MANIFEST_DEPENDENCY_MISSING')),
    ERR_MODULE_NOT_FOUND: an((t, e, i = 'package') => `Cannot find ${i} '${t}' imported from ${e}`),
    ERR_PACKAGE_IMPORT_NOT_DEFINED: an(Sn('ERR_PACKAGE_IMPORT_NOT_DEFINED')),
    ERR_PACKAGE_PATH_NOT_EXPORTED: an(Sn('ERR_PACKAGE_PATH_NOT_EXPORTED')),
    ERR_UNSUPPORTED_DIR_IMPORT: an(Sn('ERR_UNSUPPORTED_DIR_IMPORT')),
    ERR_UNSUPPORTED_ESM_URL_SCHEME: an(Sn('ERR_UNSUPPORTED_ESM_URL_SCHEME')),
    ERR_UNKNOWN_FILE_EXTENSION: an(Sn('ERR_UNKNOWN_FILE_EXTENSION')),
  };
  function Sn(t) {
    return (...e) => [t, ...e].join(' ');
  }
  function an(t) {
    return class extends Error {
      constructor(...i) {
        super(t(...i));
      }
    };
  }
  z0.createErrRequireEsm = cY;
  function cY(t, e, i) {
    let n = 'ERR_REQUIRE_ESM',
      r = new Error(uY(t, e, i));
    return (
      (r.name = `Error [${n}]`),
      r.stack,
      Object.defineProperty(r, 'name', { value: 'Error', enumerable: !1, writable: !0, configurable: !0 }),
      (r.code = n),
      r
    );
  }
  function uY(t, e = null, i = null) {
    let n = aY.extname(t),
      r = `Must use import to load ES Module: ${t}`;
    if (e && i) {
      let s = require('path'),
        o = s.basename(t) === s.basename(e) ? t : s.basename(t);
      return (
        (r += `
require() of ES modules is not supported.
require() of ${t} ${
          e ? `from ${e} ` : ''
        }is an ES module file as it is a ${n} file whose nearest parent package.json contains "type": "module" which defines all ${n} files in that package scope as ES modules.
Instead change the requiring code to use import(), or remove "type": "module" from ${i}.
`),
        r
      );
    }
    return r;
  }
});
var TD = P((gpe, RD) => {
  'use strict';
  RD.exports = { CHAR_FORWARD_SLASH: 47 };
});
var hh = P((xpe, DD) => {
  'use strict';
  var {
      ArrayIsArray: lY,
      ArrayPrototypeIncludes: pY,
      ArrayPrototypeJoin: V0,
      ArrayPrototypePush: OD,
      JSONParse: fY,
      ObjectKeys: kD,
      RegExpPrototypeTest: AD,
      SafeMap: ND,
      SafeWeakMap: dY,
      StringPrototypeCharCodeAt: hY,
      StringPrototypeEndsWith: mY,
      StringPrototypeLastIndexOf: gY,
      StringPrototypeIndexOf: xY,
      StringPrototypeMatch: yY,
      StringPrototypeSlice: PD,
      StringPrototypeStartsWith: dc,
    } = Io(),
    { NativeModule: bY } = F0(),
    { pathToFileURL: uh, fileURLToPath: vY } = require('url'),
    wY = require('fs'),
    Jt = require('path'),
    { sep: lh } = Jt,
    { internalModuleStat: EY } = M0(),
    _Y = q0(),
    { cjsConditions: $0 } = CD(),
    { getOptionValue: LD } = ml(),
    ID = LD('--preserve-symlinks'),
    SY = LD('--preserve-symlinks-main'),
    { normalizeSlashes: CY } = Vn(),
    { createErrRequireEsm: RY } = gl(),
    {
      codes: { ERR_INVALID_MODULE_SPECIFIER: TY },
    } = gl(),
    { CHAR_FORWARD_SLASH: OY } = TD(),
    Cn = require('module'),
    kY = process.platform === 'win32',
    ph = null;
  function fh(t) {
    if (((t = Jt.toNamespacedPath(t)), ph !== null)) {
      let i = ph.get(t);
      if (i !== void 0) return i;
    }
    let e = EY(t);
    return ph !== null && e >= 0 && ph.set(t, e), e;
  }
  var AY = new dY(),
    W0 = new ND();
  function K0(t) {
    let e = Jt.resolve(t, 'package.json'),
      i = W0.get(e);
    if (i !== void 0) return i;
    let n = _Y.read(e),
      r = n.containsKeys === !1 ? '{}' : n.string;
    if (r === void 0) return W0.set(e, !1), !1;
    try {
      let s = fY(r),
        o = { name: s.name, main: s.main, exports: s.exports, imports: s.imports, type: s.type };
      return W0.set(e, o), o;
    } catch (s) {
      throw ((s.path = e), (s.message = 'Error parsing ' + e + ': ' + s.message), s);
    }
  }
  function dh(t) {
    let e = xY(t, lh),
      i;
    do {
      if (((i = gY(t, lh)), (t = PD(t, 0, i)), mY(t, lh + 'node_modules'))) return !1;
      let n = K0(t + lh);
      if (n) return { data: n, path: t };
    } while (i > e);
    return !1;
  }
  function IY(t) {
    let { nodeEsmResolver: e, preferTsExts: i } = t,
      { replacementsForCjs: n, replacementsForJs: r, replacementsForMjs: s, replacementsForJsx: o } = t.extensions,
      { encodedSepRegEx: c, packageExportsResolve: u, packageImportsResolve: l } = e;
    function p(V, W, K, q) {
      let B = K0(V),
        ee = B != null ? B.main : void 0;
      if (!ee) return h(Jt.resolve(V, 'index'), W, K);
      let xe = Jt.resolve(V, ee),
        de = y(xe, K) || x(xe, K) || h(xe, W, K) || h(Jt.resolve(xe, 'index'), W, K);
      if (de === !1)
        if (((de = h(Jt.resolve(V, 'index'), W, K)), de)) {
          let Z = Jt.resolve(V, 'package.json');
          process.emitWarning(
            `Invalid 'main' field in '${Z}' of '${ee}'. Please either fix that or report it to the module author`,
            'DeprecationWarning',
            'DEP0128'
          );
        } else {
          let Z = new Error(`Cannot find module '${xe}'. Please verify that the package.json has a valid "main" entry`);
          throw ((Z.code = 'MODULE_NOT_FOUND'), (Z.path = Jt.resolve(V, 'package.json')), (Z.requestPath = q), Z);
        }
      return de;
    }
    let d = new ND();
    function x(V, W) {
      if (fh(V) === 0) return ID && !W ? Jt.resolve(V) : b(V);
    }
    function b(V) {
      return wY.realpathSync(V, {});
    }
    function g(V) {
      let W = V.lastIndexOf('.');
      if (W >= 0) {
        let K = V.slice(W);
        if (K === '.js' || K === '.jsx' || K === '.mjs' || K === '.cjs') {
          let q = V.slice(0, W),
            B = K === '.js' ? r : K === '.jsx' ? o : K === '.mjs' ? s : n;
          for (let ee = 0; ee < B.length; ee++) {
            let xe = q + B[ee],
              de = fh(xe);
            if (de === 0) return [de, xe];
          }
        }
      }
      return [fh(V), V];
    }
    function y(V, W) {
      let K = V.lastIndexOf('.');
      if (K >= 0) {
        let q = V.slice(K);
        if (q === '.js' || q === '.jsx' || q === '.mjs' || q === '.cjs') {
          let B = V.slice(0, K),
            ee = q === '.js' ? r : q === '.jsx' ? o : q === '.mjs' ? s : n;
          for (let xe = 0; xe < ee.length; xe++) {
            let de = x(B + ee[xe], W);
            if (de) return de;
          }
        }
      }
      return !1;
    }
    function h(V, W, K) {
      for (let q = 0; q < W.length; q++) {
        let B = x(V + W[q], K);
        if (B) return B;
      }
      return !1;
    }
    function v(V) {
      if (!V) return !1;
      if (V.filename) return V.filename;
      if (V.id === '<repl>' || V.id === 'internal/preload')
        try {
          return process.cwd() + Jt.sep;
        } catch {
          return !1;
        }
    }
    function C(V, W) {
      if (!V) return !1;
      let { data: K, path: q } = dh(V) || {};
      if (!K || K.exports === void 0 || typeof K.name != 'string') return !1;
      let B;
      if (W === K.name) B = '.';
      else if (dc(W, `${K.name}/`)) B = '.' + PD(W, K.name.length);
      else return !1;
      try {
        return pe(u(uh(q + '/package.json'), B, K, uh(V), $0).resolved, V, q);
      } catch (ee) {
        throw ee.code === 'ERR_MODULE_NOT_FOUND' ? le(W, q + '/package.json') : ee;
      }
    }
    let _ = /^((?:@[^/\\%]+\/)?[^./\\%][^/\\%]*)(\/.*)?$/;
    function m(V, W) {
      let { 1: K, 2: q = '' } = yY(W, _) || [];
      if (!K) return;
      let B = Jt.resolve(V, K),
        ee = K0(B);
      if (ee != null && ee.exports != null)
        try {
          return pe(u(uh(B + '/package.json'), '.' + q, ee, null, $0).resolved, null, B);
        } catch (xe) {
          throw xe.code === 'ERR_MODULE_NOT_FOUND' ? le(W, B + '/package.json') : xe;
        }
    }
    let O = !!require('module')._pathCache,
      N = Object.create(null),
      D = O ? (V) => Cn._pathCache[V] : (V) => N[V],
      z = O ? (V, W) => (Cn._pathCache[V] = W) : (V) => (N[V] = value),
      H = /(?:^|\/)\.?\.$/,
      F = function (W, K, q) {
        let B = Jt.isAbsolute(W);
        if (B) K = [''];
        else if (!K || K.length === 0) return !1;
        let ee = W + '\0' + V0(K, '\0'),
          xe = D(ee);
        if (xe) return xe;
        let de,
          Z = W.length > 0 && hY(W, W.length - 1) === OY;
        Z || (Z = AD(H, W));
        for (let oe = 0; oe < K.length; oe++) {
          let I = K[oe];
          if (I && fh(I) < 1) continue;
          if (!B) {
            let ye = m(I, W);
            if (ye) return ye;
          }
          let X = Jt.resolve(I, W),
            Q,
            [ae, ce] = g(X);
          if (
            (Z ||
              (ae === 0 && (q ? (SY ? (Q = Jt.resolve(ce)) : (Q = b(ce))) : ID ? (Q = Jt.resolve(ce)) : (Q = b(ce))),
              Q || (de === void 0 && (de = kD(Cn._extensions)), (Q = h(ce, de, q)))),
            !Q && ae === 1 && (de === void 0 && (de = kD(Cn._extensions)), (Q = p(ce, de, q, W))),
            Q)
          )
            return z(ee, Q), Q;
        }
        return !1;
      },
      ne = function (W, K, q, B) {
        if (dc(W, 'node:') || bY.canBeRequiredByUsers(W)) return W;
        let ee;
        if (typeof B == 'object' && B !== null)
          if (lY(B.paths))
            if (dc(W, './') || dc(W, '../') || (kY && dc(W, '.\\')) || dc(W, '..\\')) ee = B.paths;
            else {
              let ae = new Cn('', null);
              ee = [];
              for (let ce = 0; ce < B.paths.length; ce++) {
                let ye = B.paths[ce];
                ae.paths = Cn._nodeModulePaths(ye);
                let ve = Cn._resolveLookupPaths(W, ae);
                for (let Ce = 0; Ce < ve.length; Ce++) pY(ee, ve[Ce]) || OD(ee, ve[Ce]);
              }
            }
          else if (B.paths === void 0) ee = Cn._resolveLookupPaths(W, K);
          else throw new ERR_INVALID_ARG_VALUE('options.paths', B.paths);
        else ee = Cn._resolveLookupPaths(W, K);
        if (K != null && K.filename && W[0] === '#') {
          let Q = dh(K.filename) || {};
          if (Q.data != null && Q.data.imports != null)
            try {
              return pe(l(W, uh(K.filename), $0), K.filename, Q.path);
            } catch (ae) {
              throw ae.code === 'ERR_MODULE_NOT_FOUND' ? le(W) : ae;
            }
        }
        let xe = v(K),
          de = C(xe, W);
        if (de) {
          let Q = W + '\0' + (ee.length === 1 ? ee[0] : V0(ee, '\0'));
          return (Cn._pathCache[Q] = de), de;
        }
        let Z = Cn._findPath(W, ee, q, !1);
        if (Z) return Z;
        let oe = [];
        for (let Q = K; Q; Q = AY.get(Q)) OD(oe, Q.filename || Q.id);
        let I = `Cannot find module '${W}'`;
        oe.length > 0 &&
          (I =
            I +
            `
Require stack:
- ` +
            V0(
              oe,
              `
- `
            ));
        let X = new Error(I);
        throw ((X.code = 'MODULE_NOT_FOUND'), (X.requireStack = oe), X);
      };
    function pe(V, W, K) {
      if (AD(c, V)) throw new TY(V, 'must not include encoded "/" or "\\" characters', W);
      let q = vY(V),
        B = y(q) || x(q);
      if (B) return B;
      throw le(q, Jt.resolve(K, 'package.json'));
    }
    function le(V, W) {
      let K = new Error(`Cannot find module '${V}'`);
      return (K.code = 'MODULE_NOT_FOUND'), W && (K.path = W), K;
    }
    return { Module_findPath: F, Module_resolveFilename: ne };
  }
  function NY(t, e, i) {
    let n = dh(i),
      r = t.moduleTypeClassifier.classifyModuleByModuleTypeOverrides(CY(i));
    if (r.moduleType === 'cjs') return;
    let s = i.lastIndexOf('.'),
      o = s >= 0 ? i.slice(s) : '';
    if (
      !((o === '.cts' || o === '.cjs') && r.moduleType === 'auto') &&
      (o === '.mts' || o === '.mjs' || r.moduleType === 'esm' || (n && n.data && n.data.type === 'module'))
    ) {
      let c = e.parent && e.parent.filename,
        u = n ? Jt.resolve(n.path, 'package.json') : null;
      throw RY(i, c, u);
    }
  }
  DD.exports = { createCjsLoader: IY, assertScriptCanLoadAsCJSImpl: NY, readPackageScope: dh };
});
var FD = P((mh) => {
  'use strict';
  Object.defineProperty(mh, '__esModule', { value: !0 });
  mh.classifyModule = void 0;
  var PY = hh();
  function LY(t, e) {
    let i = t.lastIndexOf('.');
    switch (i >= 0 ? t.slice(i) : '') {
      case '.cjs':
      case '.cts':
        return e ? 'nodecjs' : 'cjs';
      case '.mjs':
      case '.mts':
        return e ? 'nodeesm' : 'esm';
    }
    if (e) {
      let r = (0, PY.readPackageScope)(t);
      return r && r.data.type === 'module' ? 'nodeesm' : 'nodecjs';
    }
  }
  mh.classifyModule = LY;
});
var jD = P((xh) => {
  'use strict';
  Object.defineProperty(xh, '__esModule', { value: !0 });
  xh.getExtensions = void 0;
  var DY = Vn(),
    FY = new Map([
      ['.ts', '.js'],
      ['.tsx', '.js'],
      ['.jsx', '.js'],
      ['.mts', '.mjs'],
      ['.cts', '.cjs'],
    ]),
    jY = new Map([
      ['.ts', ['.js']],
      ['.tsx', ['.js', '.jsx']],
      ['.mts', ['.mjs']],
      ['.cts', ['.cjs']],
    ]),
    MY = ['.js', '.json', '.node', '.mjs', '.cjs'],
    gh = ['.ts', '.tsx', '.jsx', '.cts', '.mts'];
  function UY(t, e, i) {
    let n = (0, DY.versionGteLt)(i, '4.5.0'),
      r = [];
    n || r.push('.cts', '.cjs', '.mts', '.mjs');
    let s = Array.from(new Set([...(e.preferTsExts ? gh : []), ...MY, ...gh])),
      o = ['.ts'],
      c = [];
    t.options.jsx && c.push('.tsx'),
      n && o.push('.mts', '.cts'),
      t.options.allowJs && (o.push('.js'), t.options.jsx && c.push('.jsx'), n && o.push('.mjs', '.cjs'));
    let u = [...o, ...c],
      l = s.filter((_) => u.includes(_)),
      p = gh.filter((_) => l.includes(_)),
      d = s.filter((_) => [...u, '.js', '.mjs', '.cjs', '.mts', '.cts'].includes(_)),
      x = d.filter((_) => ['.js', '.jsx', '.ts', '.tsx'].includes(_)),
      b = d.filter((_) => ['.jsx', '.tsx'].includes(_)),
      g = d.filter((_) => ['.mjs', '.mts'].includes(_)),
      y = d.filter((_) => ['.cjs', '.cts'].includes(_)),
      h = d.filter((_) => ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts'].includes(_)),
      v = Array.from(new Set([...h, '.json', '.node'])),
      C = Array.from(new Set([...x, '.json', '.node']));
    return {
      compiled: l,
      nodeDoesNotUnderstand: gh,
      compiledNodeDoesNotUnderstand: p,
      nodeEquivalents: FY,
      tsResolverEquivalents: jY,
      requiresHigherTypescriptVersion: r,
      experimentalSpecifierResolutionAddsIfOmitted: v,
      legacyMainResolveAddsIfOmitted: C,
      replacementsForMjs: g,
      replacementsForCjs: y,
      replacementsForJsx: b,
      replacementsForJs: x,
    };
  }
  xh.getExtensions = UY;
});
var MD = P((yh) => {
  'use strict';
  Object.defineProperty(yh, '__esModule', { value: !0 });
  yh.createTsTranspileModule = void 0;
  function qY(t, e) {
    let {
        createProgram: i,
        createSourceFile: n,
        getDefaultCompilerOptions: r,
        getImpliedNodeFormatForFile: s,
        fixupCompilerOptions: o,
        transpileOptionValueCompilerOptions: c,
        getNewLineCharacter: u,
        fileExtensionIs: l,
        normalizePath: p,
        Debug: d,
        toPath: x,
        getSetExternalModuleIndicator: b,
        getEntries: g,
        addRange: y,
        hasProperty: h,
        getEmitScriptTarget: v,
        getDirectoryPath: C,
      } = t,
      _ = [],
      m = e.compilerOptions ? o(e.compilerOptions, _) : {},
      O = r();
    for (let W in O) h(O, W) && m[W] === void 0 && (m[W] = O[W]);
    for (let W of c) m[W.name] = W.transpileOptionValue;
    (m.suppressOutputPathCheck = !0), (m.allowNonTsExtensions = !0);
    let N = u(m),
      D = {
        getSourceFile: (W) => (W === p(z) ? ne : void 0),
        writeFile: (W, K) => {
          l(W, '.map')
            ? (d.assertEqual(le, void 0, 'Unexpected multiple source map outputs, file:', W), (le = K))
            : (d.assertEqual(pe, void 0, 'Unexpected multiple outputs, file:', W), (pe = K));
        },
        getDefaultLibFileName: () => 'lib.d.ts',
        useCaseSensitiveFileNames: () => !0,
        getCanonicalFileName: (W) => W,
        getCurrentDirectory: () => '',
        getNewLine: () => N,
        fileExists: (W) => W === z || W === H,
        readFile: (W) => (W === H ? `{"type": "${F}"}` : ''),
        directoryExists: () => !0,
        getDirectories: () => [],
      },
      z,
      H,
      F,
      ne,
      pe,
      le;
    return V;
    function V(W, K, q = 'commonjs') {
      (z = K.fileName || (e.compilerOptions && e.compilerOptions.jsx ? 'module.tsx' : 'module.ts')),
        (H = C(z) + '/package.json'),
        (F = q),
        (ne = n(z, W, {
          languageVersion: v(m),
          impliedNodeFormat: s(x(z, '', D.getCanonicalFileName), void 0, D, m),
          setExternalModuleIndicator: b(m),
        })),
        K.moduleName && (ne.moduleName = K.moduleName),
        K.renamedDependencies && (ne.renamedDependencies = new Map(g(K.renamedDependencies))),
        (pe = void 0),
        (le = void 0);
      let B = i([z], m, D),
        ee = _.slice();
      return (
        e.reportDiagnostics && (y(ee, B.getSyntacticDiagnostics(ne)), y(ee, B.getOptionsDiagnostics())),
        B.emit(void 0, void 0, void 0, void 0, e.transformers),
        pe === void 0 ? d.fail('Output generation failed') : { outputText: pe, diagnostics: ee, sourceMapText: le }
      );
    }
  }
  yh.createTsTranspileModule = qY;
});
var qD = P((bh, UD) => {
  'use strict';
  (function (t, e) {
    typeof bh == 'object' && typeof UD < 'u'
      ? e(bh)
      : typeof define == 'function' && define.amd
      ? define(['exports'], e)
      : ((t = typeof globalThis < 'u' ? globalThis : t || self), e((t.acorn = {})));
  })(bh, function (t) {
    'use strict';
    var e = [
        509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10,
        50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13,
        9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193,
        17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9,
        71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2,
        7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49,
        6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628,
        1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2,
        14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9,
        4759, 9, 787719, 239,
      ],
      i = [
        0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35,
        5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310,
        10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21,
        11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17,
        111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3,
        0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2,
        0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2,
        31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0,
        3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72,
        264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2,
        33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29,
        19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2,
        6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0,
        3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2,
        30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322,
        29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2,
        3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6,
        2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541,
        1507, 4938, 6, 4191,
      ],
      n =
        '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F',
      r =
        '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
      s = {
        3: 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile',
        5: 'class enum extends super const export import',
        6: 'enum',
        strict: 'implements interface let package private protected public static yield',
        strictBind: 'eval arguments',
      },
      o =
        'break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this',
      c = { 5: o, '5module': o + ' export import', 6: o + ' const class extends export import super' },
      u = /^in(stanceof)?$/,
      l = new RegExp('[' + r + ']'),
      p = new RegExp('[' + r + n + ']');
    function d(a, f) {
      for (var E = 65536, T = 0; T < f.length; T += 2) {
        if (((E += f[T]), E > a)) return !1;
        if (((E += f[T + 1]), E >= a)) return !0;
      }
      return !1;
    }
    function x(a, f) {
      return a < 65
        ? a === 36
        : a < 91
        ? !0
        : a < 97
        ? a === 95
        : a < 123
        ? !0
        : a <= 65535
        ? a >= 170 && l.test(String.fromCharCode(a))
        : f === !1
        ? !1
        : d(a, i);
    }
    function b(a, f) {
      return a < 48
        ? a === 36
        : a < 58
        ? !0
        : a < 65
        ? !1
        : a < 91
        ? !0
        : a < 97
        ? a === 95
        : a < 123
        ? !0
        : a <= 65535
        ? a >= 170 && p.test(String.fromCharCode(a))
        : f === !1
        ? !1
        : d(a, i) || d(a, e);
    }
    var g = function (f, E) {
      E === void 0 && (E = {}),
        (this.label = f),
        (this.keyword = E.keyword),
        (this.beforeExpr = !!E.beforeExpr),
        (this.startsExpr = !!E.startsExpr),
        (this.isLoop = !!E.isLoop),
        (this.isAssign = !!E.isAssign),
        (this.prefix = !!E.prefix),
        (this.postfix = !!E.postfix),
        (this.binop = E.binop || null),
        (this.updateContext = null);
    };
    function y(a, f) {
      return new g(a, { beforeExpr: !0, binop: f });
    }
    var h = { beforeExpr: !0 },
      v = { startsExpr: !0 },
      C = {};
    function _(a, f) {
      return f === void 0 && (f = {}), (f.keyword = a), (C[a] = new g(a, f));
    }
    var m = {
        num: new g('num', v),
        regexp: new g('regexp', v),
        string: new g('string', v),
        name: new g('name', v),
        privateId: new g('privateId', v),
        eof: new g('eof'),
        bracketL: new g('[', { beforeExpr: !0, startsExpr: !0 }),
        bracketR: new g(']'),
        braceL: new g('{', { beforeExpr: !0, startsExpr: !0 }),
        braceR: new g('}'),
        parenL: new g('(', { beforeExpr: !0, startsExpr: !0 }),
        parenR: new g(')'),
        comma: new g(',', h),
        semi: new g(';', h),
        colon: new g(':', h),
        dot: new g('.'),
        question: new g('?', h),
        questionDot: new g('?.'),
        arrow: new g('=>', h),
        template: new g('template'),
        invalidTemplate: new g('invalidTemplate'),
        ellipsis: new g('...', h),
        backQuote: new g('`', v),
        dollarBraceL: new g('${', { beforeExpr: !0, startsExpr: !0 }),
        eq: new g('=', { beforeExpr: !0, isAssign: !0 }),
        assign: new g('_=', { beforeExpr: !0, isAssign: !0 }),
        incDec: new g('++/--', { prefix: !0, postfix: !0, startsExpr: !0 }),
        prefix: new g('!/~', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        logicalOR: y('||', 1),
        logicalAND: y('&&', 2),
        bitwiseOR: y('|', 3),
        bitwiseXOR: y('^', 4),
        bitwiseAND: y('&', 5),
        equality: y('==/!=/===/!==', 6),
        relational: y('</>/<=/>=', 7),
        bitShift: y('<</>>/>>>', 8),
        plusMin: new g('+/-', { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
        modulo: y('%', 10),
        star: y('*', 10),
        slash: y('/', 10),
        starstar: new g('**', { beforeExpr: !0 }),
        coalesce: y('??', 1),
        _break: _('break'),
        _case: _('case', h),
        _catch: _('catch'),
        _continue: _('continue'),
        _debugger: _('debugger'),
        _default: _('default', h),
        _do: _('do', { isLoop: !0, beforeExpr: !0 }),
        _else: _('else', h),
        _finally: _('finally'),
        _for: _('for', { isLoop: !0 }),
        _function: _('function', v),
        _if: _('if'),
        _return: _('return', h),
        _switch: _('switch'),
        _throw: _('throw', h),
        _try: _('try'),
        _var: _('var'),
        _const: _('const'),
        _while: _('while', { isLoop: !0 }),
        _with: _('with'),
        _new: _('new', { beforeExpr: !0, startsExpr: !0 }),
        _this: _('this', v),
        _super: _('super', v),
        _class: _('class', v),
        _extends: _('extends', h),
        _export: _('export'),
        _import: _('import', v),
        _null: _('null', v),
        _true: _('true', v),
        _false: _('false', v),
        _in: _('in', { beforeExpr: !0, binop: 7 }),
        _instanceof: _('instanceof', { beforeExpr: !0, binop: 7 }),
        _typeof: _('typeof', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _void: _('void', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _delete: _('delete', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
      },
      O = /\r\n?|\n|\u2028|\u2029/,
      N = new RegExp(O.source, 'g');
    function D(a) {
      return a === 10 || a === 13 || a === 8232 || a === 8233;
    }
    function z(a, f, E) {
      E === void 0 && (E = a.length);
      for (var T = f; T < E; T++) {
        var L = a.charCodeAt(T);
        if (D(L)) return T < E - 1 && L === 13 && a.charCodeAt(T + 1) === 10 ? T + 2 : T + 1;
      }
      return -1;
    }
    var H = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
      F = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
      ne = Object.prototype,
      pe = ne.hasOwnProperty,
      le = ne.toString,
      V =
        Object.hasOwn ||
        function (a, f) {
          return pe.call(a, f);
        },
      W =
        Array.isArray ||
        function (a) {
          return le.call(a) === '[object Array]';
        };
    function K(a) {
      return new RegExp('^(?:' + a.replace(/ /g, '|') + ')$');
    }
    function q(a) {
      return a <= 65535
        ? String.fromCharCode(a)
        : ((a -= 65536), String.fromCharCode((a >> 10) + 55296, (a & 1023) + 56320));
    }
    var B = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,
      ee = function (f, E) {
        (this.line = f), (this.column = E);
      };
    ee.prototype.offset = function (f) {
      return new ee(this.line, this.column + f);
    };
    var xe = function (f, E, T) {
      (this.start = E), (this.end = T), f.sourceFile !== null && (this.source = f.sourceFile);
    };
    function de(a, f) {
      for (var E = 1, T = 0; ; ) {
        var L = z(a, T, f);
        if (L < 0) return new ee(E, f - T);
        ++E, (T = L);
      }
    }
    var Z = {
        ecmaVersion: null,
        sourceType: 'script',
        onInsertedSemicolon: null,
        onTrailingComma: null,
        allowReserved: null,
        allowReturnOutsideFunction: !1,
        allowImportExportEverywhere: !1,
        allowAwaitOutsideFunction: null,
        allowSuperOutsideMethod: null,
        allowHashBang: !1,
        checkPrivateFields: !0,
        locations: !1,
        onToken: null,
        onComment: null,
        ranges: !1,
        program: null,
        sourceFile: null,
        directSourceFile: null,
        preserveParens: !1,
      },
      oe = !1;
    function I(a) {
      var f = {};
      for (var E in Z) f[E] = a && V(a, E) ? a[E] : Z[E];
      if (
        (f.ecmaVersion === 'latest'
          ? (f.ecmaVersion = 1e8)
          : f.ecmaVersion == null
          ? (!oe &&
              typeof console == 'object' &&
              console.warn &&
              ((oe = !0),
              console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)),
            (f.ecmaVersion = 11))
          : f.ecmaVersion >= 2015 && (f.ecmaVersion -= 2009),
        f.allowReserved == null && (f.allowReserved = f.ecmaVersion < 5),
        (!a || a.allowHashBang == null) && (f.allowHashBang = f.ecmaVersion >= 14),
        W(f.onToken))
      ) {
        var T = f.onToken;
        f.onToken = function (L) {
          return T.push(L);
        };
      }
      return W(f.onComment) && (f.onComment = X(f, f.onComment)), f;
    }
    function X(a, f) {
      return function (E, T, L, $, J, he) {
        var ge = { type: E ? 'Block' : 'Line', value: T, start: L, end: $ };
        a.locations && (ge.loc = new xe(this, J, he)), a.ranges && (ge.range = [L, $]), f.push(ge);
      };
    }
    var Q = 1,
      ae = 2,
      ce = 4,
      ye = 8,
      ve = 16,
      Ce = 32,
      Oe = 64,
      ke = 128,
      ze = 256,
      R = Q | ae | ze;
    function w(a, f) {
      return ae | (a ? ce : 0) | (f ? ye : 0);
    }
    var A = 0,
      k = 1,
      S = 2,
      M = 3,
      j = 4,
      U = 5,
      re = function (f, E, T) {
        (this.options = f = I(f)),
          (this.sourceFile = f.sourceFile),
          (this.keywords = K(c[f.ecmaVersion >= 6 ? 6 : f.sourceType === 'module' ? '5module' : 5]));
        var L = '';
        f.allowReserved !== !0 &&
          ((L = s[f.ecmaVersion >= 6 ? 6 : f.ecmaVersion === 5 ? 5 : 3]), f.sourceType === 'module' && (L += ' await')),
          (this.reservedWords = K(L));
        var $ = (L ? L + ' ' : '') + s.strict;
        (this.reservedWordsStrict = K($)),
          (this.reservedWordsStrictBind = K($ + ' ' + s.strictBind)),
          (this.input = String(E)),
          (this.containsEsc = !1),
          T
            ? ((this.pos = T),
              (this.lineStart =
                this.input.lastIndexOf(
                  `
`,
                  T - 1
                ) + 1),
              (this.curLine = this.input.slice(0, this.lineStart).split(O).length))
            : ((this.pos = this.lineStart = 0), (this.curLine = 1)),
          (this.type = m.eof),
          (this.value = null),
          (this.start = this.end = this.pos),
          (this.startLoc = this.endLoc = this.curPosition()),
          (this.lastTokEndLoc = this.lastTokStartLoc = null),
          (this.lastTokStart = this.lastTokEnd = this.pos),
          (this.context = this.initialContext()),
          (this.exprAllowed = !0),
          (this.inModule = f.sourceType === 'module'),
          (this.strict = this.inModule || this.strictDirective(this.pos)),
          (this.potentialArrowAt = -1),
          (this.potentialArrowInForAwait = !1),
          (this.yieldPos = this.awaitPos = this.awaitIdentPos = 0),
          (this.labels = []),
          (this.undefinedExports = Object.create(null)),
          this.pos === 0 && f.allowHashBang && this.input.slice(0, 2) === '#!' && this.skipLineComment(2),
          (this.scopeStack = []),
          this.enterScope(Q),
          (this.regexpState = null),
          (this.privateNameStack = []);
      },
      se = {
        inFunction: { configurable: !0 },
        inGenerator: { configurable: !0 },
        inAsync: { configurable: !0 },
        canAwait: { configurable: !0 },
        allowSuper: { configurable: !0 },
        allowDirectSuper: { configurable: !0 },
        treatFunctionsAsVar: { configurable: !0 },
        allowNewDotTarget: { configurable: !0 },
        inClassStaticBlock: { configurable: !0 },
      };
    (re.prototype.parse = function () {
      var f = this.options.program || this.startNode();
      return this.nextToken(), this.parseTopLevel(f);
    }),
      (se.inFunction.get = function () {
        return (this.currentVarScope().flags & ae) > 0;
      }),
      (se.inGenerator.get = function () {
        return (this.currentVarScope().flags & ye) > 0 && !this.currentVarScope().inClassFieldInit;
      }),
      (se.inAsync.get = function () {
        return (this.currentVarScope().flags & ce) > 0 && !this.currentVarScope().inClassFieldInit;
      }),
      (se.canAwait.get = function () {
        for (var a = this.scopeStack.length - 1; a >= 0; a--) {
          var f = this.scopeStack[a];
          if (f.inClassFieldInit || f.flags & ze) return !1;
          if (f.flags & ae) return (f.flags & ce) > 0;
        }
        return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction;
      }),
      (se.allowSuper.get = function () {
        var a = this.currentThisScope(),
          f = a.flags,
          E = a.inClassFieldInit;
        return (f & Oe) > 0 || E || this.options.allowSuperOutsideMethod;
      }),
      (se.allowDirectSuper.get = function () {
        return (this.currentThisScope().flags & ke) > 0;
      }),
      (se.treatFunctionsAsVar.get = function () {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }),
      (se.allowNewDotTarget.get = function () {
        var a = this.currentThisScope(),
          f = a.flags,
          E = a.inClassFieldInit;
        return (f & (ae | ze)) > 0 || E;
      }),
      (se.inClassStaticBlock.get = function () {
        return (this.currentVarScope().flags & ze) > 0;
      }),
      (re.extend = function () {
        for (var f = [], E = arguments.length; E--; ) f[E] = arguments[E];
        for (var T = this, L = 0; L < f.length; L++) T = f[L](T);
        return T;
      }),
      (re.parse = function (f, E) {
        return new this(E, f).parse();
      }),
      (re.parseExpressionAt = function (f, E, T) {
        var L = new this(T, f, E);
        return L.nextToken(), L.parseExpression();
      }),
      (re.tokenizer = function (f, E) {
        return new this(E, f);
      }),
      Object.defineProperties(re.prototype, se);
    var fe = re.prototype,
      De = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    (fe.strictDirective = function (a) {
      if (this.options.ecmaVersion < 5) return !1;
      for (;;) {
        (F.lastIndex = a), (a += F.exec(this.input)[0].length);
        var f = De.exec(this.input.slice(a));
        if (!f) return !1;
        if ((f[1] || f[2]) === 'use strict') {
          F.lastIndex = a + f[0].length;
          var E = F.exec(this.input),
            T = E.index + E[0].length,
            L = this.input.charAt(T);
          return (
            L === ';' ||
            L === '}' ||
            (O.test(E[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(L) || (L === '!' && this.input.charAt(T + 1) === '=')))
          );
        }
        (a += f[0].length), (F.lastIndex = a), (a += F.exec(this.input)[0].length), this.input[a] === ';' && a++;
      }
    }),
      (fe.eat = function (a) {
        return this.type === a ? (this.next(), !0) : !1;
      }),
      (fe.isContextual = function (a) {
        return this.type === m.name && this.value === a && !this.containsEsc;
      }),
      (fe.eatContextual = function (a) {
        return this.isContextual(a) ? (this.next(), !0) : !1;
      }),
      (fe.expectContextual = function (a) {
        this.eatContextual(a) || this.unexpected();
      }),
      (fe.canInsertSemicolon = function () {
        return this.type === m.eof || this.type === m.braceR || O.test(this.input.slice(this.lastTokEnd, this.start));
      }),
      (fe.insertSemicolon = function () {
        if (this.canInsertSemicolon())
          return (
            this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc),
            !0
          );
      }),
      (fe.semicolon = function () {
        !this.eat(m.semi) && !this.insertSemicolon() && this.unexpected();
      }),
      (fe.afterTrailingComma = function (a, f) {
        if (this.type === a)
          return (
            this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc),
            f || this.next(),
            !0
          );
      }),
      (fe.expect = function (a) {
        this.eat(a) || this.unexpected();
      }),
      (fe.unexpected = function (a) {
        this.raise(a ?? this.start, 'Unexpected token');
      });
    var Ne = function () {
      this.shorthandAssign =
        this.trailingComma =
        this.parenthesizedAssign =
        this.parenthesizedBind =
        this.doubleProto =
          -1;
    };
    (fe.checkPatternErrors = function (a, f) {
      if (a) {
        a.trailingComma > -1 && this.raiseRecoverable(a.trailingComma, 'Comma is not permitted after the rest element');
        var E = f ? a.parenthesizedAssign : a.parenthesizedBind;
        E > -1 && this.raiseRecoverable(E, f ? 'Assigning to rvalue' : 'Parenthesized pattern');
      }
    }),
      (fe.checkExpressionErrors = function (a, f) {
        if (!a) return !1;
        var E = a.shorthandAssign,
          T = a.doubleProto;
        if (!f) return E >= 0 || T >= 0;
        E >= 0 && this.raise(E, 'Shorthand property assignments are valid only in destructuring patterns'),
          T >= 0 && this.raiseRecoverable(T, 'Redefinition of __proto__ property');
      }),
      (fe.checkYieldAwaitInDefaultParams = function () {
        this.yieldPos &&
          (!this.awaitPos || this.yieldPos < this.awaitPos) &&
          this.raise(this.yieldPos, 'Yield expression cannot be a default value'),
          this.awaitPos && this.raise(this.awaitPos, 'Await expression cannot be a default value');
      }),
      (fe.isSimpleAssignTarget = function (a) {
        return a.type === 'ParenthesizedExpression'
          ? this.isSimpleAssignTarget(a.expression)
          : a.type === 'Identifier' || a.type === 'MemberExpression';
      });
    var me = re.prototype;
    me.parseTopLevel = function (a) {
      var f = Object.create(null);
      for (a.body || (a.body = []); this.type !== m.eof; ) {
        var E = this.parseStatement(null, !0, f);
        a.body.push(E);
      }
      if (this.inModule)
        for (var T = 0, L = Object.keys(this.undefinedExports); T < L.length; T += 1) {
          var $ = L[T];
          this.raiseRecoverable(this.undefinedExports[$].start, "Export '" + $ + "' is not defined");
        }
      return (
        this.adaptDirectivePrologue(a.body),
        this.next(),
        (a.sourceType = this.options.sourceType),
        this.finishNode(a, 'Program')
      );
    };
    var _e = { kind: 'loop' },
      Me = { kind: 'switch' };
    (me.isLet = function (a) {
      if (this.options.ecmaVersion < 6 || !this.isContextual('let')) return !1;
      F.lastIndex = this.pos;
      var f = F.exec(this.input),
        E = this.pos + f[0].length,
        T = this.input.charCodeAt(E);
      if (T === 91 || T === 92) return !0;
      if (a) return !1;
      if (T === 123 || (T > 55295 && T < 56320)) return !0;
      if (x(T, !0)) {
        for (var L = E + 1; b((T = this.input.charCodeAt(L)), !0); ) ++L;
        if (T === 92 || (T > 55295 && T < 56320)) return !0;
        var $ = this.input.slice(E, L);
        if (!u.test($)) return !0;
      }
      return !1;
    }),
      (me.isAsyncFunction = function () {
        if (this.options.ecmaVersion < 8 || !this.isContextual('async')) return !1;
        F.lastIndex = this.pos;
        var a = F.exec(this.input),
          f = this.pos + a[0].length,
          E;
        return (
          !O.test(this.input.slice(this.pos, f)) &&
          this.input.slice(f, f + 8) === 'function' &&
          (f + 8 === this.input.length || !(b((E = this.input.charCodeAt(f + 8))) || (E > 55295 && E < 56320)))
        );
      }),
      (me.parseStatement = function (a, f, E) {
        var T = this.type,
          L = this.startNode(),
          $;
        switch ((this.isLet(a) && ((T = m._var), ($ = 'let')), T)) {
          case m._break:
          case m._continue:
            return this.parseBreakContinueStatement(L, T.keyword);
          case m._debugger:
            return this.parseDebuggerStatement(L);
          case m._do:
            return this.parseDoStatement(L);
          case m._for:
            return this.parseForStatement(L);
          case m._function:
            return (
              a && (this.strict || (a !== 'if' && a !== 'label')) && this.options.ecmaVersion >= 6 && this.unexpected(),
              this.parseFunctionStatement(L, !1, !a)
            );
          case m._class:
            return a && this.unexpected(), this.parseClass(L, !0);
          case m._if:
            return this.parseIfStatement(L);
          case m._return:
            return this.parseReturnStatement(L);
          case m._switch:
            return this.parseSwitchStatement(L);
          case m._throw:
            return this.parseThrowStatement(L);
          case m._try:
            return this.parseTryStatement(L);
          case m._const:
          case m._var:
            return ($ = $ || this.value), a && $ !== 'var' && this.unexpected(), this.parseVarStatement(L, $);
          case m._while:
            return this.parseWhileStatement(L);
          case m._with:
            return this.parseWithStatement(L);
          case m.braceL:
            return this.parseBlock(!0, L);
          case m.semi:
            return this.parseEmptyStatement(L);
          case m._export:
          case m._import:
            if (this.options.ecmaVersion > 10 && T === m._import) {
              F.lastIndex = this.pos;
              var J = F.exec(this.input),
                he = this.pos + J[0].length,
                ge = this.input.charCodeAt(he);
              if (ge === 40 || ge === 46) return this.parseExpressionStatement(L, this.parseExpression());
            }
            return (
              this.options.allowImportExportEverywhere ||
                (f || this.raise(this.start, "'import' and 'export' may only appear at the top level"),
                this.inModule ||
                  this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")),
              T === m._import ? this.parseImport(L) : this.parseExport(L, E)
            );
          default:
            if (this.isAsyncFunction())
              return a && this.unexpected(), this.next(), this.parseFunctionStatement(L, !0, !a);
            var Fe = this.value,
              qe = this.parseExpression();
            return T === m.name && qe.type === 'Identifier' && this.eat(m.colon)
              ? this.parseLabeledStatement(L, Fe, qe, a)
              : this.parseExpressionStatement(L, qe);
        }
      }),
      (me.parseBreakContinueStatement = function (a, f) {
        var E = f === 'break';
        this.next(),
          this.eat(m.semi) || this.insertSemicolon()
            ? (a.label = null)
            : this.type !== m.name
            ? this.unexpected()
            : ((a.label = this.parseIdent()), this.semicolon());
        for (var T = 0; T < this.labels.length; ++T) {
          var L = this.labels[T];
          if (
            (a.label == null || L.name === a.label.name) &&
            ((L.kind != null && (E || L.kind === 'loop')) || (a.label && E))
          )
            break;
        }
        return (
          T === this.labels.length && this.raise(a.start, 'Unsyntactic ' + f),
          this.finishNode(a, E ? 'BreakStatement' : 'ContinueStatement')
        );
      }),
      (me.parseDebuggerStatement = function (a) {
        return this.next(), this.semicolon(), this.finishNode(a, 'DebuggerStatement');
      }),
      (me.parseDoStatement = function (a) {
        return (
          this.next(),
          this.labels.push(_e),
          (a.body = this.parseStatement('do')),
          this.labels.pop(),
          this.expect(m._while),
          (a.test = this.parseParenExpression()),
          this.options.ecmaVersion >= 6 ? this.eat(m.semi) : this.semicolon(),
          this.finishNode(a, 'DoWhileStatement')
        );
      }),
      (me.parseForStatement = function (a) {
        this.next();
        var f = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual('await') ? this.lastTokStart : -1;
        if ((this.labels.push(_e), this.enterScope(0), this.expect(m.parenL), this.type === m.semi))
          return f > -1 && this.unexpected(f), this.parseFor(a, null);
        var E = this.isLet();
        if (this.type === m._var || this.type === m._const || E) {
          var T = this.startNode(),
            L = E ? 'let' : this.value;
          return (
            this.next(),
            this.parseVar(T, !0, L),
            this.finishNode(T, 'VariableDeclaration'),
            (this.type === m._in || (this.options.ecmaVersion >= 6 && this.isContextual('of'))) &&
            T.declarations.length === 1
              ? (this.options.ecmaVersion >= 9 &&
                  (this.type === m._in ? f > -1 && this.unexpected(f) : (a.await = f > -1)),
                this.parseForIn(a, T))
              : (f > -1 && this.unexpected(f), this.parseFor(a, T))
          );
        }
        var $ = this.isContextual('let'),
          J = !1,
          he = new Ne(),
          ge = this.parseExpression(f > -1 ? 'await' : !0, he);
        return this.type === m._in || (J = this.options.ecmaVersion >= 6 && this.isContextual('of'))
          ? (this.options.ecmaVersion >= 9 && (this.type === m._in ? f > -1 && this.unexpected(f) : (a.await = f > -1)),
            $ && J && this.raise(ge.start, "The left-hand side of a for-of loop may not start with 'let'."),
            this.toAssignable(ge, !1, he),
            this.checkLValPattern(ge),
            this.parseForIn(a, ge))
          : (this.checkExpressionErrors(he, !0), f > -1 && this.unexpected(f), this.parseFor(a, ge));
      }),
      (me.parseFunctionStatement = function (a, f, E) {
        return this.next(), this.parseFunction(a, Ie | (E ? 0 : st), !1, f);
      }),
      (me.parseIfStatement = function (a) {
        return (
          this.next(),
          (a.test = this.parseParenExpression()),
          (a.consequent = this.parseStatement('if')),
          (a.alternate = this.eat(m._else) ? this.parseStatement('if') : null),
          this.finishNode(a, 'IfStatement')
        );
      }),
      (me.parseReturnStatement = function (a) {
        return (
          !this.inFunction &&
            !this.options.allowReturnOutsideFunction &&
            this.raise(this.start, "'return' outside of function"),
          this.next(),
          this.eat(m.semi) || this.insertSemicolon()
            ? (a.argument = null)
            : ((a.argument = this.parseExpression()), this.semicolon()),
          this.finishNode(a, 'ReturnStatement')
        );
      }),
      (me.parseSwitchStatement = function (a) {
        this.next(),
          (a.discriminant = this.parseParenExpression()),
          (a.cases = []),
          this.expect(m.braceL),
          this.labels.push(Me),
          this.enterScope(0);
        for (var f, E = !1; this.type !== m.braceR; )
          if (this.type === m._case || this.type === m._default) {
            var T = this.type === m._case;
            f && this.finishNode(f, 'SwitchCase'),
              a.cases.push((f = this.startNode())),
              (f.consequent = []),
              this.next(),
              T
                ? (f.test = this.parseExpression())
                : (E && this.raiseRecoverable(this.lastTokStart, 'Multiple default clauses'),
                  (E = !0),
                  (f.test = null)),
              this.expect(m.colon);
          } else f || this.unexpected(), f.consequent.push(this.parseStatement(null));
        return (
          this.exitScope(),
          f && this.finishNode(f, 'SwitchCase'),
          this.next(),
          this.labels.pop(),
          this.finishNode(a, 'SwitchStatement')
        );
      }),
      (me.parseThrowStatement = function (a) {
        return (
          this.next(),
          O.test(this.input.slice(this.lastTokEnd, this.start)) &&
            this.raise(this.lastTokEnd, 'Illegal newline after throw'),
          (a.argument = this.parseExpression()),
          this.semicolon(),
          this.finishNode(a, 'ThrowStatement')
        );
      });
    var xt = [];
    (me.parseCatchClauseParam = function () {
      var a = this.parseBindingAtom(),
        f = a.type === 'Identifier';
      return this.enterScope(f ? Ce : 0), this.checkLValPattern(a, f ? j : S), this.expect(m.parenR), a;
    }),
      (me.parseTryStatement = function (a) {
        if ((this.next(), (a.block = this.parseBlock()), (a.handler = null), this.type === m._catch)) {
          var f = this.startNode();
          this.next(),
            this.eat(m.parenL)
              ? (f.param = this.parseCatchClauseParam())
              : (this.options.ecmaVersion < 10 && this.unexpected(), (f.param = null), this.enterScope(0)),
            (f.body = this.parseBlock(!1)),
            this.exitScope(),
            (a.handler = this.finishNode(f, 'CatchClause'));
        }
        return (
          (a.finalizer = this.eat(m._finally) ? this.parseBlock() : null),
          !a.handler && !a.finalizer && this.raise(a.start, 'Missing catch or finally clause'),
          this.finishNode(a, 'TryStatement')
        );
      }),
      (me.parseVarStatement = function (a, f, E) {
        return this.next(), this.parseVar(a, !1, f, E), this.semicolon(), this.finishNode(a, 'VariableDeclaration');
      }),
      (me.parseWhileStatement = function (a) {
        return (
          this.next(),
          (a.test = this.parseParenExpression()),
          this.labels.push(_e),
          (a.body = this.parseStatement('while')),
          this.labels.pop(),
          this.finishNode(a, 'WhileStatement')
        );
      }),
      (me.parseWithStatement = function (a) {
        return (
          this.strict && this.raise(this.start, "'with' in strict mode"),
          this.next(),
          (a.object = this.parseParenExpression()),
          (a.body = this.parseStatement('with')),
          this.finishNode(a, 'WithStatement')
        );
      }),
      (me.parseEmptyStatement = function (a) {
        return this.next(), this.finishNode(a, 'EmptyStatement');
      }),
      (me.parseLabeledStatement = function (a, f, E, T) {
        for (var L = 0, $ = this.labels; L < $.length; L += 1) {
          var J = $[L];
          J.name === f && this.raise(E.start, "Label '" + f + "' is already declared");
        }
        for (
          var he = this.type.isLoop ? 'loop' : this.type === m._switch ? 'switch' : null, ge = this.labels.length - 1;
          ge >= 0;
          ge--
        ) {
          var Fe = this.labels[ge];
          if (Fe.statementStart === a.start) (Fe.statementStart = this.start), (Fe.kind = he);
          else break;
        }
        return (
          this.labels.push({ name: f, kind: he, statementStart: this.start }),
          (a.body = this.parseStatement(T ? (T.indexOf('label') === -1 ? T + 'label' : T) : 'label')),
          this.labels.pop(),
          (a.label = E),
          this.finishNode(a, 'LabeledStatement')
        );
      }),
      (me.parseExpressionStatement = function (a, f) {
        return (a.expression = f), this.semicolon(), this.finishNode(a, 'ExpressionStatement');
      }),
      (me.parseBlock = function (a, f, E) {
        for (
          a === void 0 && (a = !0),
            f === void 0 && (f = this.startNode()),
            f.body = [],
            this.expect(m.braceL),
            a && this.enterScope(0);
          this.type !== m.braceR;

        ) {
          var T = this.parseStatement(null);
          f.body.push(T);
        }
        return E && (this.strict = !1), this.next(), a && this.exitScope(), this.finishNode(f, 'BlockStatement');
      }),
      (me.parseFor = function (a, f) {
        return (
          (a.init = f),
          this.expect(m.semi),
          (a.test = this.type === m.semi ? null : this.parseExpression()),
          this.expect(m.semi),
          (a.update = this.type === m.parenR ? null : this.parseExpression()),
          this.expect(m.parenR),
          (a.body = this.parseStatement('for')),
          this.exitScope(),
          this.labels.pop(),
          this.finishNode(a, 'ForStatement')
        );
      }),
      (me.parseForIn = function (a, f) {
        var E = this.type === m._in;
        return (
          this.next(),
          f.type === 'VariableDeclaration' &&
            f.declarations[0].init != null &&
            (!E ||
              this.options.ecmaVersion < 8 ||
              this.strict ||
              f.kind !== 'var' ||
              f.declarations[0].id.type !== 'Identifier') &&
            this.raise(f.start, (E ? 'for-in' : 'for-of') + ' loop variable declaration may not have an initializer'),
          (a.left = f),
          (a.right = E ? this.parseExpression() : this.parseMaybeAssign()),
          this.expect(m.parenR),
          (a.body = this.parseStatement('for')),
          this.exitScope(),
          this.labels.pop(),
          this.finishNode(a, E ? 'ForInStatement' : 'ForOfStatement')
        );
      }),
      (me.parseVar = function (a, f, E, T) {
        for (a.declarations = [], a.kind = E; ; ) {
          var L = this.startNode();
          if (
            (this.parseVarId(L, E),
            this.eat(m.eq)
              ? (L.init = this.parseMaybeAssign(f))
              : !T &&
                E === 'const' &&
                !(this.type === m._in || (this.options.ecmaVersion >= 6 && this.isContextual('of')))
              ? this.unexpected()
              : !T && L.id.type !== 'Identifier' && !(f && (this.type === m._in || this.isContextual('of')))
              ? this.raise(this.lastTokEnd, 'Complex binding patterns require an initialization value')
              : (L.init = null),
            a.declarations.push(this.finishNode(L, 'VariableDeclarator')),
            !this.eat(m.comma))
          )
            break;
        }
        return a;
      }),
      (me.parseVarId = function (a, f) {
        (a.id = this.parseBindingAtom()), this.checkLValPattern(a.id, f === 'var' ? k : S, !1);
      });
    var Ie = 1,
      st = 2,
      yt = 4;
    (me.parseFunction = function (a, f, E, T, L) {
      this.initFunction(a),
        (this.options.ecmaVersion >= 9 || (this.options.ecmaVersion >= 6 && !T)) &&
          (this.type === m.star && f & st && this.unexpected(), (a.generator = this.eat(m.star))),
        this.options.ecmaVersion >= 8 && (a.async = !!T),
        f & Ie &&
          ((a.id = f & yt && this.type !== m.name ? null : this.parseIdent()),
          a.id &&
            !(f & st) &&
            this.checkLValSimple(a.id, this.strict || a.generator || a.async ? (this.treatFunctionsAsVar ? k : S) : M));
      var $ = this.yieldPos,
        J = this.awaitPos,
        he = this.awaitIdentPos;
      return (
        (this.yieldPos = 0),
        (this.awaitPos = 0),
        (this.awaitIdentPos = 0),
        this.enterScope(w(a.async, a.generator)),
        f & Ie || (a.id = this.type === m.name ? this.parseIdent() : null),
        this.parseFunctionParams(a),
        this.parseFunctionBody(a, E, !1, L),
        (this.yieldPos = $),
        (this.awaitPos = J),
        (this.awaitIdentPos = he),
        this.finishNode(a, f & Ie ? 'FunctionDeclaration' : 'FunctionExpression')
      );
    }),
      (me.parseFunctionParams = function (a) {
        this.expect(m.parenL),
          (a.params = this.parseBindingList(m.parenR, !1, this.options.ecmaVersion >= 8)),
          this.checkYieldAwaitInDefaultParams();
      }),
      (me.parseClass = function (a, f) {
        this.next();
        var E = this.strict;
        (this.strict = !0), this.parseClassId(a, f), this.parseClassSuper(a);
        var T = this.enterClassBody(),
          L = this.startNode(),
          $ = !1;
        for (L.body = [], this.expect(m.braceL); this.type !== m.braceR; ) {
          var J = this.parseClassElement(a.superClass !== null);
          J &&
            (L.body.push(J),
            J.type === 'MethodDefinition' && J.kind === 'constructor'
              ? ($ && this.raiseRecoverable(J.start, 'Duplicate constructor in the same class'), ($ = !0))
              : J.key &&
                J.key.type === 'PrivateIdentifier' &&
                St(T, J) &&
                this.raiseRecoverable(J.key.start, "Identifier '#" + J.key.name + "' has already been declared"));
        }
        return (
          (this.strict = E),
          this.next(),
          (a.body = this.finishNode(L, 'ClassBody')),
          this.exitClassBody(),
          this.finishNode(a, f ? 'ClassDeclaration' : 'ClassExpression')
        );
      }),
      (me.parseClassElement = function (a) {
        if (this.eat(m.semi)) return null;
        var f = this.options.ecmaVersion,
          E = this.startNode(),
          T = '',
          L = !1,
          $ = !1,
          J = 'method',
          he = !1;
        if (this.eatContextual('static')) {
          if (f >= 13 && this.eat(m.braceL)) return this.parseClassStaticBlock(E), E;
          this.isClassElementNameStart() || this.type === m.star ? (he = !0) : (T = 'static');
        }
        if (
          ((E.static = he),
          !T &&
            f >= 8 &&
            this.eatContextual('async') &&
            ((this.isClassElementNameStart() || this.type === m.star) && !this.canInsertSemicolon()
              ? ($ = !0)
              : (T = 'async')),
          !T && (f >= 9 || !$) && this.eat(m.star) && (L = !0),
          !T && !$ && !L)
        ) {
          var ge = this.value;
          (this.eatContextual('get') || this.eatContextual('set')) &&
            (this.isClassElementNameStart() ? (J = ge) : (T = ge));
        }
        if (
          (T
            ? ((E.computed = !1),
              (E.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc)),
              (E.key.name = T),
              this.finishNode(E.key, 'Identifier'))
            : this.parseClassElementName(E),
          f < 13 || this.type === m.parenL || J !== 'method' || L || $)
        ) {
          var Fe = !E.static && bt(E, 'constructor'),
            qe = Fe && a;
          Fe && J !== 'method' && this.raise(E.key.start, "Constructor can't have get/set modifier"),
            (E.kind = Fe ? 'constructor' : J),
            this.parseClassMethod(E, L, $, qe);
        } else this.parseClassField(E);
        return E;
      }),
      (me.isClassElementNameStart = function () {
        return (
          this.type === m.name ||
          this.type === m.privateId ||
          this.type === m.num ||
          this.type === m.string ||
          this.type === m.bracketL ||
          this.type.keyword
        );
      }),
      (me.parseClassElementName = function (a) {
        this.type === m.privateId
          ? (this.value === 'constructor' &&
              this.raise(this.start, "Classes can't have an element named '#constructor'"),
            (a.computed = !1),
            (a.key = this.parsePrivateIdent()))
          : this.parsePropertyName(a);
      }),
      (me.parseClassMethod = function (a, f, E, T) {
        var L = a.key;
        a.kind === 'constructor'
          ? (f && this.raise(L.start, "Constructor can't be a generator"),
            E && this.raise(L.start, "Constructor can't be an async method"))
          : a.static &&
            bt(a, 'prototype') &&
            this.raise(L.start, 'Classes may not have a static property named prototype');
        var $ = (a.value = this.parseMethod(f, E, T));
        return (
          a.kind === 'get' && $.params.length !== 0 && this.raiseRecoverable($.start, 'getter should have no params'),
          a.kind === 'set' &&
            $.params.length !== 1 &&
            this.raiseRecoverable($.start, 'setter should have exactly one param'),
          a.kind === 'set' &&
            $.params[0].type === 'RestElement' &&
            this.raiseRecoverable($.params[0].start, 'Setter cannot use rest params'),
          this.finishNode(a, 'MethodDefinition')
        );
      }),
      (me.parseClassField = function (a) {
        if (
          (bt(a, 'constructor')
            ? this.raise(a.key.start, "Classes can't have a field named 'constructor'")
            : a.static &&
              bt(a, 'prototype') &&
              this.raise(a.key.start, "Classes can't have a static field named 'prototype'"),
          this.eat(m.eq))
        ) {
          var f = this.currentThisScope(),
            E = f.inClassFieldInit;
          (f.inClassFieldInit = !0), (a.value = this.parseMaybeAssign()), (f.inClassFieldInit = E);
        } else a.value = null;
        return this.semicolon(), this.finishNode(a, 'PropertyDefinition');
      }),
      (me.parseClassStaticBlock = function (a) {
        a.body = [];
        var f = this.labels;
        for (this.labels = [], this.enterScope(ze | Oe); this.type !== m.braceR; ) {
          var E = this.parseStatement(null);
          a.body.push(E);
        }
        return this.next(), this.exitScope(), (this.labels = f), this.finishNode(a, 'StaticBlock');
      }),
      (me.parseClassId = function (a, f) {
        this.type === m.name
          ? ((a.id = this.parseIdent()), f && this.checkLValSimple(a.id, S, !1))
          : (f === !0 && this.unexpected(), (a.id = null));
      }),
      (me.parseClassSuper = function (a) {
        a.superClass = this.eat(m._extends) ? this.parseExprSubscripts(null, !1) : null;
      }),
      (me.enterClassBody = function () {
        var a = { declared: Object.create(null), used: [] };
        return this.privateNameStack.push(a), a.declared;
      }),
      (me.exitClassBody = function () {
        var a = this.privateNameStack.pop(),
          f = a.declared,
          E = a.used;
        if (this.options.checkPrivateFields)
          for (
            var T = this.privateNameStack.length, L = T === 0 ? null : this.privateNameStack[T - 1], $ = 0;
            $ < E.length;
            ++$
          ) {
            var J = E[$];
            V(f, J.name) ||
              (L
                ? L.used.push(J)
                : this.raiseRecoverable(
                    J.start,
                    "Private field '#" + J.name + "' must be declared in an enclosing class"
                  ));
          }
      });
    function St(a, f) {
      var E = f.key.name,
        T = a[E],
        L = 'true';
      return (
        f.type === 'MethodDefinition' &&
          (f.kind === 'get' || f.kind === 'set') &&
          (L = (f.static ? 's' : 'i') + f.kind),
        (T === 'iget' && L === 'iset') ||
        (T === 'iset' && L === 'iget') ||
        (T === 'sget' && L === 'sset') ||
        (T === 'sset' && L === 'sget')
          ? ((a[E] = 'true'), !1)
          : T
          ? !0
          : ((a[E] = L), !1)
      );
    }
    function bt(a, f) {
      var E = a.computed,
        T = a.key;
      return !E && ((T.type === 'Identifier' && T.name === f) || (T.type === 'Literal' && T.value === f));
    }
    (me.parseExportAllDeclaration = function (a, f) {
      return (
        this.options.ecmaVersion >= 11 &&
          (this.eatContextual('as')
            ? ((a.exported = this.parseModuleExportName()), this.checkExport(f, a.exported, this.lastTokStart))
            : (a.exported = null)),
        this.expectContextual('from'),
        this.type !== m.string && this.unexpected(),
        (a.source = this.parseExprAtom()),
        this.semicolon(),
        this.finishNode(a, 'ExportAllDeclaration')
      );
    }),
      (me.parseExport = function (a, f) {
        if ((this.next(), this.eat(m.star))) return this.parseExportAllDeclaration(a, f);
        if (this.eat(m._default))
          return (
            this.checkExport(f, 'default', this.lastTokStart),
            (a.declaration = this.parseExportDefaultDeclaration()),
            this.finishNode(a, 'ExportDefaultDeclaration')
          );
        if (this.shouldParseExportStatement())
          (a.declaration = this.parseExportDeclaration(a)),
            a.declaration.type === 'VariableDeclaration'
              ? this.checkVariableExport(f, a.declaration.declarations)
              : this.checkExport(f, a.declaration.id, a.declaration.id.start),
            (a.specifiers = []),
            (a.source = null);
        else {
          if (((a.declaration = null), (a.specifiers = this.parseExportSpecifiers(f)), this.eatContextual('from')))
            this.type !== m.string && this.unexpected(), (a.source = this.parseExprAtom());
          else {
            for (var E = 0, T = a.specifiers; E < T.length; E += 1) {
              var L = T[E];
              this.checkUnreserved(L.local),
                this.checkLocalExport(L.local),
                L.local.type === 'Literal' &&
                  this.raise(L.local.start, 'A string literal cannot be used as an exported binding without `from`.');
            }
            a.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(a, 'ExportNamedDeclaration');
      }),
      (me.parseExportDeclaration = function (a) {
        return this.parseStatement(null);
      }),
      (me.parseExportDefaultDeclaration = function () {
        var a;
        if (this.type === m._function || (a = this.isAsyncFunction())) {
          var f = this.startNode();
          return this.next(), a && this.next(), this.parseFunction(f, Ie | yt, !1, a);
        } else if (this.type === m._class) {
          var E = this.startNode();
          return this.parseClass(E, 'nullableID');
        } else {
          var T = this.parseMaybeAssign();
          return this.semicolon(), T;
        }
      }),
      (me.checkExport = function (a, f, E) {
        a &&
          (typeof f != 'string' && (f = f.type === 'Identifier' ? f.name : f.value),
          V(a, f) && this.raiseRecoverable(E, "Duplicate export '" + f + "'"),
          (a[f] = !0));
      }),
      (me.checkPatternExport = function (a, f) {
        var E = f.type;
        if (E === 'Identifier') this.checkExport(a, f, f.start);
        else if (E === 'ObjectPattern')
          for (var T = 0, L = f.properties; T < L.length; T += 1) {
            var $ = L[T];
            this.checkPatternExport(a, $);
          }
        else if (E === 'ArrayPattern')
          for (var J = 0, he = f.elements; J < he.length; J += 1) {
            var ge = he[J];
            ge && this.checkPatternExport(a, ge);
          }
        else
          E === 'Property'
            ? this.checkPatternExport(a, f.value)
            : E === 'AssignmentPattern'
            ? this.checkPatternExport(a, f.left)
            : E === 'RestElement'
            ? this.checkPatternExport(a, f.argument)
            : E === 'ParenthesizedExpression' && this.checkPatternExport(a, f.expression);
      }),
      (me.checkVariableExport = function (a, f) {
        if (a)
          for (var E = 0, T = f; E < T.length; E += 1) {
            var L = T[E];
            this.checkPatternExport(a, L.id);
          }
      }),
      (me.shouldParseExportStatement = function () {
        return (
          this.type.keyword === 'var' ||
          this.type.keyword === 'const' ||
          this.type.keyword === 'class' ||
          this.type.keyword === 'function' ||
          this.isLet() ||
          this.isAsyncFunction()
        );
      }),
      (me.parseExportSpecifier = function (a) {
        var f = this.startNode();
        return (
          (f.local = this.parseModuleExportName()),
          (f.exported = this.eatContextual('as') ? this.parseModuleExportName() : f.local),
          this.checkExport(a, f.exported, f.exported.start),
          this.finishNode(f, 'ExportSpecifier')
        );
      }),
      (me.parseExportSpecifiers = function (a) {
        var f = [],
          E = !0;
        for (this.expect(m.braceL); !this.eat(m.braceR); ) {
          if (E) E = !1;
          else if ((this.expect(m.comma), this.afterTrailingComma(m.braceR))) break;
          f.push(this.parseExportSpecifier(a));
        }
        return f;
      }),
      (me.parseImport = function (a) {
        return (
          this.next(),
          this.type === m.string
            ? ((a.specifiers = xt), (a.source = this.parseExprAtom()))
            : ((a.specifiers = this.parseImportSpecifiers()),
              this.expectContextual('from'),
              (a.source = this.type === m.string ? this.parseExprAtom() : this.unexpected())),
          this.semicolon(),
          this.finishNode(a, 'ImportDeclaration')
        );
      }),
      (me.parseImportSpecifier = function () {
        var a = this.startNode();
        return (
          (a.imported = this.parseModuleExportName()),
          this.eatContextual('as')
            ? (a.local = this.parseIdent())
            : (this.checkUnreserved(a.imported), (a.local = a.imported)),
          this.checkLValSimple(a.local, S),
          this.finishNode(a, 'ImportSpecifier')
        );
      }),
      (me.parseImportDefaultSpecifier = function () {
        var a = this.startNode();
        return (
          (a.local = this.parseIdent()), this.checkLValSimple(a.local, S), this.finishNode(a, 'ImportDefaultSpecifier')
        );
      }),
      (me.parseImportNamespaceSpecifier = function () {
        var a = this.startNode();
        return (
          this.next(),
          this.expectContextual('as'),
          (a.local = this.parseIdent()),
          this.checkLValSimple(a.local, S),
          this.finishNode(a, 'ImportNamespaceSpecifier')
        );
      }),
      (me.parseImportSpecifiers = function () {
        var a = [],
          f = !0;
        if (this.type === m.name && (a.push(this.parseImportDefaultSpecifier()), !this.eat(m.comma))) return a;
        if (this.type === m.star) return a.push(this.parseImportNamespaceSpecifier()), a;
        for (this.expect(m.braceL); !this.eat(m.braceR); ) {
          if (f) f = !1;
          else if ((this.expect(m.comma), this.afterTrailingComma(m.braceR))) break;
          a.push(this.parseImportSpecifier());
        }
        return a;
      }),
      (me.parseModuleExportName = function () {
        if (this.options.ecmaVersion >= 13 && this.type === m.string) {
          var a = this.parseLiteral(this.value);
          return B.test(a.value) && this.raise(a.start, 'An export name cannot include a lone surrogate.'), a;
        }
        return this.parseIdent(!0);
      }),
      (me.adaptDirectivePrologue = function (a) {
        for (var f = 0; f < a.length && this.isDirectiveCandidate(a[f]); ++f)
          a[f].directive = a[f].expression.raw.slice(1, -1);
      }),
      (me.isDirectiveCandidate = function (a) {
        return (
          this.options.ecmaVersion >= 5 &&
          a.type === 'ExpressionStatement' &&
          a.expression.type === 'Literal' &&
          typeof a.expression.value == 'string' &&
          (this.input[a.start] === '"' || this.input[a.start] === "'")
        );
      });
    var lt = re.prototype;
    (lt.toAssignable = function (a, f, E) {
      if (this.options.ecmaVersion >= 6 && a)
        switch (a.type) {
          case 'Identifier':
            this.inAsync &&
              a.name === 'await' &&
              this.raise(a.start, "Cannot use 'await' as identifier inside an async function");
            break;
          case 'ObjectPattern':
          case 'ArrayPattern':
          case 'AssignmentPattern':
          case 'RestElement':
            break;
          case 'ObjectExpression':
            (a.type = 'ObjectPattern'), E && this.checkPatternErrors(E, !0);
            for (var T = 0, L = a.properties; T < L.length; T += 1) {
              var $ = L[T];
              this.toAssignable($, f),
                $.type === 'RestElement' &&
                  ($.argument.type === 'ArrayPattern' || $.argument.type === 'ObjectPattern') &&
                  this.raise($.argument.start, 'Unexpected token');
            }
            break;
          case 'Property':
            a.kind !== 'init' && this.raise(a.key.start, "Object pattern can't contain getter or setter"),
              this.toAssignable(a.value, f);
            break;
          case 'ArrayExpression':
            (a.type = 'ArrayPattern'), E && this.checkPatternErrors(E, !0), this.toAssignableList(a.elements, f);
            break;
          case 'SpreadElement':
            (a.type = 'RestElement'),
              this.toAssignable(a.argument, f),
              a.argument.type === 'AssignmentPattern' &&
                this.raise(a.argument.start, 'Rest elements cannot have a default value');
            break;
          case 'AssignmentExpression':
            a.operator !== '=' && this.raise(a.left.end, "Only '=' operator can be used for specifying default value."),
              (a.type = 'AssignmentPattern'),
              delete a.operator,
              this.toAssignable(a.left, f);
            break;
          case 'ParenthesizedExpression':
            this.toAssignable(a.expression, f, E);
            break;
          case 'ChainExpression':
            this.raiseRecoverable(a.start, 'Optional chaining cannot appear in left-hand side');
            break;
          case 'MemberExpression':
            if (!f) break;
          default:
            this.raise(a.start, 'Assigning to rvalue');
        }
      else E && this.checkPatternErrors(E, !0);
      return a;
    }),
      (lt.toAssignableList = function (a, f) {
        for (var E = a.length, T = 0; T < E; T++) {
          var L = a[T];
          L && this.toAssignable(L, f);
        }
        if (E) {
          var $ = a[E - 1];
          this.options.ecmaVersion === 6 &&
            f &&
            $ &&
            $.type === 'RestElement' &&
            $.argument.type !== 'Identifier' &&
            this.unexpected($.argument.start);
        }
        return a;
      }),
      (lt.parseSpread = function (a) {
        var f = this.startNode();
        return this.next(), (f.argument = this.parseMaybeAssign(!1, a)), this.finishNode(f, 'SpreadElement');
      }),
      (lt.parseRestBinding = function () {
        var a = this.startNode();
        return (
          this.next(),
          this.options.ecmaVersion === 6 && this.type !== m.name && this.unexpected(),
          (a.argument = this.parseBindingAtom()),
          this.finishNode(a, 'RestElement')
        );
      }),
      (lt.parseBindingAtom = function () {
        if (this.options.ecmaVersion >= 6)
          switch (this.type) {
            case m.bracketL:
              var a = this.startNode();
              return (
                this.next(),
                (a.elements = this.parseBindingList(m.bracketR, !0, !0)),
                this.finishNode(a, 'ArrayPattern')
              );
            case m.braceL:
              return this.parseObj(!0);
          }
        return this.parseIdent();
      }),
      (lt.parseBindingList = function (a, f, E, T) {
        for (var L = [], $ = !0; !this.eat(a); )
          if (($ ? ($ = !1) : this.expect(m.comma), f && this.type === m.comma)) L.push(null);
          else {
            if (E && this.afterTrailingComma(a)) break;
            if (this.type === m.ellipsis) {
              var J = this.parseRestBinding();
              this.parseBindingListItem(J),
                L.push(J),
                this.type === m.comma &&
                  this.raiseRecoverable(this.start, 'Comma is not permitted after the rest element'),
                this.expect(a);
              break;
            } else L.push(this.parseAssignableListItem(T));
          }
        return L;
      }),
      (lt.parseAssignableListItem = function (a) {
        var f = this.parseMaybeDefault(this.start, this.startLoc);
        return this.parseBindingListItem(f), f;
      }),
      (lt.parseBindingListItem = function (a) {
        return a;
      }),
      (lt.parseMaybeDefault = function (a, f, E) {
        if (((E = E || this.parseBindingAtom()), this.options.ecmaVersion < 6 || !this.eat(m.eq))) return E;
        var T = this.startNodeAt(a, f);
        return (T.left = E), (T.right = this.parseMaybeAssign()), this.finishNode(T, 'AssignmentPattern');
      }),
      (lt.checkLValSimple = function (a, f, E) {
        f === void 0 && (f = A);
        var T = f !== A;
        switch (a.type) {
          case 'Identifier':
            this.strict &&
              this.reservedWordsStrictBind.test(a.name) &&
              this.raiseRecoverable(a.start, (T ? 'Binding ' : 'Assigning to ') + a.name + ' in strict mode'),
              T &&
                (f === S &&
                  a.name === 'let' &&
                  this.raiseRecoverable(a.start, 'let is disallowed as a lexically bound name'),
                E && (V(E, a.name) && this.raiseRecoverable(a.start, 'Argument name clash'), (E[a.name] = !0)),
                f !== U && this.declareName(a.name, f, a.start));
            break;
          case 'ChainExpression':
            this.raiseRecoverable(a.start, 'Optional chaining cannot appear in left-hand side');
            break;
          case 'MemberExpression':
            T && this.raiseRecoverable(a.start, 'Binding member expression');
            break;
          case 'ParenthesizedExpression':
            return (
              T && this.raiseRecoverable(a.start, 'Binding parenthesized expression'),
              this.checkLValSimple(a.expression, f, E)
            );
          default:
            this.raise(a.start, (T ? 'Binding' : 'Assigning to') + ' rvalue');
        }
      }),
      (lt.checkLValPattern = function (a, f, E) {
        switch ((f === void 0 && (f = A), a.type)) {
          case 'ObjectPattern':
            for (var T = 0, L = a.properties; T < L.length; T += 1) {
              var $ = L[T];
              this.checkLValInnerPattern($, f, E);
            }
            break;
          case 'ArrayPattern':
            for (var J = 0, he = a.elements; J < he.length; J += 1) {
              var ge = he[J];
              ge && this.checkLValInnerPattern(ge, f, E);
            }
            break;
          default:
            this.checkLValSimple(a, f, E);
        }
      }),
      (lt.checkLValInnerPattern = function (a, f, E) {
        switch ((f === void 0 && (f = A), a.type)) {
          case 'Property':
            this.checkLValInnerPattern(a.value, f, E);
            break;
          case 'AssignmentPattern':
            this.checkLValPattern(a.left, f, E);
            break;
          case 'RestElement':
            this.checkLValPattern(a.argument, f, E);
            break;
          default:
            this.checkLValPattern(a, f, E);
        }
      });
    var Qe = function (f, E, T, L, $) {
        (this.token = f), (this.isExpr = !!E), (this.preserveSpace = !!T), (this.override = L), (this.generator = !!$);
      },
      et = {
        b_stat: new Qe('{', !1),
        b_expr: new Qe('{', !0),
        b_tmpl: new Qe('${', !1),
        p_stat: new Qe('(', !1),
        p_expr: new Qe('(', !0),
        q_tmpl: new Qe('`', !0, !0, function (a) {
          return a.tryReadTemplateToken();
        }),
        f_stat: new Qe('function', !1),
        f_expr: new Qe('function', !0),
        f_expr_gen: new Qe('function', !0, !1, null, !0),
        f_gen: new Qe('function', !1, !1, null, !0),
      },
      fn = re.prototype;
    (fn.initialContext = function () {
      return [et.b_stat];
    }),
      (fn.curContext = function () {
        return this.context[this.context.length - 1];
      }),
      (fn.braceIsBlock = function (a) {
        var f = this.curContext();
        return f === et.f_expr || f === et.f_stat
          ? !0
          : a === m.colon && (f === et.b_stat || f === et.b_expr)
          ? !f.isExpr
          : a === m._return || (a === m.name && this.exprAllowed)
          ? O.test(this.input.slice(this.lastTokEnd, this.start))
          : a === m._else || a === m.semi || a === m.eof || a === m.parenR || a === m.arrow
          ? !0
          : a === m.braceL
          ? f === et.b_stat
          : a === m._var || a === m._const || a === m.name
          ? !1
          : !this.exprAllowed;
      }),
      (fn.inGeneratorContext = function () {
        for (var a = this.context.length - 1; a >= 1; a--) {
          var f = this.context[a];
          if (f.token === 'function') return f.generator;
        }
        return !1;
      }),
      (fn.updateContext = function (a) {
        var f,
          E = this.type;
        E.keyword && a === m.dot
          ? (this.exprAllowed = !1)
          : (f = E.updateContext)
          ? f.call(this, a)
          : (this.exprAllowed = E.beforeExpr);
      }),
      (fn.overrideContext = function (a) {
        this.curContext() !== a && (this.context[this.context.length - 1] = a);
      }),
      (m.parenR.updateContext = m.braceR.updateContext =
        function () {
          if (this.context.length === 1) {
            this.exprAllowed = !0;
            return;
          }
          var a = this.context.pop();
          a === et.b_stat && this.curContext().token === 'function' && (a = this.context.pop()),
            (this.exprAllowed = !a.isExpr);
        }),
      (m.braceL.updateContext = function (a) {
        this.context.push(this.braceIsBlock(a) ? et.b_stat : et.b_expr), (this.exprAllowed = !0);
      }),
      (m.dollarBraceL.updateContext = function () {
        this.context.push(et.b_tmpl), (this.exprAllowed = !0);
      }),
      (m.parenL.updateContext = function (a) {
        var f = a === m._if || a === m._for || a === m._with || a === m._while;
        this.context.push(f ? et.p_stat : et.p_expr), (this.exprAllowed = !0);
      }),
      (m.incDec.updateContext = function () {}),
      (m._function.updateContext = m._class.updateContext =
        function (a) {
          a.beforeExpr &&
          a !== m._else &&
          !(a === m.semi && this.curContext() !== et.p_stat) &&
          !(a === m._return && O.test(this.input.slice(this.lastTokEnd, this.start))) &&
          !((a === m.colon || a === m.braceL) && this.curContext() === et.b_stat)
            ? this.context.push(et.f_expr)
            : this.context.push(et.f_stat),
            (this.exprAllowed = !1);
        }),
      (m.backQuote.updateContext = function () {
        this.curContext() === et.q_tmpl ? this.context.pop() : this.context.push(et.q_tmpl), (this.exprAllowed = !1);
      }),
      (m.star.updateContext = function (a) {
        if (a === m._function) {
          var f = this.context.length - 1;
          this.context[f] === et.f_expr ? (this.context[f] = et.f_expr_gen) : (this.context[f] = et.f_gen);
        }
        this.exprAllowed = !0;
      }),
      (m.name.updateContext = function (a) {
        var f = !1;
        this.options.ecmaVersion >= 6 &&
          a !== m.dot &&
          ((this.value === 'of' && !this.exprAllowed) || (this.value === 'yield' && this.inGeneratorContext())) &&
          (f = !0),
          (this.exprAllowed = f);
      });
    var Ee = re.prototype;
    (Ee.checkPropClash = function (a, f, E) {
      if (
        !(this.options.ecmaVersion >= 9 && a.type === 'SpreadElement') &&
        !(this.options.ecmaVersion >= 6 && (a.computed || a.method || a.shorthand))
      ) {
        var T = a.key,
          L;
        switch (T.type) {
          case 'Identifier':
            L = T.name;
            break;
          case 'Literal':
            L = String(T.value);
            break;
          default:
            return;
        }
        var $ = a.kind;
        if (this.options.ecmaVersion >= 6) {
          L === '__proto__' &&
            $ === 'init' &&
            (f.proto &&
              (E
                ? E.doubleProto < 0 && (E.doubleProto = T.start)
                : this.raiseRecoverable(T.start, 'Redefinition of __proto__ property')),
            (f.proto = !0));
          return;
        }
        L = '$' + L;
        var J = f[L];
        if (J) {
          var he;
          $ === 'init' ? (he = (this.strict && J.init) || J.get || J.set) : (he = J.init || J[$]),
            he && this.raiseRecoverable(T.start, 'Redefinition of property');
        } else J = f[L] = { init: !1, get: !1, set: !1 };
        J[$] = !0;
      }
    }),
      (Ee.parseExpression = function (a, f) {
        var E = this.start,
          T = this.startLoc,
          L = this.parseMaybeAssign(a, f);
        if (this.type === m.comma) {
          var $ = this.startNodeAt(E, T);
          for ($.expressions = [L]; this.eat(m.comma); ) $.expressions.push(this.parseMaybeAssign(a, f));
          return this.finishNode($, 'SequenceExpression');
        }
        return L;
      }),
      (Ee.parseMaybeAssign = function (a, f, E) {
        if (this.isContextual('yield')) {
          if (this.inGenerator) return this.parseYield(a);
          this.exprAllowed = !1;
        }
        var T = !1,
          L = -1,
          $ = -1,
          J = -1;
        f
          ? ((L = f.parenthesizedAssign),
            ($ = f.trailingComma),
            (J = f.doubleProto),
            (f.parenthesizedAssign = f.trailingComma = -1))
          : ((f = new Ne()), (T = !0));
        var he = this.start,
          ge = this.startLoc;
        (this.type === m.parenL || this.type === m.name) &&
          ((this.potentialArrowAt = this.start), (this.potentialArrowInForAwait = a === 'await'));
        var Fe = this.parseMaybeConditional(a, f);
        if ((E && (Fe = E.call(this, Fe, he, ge)), this.type.isAssign)) {
          var qe = this.startNodeAt(he, ge);
          return (
            (qe.operator = this.value),
            this.type === m.eq && (Fe = this.toAssignable(Fe, !1, f)),
            T || (f.parenthesizedAssign = f.trailingComma = f.doubleProto = -1),
            f.shorthandAssign >= Fe.start && (f.shorthandAssign = -1),
            this.type === m.eq ? this.checkLValPattern(Fe) : this.checkLValSimple(Fe),
            (qe.left = Fe),
            this.next(),
            (qe.right = this.parseMaybeAssign(a)),
            J > -1 && (f.doubleProto = J),
            this.finishNode(qe, 'AssignmentExpression')
          );
        } else T && this.checkExpressionErrors(f, !0);
        return L > -1 && (f.parenthesizedAssign = L), $ > -1 && (f.trailingComma = $), Fe;
      }),
      (Ee.parseMaybeConditional = function (a, f) {
        var E = this.start,
          T = this.startLoc,
          L = this.parseExprOps(a, f);
        if (this.checkExpressionErrors(f)) return L;
        if (this.eat(m.question)) {
          var $ = this.startNodeAt(E, T);
          return (
            ($.test = L),
            ($.consequent = this.parseMaybeAssign()),
            this.expect(m.colon),
            ($.alternate = this.parseMaybeAssign(a)),
            this.finishNode($, 'ConditionalExpression')
          );
        }
        return L;
      }),
      (Ee.parseExprOps = function (a, f) {
        var E = this.start,
          T = this.startLoc,
          L = this.parseMaybeUnary(f, !1, !1, a);
        return this.checkExpressionErrors(f) || (L.start === E && L.type === 'ArrowFunctionExpression')
          ? L
          : this.parseExprOp(L, E, T, -1, a);
      }),
      (Ee.parseExprOp = function (a, f, E, T, L) {
        var $ = this.type.binop;
        if ($ != null && (!L || this.type !== m._in) && $ > T) {
          var J = this.type === m.logicalOR || this.type === m.logicalAND,
            he = this.type === m.coalesce;
          he && ($ = m.logicalAND.binop);
          var ge = this.value;
          this.next();
          var Fe = this.start,
            qe = this.startLoc,
            Dt = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, L), Fe, qe, $, L),
            Ms = this.buildBinary(f, E, a, Dt, ge, J || he);
          return (
            ((J && this.type === m.coalesce) || (he && (this.type === m.logicalOR || this.type === m.logicalAND))) &&
              this.raiseRecoverable(
                this.start,
                'Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses'
              ),
            this.parseExprOp(Ms, f, E, T, L)
          );
        }
        return a;
      }),
      (Ee.buildBinary = function (a, f, E, T, L, $) {
        T.type === 'PrivateIdentifier' &&
          this.raise(T.start, 'Private identifier can only be left side of binary expression');
        var J = this.startNodeAt(a, f);
        return (
          (J.left = E),
          (J.operator = L),
          (J.right = T),
          this.finishNode(J, $ ? 'LogicalExpression' : 'BinaryExpression')
        );
      }),
      (Ee.parseMaybeUnary = function (a, f, E, T) {
        var L = this.start,
          $ = this.startLoc,
          J;
        if (this.isContextual('await') && this.canAwait) (J = this.parseAwait(T)), (f = !0);
        else if (this.type.prefix) {
          var he = this.startNode(),
            ge = this.type === m.incDec;
          (he.operator = this.value),
            (he.prefix = !0),
            this.next(),
            (he.argument = this.parseMaybeUnary(null, !0, ge, T)),
            this.checkExpressionErrors(a, !0),
            ge
              ? this.checkLValSimple(he.argument)
              : this.strict && he.operator === 'delete' && he.argument.type === 'Identifier'
              ? this.raiseRecoverable(he.start, 'Deleting local variable in strict mode')
              : he.operator === 'delete' && Ze(he.argument)
              ? this.raiseRecoverable(he.start, 'Private fields can not be deleted')
              : (f = !0),
            (J = this.finishNode(he, ge ? 'UpdateExpression' : 'UnaryExpression'));
        } else if (!f && this.type === m.privateId)
          (T || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(),
            (J = this.parsePrivateIdent()),
            this.type !== m._in && this.unexpected();
        else {
          if (((J = this.parseExprSubscripts(a, T)), this.checkExpressionErrors(a))) return J;
          for (; this.type.postfix && !this.canInsertSemicolon(); ) {
            var Fe = this.startNodeAt(L, $);
            (Fe.operator = this.value),
              (Fe.prefix = !1),
              (Fe.argument = J),
              this.checkLValSimple(J),
              this.next(),
              (J = this.finishNode(Fe, 'UpdateExpression'));
          }
        }
        if (!E && this.eat(m.starstar))
          if (f) this.unexpected(this.lastTokStart);
          else return this.buildBinary(L, $, J, this.parseMaybeUnary(null, !1, !1, T), '**', !1);
        else return J;
      });
    function Ze(a) {
      return (
        (a.type === 'MemberExpression' && a.property.type === 'PrivateIdentifier') ||
        (a.type === 'ChainExpression' && Ze(a.expression))
      );
    }
    (Ee.parseExprSubscripts = function (a, f) {
      var E = this.start,
        T = this.startLoc,
        L = this.parseExprAtom(a, f);
      if (L.type === 'ArrowFunctionExpression' && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ')')
        return L;
      var $ = this.parseSubscripts(L, E, T, !1, f);
      return (
        a &&
          $.type === 'MemberExpression' &&
          (a.parenthesizedAssign >= $.start && (a.parenthesizedAssign = -1),
          a.parenthesizedBind >= $.start && (a.parenthesizedBind = -1),
          a.trailingComma >= $.start && (a.trailingComma = -1)),
        $
      );
    }),
      (Ee.parseSubscripts = function (a, f, E, T, L) {
        for (
          var $ =
              this.options.ecmaVersion >= 8 &&
              a.type === 'Identifier' &&
              a.name === 'async' &&
              this.lastTokEnd === a.end &&
              !this.canInsertSemicolon() &&
              a.end - a.start === 5 &&
              this.potentialArrowAt === a.start,
            J = !1;
          ;

        ) {
          var he = this.parseSubscript(a, f, E, T, $, J, L);
          if ((he.optional && (J = !0), he === a || he.type === 'ArrowFunctionExpression')) {
            if (J) {
              var ge = this.startNodeAt(f, E);
              (ge.expression = he), (he = this.finishNode(ge, 'ChainExpression'));
            }
            return he;
          }
          a = he;
        }
      }),
      (Ee.shouldParseAsyncArrow = function () {
        return !this.canInsertSemicolon() && this.eat(m.arrow);
      }),
      (Ee.parseSubscriptAsyncArrow = function (a, f, E, T) {
        return this.parseArrowExpression(this.startNodeAt(a, f), E, !0, T);
      }),
      (Ee.parseSubscript = function (a, f, E, T, L, $, J) {
        var he = this.options.ecmaVersion >= 11,
          ge = he && this.eat(m.questionDot);
        T && ge && this.raise(this.lastTokStart, 'Optional chaining cannot appear in the callee of new expressions');
        var Fe = this.eat(m.bracketL);
        if (Fe || (ge && this.type !== m.parenL && this.type !== m.backQuote) || this.eat(m.dot)) {
          var qe = this.startNodeAt(f, E);
          (qe.object = a),
            Fe
              ? ((qe.property = this.parseExpression()), this.expect(m.bracketR))
              : this.type === m.privateId && a.type !== 'Super'
              ? (qe.property = this.parsePrivateIdent())
              : (qe.property = this.parseIdent(this.options.allowReserved !== 'never')),
            (qe.computed = !!Fe),
            he && (qe.optional = ge),
            (a = this.finishNode(qe, 'MemberExpression'));
        } else if (!T && this.eat(m.parenL)) {
          var Dt = new Ne(),
            Ms = this.yieldPos,
            Ic = this.awaitPos,
            Go = this.awaitIdentPos;
          (this.yieldPos = 0), (this.awaitPos = 0), (this.awaitIdentPos = 0);
          var Xl = this.parseExprList(m.parenR, this.options.ecmaVersion >= 8, !1, Dt);
          if (L && !ge && this.shouldParseAsyncArrow())
            return (
              this.checkPatternErrors(Dt, !1),
              this.checkYieldAwaitInDefaultParams(),
              this.awaitIdentPos > 0 &&
                this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"),
              (this.yieldPos = Ms),
              (this.awaitPos = Ic),
              (this.awaitIdentPos = Go),
              this.parseSubscriptAsyncArrow(f, E, Xl, J)
            );
          this.checkExpressionErrors(Dt, !0),
            (this.yieldPos = Ms || this.yieldPos),
            (this.awaitPos = Ic || this.awaitPos),
            (this.awaitIdentPos = Go || this.awaitIdentPos);
          var zo = this.startNodeAt(f, E);
          (zo.callee = a), (zo.arguments = Xl), he && (zo.optional = ge), (a = this.finishNode(zo, 'CallExpression'));
        } else if (this.type === m.backQuote) {
          (ge || $) &&
            this.raise(this.start, 'Optional chaining cannot appear in the tag of tagged template expressions');
          var Vo = this.startNodeAt(f, E);
          (Vo.tag = a),
            (Vo.quasi = this.parseTemplate({ isTagged: !0 })),
            (a = this.finishNode(Vo, 'TaggedTemplateExpression'));
        }
        return a;
      }),
      (Ee.parseExprAtom = function (a, f, E) {
        this.type === m.slash && this.readRegexp();
        var T,
          L = this.potentialArrowAt === this.start;
        switch (this.type) {
          case m._super:
            return (
              this.allowSuper || this.raise(this.start, "'super' keyword outside a method"),
              (T = this.startNode()),
              this.next(),
              this.type === m.parenL &&
                !this.allowDirectSuper &&
                this.raise(T.start, 'super() call outside constructor of a subclass'),
              this.type !== m.dot && this.type !== m.bracketL && this.type !== m.parenL && this.unexpected(),
              this.finishNode(T, 'Super')
            );
          case m._this:
            return (T = this.startNode()), this.next(), this.finishNode(T, 'ThisExpression');
          case m.name:
            var $ = this.start,
              J = this.startLoc,
              he = this.containsEsc,
              ge = this.parseIdent(!1);
            if (
              this.options.ecmaVersion >= 8 &&
              !he &&
              ge.name === 'async' &&
              !this.canInsertSemicolon() &&
              this.eat(m._function)
            )
              return this.overrideContext(et.f_expr), this.parseFunction(this.startNodeAt($, J), 0, !1, !0, f);
            if (L && !this.canInsertSemicolon()) {
              if (this.eat(m.arrow)) return this.parseArrowExpression(this.startNodeAt($, J), [ge], !1, f);
              if (
                this.options.ecmaVersion >= 8 &&
                ge.name === 'async' &&
                this.type === m.name &&
                !he &&
                (!this.potentialArrowInForAwait || this.value !== 'of' || this.containsEsc)
              )
                return (
                  (ge = this.parseIdent(!1)),
                  (this.canInsertSemicolon() || !this.eat(m.arrow)) && this.unexpected(),
                  this.parseArrowExpression(this.startNodeAt($, J), [ge], !0, f)
                );
            }
            return ge;
          case m.regexp:
            var Fe = this.value;
            return (T = this.parseLiteral(Fe.value)), (T.regex = { pattern: Fe.pattern, flags: Fe.flags }), T;
          case m.num:
          case m.string:
            return this.parseLiteral(this.value);
          case m._null:
          case m._true:
          case m._false:
            return (
              (T = this.startNode()),
              (T.value = this.type === m._null ? null : this.type === m._true),
              (T.raw = this.type.keyword),
              this.next(),
              this.finishNode(T, 'Literal')
            );
          case m.parenL:
            var qe = this.start,
              Dt = this.parseParenAndDistinguishExpression(L, f);
            return (
              a &&
                (a.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(Dt) && (a.parenthesizedAssign = qe),
                a.parenthesizedBind < 0 && (a.parenthesizedBind = qe)),
              Dt
            );
          case m.bracketL:
            return (
              (T = this.startNode()),
              this.next(),
              (T.elements = this.parseExprList(m.bracketR, !0, !0, a)),
              this.finishNode(T, 'ArrayExpression')
            );
          case m.braceL:
            return this.overrideContext(et.b_expr), this.parseObj(!1, a);
          case m._function:
            return (T = this.startNode()), this.next(), this.parseFunction(T, 0);
          case m._class:
            return this.parseClass(this.startNode(), !1);
          case m._new:
            return this.parseNew();
          case m.backQuote:
            return this.parseTemplate();
          case m._import:
            return this.options.ecmaVersion >= 11 ? this.parseExprImport(E) : this.unexpected();
          default:
            return this.parseExprAtomDefault();
        }
      }),
      (Ee.parseExprAtomDefault = function () {
        this.unexpected();
      }),
      (Ee.parseExprImport = function (a) {
        var f = this.startNode();
        this.containsEsc && this.raiseRecoverable(this.start, 'Escape sequence in keyword import');
        var E = this.parseIdent(!0);
        if (this.type === m.parenL && !a) return this.parseDynamicImport(f);
        if (this.type === m.dot) return (f.meta = E), this.parseImportMeta(f);
        this.unexpected();
      }),
      (Ee.parseDynamicImport = function (a) {
        if ((this.next(), (a.source = this.parseMaybeAssign()), !this.eat(m.parenR))) {
          var f = this.start;
          this.eat(m.comma) && this.eat(m.parenR)
            ? this.raiseRecoverable(f, 'Trailing comma is not allowed in import()')
            : this.unexpected(f);
        }
        return this.finishNode(a, 'ImportExpression');
      }),
      (Ee.parseImportMeta = function (a) {
        this.next();
        var f = this.containsEsc;
        return (
          (a.property = this.parseIdent(!0)),
          a.property.name !== 'meta' &&
            this.raiseRecoverable(a.property.start, "The only valid meta property for import is 'import.meta'"),
          f && this.raiseRecoverable(a.start, "'import.meta' must not contain escaped characters"),
          this.options.sourceType !== 'module' &&
            !this.options.allowImportExportEverywhere &&
            this.raiseRecoverable(a.start, "Cannot use 'import.meta' outside a module"),
          this.finishNode(a, 'MetaProperty')
        );
      }),
      (Ee.parseLiteral = function (a) {
        var f = this.startNode();
        return (
          (f.value = a),
          (f.raw = this.input.slice(this.start, this.end)),
          f.raw.charCodeAt(f.raw.length - 1) === 110 && (f.bigint = f.raw.slice(0, -1).replace(/_/g, '')),
          this.next(),
          this.finishNode(f, 'Literal')
        );
      }),
      (Ee.parseParenExpression = function () {
        this.expect(m.parenL);
        var a = this.parseExpression();
        return this.expect(m.parenR), a;
      }),
      (Ee.shouldParseArrow = function (a) {
        return !this.canInsertSemicolon();
      }),
      (Ee.parseParenAndDistinguishExpression = function (a, f) {
        var E = this.start,
          T = this.startLoc,
          L,
          $ = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var J = this.start,
            he = this.startLoc,
            ge = [],
            Fe = !0,
            qe = !1,
            Dt = new Ne(),
            Ms = this.yieldPos,
            Ic = this.awaitPos,
            Go;
          for (this.yieldPos = 0, this.awaitPos = 0; this.type !== m.parenR; )
            if ((Fe ? (Fe = !1) : this.expect(m.comma), $ && this.afterTrailingComma(m.parenR, !0))) {
              qe = !0;
              break;
            } else if (this.type === m.ellipsis) {
              (Go = this.start),
                ge.push(this.parseParenItem(this.parseRestBinding())),
                this.type === m.comma &&
                  this.raiseRecoverable(this.start, 'Comma is not permitted after the rest element');
              break;
            } else ge.push(this.parseMaybeAssign(!1, Dt, this.parseParenItem));
          var Xl = this.lastTokEnd,
            zo = this.lastTokEndLoc;
          if ((this.expect(m.parenR), a && this.shouldParseArrow(ge) && this.eat(m.arrow)))
            return (
              this.checkPatternErrors(Dt, !1),
              this.checkYieldAwaitInDefaultParams(),
              (this.yieldPos = Ms),
              (this.awaitPos = Ic),
              this.parseParenArrowList(E, T, ge, f)
            );
          (!ge.length || qe) && this.unexpected(this.lastTokStart),
            Go && this.unexpected(Go),
            this.checkExpressionErrors(Dt, !0),
            (this.yieldPos = Ms || this.yieldPos),
            (this.awaitPos = Ic || this.awaitPos),
            ge.length > 1
              ? ((L = this.startNodeAt(J, he)),
                (L.expressions = ge),
                this.finishNodeAt(L, 'SequenceExpression', Xl, zo))
              : (L = ge[0]);
        } else L = this.parseParenExpression();
        if (this.options.preserveParens) {
          var Vo = this.startNodeAt(E, T);
          return (Vo.expression = L), this.finishNode(Vo, 'ParenthesizedExpression');
        } else return L;
      }),
      (Ee.parseParenItem = function (a) {
        return a;
      }),
      (Ee.parseParenArrowList = function (a, f, E, T) {
        return this.parseArrowExpression(this.startNodeAt(a, f), E, !1, T);
      });
    var Ht = [];
    (Ee.parseNew = function () {
      this.containsEsc && this.raiseRecoverable(this.start, 'Escape sequence in keyword new');
      var a = this.startNode(),
        f = this.parseIdent(!0);
      if (this.options.ecmaVersion >= 6 && this.eat(m.dot)) {
        a.meta = f;
        var E = this.containsEsc;
        return (
          (a.property = this.parseIdent(!0)),
          a.property.name !== 'target' &&
            this.raiseRecoverable(a.property.start, "The only valid meta property for new is 'new.target'"),
          E && this.raiseRecoverable(a.start, "'new.target' must not contain escaped characters"),
          this.allowNewDotTarget ||
            this.raiseRecoverable(a.start, "'new.target' can only be used in functions and class static block"),
          this.finishNode(a, 'MetaProperty')
        );
      }
      var T = this.start,
        L = this.startLoc;
      return (
        (a.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), T, L, !0, !1)),
        this.eat(m.parenL)
          ? (a.arguments = this.parseExprList(m.parenR, this.options.ecmaVersion >= 8, !1))
          : (a.arguments = Ht),
        this.finishNode(a, 'NewExpression')
      );
    }),
      (Ee.parseTemplateElement = function (a) {
        var f = a.isTagged,
          E = this.startNode();
        return (
          this.type === m.invalidTemplate
            ? (f || this.raiseRecoverable(this.start, 'Bad escape sequence in untagged template literal'),
              (E.value = { raw: this.value, cooked: null }))
            : (E.value = {
                raw: this.input.slice(this.start, this.end).replace(
                  /\r\n?/g,
                  `
`
                ),
                cooked: this.value,
              }),
          this.next(),
          (E.tail = this.type === m.backQuote),
          this.finishNode(E, 'TemplateElement')
        );
      }),
      (Ee.parseTemplate = function (a) {
        a === void 0 && (a = {});
        var f = a.isTagged;
        f === void 0 && (f = !1);
        var E = this.startNode();
        this.next(), (E.expressions = []);
        var T = this.parseTemplateElement({ isTagged: f });
        for (E.quasis = [T]; !T.tail; )
          this.type === m.eof && this.raise(this.pos, 'Unterminated template literal'),
            this.expect(m.dollarBraceL),
            E.expressions.push(this.parseExpression()),
            this.expect(m.braceR),
            E.quasis.push((T = this.parseTemplateElement({ isTagged: f })));
        return this.next(), this.finishNode(E, 'TemplateLiteral');
      }),
      (Ee.isAsyncProp = function (a) {
        return (
          !a.computed &&
          a.key.type === 'Identifier' &&
          a.key.name === 'async' &&
          (this.type === m.name ||
            this.type === m.num ||
            this.type === m.string ||
            this.type === m.bracketL ||
            this.type.keyword ||
            (this.options.ecmaVersion >= 9 && this.type === m.star)) &&
          !O.test(this.input.slice(this.lastTokEnd, this.start))
        );
      }),
      (Ee.parseObj = function (a, f) {
        var E = this.startNode(),
          T = !0,
          L = {};
        for (E.properties = [], this.next(); !this.eat(m.braceR); ) {
          if (T) T = !1;
          else if ((this.expect(m.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(m.braceR))) break;
          var $ = this.parseProperty(a, f);
          a || this.checkPropClash($, L, f), E.properties.push($);
        }
        return this.finishNode(E, a ? 'ObjectPattern' : 'ObjectExpression');
      }),
      (Ee.parseProperty = function (a, f) {
        var E = this.startNode(),
          T,
          L,
          $,
          J;
        if (this.options.ecmaVersion >= 9 && this.eat(m.ellipsis))
          return a
            ? ((E.argument = this.parseIdent(!1)),
              this.type === m.comma &&
                this.raiseRecoverable(this.start, 'Comma is not permitted after the rest element'),
              this.finishNode(E, 'RestElement'))
            : ((E.argument = this.parseMaybeAssign(!1, f)),
              this.type === m.comma && f && f.trailingComma < 0 && (f.trailingComma = this.start),
              this.finishNode(E, 'SpreadElement'));
        this.options.ecmaVersion >= 6 &&
          ((E.method = !1),
          (E.shorthand = !1),
          (a || f) && (($ = this.start), (J = this.startLoc)),
          a || (T = this.eat(m.star)));
        var he = this.containsEsc;
        return (
          this.parsePropertyName(E),
          !a && !he && this.options.ecmaVersion >= 8 && !T && this.isAsyncProp(E)
            ? ((L = !0), (T = this.options.ecmaVersion >= 9 && this.eat(m.star)), this.parsePropertyName(E))
            : (L = !1),
          this.parsePropertyValue(E, a, T, L, $, J, f, he),
          this.finishNode(E, 'Property')
        );
      }),
      (Ee.parseGetterSetter = function (a) {
        (a.kind = a.key.name), this.parsePropertyName(a), (a.value = this.parseMethod(!1));
        var f = a.kind === 'get' ? 0 : 1;
        if (a.value.params.length !== f) {
          var E = a.value.start;
          a.kind === 'get'
            ? this.raiseRecoverable(E, 'getter should have no params')
            : this.raiseRecoverable(E, 'setter should have exactly one param');
        } else
          a.kind === 'set' &&
            a.value.params[0].type === 'RestElement' &&
            this.raiseRecoverable(a.value.params[0].start, 'Setter cannot use rest params');
      }),
      (Ee.parsePropertyValue = function (a, f, E, T, L, $, J, he) {
        (E || T) && this.type === m.colon && this.unexpected(),
          this.eat(m.colon)
            ? ((a.value = f ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, J)),
              (a.kind = 'init'))
            : this.options.ecmaVersion >= 6 && this.type === m.parenL
            ? (f && this.unexpected(), (a.kind = 'init'), (a.method = !0), (a.value = this.parseMethod(E, T)))
            : !f &&
              !he &&
              this.options.ecmaVersion >= 5 &&
              !a.computed &&
              a.key.type === 'Identifier' &&
              (a.key.name === 'get' || a.key.name === 'set') &&
              this.type !== m.comma &&
              this.type !== m.braceR &&
              this.type !== m.eq
            ? ((E || T) && this.unexpected(), this.parseGetterSetter(a))
            : this.options.ecmaVersion >= 6 && !a.computed && a.key.type === 'Identifier'
            ? ((E || T) && this.unexpected(),
              this.checkUnreserved(a.key),
              a.key.name === 'await' && !this.awaitIdentPos && (this.awaitIdentPos = L),
              (a.kind = 'init'),
              f
                ? (a.value = this.parseMaybeDefault(L, $, this.copyNode(a.key)))
                : this.type === m.eq && J
                ? (J.shorthandAssign < 0 && (J.shorthandAssign = this.start),
                  (a.value = this.parseMaybeDefault(L, $, this.copyNode(a.key))))
                : (a.value = this.copyNode(a.key)),
              (a.shorthand = !0))
            : this.unexpected();
      }),
      (Ee.parsePropertyName = function (a) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(m.bracketL))
            return (a.computed = !0), (a.key = this.parseMaybeAssign()), this.expect(m.bracketR), a.key;
          a.computed = !1;
        }
        return (a.key =
          this.type === m.num || this.type === m.string
            ? this.parseExprAtom()
            : this.parseIdent(this.options.allowReserved !== 'never'));
      }),
      (Ee.initFunction = function (a) {
        (a.id = null),
          this.options.ecmaVersion >= 6 && (a.generator = a.expression = !1),
          this.options.ecmaVersion >= 8 && (a.async = !1);
      }),
      (Ee.parseMethod = function (a, f, E) {
        var T = this.startNode(),
          L = this.yieldPos,
          $ = this.awaitPos,
          J = this.awaitIdentPos;
        return (
          this.initFunction(T),
          this.options.ecmaVersion >= 6 && (T.generator = a),
          this.options.ecmaVersion >= 8 && (T.async = !!f),
          (this.yieldPos = 0),
          (this.awaitPos = 0),
          (this.awaitIdentPos = 0),
          this.enterScope(w(f, T.generator) | Oe | (E ? ke : 0)),
          this.expect(m.parenL),
          (T.params = this.parseBindingList(m.parenR, !1, this.options.ecmaVersion >= 8)),
          this.checkYieldAwaitInDefaultParams(),
          this.parseFunctionBody(T, !1, !0, !1),
          (this.yieldPos = L),
          (this.awaitPos = $),
          (this.awaitIdentPos = J),
          this.finishNode(T, 'FunctionExpression')
        );
      }),
      (Ee.parseArrowExpression = function (a, f, E, T) {
        var L = this.yieldPos,
          $ = this.awaitPos,
          J = this.awaitIdentPos;
        return (
          this.enterScope(w(E, !1) | ve),
          this.initFunction(a),
          this.options.ecmaVersion >= 8 && (a.async = !!E),
          (this.yieldPos = 0),
          (this.awaitPos = 0),
          (this.awaitIdentPos = 0),
          (a.params = this.toAssignableList(f, !0)),
          this.parseFunctionBody(a, !0, !1, T),
          (this.yieldPos = L),
          (this.awaitPos = $),
          (this.awaitIdentPos = J),
          this.finishNode(a, 'ArrowFunctionExpression')
        );
      }),
      (Ee.parseFunctionBody = function (a, f, E, T) {
        var L = f && this.type !== m.braceL,
          $ = this.strict,
          J = !1;
        if (L) (a.body = this.parseMaybeAssign(T)), (a.expression = !0), this.checkParams(a, !1);
        else {
          var he = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(a.params);
          (!$ || he) &&
            ((J = this.strictDirective(this.end)),
            J &&
              he &&
              this.raiseRecoverable(
                a.start,
                "Illegal 'use strict' directive in function with non-simple parameter list"
              ));
          var ge = this.labels;
          (this.labels = []),
            J && (this.strict = !0),
            this.checkParams(a, !$ && !J && !f && !E && this.isSimpleParamList(a.params)),
            this.strict && a.id && this.checkLValSimple(a.id, U),
            (a.body = this.parseBlock(!1, void 0, J && !$)),
            (a.expression = !1),
            this.adaptDirectivePrologue(a.body.body),
            (this.labels = ge);
        }
        this.exitScope();
      }),
      (Ee.isSimpleParamList = function (a) {
        for (var f = 0, E = a; f < E.length; f += 1) {
          var T = E[f];
          if (T.type !== 'Identifier') return !1;
        }
        return !0;
      }),
      (Ee.checkParams = function (a, f) {
        for (var E = Object.create(null), T = 0, L = a.params; T < L.length; T += 1) {
          var $ = L[T];
          this.checkLValInnerPattern($, k, f ? null : E);
        }
      }),
      (Ee.parseExprList = function (a, f, E, T) {
        for (var L = [], $ = !0; !this.eat(a); ) {
          if ($) $ = !1;
          else if ((this.expect(m.comma), f && this.afterTrailingComma(a))) break;
          var J = void 0;
          E && this.type === m.comma
            ? (J = null)
            : this.type === m.ellipsis
            ? ((J = this.parseSpread(T)),
              T && this.type === m.comma && T.trailingComma < 0 && (T.trailingComma = this.start))
            : (J = this.parseMaybeAssign(!1, T)),
            L.push(J);
        }
        return L;
      }),
      (Ee.checkUnreserved = function (a) {
        var f = a.start,
          E = a.end,
          T = a.name;
        if (
          (this.inGenerator &&
            T === 'yield' &&
            this.raiseRecoverable(f, "Cannot use 'yield' as identifier inside a generator"),
          this.inAsync &&
            T === 'await' &&
            this.raiseRecoverable(f, "Cannot use 'await' as identifier inside an async function"),
          this.currentThisScope().inClassFieldInit &&
            T === 'arguments' &&
            this.raiseRecoverable(f, "Cannot use 'arguments' in class field initializer"),
          this.inClassStaticBlock &&
            (T === 'arguments' || T === 'await') &&
            this.raise(f, 'Cannot use ' + T + ' in class static initialization block'),
          this.keywords.test(T) && this.raise(f, "Unexpected keyword '" + T + "'"),
          !(this.options.ecmaVersion < 6 && this.input.slice(f, E).indexOf('\\') !== -1))
        ) {
          var L = this.strict ? this.reservedWordsStrict : this.reservedWords;
          L.test(T) &&
            (!this.inAsync &&
              T === 'await' &&
              this.raiseRecoverable(f, "Cannot use keyword 'await' outside an async function"),
            this.raiseRecoverable(f, "The keyword '" + T + "' is reserved"));
        }
      }),
      (Ee.parseIdent = function (a) {
        var f = this.parseIdentNode();
        return (
          this.next(!!a),
          this.finishNode(f, 'Identifier'),
          a || (this.checkUnreserved(f), f.name === 'await' && !this.awaitIdentPos && (this.awaitIdentPos = f.start)),
          f
        );
      }),
      (Ee.parseIdentNode = function () {
        var a = this.startNode();
        return (
          this.type === m.name
            ? (a.name = this.value)
            : this.type.keyword
            ? ((a.name = this.type.keyword),
              (a.name === 'class' || a.name === 'function') &&
                (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) &&
                this.context.pop())
            : this.unexpected(),
          a
        );
      }),
      (Ee.parsePrivateIdent = function () {
        var a = this.startNode();
        return (
          this.type === m.privateId ? (a.name = this.value) : this.unexpected(),
          this.next(),
          this.finishNode(a, 'PrivateIdentifier'),
          this.options.checkPrivateFields &&
            (this.privateNameStack.length === 0
              ? this.raise(a.start, "Private field '#" + a.name + "' must be declared in an enclosing class")
              : this.privateNameStack[this.privateNameStack.length - 1].used.push(a)),
          a
        );
      }),
      (Ee.parseYield = function (a) {
        this.yieldPos || (this.yieldPos = this.start);
        var f = this.startNode();
        return (
          this.next(),
          this.type === m.semi || this.canInsertSemicolon() || (this.type !== m.star && !this.type.startsExpr)
            ? ((f.delegate = !1), (f.argument = null))
            : ((f.delegate = this.eat(m.star)), (f.argument = this.parseMaybeAssign(a))),
          this.finishNode(f, 'YieldExpression')
        );
      }),
      (Ee.parseAwait = function (a) {
        this.awaitPos || (this.awaitPos = this.start);
        var f = this.startNode();
        return this.next(), (f.argument = this.parseMaybeUnary(null, !0, !1, a)), this.finishNode(f, 'AwaitExpression');
      });
    var oi = re.prototype;
    (oi.raise = function (a, f) {
      var E = de(this.input, a);
      f += ' (' + E.line + ':' + E.column + ')';
      var T = new SyntaxError(f);
      throw ((T.pos = a), (T.loc = E), (T.raisedAt = this.pos), T);
    }),
      (oi.raiseRecoverable = oi.raise),
      (oi.curPosition = function () {
        if (this.options.locations) return new ee(this.curLine, this.pos - this.lineStart);
      });
    var Ue = re.prototype,
      Ve = function (f) {
        (this.flags = f), (this.var = []), (this.lexical = []), (this.functions = []), (this.inClassFieldInit = !1);
      };
    (Ue.enterScope = function (a) {
      this.scopeStack.push(new Ve(a));
    }),
      (Ue.exitScope = function () {
        this.scopeStack.pop();
      }),
      (Ue.treatFunctionsAsVarInScope = function (a) {
        return a.flags & ae || (!this.inModule && a.flags & Q);
      }),
      (Ue.declareName = function (a, f, E) {
        var T = !1;
        if (f === S) {
          var L = this.currentScope();
          (T = L.lexical.indexOf(a) > -1 || L.functions.indexOf(a) > -1 || L.var.indexOf(a) > -1),
            L.lexical.push(a),
            this.inModule && L.flags & Q && delete this.undefinedExports[a];
        } else if (f === j) {
          var $ = this.currentScope();
          $.lexical.push(a);
        } else if (f === M) {
          var J = this.currentScope();
          this.treatFunctionsAsVar
            ? (T = J.lexical.indexOf(a) > -1)
            : (T = J.lexical.indexOf(a) > -1 || J.var.indexOf(a) > -1),
            J.functions.push(a);
        } else
          for (var he = this.scopeStack.length - 1; he >= 0; --he) {
            var ge = this.scopeStack[he];
            if (
              (ge.lexical.indexOf(a) > -1 && !(ge.flags & Ce && ge.lexical[0] === a)) ||
              (!this.treatFunctionsAsVarInScope(ge) && ge.functions.indexOf(a) > -1)
            ) {
              T = !0;
              break;
            }
            if ((ge.var.push(a), this.inModule && ge.flags & Q && delete this.undefinedExports[a], ge.flags & R)) break;
          }
        T && this.raiseRecoverable(E, "Identifier '" + a + "' has already been declared");
      }),
      (Ue.checkLocalExport = function (a) {
        this.scopeStack[0].lexical.indexOf(a.name) === -1 &&
          this.scopeStack[0].var.indexOf(a.name) === -1 &&
          (this.undefinedExports[a.name] = a);
      }),
      (Ue.currentScope = function () {
        return this.scopeStack[this.scopeStack.length - 1];
      }),
      (Ue.currentVarScope = function () {
        for (var a = this.scopeStack.length - 1; ; a--) {
          var f = this.scopeStack[a];
          if (f.flags & R) return f;
        }
      }),
      (Ue.currentThisScope = function () {
        for (var a = this.scopeStack.length - 1; ; a--) {
          var f = this.scopeStack[a];
          if (f.flags & R && !(f.flags & ve)) return f;
        }
      });
    var Ot = function (f, E, T) {
        (this.type = ''),
          (this.start = E),
          (this.end = 0),
          f.options.locations && (this.loc = new xe(f, T)),
          f.options.directSourceFile && (this.sourceFile = f.options.directSourceFile),
          f.options.ranges && (this.range = [E, 0]);
      },
      dt = re.prototype;
    (dt.startNode = function () {
      return new Ot(this, this.start, this.startLoc);
    }),
      (dt.startNodeAt = function (a, f) {
        return new Ot(this, a, f);
      });
    function vi(a, f, E, T) {
      return (
        (a.type = f), (a.end = E), this.options.locations && (a.loc.end = T), this.options.ranges && (a.range[1] = E), a
      );
    }
    (dt.finishNode = function (a, f) {
      return vi.call(this, a, f, this.lastTokEnd, this.lastTokEndLoc);
    }),
      (dt.finishNodeAt = function (a, f, E, T) {
        return vi.call(this, a, f, E, T);
      }),
      (dt.copyNode = function (a) {
        var f = new Ot(this, a.start, this.startLoc);
        for (var E in a) f[E] = a[E];
        return f;
      });
    var Li =
        'ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS',
      Di = Li + ' Extended_Pictographic',
      $l = Di,
      z_ = $l + ' EBase EComp EMod EPres ExtPict',
      V_ = z_,
      Nq = V_,
      Pq = { 9: Li, 10: Di, 11: $l, 12: z_, 13: V_, 14: Nq },
      Lq =
        'Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji',
      Dq = { 9: '', 10: '', 11: '', 12: '', 13: '', 14: Lq },
      $_ =
        'Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu',
      W_ =
        'Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb',
      K_ =
        W_ +
        ' Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd',
      X_ = K_ + ' Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho',
      Y_ = X_ + ' Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi',
      J_ = Y_ + ' Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith',
      Fq = J_ + ' Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz',
      jq = { 9: W_, 10: K_, 11: X_, 12: Y_, 13: J_, 14: Fq },
      Z_ = {};
    function Mq(a) {
      var f = (Z_[a] = {
        binary: K(Pq[a] + ' ' + $_),
        binaryOfStrings: K(Dq[a]),
        nonBinary: { General_Category: K($_), Script: K(jq[a]) },
      });
      (f.nonBinary.Script_Extensions = f.nonBinary.Script),
        (f.nonBinary.gc = f.nonBinary.General_Category),
        (f.nonBinary.sc = f.nonBinary.Script),
        (f.nonBinary.scx = f.nonBinary.Script_Extensions);
    }
    for (var km = 0, Q_ = [9, 10, 11, 12, 13, 14]; km < Q_.length; km += 1) {
      var Uq = Q_[km];
      Mq(Uq);
    }
    var we = re.prototype,
      An = function (f) {
        (this.parser = f),
          (this.validFlags =
            'gim' +
            (f.options.ecmaVersion >= 6 ? 'uy' : '') +
            (f.options.ecmaVersion >= 9 ? 's' : '') +
            (f.options.ecmaVersion >= 13 ? 'd' : '') +
            (f.options.ecmaVersion >= 15 ? 'v' : '')),
          (this.unicodeProperties = Z_[f.options.ecmaVersion >= 14 ? 14 : f.options.ecmaVersion]),
          (this.source = ''),
          (this.flags = ''),
          (this.start = 0),
          (this.switchU = !1),
          (this.switchV = !1),
          (this.switchN = !1),
          (this.pos = 0),
          (this.lastIntValue = 0),
          (this.lastStringValue = ''),
          (this.lastAssertionIsQuantifiable = !1),
          (this.numCapturingParens = 0),
          (this.maxBackReference = 0),
          (this.groupNames = []),
          (this.backReferenceNames = []);
      };
    (An.prototype.reset = function (f, E, T) {
      var L = T.indexOf('v') !== -1,
        $ = T.indexOf('u') !== -1;
      (this.start = f | 0),
        (this.source = E + ''),
        (this.flags = T),
        L && this.parser.options.ecmaVersion >= 15
          ? ((this.switchU = !0), (this.switchV = !0), (this.switchN = !0))
          : ((this.switchU = $ && this.parser.options.ecmaVersion >= 6),
            (this.switchV = !1),
            (this.switchN = $ && this.parser.options.ecmaVersion >= 9));
    }),
      (An.prototype.raise = function (f) {
        this.parser.raiseRecoverable(this.start, 'Invalid regular expression: /' + this.source + '/: ' + f);
      }),
      (An.prototype.at = function (f, E) {
        E === void 0 && (E = !1);
        var T = this.source,
          L = T.length;
        if (f >= L) return -1;
        var $ = T.charCodeAt(f);
        if (!(E || this.switchU) || $ <= 55295 || $ >= 57344 || f + 1 >= L) return $;
        var J = T.charCodeAt(f + 1);
        return J >= 56320 && J <= 57343 ? ($ << 10) + J - 56613888 : $;
      }),
      (An.prototype.nextIndex = function (f, E) {
        E === void 0 && (E = !1);
        var T = this.source,
          L = T.length;
        if (f >= L) return L;
        var $ = T.charCodeAt(f),
          J;
        return !(E || this.switchU) ||
          $ <= 55295 ||
          $ >= 57344 ||
          f + 1 >= L ||
          (J = T.charCodeAt(f + 1)) < 56320 ||
          J > 57343
          ? f + 1
          : f + 2;
      }),
      (An.prototype.current = function (f) {
        return f === void 0 && (f = !1), this.at(this.pos, f);
      }),
      (An.prototype.lookahead = function (f) {
        return f === void 0 && (f = !1), this.at(this.nextIndex(this.pos, f), f);
      }),
      (An.prototype.advance = function (f) {
        f === void 0 && (f = !1), (this.pos = this.nextIndex(this.pos, f));
      }),
      (An.prototype.eat = function (f, E) {
        return E === void 0 && (E = !1), this.current(E) === f ? (this.advance(E), !0) : !1;
      }),
      (An.prototype.eatChars = function (f, E) {
        E === void 0 && (E = !1);
        for (var T = this.pos, L = 0, $ = f; L < $.length; L += 1) {
          var J = $[L],
            he = this.at(T, E);
          if (he === -1 || he !== J) return !1;
          T = this.nextIndex(T, E);
        }
        return (this.pos = T), !0;
      }),
      (we.validateRegExpFlags = function (a) {
        for (var f = a.validFlags, E = a.flags, T = !1, L = !1, $ = 0; $ < E.length; $++) {
          var J = E.charAt($);
          f.indexOf(J) === -1 && this.raise(a.start, 'Invalid regular expression flag'),
            E.indexOf(J, $ + 1) > -1 && this.raise(a.start, 'Duplicate regular expression flag'),
            J === 'u' && (T = !0),
            J === 'v' && (L = !0);
        }
        this.options.ecmaVersion >= 15 && T && L && this.raise(a.start, 'Invalid regular expression flag');
      }),
      (we.validateRegExpPattern = function (a) {
        this.regexp_pattern(a),
          !a.switchN &&
            this.options.ecmaVersion >= 9 &&
            a.groupNames.length > 0 &&
            ((a.switchN = !0), this.regexp_pattern(a));
      }),
      (we.regexp_pattern = function (a) {
        (a.pos = 0),
          (a.lastIntValue = 0),
          (a.lastStringValue = ''),
          (a.lastAssertionIsQuantifiable = !1),
          (a.numCapturingParens = 0),
          (a.maxBackReference = 0),
          (a.groupNames.length = 0),
          (a.backReferenceNames.length = 0),
          this.regexp_disjunction(a),
          a.pos !== a.source.length &&
            (a.eat(41) && a.raise("Unmatched ')'"), (a.eat(93) || a.eat(125)) && a.raise('Lone quantifier brackets')),
          a.maxBackReference > a.numCapturingParens && a.raise('Invalid escape');
        for (var f = 0, E = a.backReferenceNames; f < E.length; f += 1) {
          var T = E[f];
          a.groupNames.indexOf(T) === -1 && a.raise('Invalid named capture referenced');
        }
      }),
      (we.regexp_disjunction = function (a) {
        for (this.regexp_alternative(a); a.eat(124); ) this.regexp_alternative(a);
        this.regexp_eatQuantifier(a, !0) && a.raise('Nothing to repeat'),
          a.eat(123) && a.raise('Lone quantifier brackets');
      }),
      (we.regexp_alternative = function (a) {
        for (; a.pos < a.source.length && this.regexp_eatTerm(a); );
      }),
      (we.regexp_eatTerm = function (a) {
        return this.regexp_eatAssertion(a)
          ? (a.lastAssertionIsQuantifiable &&
              this.regexp_eatQuantifier(a) &&
              a.switchU &&
              a.raise('Invalid quantifier'),
            !0)
          : (a.switchU ? this.regexp_eatAtom(a) : this.regexp_eatExtendedAtom(a))
          ? (this.regexp_eatQuantifier(a), !0)
          : !1;
      }),
      (we.regexp_eatAssertion = function (a) {
        var f = a.pos;
        if (((a.lastAssertionIsQuantifiable = !1), a.eat(94) || a.eat(36))) return !0;
        if (a.eat(92)) {
          if (a.eat(66) || a.eat(98)) return !0;
          a.pos = f;
        }
        if (a.eat(40) && a.eat(63)) {
          var E = !1;
          if ((this.options.ecmaVersion >= 9 && (E = a.eat(60)), a.eat(61) || a.eat(33)))
            return (
              this.regexp_disjunction(a),
              a.eat(41) || a.raise('Unterminated group'),
              (a.lastAssertionIsQuantifiable = !E),
              !0
            );
        }
        return (a.pos = f), !1;
      }),
      (we.regexp_eatQuantifier = function (a, f) {
        return f === void 0 && (f = !1), this.regexp_eatQuantifierPrefix(a, f) ? (a.eat(63), !0) : !1;
      }),
      (we.regexp_eatQuantifierPrefix = function (a, f) {
        return a.eat(42) || a.eat(43) || a.eat(63) || this.regexp_eatBracedQuantifier(a, f);
      }),
      (we.regexp_eatBracedQuantifier = function (a, f) {
        var E = a.pos;
        if (a.eat(123)) {
          var T = 0,
            L = -1;
          if (
            this.regexp_eatDecimalDigits(a) &&
            ((T = a.lastIntValue), a.eat(44) && this.regexp_eatDecimalDigits(a) && (L = a.lastIntValue), a.eat(125))
          )
            return L !== -1 && L < T && !f && a.raise('numbers out of order in {} quantifier'), !0;
          a.switchU && !f && a.raise('Incomplete quantifier'), (a.pos = E);
        }
        return !1;
      }),
      (we.regexp_eatAtom = function (a) {
        return (
          this.regexp_eatPatternCharacters(a) ||
          a.eat(46) ||
          this.regexp_eatReverseSolidusAtomEscape(a) ||
          this.regexp_eatCharacterClass(a) ||
          this.regexp_eatUncapturingGroup(a) ||
          this.regexp_eatCapturingGroup(a)
        );
      }),
      (we.regexp_eatReverseSolidusAtomEscape = function (a) {
        var f = a.pos;
        if (a.eat(92)) {
          if (this.regexp_eatAtomEscape(a)) return !0;
          a.pos = f;
        }
        return !1;
      }),
      (we.regexp_eatUncapturingGroup = function (a) {
        var f = a.pos;
        if (a.eat(40)) {
          if (a.eat(63) && a.eat(58)) {
            if ((this.regexp_disjunction(a), a.eat(41))) return !0;
            a.raise('Unterminated group');
          }
          a.pos = f;
        }
        return !1;
      }),
      (we.regexp_eatCapturingGroup = function (a) {
        if (a.eat(40)) {
          if (
            (this.options.ecmaVersion >= 9
              ? this.regexp_groupSpecifier(a)
              : a.current() === 63 && a.raise('Invalid group'),
            this.regexp_disjunction(a),
            a.eat(41))
          )
            return (a.numCapturingParens += 1), !0;
          a.raise('Unterminated group');
        }
        return !1;
      }),
      (we.regexp_eatExtendedAtom = function (a) {
        return (
          a.eat(46) ||
          this.regexp_eatReverseSolidusAtomEscape(a) ||
          this.regexp_eatCharacterClass(a) ||
          this.regexp_eatUncapturingGroup(a) ||
          this.regexp_eatCapturingGroup(a) ||
          this.regexp_eatInvalidBracedQuantifier(a) ||
          this.regexp_eatExtendedPatternCharacter(a)
        );
      }),
      (we.regexp_eatInvalidBracedQuantifier = function (a) {
        return this.regexp_eatBracedQuantifier(a, !0) && a.raise('Nothing to repeat'), !1;
      }),
      (we.regexp_eatSyntaxCharacter = function (a) {
        var f = a.current();
        return eS(f) ? ((a.lastIntValue = f), a.advance(), !0) : !1;
      });
    function eS(a) {
      return a === 36 || (a >= 40 && a <= 43) || a === 46 || a === 63 || (a >= 91 && a <= 94) || (a >= 123 && a <= 125);
    }
    (we.regexp_eatPatternCharacters = function (a) {
      for (var f = a.pos, E = 0; (E = a.current()) !== -1 && !eS(E); ) a.advance();
      return a.pos !== f;
    }),
      (we.regexp_eatExtendedPatternCharacter = function (a) {
        var f = a.current();
        return f !== -1 &&
          f !== 36 &&
          !(f >= 40 && f <= 43) &&
          f !== 46 &&
          f !== 63 &&
          f !== 91 &&
          f !== 94 &&
          f !== 124
          ? (a.advance(), !0)
          : !1;
      }),
      (we.regexp_groupSpecifier = function (a) {
        if (a.eat(63)) {
          if (this.regexp_eatGroupName(a)) {
            a.groupNames.indexOf(a.lastStringValue) !== -1 && a.raise('Duplicate capture group name'),
              a.groupNames.push(a.lastStringValue);
            return;
          }
          a.raise('Invalid group');
        }
      }),
      (we.regexp_eatGroupName = function (a) {
        if (((a.lastStringValue = ''), a.eat(60))) {
          if (this.regexp_eatRegExpIdentifierName(a) && a.eat(62)) return !0;
          a.raise('Invalid capture group name');
        }
        return !1;
      }),
      (we.regexp_eatRegExpIdentifierName = function (a) {
        if (((a.lastStringValue = ''), this.regexp_eatRegExpIdentifierStart(a))) {
          for (a.lastStringValue += q(a.lastIntValue); this.regexp_eatRegExpIdentifierPart(a); )
            a.lastStringValue += q(a.lastIntValue);
          return !0;
        }
        return !1;
      }),
      (we.regexp_eatRegExpIdentifierStart = function (a) {
        var f = a.pos,
          E = this.options.ecmaVersion >= 11,
          T = a.current(E);
        return (
          a.advance(E),
          T === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(a, E) && (T = a.lastIntValue),
          qq(T) ? ((a.lastIntValue = T), !0) : ((a.pos = f), !1)
        );
      });
    function qq(a) {
      return x(a, !0) || a === 36 || a === 95;
    }
    we.regexp_eatRegExpIdentifierPart = function (a) {
      var f = a.pos,
        E = this.options.ecmaVersion >= 11,
        T = a.current(E);
      return (
        a.advance(E),
        T === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(a, E) && (T = a.lastIntValue),
        Bq(T) ? ((a.lastIntValue = T), !0) : ((a.pos = f), !1)
      );
    };
    function Bq(a) {
      return b(a, !0) || a === 36 || a === 95 || a === 8204 || a === 8205;
    }
    (we.regexp_eatAtomEscape = function (a) {
      return this.regexp_eatBackReference(a) ||
        this.regexp_eatCharacterClassEscape(a) ||
        this.regexp_eatCharacterEscape(a) ||
        (a.switchN && this.regexp_eatKGroupName(a))
        ? !0
        : (a.switchU && (a.current() === 99 && a.raise('Invalid unicode escape'), a.raise('Invalid escape')), !1);
    }),
      (we.regexp_eatBackReference = function (a) {
        var f = a.pos;
        if (this.regexp_eatDecimalEscape(a)) {
          var E = a.lastIntValue;
          if (a.switchU) return E > a.maxBackReference && (a.maxBackReference = E), !0;
          if (E <= a.numCapturingParens) return !0;
          a.pos = f;
        }
        return !1;
      }),
      (we.regexp_eatKGroupName = function (a) {
        if (a.eat(107)) {
          if (this.regexp_eatGroupName(a)) return a.backReferenceNames.push(a.lastStringValue), !0;
          a.raise('Invalid named reference');
        }
        return !1;
      }),
      (we.regexp_eatCharacterEscape = function (a) {
        return (
          this.regexp_eatControlEscape(a) ||
          this.regexp_eatCControlLetter(a) ||
          this.regexp_eatZero(a) ||
          this.regexp_eatHexEscapeSequence(a) ||
          this.regexp_eatRegExpUnicodeEscapeSequence(a, !1) ||
          (!a.switchU && this.regexp_eatLegacyOctalEscapeSequence(a)) ||
          this.regexp_eatIdentityEscape(a)
        );
      }),
      (we.regexp_eatCControlLetter = function (a) {
        var f = a.pos;
        if (a.eat(99)) {
          if (this.regexp_eatControlLetter(a)) return !0;
          a.pos = f;
        }
        return !1;
      }),
      (we.regexp_eatZero = function (a) {
        return a.current() === 48 && !Wl(a.lookahead()) ? ((a.lastIntValue = 0), a.advance(), !0) : !1;
      }),
      (we.regexp_eatControlEscape = function (a) {
        var f = a.current();
        return f === 116
          ? ((a.lastIntValue = 9), a.advance(), !0)
          : f === 110
          ? ((a.lastIntValue = 10), a.advance(), !0)
          : f === 118
          ? ((a.lastIntValue = 11), a.advance(), !0)
          : f === 102
          ? ((a.lastIntValue = 12), a.advance(), !0)
          : f === 114
          ? ((a.lastIntValue = 13), a.advance(), !0)
          : !1;
      }),
      (we.regexp_eatControlLetter = function (a) {
        var f = a.current();
        return tS(f) ? ((a.lastIntValue = f % 32), a.advance(), !0) : !1;
      });
    function tS(a) {
      return (a >= 65 && a <= 90) || (a >= 97 && a <= 122);
    }
    we.regexp_eatRegExpUnicodeEscapeSequence = function (a, f) {
      f === void 0 && (f = !1);
      var E = a.pos,
        T = f || a.switchU;
      if (a.eat(117)) {
        if (this.regexp_eatFixedHexDigits(a, 4)) {
          var L = a.lastIntValue;
          if (T && L >= 55296 && L <= 56319) {
            var $ = a.pos;
            if (a.eat(92) && a.eat(117) && this.regexp_eatFixedHexDigits(a, 4)) {
              var J = a.lastIntValue;
              if (J >= 56320 && J <= 57343) return (a.lastIntValue = (L - 55296) * 1024 + (J - 56320) + 65536), !0;
            }
            (a.pos = $), (a.lastIntValue = L);
          }
          return !0;
        }
        if (T && a.eat(123) && this.regexp_eatHexDigits(a) && a.eat(125) && Hq(a.lastIntValue)) return !0;
        T && a.raise('Invalid unicode escape'), (a.pos = E);
      }
      return !1;
    };
    function Hq(a) {
      return a >= 0 && a <= 1114111;
    }
    (we.regexp_eatIdentityEscape = function (a) {
      if (a.switchU) return this.regexp_eatSyntaxCharacter(a) ? !0 : a.eat(47) ? ((a.lastIntValue = 47), !0) : !1;
      var f = a.current();
      return f !== 99 && (!a.switchN || f !== 107) ? ((a.lastIntValue = f), a.advance(), !0) : !1;
    }),
      (we.regexp_eatDecimalEscape = function (a) {
        a.lastIntValue = 0;
        var f = a.current();
        if (f >= 49 && f <= 57) {
          do (a.lastIntValue = 10 * a.lastIntValue + (f - 48)), a.advance();
          while ((f = a.current()) >= 48 && f <= 57);
          return !0;
        }
        return !1;
      });
    var iS = 0,
      Jn = 1,
      Vi = 2;
    we.regexp_eatCharacterClassEscape = function (a) {
      var f = a.current();
      if (Gq(f)) return (a.lastIntValue = -1), a.advance(), Jn;
      var E = !1;
      if (a.switchU && this.options.ecmaVersion >= 9 && ((E = f === 80) || f === 112)) {
        (a.lastIntValue = -1), a.advance();
        var T;
        if (a.eat(123) && (T = this.regexp_eatUnicodePropertyValueExpression(a)) && a.eat(125))
          return E && T === Vi && a.raise('Invalid property name'), T;
        a.raise('Invalid property name');
      }
      return iS;
    };
    function Gq(a) {
      return a === 100 || a === 68 || a === 115 || a === 83 || a === 119 || a === 87;
    }
    (we.regexp_eatUnicodePropertyValueExpression = function (a) {
      var f = a.pos;
      if (this.regexp_eatUnicodePropertyName(a) && a.eat(61)) {
        var E = a.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(a)) {
          var T = a.lastStringValue;
          return this.regexp_validateUnicodePropertyNameAndValue(a, E, T), Jn;
        }
      }
      if (((a.pos = f), this.regexp_eatLoneUnicodePropertyNameOrValue(a))) {
        var L = a.lastStringValue;
        return this.regexp_validateUnicodePropertyNameOrValue(a, L);
      }
      return iS;
    }),
      (we.regexp_validateUnicodePropertyNameAndValue = function (a, f, E) {
        V(a.unicodeProperties.nonBinary, f) || a.raise('Invalid property name'),
          a.unicodeProperties.nonBinary[f].test(E) || a.raise('Invalid property value');
      }),
      (we.regexp_validateUnicodePropertyNameOrValue = function (a, f) {
        if (a.unicodeProperties.binary.test(f)) return Jn;
        if (a.switchV && a.unicodeProperties.binaryOfStrings.test(f)) return Vi;
        a.raise('Invalid property name');
      }),
      (we.regexp_eatUnicodePropertyName = function (a) {
        var f = 0;
        for (a.lastStringValue = ''; nS((f = a.current())); ) (a.lastStringValue += q(f)), a.advance();
        return a.lastStringValue !== '';
      });
    function nS(a) {
      return tS(a) || a === 95;
    }
    we.regexp_eatUnicodePropertyValue = function (a) {
      var f = 0;
      for (a.lastStringValue = ''; zq((f = a.current())); ) (a.lastStringValue += q(f)), a.advance();
      return a.lastStringValue !== '';
    };
    function zq(a) {
      return nS(a) || Wl(a);
    }
    (we.regexp_eatLoneUnicodePropertyNameOrValue = function (a) {
      return this.regexp_eatUnicodePropertyValue(a);
    }),
      (we.regexp_eatCharacterClass = function (a) {
        if (a.eat(91)) {
          var f = a.eat(94),
            E = this.regexp_classContents(a);
          return (
            a.eat(93) || a.raise('Unterminated character class'),
            f && E === Vi && a.raise('Negated character class may contain strings'),
            !0
          );
        }
        return !1;
      }),
      (we.regexp_classContents = function (a) {
        return a.current() === 93
          ? Jn
          : a.switchV
          ? this.regexp_classSetExpression(a)
          : (this.regexp_nonEmptyClassRanges(a), Jn);
      }),
      (we.regexp_nonEmptyClassRanges = function (a) {
        for (; this.regexp_eatClassAtom(a); ) {
          var f = a.lastIntValue;
          if (a.eat(45) && this.regexp_eatClassAtom(a)) {
            var E = a.lastIntValue;
            a.switchU && (f === -1 || E === -1) && a.raise('Invalid character class'),
              f !== -1 && E !== -1 && f > E && a.raise('Range out of order in character class');
          }
        }
      }),
      (we.regexp_eatClassAtom = function (a) {
        var f = a.pos;
        if (a.eat(92)) {
          if (this.regexp_eatClassEscape(a)) return !0;
          if (a.switchU) {
            var E = a.current();
            (E === 99 || oS(E)) && a.raise('Invalid class escape'), a.raise('Invalid escape');
          }
          a.pos = f;
        }
        var T = a.current();
        return T !== 93 ? ((a.lastIntValue = T), a.advance(), !0) : !1;
      }),
      (we.regexp_eatClassEscape = function (a) {
        var f = a.pos;
        if (a.eat(98)) return (a.lastIntValue = 8), !0;
        if (a.switchU && a.eat(45)) return (a.lastIntValue = 45), !0;
        if (!a.switchU && a.eat(99)) {
          if (this.regexp_eatClassControlLetter(a)) return !0;
          a.pos = f;
        }
        return this.regexp_eatCharacterClassEscape(a) || this.regexp_eatCharacterEscape(a);
      }),
      (we.regexp_classSetExpression = function (a) {
        var f = Jn,
          E;
        if (!this.regexp_eatClassSetRange(a))
          if ((E = this.regexp_eatClassSetOperand(a))) {
            E === Vi && (f = Vi);
            for (var T = a.pos; a.eatChars([38, 38]); ) {
              if (a.current() !== 38 && (E = this.regexp_eatClassSetOperand(a))) {
                E !== Vi && (f = Jn);
                continue;
              }
              a.raise('Invalid character in character class');
            }
            if (T !== a.pos) return f;
            for (; a.eatChars([45, 45]); )
              this.regexp_eatClassSetOperand(a) || a.raise('Invalid character in character class');
            if (T !== a.pos) return f;
          } else a.raise('Invalid character in character class');
        for (;;)
          if (!this.regexp_eatClassSetRange(a)) {
            if (((E = this.regexp_eatClassSetOperand(a)), !E)) return f;
            E === Vi && (f = Vi);
          }
      }),
      (we.regexp_eatClassSetRange = function (a) {
        var f = a.pos;
        if (this.regexp_eatClassSetCharacter(a)) {
          var E = a.lastIntValue;
          if (a.eat(45) && this.regexp_eatClassSetCharacter(a)) {
            var T = a.lastIntValue;
            return E !== -1 && T !== -1 && E > T && a.raise('Range out of order in character class'), !0;
          }
          a.pos = f;
        }
        return !1;
      }),
      (we.regexp_eatClassSetOperand = function (a) {
        return this.regexp_eatClassSetCharacter(a)
          ? Jn
          : this.regexp_eatClassStringDisjunction(a) || this.regexp_eatNestedClass(a);
      }),
      (we.regexp_eatNestedClass = function (a) {
        var f = a.pos;
        if (a.eat(91)) {
          var E = a.eat(94),
            T = this.regexp_classContents(a);
          if (a.eat(93)) return E && T === Vi && a.raise('Negated character class may contain strings'), T;
          a.pos = f;
        }
        if (a.eat(92)) {
          var L = this.regexp_eatCharacterClassEscape(a);
          if (L) return L;
          a.pos = f;
        }
        return null;
      }),
      (we.regexp_eatClassStringDisjunction = function (a) {
        var f = a.pos;
        if (a.eatChars([92, 113])) {
          if (a.eat(123)) {
            var E = this.regexp_classStringDisjunctionContents(a);
            if (a.eat(125)) return E;
          } else a.raise('Invalid escape');
          a.pos = f;
        }
        return null;
      }),
      (we.regexp_classStringDisjunctionContents = function (a) {
        for (var f = this.regexp_classString(a); a.eat(124); ) this.regexp_classString(a) === Vi && (f = Vi);
        return f;
      }),
      (we.regexp_classString = function (a) {
        for (var f = 0; this.regexp_eatClassSetCharacter(a); ) f++;
        return f === 1 ? Jn : Vi;
      }),
      (we.regexp_eatClassSetCharacter = function (a) {
        var f = a.pos;
        if (a.eat(92))
          return this.regexp_eatCharacterEscape(a) || this.regexp_eatClassSetReservedPunctuator(a)
            ? !0
            : a.eat(98)
            ? ((a.lastIntValue = 8), !0)
            : ((a.pos = f), !1);
        var E = a.current();
        return E < 0 || (E === a.lookahead() && Vq(E)) || $q(E) ? !1 : (a.advance(), (a.lastIntValue = E), !0);
      });
    function Vq(a) {
      return (
        a === 33 ||
        (a >= 35 && a <= 38) ||
        (a >= 42 && a <= 44) ||
        a === 46 ||
        (a >= 58 && a <= 64) ||
        a === 94 ||
        a === 96 ||
        a === 126
      );
    }
    function $q(a) {
      return a === 40 || a === 41 || a === 45 || a === 47 || (a >= 91 && a <= 93) || (a >= 123 && a <= 125);
    }
    we.regexp_eatClassSetReservedPunctuator = function (a) {
      var f = a.current();
      return Wq(f) ? ((a.lastIntValue = f), a.advance(), !0) : !1;
    };
    function Wq(a) {
      return (
        a === 33 ||
        a === 35 ||
        a === 37 ||
        a === 38 ||
        a === 44 ||
        a === 45 ||
        (a >= 58 && a <= 62) ||
        a === 64 ||
        a === 96 ||
        a === 126
      );
    }
    (we.regexp_eatClassControlLetter = function (a) {
      var f = a.current();
      return Wl(f) || f === 95 ? ((a.lastIntValue = f % 32), a.advance(), !0) : !1;
    }),
      (we.regexp_eatHexEscapeSequence = function (a) {
        var f = a.pos;
        if (a.eat(120)) {
          if (this.regexp_eatFixedHexDigits(a, 2)) return !0;
          a.switchU && a.raise('Invalid escape'), (a.pos = f);
        }
        return !1;
      }),
      (we.regexp_eatDecimalDigits = function (a) {
        var f = a.pos,
          E = 0;
        for (a.lastIntValue = 0; Wl((E = a.current())); )
          (a.lastIntValue = 10 * a.lastIntValue + (E - 48)), a.advance();
        return a.pos !== f;
      });
    function Wl(a) {
      return a >= 48 && a <= 57;
    }
    we.regexp_eatHexDigits = function (a) {
      var f = a.pos,
        E = 0;
      for (a.lastIntValue = 0; rS((E = a.current())); ) (a.lastIntValue = 16 * a.lastIntValue + sS(E)), a.advance();
      return a.pos !== f;
    };
    function rS(a) {
      return (a >= 48 && a <= 57) || (a >= 65 && a <= 70) || (a >= 97 && a <= 102);
    }
    function sS(a) {
      return a >= 65 && a <= 70 ? 10 + (a - 65) : a >= 97 && a <= 102 ? 10 + (a - 97) : a - 48;
    }
    (we.regexp_eatLegacyOctalEscapeSequence = function (a) {
      if (this.regexp_eatOctalDigit(a)) {
        var f = a.lastIntValue;
        if (this.regexp_eatOctalDigit(a)) {
          var E = a.lastIntValue;
          f <= 3 && this.regexp_eatOctalDigit(a)
            ? (a.lastIntValue = f * 64 + E * 8 + a.lastIntValue)
            : (a.lastIntValue = f * 8 + E);
        } else a.lastIntValue = f;
        return !0;
      }
      return !1;
    }),
      (we.regexp_eatOctalDigit = function (a) {
        var f = a.current();
        return oS(f) ? ((a.lastIntValue = f - 48), a.advance(), !0) : ((a.lastIntValue = 0), !1);
      });
    function oS(a) {
      return a >= 48 && a <= 55;
    }
    we.regexp_eatFixedHexDigits = function (a, f) {
      var E = a.pos;
      a.lastIntValue = 0;
      for (var T = 0; T < f; ++T) {
        var L = a.current();
        if (!rS(L)) return (a.pos = E), !1;
        (a.lastIntValue = 16 * a.lastIntValue + sS(L)), a.advance();
      }
      return !0;
    };
    var Kl = function (f) {
        (this.type = f.type),
          (this.value = f.value),
          (this.start = f.start),
          (this.end = f.end),
          f.options.locations && (this.loc = new xe(f, f.startLoc, f.endLoc)),
          f.options.ranges && (this.range = [f.start, f.end]);
      },
      Be = re.prototype;
    (Be.next = function (a) {
      !a &&
        this.type.keyword &&
        this.containsEsc &&
        this.raiseRecoverable(this.start, 'Escape sequence in keyword ' + this.type.keyword),
        this.options.onToken && this.options.onToken(new Kl(this)),
        (this.lastTokEnd = this.end),
        (this.lastTokStart = this.start),
        (this.lastTokEndLoc = this.endLoc),
        (this.lastTokStartLoc = this.startLoc),
        this.nextToken();
    }),
      (Be.getToken = function () {
        return this.next(), new Kl(this);
      }),
      typeof Symbol < 'u' &&
        (Be[Symbol.iterator] = function () {
          var a = this;
          return {
            next: function () {
              var f = a.getToken();
              return { done: f.type === m.eof, value: f };
            },
          };
        }),
      (Be.nextToken = function () {
        var a = this.curContext();
        if (
          ((!a || !a.preserveSpace) && this.skipSpace(),
          (this.start = this.pos),
          this.options.locations && (this.startLoc = this.curPosition()),
          this.pos >= this.input.length)
        )
          return this.finishToken(m.eof);
        if (a.override) return a.override(this);
        this.readToken(this.fullCharCodeAtPos());
      }),
      (Be.readToken = function (a) {
        return x(a, this.options.ecmaVersion >= 6) || a === 92 ? this.readWord() : this.getTokenFromCode(a);
      }),
      (Be.fullCharCodeAtPos = function () {
        var a = this.input.charCodeAt(this.pos);
        if (a <= 55295 || a >= 56320) return a;
        var f = this.input.charCodeAt(this.pos + 1);
        return f <= 56319 || f >= 57344 ? a : (a << 10) + f - 56613888;
      }),
      (Be.skipBlockComment = function () {
        var a = this.options.onComment && this.curPosition(),
          f = this.pos,
          E = this.input.indexOf('*/', (this.pos += 2));
        if ((E === -1 && this.raise(this.pos - 2, 'Unterminated comment'), (this.pos = E + 2), this.options.locations))
          for (var T = void 0, L = f; (T = z(this.input, L, this.pos)) > -1; ) ++this.curLine, (L = this.lineStart = T);
        this.options.onComment &&
          this.options.onComment(!0, this.input.slice(f + 2, E), f, this.pos, a, this.curPosition());
      }),
      (Be.skipLineComment = function (a) {
        for (
          var f = this.pos,
            E = this.options.onComment && this.curPosition(),
            T = this.input.charCodeAt((this.pos += a));
          this.pos < this.input.length && !D(T);

        )
          T = this.input.charCodeAt(++this.pos);
        this.options.onComment &&
          this.options.onComment(!1, this.input.slice(f + a, this.pos), f, this.pos, E, this.curPosition());
      }),
      (Be.skipSpace = function () {
        e: for (; this.pos < this.input.length; ) {
          var a = this.input.charCodeAt(this.pos);
          switch (a) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.pos, this.options.locations && (++this.curLine, (this.lineStart = this.pos));
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break e;
              }
              break;
            default:
              if ((a > 8 && a < 14) || (a >= 5760 && H.test(String.fromCharCode(a)))) ++this.pos;
              else break e;
          }
        }
      }),
      (Be.finishToken = function (a, f) {
        (this.end = this.pos), this.options.locations && (this.endLoc = this.curPosition());
        var E = this.type;
        (this.type = a), (this.value = f), this.updateContext(E);
      }),
      (Be.readToken_dot = function () {
        var a = this.input.charCodeAt(this.pos + 1);
        if (a >= 48 && a <= 57) return this.readNumber(!0);
        var f = this.input.charCodeAt(this.pos + 2);
        return this.options.ecmaVersion >= 6 && a === 46 && f === 46
          ? ((this.pos += 3), this.finishToken(m.ellipsis))
          : (++this.pos, this.finishToken(m.dot));
      }),
      (Be.readToken_slash = function () {
        var a = this.input.charCodeAt(this.pos + 1);
        return this.exprAllowed
          ? (++this.pos, this.readRegexp())
          : a === 61
          ? this.finishOp(m.assign, 2)
          : this.finishOp(m.slash, 1);
      }),
      (Be.readToken_mult_modulo_exp = function (a) {
        var f = this.input.charCodeAt(this.pos + 1),
          E = 1,
          T = a === 42 ? m.star : m.modulo;
        return (
          this.options.ecmaVersion >= 7 &&
            a === 42 &&
            f === 42 &&
            (++E, (T = m.starstar), (f = this.input.charCodeAt(this.pos + 2))),
          f === 61 ? this.finishOp(m.assign, E + 1) : this.finishOp(T, E)
        );
      }),
      (Be.readToken_pipe_amp = function (a) {
        var f = this.input.charCodeAt(this.pos + 1);
        if (f === a) {
          if (this.options.ecmaVersion >= 12) {
            var E = this.input.charCodeAt(this.pos + 2);
            if (E === 61) return this.finishOp(m.assign, 3);
          }
          return this.finishOp(a === 124 ? m.logicalOR : m.logicalAND, 2);
        }
        return f === 61 ? this.finishOp(m.assign, 2) : this.finishOp(a === 124 ? m.bitwiseOR : m.bitwiseAND, 1);
      }),
      (Be.readToken_caret = function () {
        var a = this.input.charCodeAt(this.pos + 1);
        return a === 61 ? this.finishOp(m.assign, 2) : this.finishOp(m.bitwiseXOR, 1);
      }),
      (Be.readToken_plus_min = function (a) {
        var f = this.input.charCodeAt(this.pos + 1);
        return f === a
          ? f === 45 &&
            !this.inModule &&
            this.input.charCodeAt(this.pos + 2) === 62 &&
            (this.lastTokEnd === 0 || O.test(this.input.slice(this.lastTokEnd, this.pos)))
            ? (this.skipLineComment(3), this.skipSpace(), this.nextToken())
            : this.finishOp(m.incDec, 2)
          : f === 61
          ? this.finishOp(m.assign, 2)
          : this.finishOp(m.plusMin, 1);
      }),
      (Be.readToken_lt_gt = function (a) {
        var f = this.input.charCodeAt(this.pos + 1),
          E = 1;
        return f === a
          ? ((E = a === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2),
            this.input.charCodeAt(this.pos + E) === 61 ? this.finishOp(m.assign, E + 1) : this.finishOp(m.bitShift, E))
          : f === 33 &&
            a === 60 &&
            !this.inModule &&
            this.input.charCodeAt(this.pos + 2) === 45 &&
            this.input.charCodeAt(this.pos + 3) === 45
          ? (this.skipLineComment(4), this.skipSpace(), this.nextToken())
          : (f === 61 && (E = 2), this.finishOp(m.relational, E));
      }),
      (Be.readToken_eq_excl = function (a) {
        var f = this.input.charCodeAt(this.pos + 1);
        return f === 61
          ? this.finishOp(m.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)
          : a === 61 && f === 62 && this.options.ecmaVersion >= 6
          ? ((this.pos += 2), this.finishToken(m.arrow))
          : this.finishOp(a === 61 ? m.eq : m.prefix, 1);
      }),
      (Be.readToken_question = function () {
        var a = this.options.ecmaVersion;
        if (a >= 11) {
          var f = this.input.charCodeAt(this.pos + 1);
          if (f === 46) {
            var E = this.input.charCodeAt(this.pos + 2);
            if (E < 48 || E > 57) return this.finishOp(m.questionDot, 2);
          }
          if (f === 63) {
            if (a >= 12) {
              var T = this.input.charCodeAt(this.pos + 2);
              if (T === 61) return this.finishOp(m.assign, 3);
            }
            return this.finishOp(m.coalesce, 2);
          }
        }
        return this.finishOp(m.question, 1);
      }),
      (Be.readToken_numberSign = function () {
        var a = this.options.ecmaVersion,
          f = 35;
        if (a >= 13 && (++this.pos, (f = this.fullCharCodeAtPos()), x(f, !0) || f === 92))
          return this.finishToken(m.privateId, this.readWord1());
        this.raise(this.pos, "Unexpected character '" + q(f) + "'");
      }),
      (Be.getTokenFromCode = function (a) {
        switch (a) {
          case 46:
            return this.readToken_dot();
          case 40:
            return ++this.pos, this.finishToken(m.parenL);
          case 41:
            return ++this.pos, this.finishToken(m.parenR);
          case 59:
            return ++this.pos, this.finishToken(m.semi);
          case 44:
            return ++this.pos, this.finishToken(m.comma);
          case 91:
            return ++this.pos, this.finishToken(m.bracketL);
          case 93:
            return ++this.pos, this.finishToken(m.bracketR);
          case 123:
            return ++this.pos, this.finishToken(m.braceL);
          case 125:
            return ++this.pos, this.finishToken(m.braceR);
          case 58:
            return ++this.pos, this.finishToken(m.colon);
          case 96:
            if (this.options.ecmaVersion < 6) break;
            return ++this.pos, this.finishToken(m.backQuote);
          case 48:
            var f = this.input.charCodeAt(this.pos + 1);
            if (f === 120 || f === 88) return this.readRadixNumber(16);
            if (this.options.ecmaVersion >= 6) {
              if (f === 111 || f === 79) return this.readRadixNumber(8);
              if (f === 98 || f === 66) return this.readRadixNumber(2);
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(!1);
          case 34:
          case 39:
            return this.readString(a);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(a);
          case 124:
          case 38:
            return this.readToken_pipe_amp(a);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(a);
          case 60:
          case 62:
            return this.readToken_lt_gt(a);
          case 61:
          case 33:
            return this.readToken_eq_excl(a);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(m.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + q(a) + "'");
      }),
      (Be.finishOp = function (a, f) {
        var E = this.input.slice(this.pos, this.pos + f);
        return (this.pos += f), this.finishToken(a, E);
      }),
      (Be.readRegexp = function () {
        for (var a, f, E = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(E, 'Unterminated regular expression');
          var T = this.input.charAt(this.pos);
          if ((O.test(T) && this.raise(E, 'Unterminated regular expression'), a)) a = !1;
          else {
            if (T === '[') f = !0;
            else if (T === ']' && f) f = !1;
            else if (T === '/' && !f) break;
            a = T === '\\';
          }
          ++this.pos;
        }
        var L = this.input.slice(E, this.pos);
        ++this.pos;
        var $ = this.pos,
          J = this.readWord1();
        this.containsEsc && this.unexpected($);
        var he = this.regexpState || (this.regexpState = new An(this));
        he.reset(E, L, J), this.validateRegExpFlags(he), this.validateRegExpPattern(he);
        var ge = null;
        try {
          ge = new RegExp(L, J);
        } catch {}
        return this.finishToken(m.regexp, { pattern: L, flags: J, value: ge });
      }),
      (Be.readInt = function (a, f, E) {
        for (
          var T = this.options.ecmaVersion >= 12 && f === void 0,
            L = E && this.input.charCodeAt(this.pos) === 48,
            $ = this.pos,
            J = 0,
            he = 0,
            ge = 0,
            Fe = f ?? 1 / 0;
          ge < Fe;
          ++ge, ++this.pos
        ) {
          var qe = this.input.charCodeAt(this.pos),
            Dt = void 0;
          if (T && qe === 95) {
            L && this.raiseRecoverable(this.pos, 'Numeric separator is not allowed in legacy octal numeric literals'),
              he === 95 && this.raiseRecoverable(this.pos, 'Numeric separator must be exactly one underscore'),
              ge === 0 && this.raiseRecoverable(this.pos, 'Numeric separator is not allowed at the first of digits'),
              (he = qe);
            continue;
          }
          if (
            (qe >= 97
              ? (Dt = qe - 97 + 10)
              : qe >= 65
              ? (Dt = qe - 65 + 10)
              : qe >= 48 && qe <= 57
              ? (Dt = qe - 48)
              : (Dt = 1 / 0),
            Dt >= a)
          )
            break;
          (he = qe), (J = J * a + Dt);
        }
        return (
          T &&
            he === 95 &&
            this.raiseRecoverable(this.pos - 1, 'Numeric separator is not allowed at the last of digits'),
          this.pos === $ || (f != null && this.pos - $ !== f) ? null : J
        );
      });
    function Kq(a, f) {
      return f ? parseInt(a, 8) : parseFloat(a.replace(/_/g, ''));
    }
    function aS(a) {
      return typeof BigInt != 'function' ? null : BigInt(a.replace(/_/g, ''));
    }
    (Be.readRadixNumber = function (a) {
      var f = this.pos;
      this.pos += 2;
      var E = this.readInt(a);
      return (
        E == null && this.raise(this.start + 2, 'Expected number in radix ' + a),
        this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110
          ? ((E = aS(this.input.slice(f, this.pos))), ++this.pos)
          : x(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number'),
        this.finishToken(m.num, E)
      );
    }),
      (Be.readNumber = function (a) {
        var f = this.pos;
        !a && this.readInt(10, void 0, !0) === null && this.raise(f, 'Invalid number');
        var E = this.pos - f >= 2 && this.input.charCodeAt(f) === 48;
        E && this.strict && this.raise(f, 'Invalid number');
        var T = this.input.charCodeAt(this.pos);
        if (!E && !a && this.options.ecmaVersion >= 11 && T === 110) {
          var L = aS(this.input.slice(f, this.pos));
          return (
            ++this.pos,
            x(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number'),
            this.finishToken(m.num, L)
          );
        }
        E && /[89]/.test(this.input.slice(f, this.pos)) && (E = !1),
          T === 46 && !E && (++this.pos, this.readInt(10), (T = this.input.charCodeAt(this.pos))),
          (T === 69 || T === 101) &&
            !E &&
            ((T = this.input.charCodeAt(++this.pos)),
            (T === 43 || T === 45) && ++this.pos,
            this.readInt(10) === null && this.raise(f, 'Invalid number')),
          x(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number');
        var $ = Kq(this.input.slice(f, this.pos), E);
        return this.finishToken(m.num, $);
      }),
      (Be.readCodePoint = function () {
        var a = this.input.charCodeAt(this.pos),
          f;
        if (a === 123) {
          this.options.ecmaVersion < 6 && this.unexpected();
          var E = ++this.pos;
          (f = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos)),
            ++this.pos,
            f > 1114111 && this.invalidStringToken(E, 'Code point out of bounds');
        } else f = this.readHexChar(4);
        return f;
      }),
      (Be.readString = function (a) {
        for (var f = '', E = ++this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, 'Unterminated string constant');
          var T = this.input.charCodeAt(this.pos);
          if (T === a) break;
          T === 92
            ? ((f += this.input.slice(E, this.pos)), (f += this.readEscapedChar(!1)), (E = this.pos))
            : T === 8232 || T === 8233
            ? (this.options.ecmaVersion < 10 && this.raise(this.start, 'Unterminated string constant'),
              ++this.pos,
              this.options.locations && (this.curLine++, (this.lineStart = this.pos)))
            : (D(T) && this.raise(this.start, 'Unterminated string constant'), ++this.pos);
        }
        return (f += this.input.slice(E, this.pos++)), this.finishToken(m.string, f);
      });
    var cS = {};
    (Be.tryReadTemplateToken = function () {
      this.inTemplateElement = !0;
      try {
        this.readTmplToken();
      } catch (a) {
        if (a === cS) this.readInvalidTemplateToken();
        else throw a;
      }
      this.inTemplateElement = !1;
    }),
      (Be.invalidStringToken = function (a, f) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw cS;
        this.raise(a, f);
      }),
      (Be.readTmplToken = function () {
        for (var a = '', f = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, 'Unterminated template');
          var E = this.input.charCodeAt(this.pos);
          if (E === 96 || (E === 36 && this.input.charCodeAt(this.pos + 1) === 123))
            return this.pos === this.start && (this.type === m.template || this.type === m.invalidTemplate)
              ? E === 36
                ? ((this.pos += 2), this.finishToken(m.dollarBraceL))
                : (++this.pos, this.finishToken(m.backQuote))
              : ((a += this.input.slice(f, this.pos)), this.finishToken(m.template, a));
          if (E === 92) (a += this.input.slice(f, this.pos)), (a += this.readEscapedChar(!0)), (f = this.pos);
          else if (D(E)) {
            switch (((a += this.input.slice(f, this.pos)), ++this.pos, E)) {
              case 13:
                this.input.charCodeAt(this.pos) === 10 && ++this.pos;
              case 10:
                a += `
`;
                break;
              default:
                a += String.fromCharCode(E);
                break;
            }
            this.options.locations && (++this.curLine, (this.lineStart = this.pos)), (f = this.pos);
          } else ++this.pos;
        }
      }),
      (Be.readInvalidTemplateToken = function () {
        for (; this.pos < this.input.length; this.pos++)
          switch (this.input[this.pos]) {
            case '\\':
              ++this.pos;
              break;
            case '$':
              if (this.input[this.pos + 1] !== '{') break;
            case '`':
              return this.finishToken(m.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        this.raise(this.start, 'Unterminated template');
      }),
      (Be.readEscapedChar = function (a) {
        var f = this.input.charCodeAt(++this.pos);
        switch ((++this.pos, f)) {
          case 110:
            return `
`;
          case 114:
            return '\r';
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return q(this.readCodePoint());
          case 116:
            return '	';
          case 98:
            return '\b';
          case 118:
            return '\v';
          case 102:
            return '\f';
          case 13:
            this.input.charCodeAt(this.pos) === 10 && ++this.pos;
          case 10:
            return this.options.locations && ((this.lineStart = this.pos), ++this.curLine), '';
          case 56:
          case 57:
            if ((this.strict && this.invalidStringToken(this.pos - 1, 'Invalid escape sequence'), a)) {
              var E = this.pos - 1;
              this.invalidStringToken(E, 'Invalid escape sequence in template string');
            }
          default:
            if (f >= 48 && f <= 55) {
              var T = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0],
                L = parseInt(T, 8);
              return (
                L > 255 && ((T = T.slice(0, -1)), (L = parseInt(T, 8))),
                (this.pos += T.length - 1),
                (f = this.input.charCodeAt(this.pos)),
                (T !== '0' || f === 56 || f === 57) &&
                  (this.strict || a) &&
                  this.invalidStringToken(
                    this.pos - 1 - T.length,
                    a ? 'Octal literal in template string' : 'Octal literal in strict mode'
                  ),
                String.fromCharCode(L)
              );
            }
            return D(f) ? '' : String.fromCharCode(f);
        }
      }),
      (Be.readHexChar = function (a) {
        var f = this.pos,
          E = this.readInt(16, a);
        return E === null && this.invalidStringToken(f, 'Bad character escape sequence'), E;
      }),
      (Be.readWord1 = function () {
        this.containsEsc = !1;
        for (var a = '', f = !0, E = this.pos, T = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
          var L = this.fullCharCodeAtPos();
          if (b(L, T)) this.pos += L <= 65535 ? 1 : 2;
          else if (L === 92) {
            (this.containsEsc = !0), (a += this.input.slice(E, this.pos));
            var $ = this.pos;
            this.input.charCodeAt(++this.pos) !== 117 &&
              this.invalidStringToken(this.pos, 'Expecting Unicode escape sequence \\uXXXX'),
              ++this.pos;
            var J = this.readCodePoint();
            (f ? x : b)(J, T) || this.invalidStringToken($, 'Invalid Unicode escape'), (a += q(J)), (E = this.pos);
          } else break;
          f = !1;
        }
        return a + this.input.slice(E, this.pos);
      }),
      (Be.readWord = function () {
        var a = this.readWord1(),
          f = m.name;
        return this.keywords.test(a) && (f = C[a]), this.finishToken(f, a);
      });
    var uS = '8.10.0';
    re.acorn = {
      Parser: re,
      version: uS,
      defaultOptions: Z,
      Position: ee,
      SourceLocation: xe,
      getLineInfo: de,
      Node: Ot,
      TokenType: g,
      tokTypes: m,
      keywordTypes: C,
      TokContext: Qe,
      tokContexts: et,
      isIdentifierChar: b,
      isIdentifierStart: x,
      Token: Kl,
      isNewLine: D,
      lineBreak: O,
      lineBreakG: N,
      nonASCIIwhitespace: H,
    };
    function Xq(a, f) {
      return re.parse(a, f);
    }
    function Yq(a, f, E) {
      return re.parseExpressionAt(a, f, E);
    }
    function Jq(a, f) {
      return re.tokenizer(a, f);
    }
    (t.Node = Ot),
      (t.Parser = re),
      (t.Position = ee),
      (t.SourceLocation = xe),
      (t.TokContext = Qe),
      (t.Token = Kl),
      (t.TokenType = g),
      (t.defaultOptions = Z),
      (t.getLineInfo = de),
      (t.isIdentifierChar = b),
      (t.isIdentifierStart = x),
      (t.isNewLine = D),
      (t.keywordTypes = C),
      (t.lineBreak = O),
      (t.lineBreakG = N),
      (t.nonASCIIwhitespace = H),
      (t.parse = Xq),
      (t.parseExpressionAt = Yq),
      (t.tokContexts = et),
      (t.tokTypes = m),
      (t.tokenizer = Jq),
      (t.version = uS);
  });
});
var HD = P((vh, BD) => {
  'use strict';
  (function (t, e) {
    typeof vh == 'object' && typeof BD < 'u'
      ? e(vh)
      : typeof define == 'function' && define.amd
      ? define(['exports'], e)
      : ((t = t || self), e(((t.acorn = t.acorn || {}), (t.acorn.walk = {}))));
  })(vh, function (t) {
    'use strict';
    function e(h, v, C, _, m) {
      C || (C = y),
        (function O(N, D, z) {
          var H = z || N.type,
            F = v[H];
          C[H](N, D, O), F && F(N, D);
        })(h, _, m);
    }
    function i(h, v, C, _, m) {
      var O = [];
      C || (C = y),
        (function N(D, z, H) {
          var F = H || D.type,
            ne = v[F],
            pe = D !== O[O.length - 1];
          pe && O.push(D), C[F](D, z, N), ne && ne(D, z || O, O), pe && O.pop();
        })(h, _, m);
    }
    function n(h, v, C, _, m) {
      var O = C ? x(C, _ || void 0) : _;
      (function N(D, z, H) {
        O[H || D.type](D, z, N);
      })(h, v, m);
    }
    function r(h) {
      return typeof h == 'string'
        ? function (v) {
            return v === h;
          }
        : h ||
            function () {
              return !0;
            };
    }
    var s = function (v, C) {
      (this.node = v), (this.state = C);
    };
    function o(h, v, C, _, m) {
      C || (C = y);
      var O;
      (function N(D, z, H) {
        var F = H || D.type;
        C[F](D, z, N), O !== D && (v(D, z, F), (O = D));
      })(h, _, m);
    }
    function c(h, v, C, _) {
      C || (C = y);
      var m = [],
        O;
      (function N(D, z, H) {
        var F = H || D.type,
          ne = D !== m[m.length - 1];
        ne && m.push(D), C[F](D, z, N), O !== D && (v(D, z || m, m, F), (O = D)), ne && m.pop();
      })(h, _);
    }
    function u(h, v, C, _, m, O) {
      m || (m = y), (_ = r(_));
      try {
        (function N(D, z, H) {
          var F = H || D.type;
          if (
            ((v == null || D.start <= v) && (C == null || D.end >= C) && m[F](D, z, N),
            (v == null || D.start === v) && (C == null || D.end === C) && _(F, D))
          )
            throw new s(D, z);
        })(h, O);
      } catch (N) {
        if (N instanceof s) return N;
        throw N;
      }
    }
    function l(h, v, C, _, m) {
      (C = r(C)), _ || (_ = y);
      try {
        (function O(N, D, z) {
          var H = z || N.type;
          if (!(N.start > v || N.end < v) && (_[H](N, D, O), C(H, N))) throw new s(N, D);
        })(h, m);
      } catch (O) {
        if (O instanceof s) return O;
        throw O;
      }
    }
    function p(h, v, C, _, m) {
      (C = r(C)), _ || (_ = y);
      try {
        (function O(N, D, z) {
          if (!(N.end < v)) {
            var H = z || N.type;
            if (N.start >= v && C(H, N)) throw new s(N, D);
            _[H](N, D, O);
          }
        })(h, m);
      } catch (O) {
        if (O instanceof s) return O;
        throw O;
      }
    }
    function d(h, v, C, _, m) {
      (C = r(C)), _ || (_ = y);
      var O;
      return (
        (function N(D, z, H) {
          if (!(D.start > v)) {
            var F = H || D.type;
            D.end <= v && (!O || O.node.end < D.end) && C(F, D) && (O = new s(D, z)), _[F](D, z, N);
          }
        })(h, m),
        O
      );
    }
    function x(h, v) {
      var C = Object.create(v || y);
      for (var _ in h) C[_] = h[_];
      return C;
    }
    function b(h, v, C) {
      C(h, v);
    }
    function g(h, v, C) {}
    var y = {};
    (y.Program =
      y.BlockStatement =
      y.StaticBlock =
        function (h, v, C) {
          for (var _ = 0, m = h.body; _ < m.length; _ += 1) {
            var O = m[_];
            C(O, v, 'Statement');
          }
        }),
      (y.Statement = b),
      (y.EmptyStatement = g),
      (y.ExpressionStatement =
        y.ParenthesizedExpression =
        y.ChainExpression =
          function (h, v, C) {
            return C(h.expression, v, 'Expression');
          }),
      (y.IfStatement = function (h, v, C) {
        C(h.test, v, 'Expression'), C(h.consequent, v, 'Statement'), h.alternate && C(h.alternate, v, 'Statement');
      }),
      (y.LabeledStatement = function (h, v, C) {
        return C(h.body, v, 'Statement');
      }),
      (y.BreakStatement = y.ContinueStatement = g),
      (y.WithStatement = function (h, v, C) {
        C(h.object, v, 'Expression'), C(h.body, v, 'Statement');
      }),
      (y.SwitchStatement = function (h, v, C) {
        C(h.discriminant, v, 'Expression');
        for (var _ = 0, m = h.cases; _ < m.length; _ += 1) {
          var O = m[_];
          O.test && C(O.test, v, 'Expression');
          for (var N = 0, D = O.consequent; N < D.length; N += 1) {
            var z = D[N];
            C(z, v, 'Statement');
          }
        }
      }),
      (y.SwitchCase = function (h, v, C) {
        h.test && C(h.test, v, 'Expression');
        for (var _ = 0, m = h.consequent; _ < m.length; _ += 1) {
          var O = m[_];
          C(O, v, 'Statement');
        }
      }),
      (y.ReturnStatement =
        y.YieldExpression =
        y.AwaitExpression =
          function (h, v, C) {
            h.argument && C(h.argument, v, 'Expression');
          }),
      (y.ThrowStatement = y.SpreadElement =
        function (h, v, C) {
          return C(h.argument, v, 'Expression');
        }),
      (y.TryStatement = function (h, v, C) {
        C(h.block, v, 'Statement'), h.handler && C(h.handler, v), h.finalizer && C(h.finalizer, v, 'Statement');
      }),
      (y.CatchClause = function (h, v, C) {
        h.param && C(h.param, v, 'Pattern'), C(h.body, v, 'Statement');
      }),
      (y.WhileStatement = y.DoWhileStatement =
        function (h, v, C) {
          C(h.test, v, 'Expression'), C(h.body, v, 'Statement');
        }),
      (y.ForStatement = function (h, v, C) {
        h.init && C(h.init, v, 'ForInit'),
          h.test && C(h.test, v, 'Expression'),
          h.update && C(h.update, v, 'Expression'),
          C(h.body, v, 'Statement');
      }),
      (y.ForInStatement = y.ForOfStatement =
        function (h, v, C) {
          C(h.left, v, 'ForInit'), C(h.right, v, 'Expression'), C(h.body, v, 'Statement');
        }),
      (y.ForInit = function (h, v, C) {
        h.type === 'VariableDeclaration' ? C(h, v) : C(h, v, 'Expression');
      }),
      (y.DebuggerStatement = g),
      (y.FunctionDeclaration = function (h, v, C) {
        return C(h, v, 'Function');
      }),
      (y.VariableDeclaration = function (h, v, C) {
        for (var _ = 0, m = h.declarations; _ < m.length; _ += 1) {
          var O = m[_];
          C(O, v);
        }
      }),
      (y.VariableDeclarator = function (h, v, C) {
        C(h.id, v, 'Pattern'), h.init && C(h.init, v, 'Expression');
      }),
      (y.Function = function (h, v, C) {
        h.id && C(h.id, v, 'Pattern');
        for (var _ = 0, m = h.params; _ < m.length; _ += 1) {
          var O = m[_];
          C(O, v, 'Pattern');
        }
        C(h.body, v, h.expression ? 'Expression' : 'Statement');
      }),
      (y.Pattern = function (h, v, C) {
        h.type === 'Identifier'
          ? C(h, v, 'VariablePattern')
          : h.type === 'MemberExpression'
          ? C(h, v, 'MemberPattern')
          : C(h, v);
      }),
      (y.VariablePattern = g),
      (y.MemberPattern = b),
      (y.RestElement = function (h, v, C) {
        return C(h.argument, v, 'Pattern');
      }),
      (y.ArrayPattern = function (h, v, C) {
        for (var _ = 0, m = h.elements; _ < m.length; _ += 1) {
          var O = m[_];
          O && C(O, v, 'Pattern');
        }
      }),
      (y.ObjectPattern = function (h, v, C) {
        for (var _ = 0, m = h.properties; _ < m.length; _ += 1) {
          var O = m[_];
          O.type === 'Property'
            ? (O.computed && C(O.key, v, 'Expression'), C(O.value, v, 'Pattern'))
            : O.type === 'RestElement' && C(O.argument, v, 'Pattern');
        }
      }),
      (y.Expression = b),
      (y.ThisExpression = y.Super = y.MetaProperty = g),
      (y.ArrayExpression = function (h, v, C) {
        for (var _ = 0, m = h.elements; _ < m.length; _ += 1) {
          var O = m[_];
          O && C(O, v, 'Expression');
        }
      }),
      (y.ObjectExpression = function (h, v, C) {
        for (var _ = 0, m = h.properties; _ < m.length; _ += 1) {
          var O = m[_];
          C(O, v);
        }
      }),
      (y.FunctionExpression = y.ArrowFunctionExpression = y.FunctionDeclaration),
      (y.SequenceExpression = function (h, v, C) {
        for (var _ = 0, m = h.expressions; _ < m.length; _ += 1) {
          var O = m[_];
          C(O, v, 'Expression');
        }
      }),
      (y.TemplateLiteral = function (h, v, C) {
        for (var _ = 0, m = h.quasis; _ < m.length; _ += 1) {
          var O = m[_];
          C(O, v);
        }
        for (var N = 0, D = h.expressions; N < D.length; N += 1) {
          var z = D[N];
          C(z, v, 'Expression');
        }
      }),
      (y.TemplateElement = g),
      (y.UnaryExpression = y.UpdateExpression =
        function (h, v, C) {
          C(h.argument, v, 'Expression');
        }),
      (y.BinaryExpression = y.LogicalExpression =
        function (h, v, C) {
          C(h.left, v, 'Expression'), C(h.right, v, 'Expression');
        }),
      (y.AssignmentExpression = y.AssignmentPattern =
        function (h, v, C) {
          C(h.left, v, 'Pattern'), C(h.right, v, 'Expression');
        }),
      (y.ConditionalExpression = function (h, v, C) {
        C(h.test, v, 'Expression'), C(h.consequent, v, 'Expression'), C(h.alternate, v, 'Expression');
      }),
      (y.NewExpression = y.CallExpression =
        function (h, v, C) {
          if ((C(h.callee, v, 'Expression'), h.arguments))
            for (var _ = 0, m = h.arguments; _ < m.length; _ += 1) {
              var O = m[_];
              C(O, v, 'Expression');
            }
        }),
      (y.MemberExpression = function (h, v, C) {
        C(h.object, v, 'Expression'), h.computed && C(h.property, v, 'Expression');
      }),
      (y.ExportNamedDeclaration = y.ExportDefaultDeclaration =
        function (h, v, C) {
          h.declaration &&
            C(h.declaration, v, h.type === 'ExportNamedDeclaration' || h.declaration.id ? 'Statement' : 'Expression'),
            h.source && C(h.source, v, 'Expression');
        }),
      (y.ExportAllDeclaration = function (h, v, C) {
        h.exported && C(h.exported, v), C(h.source, v, 'Expression');
      }),
      (y.ImportDeclaration = function (h, v, C) {
        for (var _ = 0, m = h.specifiers; _ < m.length; _ += 1) {
          var O = m[_];
          C(O, v);
        }
        C(h.source, v, 'Expression');
      }),
      (y.ImportExpression = function (h, v, C) {
        C(h.source, v, 'Expression');
      }),
      (y.ImportSpecifier =
        y.ImportDefaultSpecifier =
        y.ImportNamespaceSpecifier =
        y.Identifier =
        y.PrivateIdentifier =
        y.Literal =
          g),
      (y.TaggedTemplateExpression = function (h, v, C) {
        C(h.tag, v, 'Expression'), C(h.quasi, v, 'Expression');
      }),
      (y.ClassDeclaration = y.ClassExpression =
        function (h, v, C) {
          return C(h, v, 'Class');
        }),
      (y.Class = function (h, v, C) {
        h.id && C(h.id, v, 'Pattern'), h.superClass && C(h.superClass, v, 'Expression'), C(h.body, v);
      }),
      (y.ClassBody = function (h, v, C) {
        for (var _ = 0, m = h.body; _ < m.length; _ += 1) {
          var O = m[_];
          C(O, v);
        }
      }),
      (y.MethodDefinition =
        y.PropertyDefinition =
        y.Property =
          function (h, v, C) {
            h.computed && C(h.key, v, 'Expression'), h.value && C(h.value, v, 'Expression');
          }),
      (t.ancestor = i),
      (t.base = y),
      (t.findNodeAfter = p),
      (t.findNodeAround = l),
      (t.findNodeAt = u),
      (t.findNodeBefore = d),
      (t.full = o),
      (t.fullAncestor = c),
      (t.make = x),
      (t.recursive = n),
      (t.simple = e),
      Object.defineProperty(t, '__esModule', { value: !0 });
  });
});
var WD = P((wpe, $D) => {
  'use strict';
  var {
      ArrayFrom: BY,
      ArrayPrototypeForEach: xl,
      ArrayPrototypeIncludes: HY,
      ArrayPrototypeJoin: Y0,
      ArrayPrototypePop: GY,
      ArrayPrototypePush: yl,
      FunctionPrototype: zY,
      ObjectKeys: VY,
      RegExpPrototypeSymbolReplace: $Y,
      StringPrototypeEndsWith: WY,
      StringPrototypeIncludes: GD,
      StringPrototypeIndexOf: KY,
      StringPrototypeRepeat: XY,
      StringPrototypeSplit: YY,
      StringPrototypeStartsWith: JY,
      SyntaxError: ZY,
    } = Io(),
    QY = qD().Parser,
    Ss = HD(),
    { Recoverable: eJ } = require('repl');
  function zD(t) {
    return t.ancestors[t.ancestors.length - 2] === t.body;
  }
  var X0 = zY,
    tJ = {
      ClassDeclaration(t, e, i) {
        zD(e) && (e.prepend(t, `${t.id.name}=`), yl(e.hoistedDeclarationStatements, `let ${t.id.name}; `)),
          Ss.base.ClassDeclaration(t, e, i);
      },
      ForOfStatement(t, e, i) {
        t.await === !0 && (e.containsAwait = !0), Ss.base.ForOfStatement(t, e, i);
      },
      FunctionDeclaration(t, e, i) {
        e.prepend(t, `${t.id.name}=`), yl(e.hoistedDeclarationStatements, `var ${t.id.name}; `);
      },
      FunctionExpression: X0,
      ArrowFunctionExpression: X0,
      MethodDefinition: X0,
      AwaitExpression(t, e, i) {
        (e.containsAwait = !0), Ss.base.AwaitExpression(t, e, i);
      },
      ReturnStatement(t, e, i) {
        (e.containsReturn = !0), Ss.base.ReturnStatement(t, e, i);
      },
      VariableDeclaration(t, e, i) {
        let n = t.kind,
          r = HY(['ForOfStatement', 'ForInStatement'], e.ancestors[e.ancestors.length - 2].type);
        if (n === 'var' || zD(e)) {
          let o = function (c) {
            switch (c.type) {
              case 'Identifier':
                yl(s[n === 'var' ? 0 : 1][1], c.name);
                break;
              case 'ObjectPattern':
                xl(c.properties, (u) => {
                  o(u.value);
                });
                break;
              case 'ArrayPattern':
                xl(c.elements, (u) => {
                  o(u);
                });
                break;
            }
          };
          e.replace(
            t.start,
            t.start + n.length + (r ? 1 : 0),
            n === 'var' && r ? '' : 'void' + (t.declarations.length === 1 ? '' : ' (')
          ),
            r ||
              (xl(t.declarations, (c) => {
                e.prepend(c, '('), e.append(c, c.init ? ')' : '=undefined)');
              }),
              t.declarations.length !== 1 && e.append(t.declarations[t.declarations.length - 1], ')'));
          let s = [
            ['var', []],
            ['let', []],
          ];
          xl(t.declarations, (c) => {
            o(c.id);
          }),
            xl(s, ({ 0: c, 1: u }) => {
              u.length > 0 && yl(e.hoistedDeclarationStatements, `${c} ${Y0(u, ', ')}; `);
            });
        }
        Ss.base.VariableDeclaration(t, e, i);
      },
    },
    VD = {};
  for (let t of VY(Ss.base)) {
    let e = tJ[t] || Ss.base[t];
    VD[t] = (i, n, r) => {
      let s = i !== n.ancestors[n.ancestors.length - 1];
      s && yl(n.ancestors, i), e(i, n, r), s && GY(n.ancestors);
    };
  }
  function iJ(t) {
    let e = '(async () => { ',
      i = `${e}${t} })()`,
      n = BY(i),
      r;
    try {
      r = QY.parse(i, { ecmaVersion: 'latest' });
    } catch (u) {
      if (JY(u.message, 'Unterminated ')) throw new eJ(u);
      let l = KY(t, 'await'),
        p = u.pos - e.length;
      if (
        l > p ||
        (p === l + 6 && GD(u.message, 'Expecting Unicode escape sequence')) ||
        (p === l + 7 && GD(u.message, 'Unexpected token'))
      )
        return null;
      let d = u.loc.line,
        x = d === 1 ? u.loc.column - e.length : u.loc.column,
        b =
          `
` +
          YY(
            t,
            `
`
          )[d - 1] +
          `
` +
          XY(' ', x) +
          `^

` +
          $Y(/ \([^)]+\)/, u.message, '');
      throw (
        (WY(b, 'Unexpected token') &&
          (b += " '" + (t.length - 1 >= u.pos - e.length ? t[u.pos - e.length] : t[t.length - 1]) + "'"),
        new ZY(b))
      );
    }
    let s = r.body[0].expression.callee.body,
      o = {
        body: s,
        ancestors: [],
        hoistedDeclarationStatements: [],
        replace(u, l, p) {
          for (let d = u; d < l; d++) n[d] = '';
          u === l && (p += n[u]), (n[u] = p);
        },
        prepend(u, l) {
          n[u.start] = l + n[u.start];
        },
        append(u, l) {
          n[u.end - 1] += l;
        },
        containsAwait: !1,
        containsReturn: !1,
      };
    if ((Ss.recursive(s, o, VD), !o.containsAwait || o.containsReturn)) return null;
    let c = s.body[s.body.length - 1];
    return (
      c.type === 'ExpressionStatement' && (o.prepend(c, 'return ('), o.append(c.expression, ')')),
      Y0(o.hoistedDeclarationStatements, '') + Y0(n, '')
    );
  }
  $D.exports = { processTopLevelAwait: iJ };
});
var Or = P((J0) => {
  'use strict';
  Object.defineProperty(J0, '__esModule', { value: !0 });
  J0.default = KD;
  function KD() {}
  KD.prototype = {
    diff: function (e, i) {
      var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        r = n.callback;
      typeof n == 'function' && ((r = n), (n = {})), (this.options = n);
      var s = this;
      function o(y) {
        return r
          ? (setTimeout(function () {
              r(void 0, y);
            }, 0),
            !0)
          : y;
      }
      (e = this.castInput(e)),
        (i = this.castInput(i)),
        (e = this.removeEmpty(this.tokenize(e))),
        (i = this.removeEmpty(this.tokenize(i)));
      var c = i.length,
        u = e.length,
        l = 1,
        p = c + u,
        d = [{ newPos: -1, components: [] }],
        x = this.extractCommon(d[0], i, e, 0);
      if (d[0].newPos + 1 >= c && x + 1 >= u) return o([{ value: this.join(i), count: i.length }]);
      function b() {
        for (var y = -1 * l; y <= l; y += 2) {
          var h = void 0,
            v = d[y - 1],
            C = d[y + 1],
            _ = (C ? C.newPos : 0) - y;
          v && (d[y - 1] = void 0);
          var m = v && v.newPos + 1 < c,
            O = C && 0 <= _ && _ < u;
          if (!m && !O) {
            d[y] = void 0;
            continue;
          }
          if (
            (!m || (O && v.newPos < C.newPos)
              ? ((h = rJ(C)), s.pushComponent(h.components, void 0, !0))
              : ((h = v), h.newPos++, s.pushComponent(h.components, !0, void 0)),
            (_ = s.extractCommon(h, i, e, y)),
            h.newPos + 1 >= c && _ + 1 >= u)
          )
            return o(nJ(s, h.components, i, e, s.useLongestToken));
          d[y] = h;
        }
        l++;
      }
      if (r)
        (function y() {
          setTimeout(function () {
            if (l > p) return r();
            b() || y();
          }, 0);
        })();
      else
        for (; l <= p; ) {
          var g = b();
          if (g) return g;
        }
    },
    pushComponent: function (e, i, n) {
      var r = e[e.length - 1];
      r && r.added === i && r.removed === n
        ? (e[e.length - 1] = { count: r.count + 1, added: i, removed: n })
        : e.push({ count: 1, added: i, removed: n });
    },
    extractCommon: function (e, i, n, r) {
      for (
        var s = i.length, o = n.length, c = e.newPos, u = c - r, l = 0;
        c + 1 < s && u + 1 < o && this.equals(i[c + 1], n[u + 1]);

      )
        c++, u++, l++;
      return l && e.components.push({ count: l }), (e.newPos = c), u;
    },
    equals: function (e, i) {
      return this.options.comparator
        ? this.options.comparator(e, i)
        : e === i || (this.options.ignoreCase && e.toLowerCase() === i.toLowerCase());
    },
    removeEmpty: function (e) {
      for (var i = [], n = 0; n < e.length; n++) e[n] && i.push(e[n]);
      return i;
    },
    castInput: function (e) {
      return e;
    },
    tokenize: function (e) {
      return e.split('');
    },
    join: function (e) {
      return e.join('');
    },
  };
  function nJ(t, e, i, n, r) {
    for (var s = 0, o = e.length, c = 0, u = 0; s < o; s++) {
      var l = e[s];
      if (l.removed) {
        if (((l.value = t.join(n.slice(u, u + l.count))), (u += l.count), s && e[s - 1].added)) {
          var d = e[s - 1];
          (e[s - 1] = e[s]), (e[s] = d);
        }
      } else {
        if (!l.added && r) {
          var p = i.slice(c, c + l.count);
          (p = p.map(function (b, g) {
            var y = n[u + g];
            return y.length > b.length ? y : b;
          })),
            (l.value = t.join(p));
        } else l.value = t.join(i.slice(c, c + l.count));
        (c += l.count), l.added || (u += l.count);
      }
    }
    var x = e[o - 1];
    return (
      o > 1 &&
        typeof x.value == 'string' &&
        (x.added || x.removed) &&
        t.equals('', x.value) &&
        ((e[o - 2].value += x.value), e.pop()),
      e
    );
  }
  function rJ(t) {
    return { newPos: t.newPos, components: t.components.slice(0) };
  }
});
var YD = P((bl) => {
  'use strict';
  Object.defineProperty(bl, '__esModule', { value: !0 });
  bl.diffChars = aJ;
  bl.characterDiff = void 0;
  var sJ = oJ(Or());
  function oJ(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var XD = new sJ.default();
  bl.characterDiff = XD;
  function aJ(t, e, i) {
    return XD.diff(t, e, i);
  }
});
var Q0 = P((Z0) => {
  'use strict';
  Object.defineProperty(Z0, '__esModule', { value: !0 });
  Z0.generateOptions = cJ;
  function cJ(t, e) {
    if (typeof t == 'function') e.callback = t;
    else if (t) for (var i in t) t.hasOwnProperty(i) && (e[i] = t[i]);
    return e;
  }
});
var QD = P((hc) => {
  'use strict';
  Object.defineProperty(hc, '__esModule', { value: !0 });
  hc.diffWords = fJ;
  hc.diffWordsWithSpace = dJ;
  hc.wordDiff = void 0;
  var uJ = pJ(Or()),
    lJ = Q0();
  function pJ(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var JD = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/,
    ZD = /\S/,
    vl = new uJ.default();
  hc.wordDiff = vl;
  vl.equals = function (t, e) {
    return (
      this.options.ignoreCase && ((t = t.toLowerCase()), (e = e.toLowerCase())),
      t === e || (this.options.ignoreWhitespace && !ZD.test(t) && !ZD.test(e))
    );
  };
  vl.tokenize = function (t) {
    for (var e = t.split(/(\s+|[()[\]{}'"]|\b)/), i = 0; i < e.length - 1; i++)
      !e[i + 1] && e[i + 2] && JD.test(e[i]) && JD.test(e[i + 2]) && ((e[i] += e[i + 2]), e.splice(i + 1, 2), i--);
    return e;
  };
  function fJ(t, e, i) {
    return (i = (0, lJ.generateOptions)(i, { ignoreWhitespace: !0 })), vl.diff(t, e, i);
  }
  function dJ(t, e, i) {
    return vl.diff(t, e, i);
  }
});
var Eh = P((mc) => {
  'use strict';
  Object.defineProperty(mc, '__esModule', { value: !0 });
  mc.diffLines = xJ;
  mc.diffTrimmedLines = yJ;
  mc.lineDiff = void 0;
  var hJ = gJ(Or()),
    mJ = Q0();
  function gJ(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var wh = new hJ.default();
  mc.lineDiff = wh;
  wh.tokenize = function (t) {
    var e = [],
      i = t.split(/(\n|\r\n)/);
    i[i.length - 1] || i.pop();
    for (var n = 0; n < i.length; n++) {
      var r = i[n];
      n % 2 && !this.options.newlineIsToken
        ? (e[e.length - 1] += r)
        : (this.options.ignoreWhitespace && (r = r.trim()), e.push(r));
    }
    return e;
  };
  function xJ(t, e, i) {
    return wh.diff(t, e, i);
  }
  function yJ(t, e, i) {
    var n = (0, mJ.generateOptions)(i, { ignoreWhitespace: !0 });
    return wh.diff(t, e, n);
  }
});
var eF = P((wl) => {
  'use strict';
  Object.defineProperty(wl, '__esModule', { value: !0 });
  wl.diffSentences = wJ;
  wl.sentenceDiff = void 0;
  var bJ = vJ(Or());
  function vJ(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var ew = new bJ.default();
  wl.sentenceDiff = ew;
  ew.tokenize = function (t) {
    return t.split(/(\S.+?[.!?])(?=\s+|$)/);
  };
  function wJ(t, e, i) {
    return ew.diff(t, e, i);
  }
});
var tF = P((El) => {
  'use strict';
  Object.defineProperty(El, '__esModule', { value: !0 });
  El.diffCss = SJ;
  El.cssDiff = void 0;
  var EJ = _J(Or());
  function _J(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var tw = new EJ.default();
  El.cssDiff = tw;
  tw.tokenize = function (t) {
    return t.split(/([{}:;,]|\s+)/);
  };
  function SJ(t, e, i) {
    return tw.diff(t, e, i);
  }
});
var nF = P((gc) => {
  'use strict';
  Object.defineProperty(gc, '__esModule', { value: !0 });
  gc.diffJson = OJ;
  gc.canonicalize = Sh;
  gc.jsonDiff = void 0;
  var iF = RJ(Or()),
    CJ = Eh();
  function RJ(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function _h(t) {
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (_h = function (i) {
            return typeof i;
          })
        : (_h = function (i) {
            return i && typeof Symbol == 'function' && i.constructor === Symbol && i !== Symbol.prototype
              ? 'symbol'
              : typeof i;
          }),
      _h(t)
    );
  }
  var TJ = Object.prototype.toString,
    No = new iF.default();
  gc.jsonDiff = No;
  No.useLongestToken = !0;
  No.tokenize = CJ.lineDiff.tokenize;
  No.castInput = function (t) {
    var e = this.options,
      i = e.undefinedReplacement,
      n = e.stringifyReplacer,
      r =
        n === void 0
          ? function (s, o) {
              return typeof o > 'u' ? i : o;
            }
          : n;
    return typeof t == 'string' ? t : JSON.stringify(Sh(t, null, null, r), r, '  ');
  };
  No.equals = function (t, e) {
    return iF.default.prototype.equals.call(No, t.replace(/,([\r\n])/g, '$1'), e.replace(/,([\r\n])/g, '$1'));
  };
  function OJ(t, e, i) {
    return No.diff(t, e, i);
  }
  function Sh(t, e, i, n, r) {
    (e = e || []), (i = i || []), n && (t = n(r, t));
    var s;
    for (s = 0; s < e.length; s += 1) if (e[s] === t) return i[s];
    var o;
    if (TJ.call(t) === '[object Array]') {
      for (e.push(t), o = new Array(t.length), i.push(o), s = 0; s < t.length; s += 1) o[s] = Sh(t[s], e, i, n, r);
      return e.pop(), i.pop(), o;
    }
    if ((t && t.toJSON && (t = t.toJSON()), _h(t) === 'object' && t !== null)) {
      e.push(t), (o = {}), i.push(o);
      var c = [],
        u;
      for (u in t) t.hasOwnProperty(u) && c.push(u);
      for (c.sort(), s = 0; s < c.length; s += 1) (u = c[s]), (o[u] = Sh(t[u], e, i, n, u));
      e.pop(), i.pop();
    } else o = t;
    return o;
  }
});
var rF = P((Sl) => {
  'use strict';
  Object.defineProperty(Sl, '__esModule', { value: !0 });
  Sl.diffArrays = IJ;
  Sl.arrayDiff = void 0;
  var kJ = AJ(Or());
  function AJ(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var _l = new kJ.default();
  Sl.arrayDiff = _l;
  _l.tokenize = function (t) {
    return t.slice();
  };
  _l.join = _l.removeEmpty = function (t) {
    return t;
  };
  function IJ(t, e, i) {
    return _l.diff(t, e, i);
  }
});
var Ch = P((iw) => {
  'use strict';
  Object.defineProperty(iw, '__esModule', { value: !0 });
  iw.parsePatch = NJ;
  function NJ(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      i = t.split(/\r\n|[\n\v\f\r\x85]/),
      n = t.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      r = [],
      s = 0;
    function o() {
      var l = {};
      for (r.push(l); s < i.length; ) {
        var p = i[s];
        if (/^(\-\-\-|\+\+\+|@@)\s/.test(p)) break;
        var d = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(p);
        d && (l.index = d[1]), s++;
      }
      for (c(l), c(l), l.hunks = []; s < i.length; ) {
        var x = i[s];
        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(x)) break;
        if (/^@@/.test(x)) l.hunks.push(u());
        else {
          if (x && e.strict) throw new Error('Unknown line ' + (s + 1) + ' ' + JSON.stringify(x));
          s++;
        }
      }
    }
    function c(l) {
      var p = /^(---|\+\+\+)\s+(.*)$/.exec(i[s]);
      if (p) {
        var d = p[1] === '---' ? 'old' : 'new',
          x = p[2].split('	', 2),
          b = x[0].replace(/\\\\/g, '\\');
        /^".*"$/.test(b) && (b = b.substr(1, b.length - 2)),
          (l[d + 'FileName'] = b),
          (l[d + 'Header'] = (x[1] || '').trim()),
          s++;
      }
    }
    function u() {
      for (
        var l = s,
          p = i[s++],
          d = p.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/),
          x = {
            oldStart: +d[1],
            oldLines: +d[2] || 1,
            newStart: +d[3],
            newLines: +d[4] || 1,
            lines: [],
            linedelimiters: [],
          },
          b = 0,
          g = 0;
        s < i.length &&
        !(
          i[s].indexOf('--- ') === 0 &&
          s + 2 < i.length &&
          i[s + 1].indexOf('+++ ') === 0 &&
          i[s + 2].indexOf('@@') === 0
        );
        s++
      ) {
        var y = i[s].length == 0 && s != i.length - 1 ? ' ' : i[s][0];
        if (y === '+' || y === '-' || y === ' ' || y === '\\')
          x.lines.push(i[s]),
            x.linedelimiters.push(
              n[s] ||
                `
`
            ),
            y === '+' ? b++ : y === '-' ? g++ : y === ' ' && (b++, g++);
        else break;
      }
      if ((!b && x.newLines === 1 && (x.newLines = 0), !g && x.oldLines === 1 && (x.oldLines = 0), e.strict)) {
        if (b !== x.newLines) throw new Error('Added line count did not match for hunk at line ' + (l + 1));
        if (g !== x.oldLines) throw new Error('Removed line count did not match for hunk at line ' + (l + 1));
      }
      return x;
    }
    for (; s < i.length; ) o();
    return r;
  }
});
var sF = P((nw) => {
  'use strict';
  Object.defineProperty(nw, '__esModule', { value: !0 });
  nw.default = PJ;
  function PJ(t, e, i) {
    var n = !0,
      r = !1,
      s = !1,
      o = 1;
    return function c() {
      if (n && !s) {
        if ((r ? o++ : (n = !1), t + o <= i)) return o;
        s = !0;
      }
      if (!r) return s || (n = !0), e <= t - o ? -o++ : ((r = !0), c());
    };
  }
});
var cF = P((Rh) => {
  'use strict';
  Object.defineProperty(Rh, '__esModule', { value: !0 });
  Rh.applyPatch = aF;
  Rh.applyPatches = FJ;
  var oF = Ch(),
    LJ = DJ(sF());
  function DJ(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function aF(t, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if ((typeof e == 'string' && (e = (0, oF.parsePatch)(e)), Array.isArray(e))) {
      if (e.length > 1) throw new Error('applyPatch only works with a single input.');
      e = e[0];
    }
    var n = t.split(/\r\n|[\n\v\f\r\x85]/),
      r = t.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      s = e.hunks,
      o =
        i.compareLine ||
        function (W, K, q, B) {
          return K === B;
        },
      c = 0,
      u = i.fuzzFactor || 0,
      l = 0,
      p = 0,
      d,
      x;
    function b(W, K) {
      for (var q = 0; q < W.lines.length; q++) {
        var B = W.lines[q],
          ee = B.length > 0 ? B[0] : ' ',
          xe = B.length > 0 ? B.substr(1) : B;
        if (ee === ' ' || ee === '-') {
          if (!o(K + 1, n[K], ee, xe) && (c++, c > u)) return !1;
          K++;
        }
      }
      return !0;
    }
    for (var g = 0; g < s.length; g++) {
      for (
        var y = s[g], h = n.length - y.oldLines, v = 0, C = p + y.oldStart - 1, _ = (0, LJ.default)(C, l, h);
        v !== void 0;
        v = _()
      )
        if (b(y, C + v)) {
          y.offset = p += v;
          break;
        }
      if (v === void 0) return !1;
      l = y.offset + y.oldStart + y.oldLines;
    }
    for (var m = 0, O = 0; O < s.length; O++) {
      var N = s[O],
        D = N.oldStart + N.offset + m - 1;
      (m += N.newLines - N.oldLines), D < 0 && (D = 0);
      for (var z = 0; z < N.lines.length; z++) {
        var H = N.lines[z],
          F = H.length > 0 ? H[0] : ' ',
          ne = H.length > 0 ? H.substr(1) : H,
          pe = N.linedelimiters[z];
        if (F === ' ') D++;
        else if (F === '-') n.splice(D, 1), r.splice(D, 1);
        else if (F === '+') n.splice(D, 0, ne), r.splice(D, 0, pe), D++;
        else if (F === '\\') {
          var le = N.lines[z - 1] ? N.lines[z - 1][0] : null;
          le === '+' ? (d = !0) : le === '-' && (x = !0);
        }
      }
    }
    if (d) for (; !n[n.length - 1]; ) n.pop(), r.pop();
    else
      x &&
        (n.push(''),
        r.push(`
`));
    for (var V = 0; V < n.length - 1; V++) n[V] = n[V] + r[V];
    return n.join('');
  }
  function FJ(t, e) {
    typeof t == 'string' && (t = (0, oF.parsePatch)(t));
    var i = 0;
    function n() {
      var r = t[i++];
      if (!r) return e.complete();
      e.loadFile(r, function (s, o) {
        if (s) return e.complete(s);
        var c = aF(o, r, e);
        e.patched(r, c, function (u) {
          if (u) return e.complete(u);
          n();
        });
      });
    }
    n();
  }
});
var sw = P((Cl) => {
  'use strict';
  Object.defineProperty(Cl, '__esModule', { value: !0 });
  Cl.structuredPatch = uF;
  Cl.createTwoFilesPatch = lF;
  Cl.createPatch = BJ;
  var jJ = Eh();
  function rw(t) {
    return qJ(t) || UJ(t) || MJ();
  }
  function MJ() {
    throw new TypeError('Invalid attempt to spread non-iterable instance');
  }
  function UJ(t) {
    if (Symbol.iterator in Object(t) || Object.prototype.toString.call(t) === '[object Arguments]')
      return Array.from(t);
  }
  function qJ(t) {
    if (Array.isArray(t)) {
      for (var e = 0, i = new Array(t.length); e < t.length; e++) i[e] = t[e];
      return i;
    }
  }
  function uF(t, e, i, n, r, s, o) {
    o || (o = {}), typeof o.context > 'u' && (o.context = 4);
    var c = (0, jJ.diffLines)(i, n, o);
    c.push({ value: '', lines: [] });
    function u(v) {
      return v.map(function (C) {
        return ' ' + C;
      });
    }
    for (
      var l = [],
        p = 0,
        d = 0,
        x = [],
        b = 1,
        g = 1,
        y = function (C) {
          var _ = c[C],
            m =
              _.lines ||
              _.value.replace(/\n$/, '').split(`
`);
          if (((_.lines = m), _.added || _.removed)) {
            var O;
            if (!p) {
              var N = c[C - 1];
              (p = b),
                (d = g),
                N && ((x = o.context > 0 ? u(N.lines.slice(-o.context)) : []), (p -= x.length), (d -= x.length));
            }
            (O = x).push.apply(
              O,
              rw(
                m.map(function (V) {
                  return (_.added ? '+' : '-') + V;
                })
              )
            ),
              _.added ? (g += m.length) : (b += m.length);
          } else {
            if (p)
              if (m.length <= o.context * 2 && C < c.length - 2) {
                var D;
                (D = x).push.apply(D, rw(u(m)));
              } else {
                var z,
                  H = Math.min(m.length, o.context);
                (z = x).push.apply(z, rw(u(m.slice(0, H))));
                var F = { oldStart: p, oldLines: b - p + H, newStart: d, newLines: g - d + H, lines: x };
                if (C >= c.length - 2 && m.length <= o.context) {
                  var ne = /\n$/.test(i),
                    pe = /\n$/.test(n),
                    le = m.length == 0 && x.length > F.oldLines;
                  !ne && le && x.splice(F.oldLines, 0, '\\ No newline at end of file'),
                    ((!ne && !le) || !pe) && x.push('\\ No newline at end of file');
                }
                l.push(F), (p = 0), (d = 0), (x = []);
              }
            (b += m.length), (g += m.length);
          }
        },
        h = 0;
      h < c.length;
      h++
    )
      y(h);
    return { oldFileName: t, newFileName: e, oldHeader: r, newHeader: s, hunks: l };
  }
  function lF(t, e, i, n, r, s, o) {
    var c = uF(t, e, i, n, r, s, o),
      u = [];
    t == e && u.push('Index: ' + t),
      u.push('==================================================================='),
      u.push('--- ' + c.oldFileName + (typeof c.oldHeader > 'u' ? '' : '	' + c.oldHeader)),
      u.push('+++ ' + c.newFileName + (typeof c.newHeader > 'u' ? '' : '	' + c.newHeader));
    for (var l = 0; l < c.hunks.length; l++) {
      var p = c.hunks[l];
      u.push('@@ -' + p.oldStart + ',' + p.oldLines + ' +' + p.newStart + ',' + p.newLines + ' @@'),
        u.push.apply(u, p.lines);
    }
    return (
      u.join(`
`) +
      `
`
    );
  }
  function BJ(t, e, i, n, r, s) {
    return lF(t, t, e, i, n, r, s);
  }
});
var fF = P((Th) => {
  'use strict';
  Object.defineProperty(Th, '__esModule', { value: !0 });
  Th.arrayEqual = HJ;
  Th.arrayStartsWith = pF;
  function HJ(t, e) {
    return t.length !== e.length ? !1 : pF(t, e);
  }
  function pF(t, e) {
    if (e.length > t.length) return !1;
    for (var i = 0; i < e.length; i++) if (e[i] !== t[i]) return !1;
    return !0;
  }
});
var _F = P((kh) => {
  'use strict';
  Object.defineProperty(kh, '__esModule', { value: !0 });
  kh.calcLineCount = EF;
  kh.merge = KJ;
  var GJ = sw(),
    zJ = Ch(),
    ow = fF();
  function xc(t) {
    return WJ(t) || $J(t) || VJ();
  }
  function VJ() {
    throw new TypeError('Invalid attempt to spread non-iterable instance');
  }
  function $J(t) {
    if (Symbol.iterator in Object(t) || Object.prototype.toString.call(t) === '[object Arguments]')
      return Array.from(t);
  }
  function WJ(t) {
    if (Array.isArray(t)) {
      for (var e = 0, i = new Array(t.length); e < t.length; e++) i[e] = t[e];
      return i;
    }
  }
  function EF(t) {
    var e = aw(t.lines),
      i = e.oldLines,
      n = e.newLines;
    i !== void 0 ? (t.oldLines = i) : delete t.oldLines, n !== void 0 ? (t.newLines = n) : delete t.newLines;
  }
  function KJ(t, e, i) {
    (t = dF(t, i)), (e = dF(e, i));
    var n = {};
    (t.index || e.index) && (n.index = t.index || e.index),
      (t.newFileName || e.newFileName) &&
        (hF(t)
          ? hF(e)
            ? ((n.oldFileName = Oh(n, t.oldFileName, e.oldFileName)),
              (n.newFileName = Oh(n, t.newFileName, e.newFileName)),
              (n.oldHeader = Oh(n, t.oldHeader, e.oldHeader)),
              (n.newHeader = Oh(n, t.newHeader, e.newHeader)))
            : ((n.oldFileName = t.oldFileName),
              (n.newFileName = t.newFileName),
              (n.oldHeader = t.oldHeader),
              (n.newHeader = t.newHeader))
          : ((n.oldFileName = e.oldFileName || t.oldFileName),
            (n.newFileName = e.newFileName || t.newFileName),
            (n.oldHeader = e.oldHeader || t.oldHeader),
            (n.newHeader = e.newHeader || t.newHeader))),
      (n.hunks = []);
    for (var r = 0, s = 0, o = 0, c = 0; r < t.hunks.length || s < e.hunks.length; ) {
      var u = t.hunks[r] || { oldStart: 1 / 0 },
        l = e.hunks[s] || { oldStart: 1 / 0 };
      if (mF(u, l)) n.hunks.push(gF(u, o)), r++, (c += u.newLines - u.oldLines);
      else if (mF(l, u)) n.hunks.push(gF(l, c)), s++, (o += l.newLines - l.oldLines);
      else {
        var p = {
          oldStart: Math.min(u.oldStart, l.oldStart),
          oldLines: 0,
          newStart: Math.min(u.newStart + o, l.oldStart + c),
          newLines: 0,
          lines: [],
        };
        XJ(p, u.oldStart, u.lines, l.oldStart, l.lines), s++, r++, n.hunks.push(p);
      }
    }
    return n;
  }
  function dF(t, e) {
    if (typeof t == 'string') {
      if (/^@@/m.test(t) || /^Index:/m.test(t)) return (0, zJ.parsePatch)(t)[0];
      if (!e) throw new Error('Must provide a base reference or pass in a patch');
      return (0, GJ.structuredPatch)(void 0, void 0, e, t);
    }
    return t;
  }
  function hF(t) {
    return t.newFileName && t.newFileName !== t.oldFileName;
  }
  function Oh(t, e, i) {
    return e === i ? e : ((t.conflict = !0), { mine: e, theirs: i });
  }
  function mF(t, e) {
    return t.oldStart < e.oldStart && t.oldStart + t.oldLines < e.oldStart;
  }
  function gF(t, e) {
    return {
      oldStart: t.oldStart,
      oldLines: t.oldLines,
      newStart: t.newStart + e,
      newLines: t.newLines,
      lines: t.lines,
    };
  }
  function XJ(t, e, i, n, r) {
    var s = { offset: e, lines: i, index: 0 },
      o = { offset: n, lines: r, index: 0 };
    for (yF(t, s, o), yF(t, o, s); s.index < s.lines.length && o.index < o.lines.length; ) {
      var c = s.lines[s.index],
        u = o.lines[o.index];
      if ((c[0] === '-' || c[0] === '+') && (u[0] === '-' || u[0] === '+')) YJ(t, s, o);
      else if (c[0] === '+' && u[0] === ' ') {
        var l;
        (l = t.lines).push.apply(l, xc(Po(s)));
      } else if (u[0] === '+' && c[0] === ' ') {
        var p;
        (p = t.lines).push.apply(p, xc(Po(o)));
      } else
        c[0] === '-' && u[0] === ' '
          ? xF(t, s, o)
          : u[0] === '-' && c[0] === ' '
          ? xF(t, o, s, !0)
          : c === u
          ? (t.lines.push(c), s.index++, o.index++)
          : cw(t, Po(s), Po(o));
    }
    bF(t, s), bF(t, o), EF(t);
  }
  function YJ(t, e, i) {
    var n = Po(e),
      r = Po(i);
    if (vF(n) && vF(r)) {
      if ((0, ow.arrayStartsWith)(n, r) && wF(i, n, n.length - r.length)) {
        var s;
        (s = t.lines).push.apply(s, xc(n));
        return;
      } else if ((0, ow.arrayStartsWith)(r, n) && wF(e, r, r.length - n.length)) {
        var o;
        (o = t.lines).push.apply(o, xc(r));
        return;
      }
    } else if ((0, ow.arrayEqual)(n, r)) {
      var c;
      (c = t.lines).push.apply(c, xc(n));
      return;
    }
    cw(t, n, r);
  }
  function xF(t, e, i, n) {
    var r = Po(e),
      s = JJ(i, r);
    if (s.merged) {
      var o;
      (o = t.lines).push.apply(o, xc(s.merged));
    } else cw(t, n ? s : r, n ? r : s);
  }
  function cw(t, e, i) {
    (t.conflict = !0), t.lines.push({ conflict: !0, mine: e, theirs: i });
  }
  function yF(t, e, i) {
    for (; e.offset < i.offset && e.index < e.lines.length; ) {
      var n = e.lines[e.index++];
      t.lines.push(n), e.offset++;
    }
  }
  function bF(t, e) {
    for (; e.index < e.lines.length; ) {
      var i = e.lines[e.index++];
      t.lines.push(i);
    }
  }
  function Po(t) {
    for (var e = [], i = t.lines[t.index][0]; t.index < t.lines.length; ) {
      var n = t.lines[t.index];
      if ((i === '-' && n[0] === '+' && (i = '+'), i === n[0])) e.push(n), t.index++;
      else break;
    }
    return e;
  }
  function JJ(t, e) {
    for (var i = [], n = [], r = 0, s = !1, o = !1; r < e.length && t.index < t.lines.length; ) {
      var c = t.lines[t.index],
        u = e[r];
      if (u[0] === '+') break;
      if (((s = s || c[0] !== ' '), n.push(u), r++, c[0] === '+'))
        for (o = !0; c[0] === '+'; ) i.push(c), (c = t.lines[++t.index]);
      u.substr(1) === c.substr(1) ? (i.push(c), t.index++) : (o = !0);
    }
    if (((e[r] || '')[0] === '+' && s && (o = !0), o)) return i;
    for (; r < e.length; ) n.push(e[r++]);
    return { merged: n, changes: i };
  }
  function vF(t) {
    return t.reduce(function (e, i) {
      return e && i[0] === '-';
    }, !0);
  }
  function wF(t, e, i) {
    for (var n = 0; n < i; n++) {
      var r = e[e.length - i + n].substr(1);
      if (t.lines[t.index + n] !== ' ' + r) return !1;
    }
    return (t.index += i), !0;
  }
  function aw(t) {
    var e = 0,
      i = 0;
    return (
      t.forEach(function (n) {
        if (typeof n != 'string') {
          var r = aw(n.mine),
            s = aw(n.theirs);
          e !== void 0 && (r.oldLines === s.oldLines ? (e += r.oldLines) : (e = void 0)),
            i !== void 0 && (r.newLines === s.newLines ? (i += r.newLines) : (i = void 0));
        } else i !== void 0 && (n[0] === '+' || n[0] === ' ') && i++, e !== void 0 && (n[0] === '-' || n[0] === ' ') && e++;
      }),
      { oldLines: e, newLines: i }
    );
  }
});
var SF = P((uw) => {
  'use strict';
  Object.defineProperty(uw, '__esModule', { value: !0 });
  uw.convertChangesToDMP = ZJ;
  function ZJ(t) {
    for (var e = [], i, n, r = 0; r < t.length; r++)
      (i = t[r]), i.added ? (n = 1) : i.removed ? (n = -1) : (n = 0), e.push([n, i.value]);
    return e;
  }
});
var CF = P((lw) => {
  'use strict';
  Object.defineProperty(lw, '__esModule', { value: !0 });
  lw.convertChangesToXML = QJ;
  function QJ(t) {
    for (var e = [], i = 0; i < t.length; i++) {
      var n = t[i];
      n.added ? e.push('<ins>') : n.removed && e.push('<del>'),
        e.push(eZ(n.value)),
        n.added ? e.push('</ins>') : n.removed && e.push('</del>');
    }
    return e.join('');
  }
  function eZ(t) {
    var e = t;
    return (
      (e = e.replace(/&/g, '&amp;')),
      (e = e.replace(/</g, '&lt;')),
      (e = e.replace(/>/g, '&gt;')),
      (e = e.replace(/"/g, '&quot;')),
      e
    );
  }
});
var AF = P((_t) => {
  'use strict';
  Object.defineProperty(_t, '__esModule', { value: !0 });
  Object.defineProperty(_t, 'Diff', {
    enumerable: !0,
    get: function () {
      return tZ.default;
    },
  });
  Object.defineProperty(_t, 'diffChars', {
    enumerable: !0,
    get: function () {
      return iZ.diffChars;
    },
  });
  Object.defineProperty(_t, 'diffWords', {
    enumerable: !0,
    get: function () {
      return RF.diffWords;
    },
  });
  Object.defineProperty(_t, 'diffWordsWithSpace', {
    enumerable: !0,
    get: function () {
      return RF.diffWordsWithSpace;
    },
  });
  Object.defineProperty(_t, 'diffLines', {
    enumerable: !0,
    get: function () {
      return TF.diffLines;
    },
  });
  Object.defineProperty(_t, 'diffTrimmedLines', {
    enumerable: !0,
    get: function () {
      return TF.diffTrimmedLines;
    },
  });
  Object.defineProperty(_t, 'diffSentences', {
    enumerable: !0,
    get: function () {
      return nZ.diffSentences;
    },
  });
  Object.defineProperty(_t, 'diffCss', {
    enumerable: !0,
    get: function () {
      return rZ.diffCss;
    },
  });
  Object.defineProperty(_t, 'diffJson', {
    enumerable: !0,
    get: function () {
      return OF.diffJson;
    },
  });
  Object.defineProperty(_t, 'canonicalize', {
    enumerable: !0,
    get: function () {
      return OF.canonicalize;
    },
  });
  Object.defineProperty(_t, 'diffArrays', {
    enumerable: !0,
    get: function () {
      return sZ.diffArrays;
    },
  });
  Object.defineProperty(_t, 'applyPatch', {
    enumerable: !0,
    get: function () {
      return kF.applyPatch;
    },
  });
  Object.defineProperty(_t, 'applyPatches', {
    enumerable: !0,
    get: function () {
      return kF.applyPatches;
    },
  });
  Object.defineProperty(_t, 'parsePatch', {
    enumerable: !0,
    get: function () {
      return oZ.parsePatch;
    },
  });
  Object.defineProperty(_t, 'merge', {
    enumerable: !0,
    get: function () {
      return aZ.merge;
    },
  });
  Object.defineProperty(_t, 'structuredPatch', {
    enumerable: !0,
    get: function () {
      return pw.structuredPatch;
    },
  });
  Object.defineProperty(_t, 'createTwoFilesPatch', {
    enumerable: !0,
    get: function () {
      return pw.createTwoFilesPatch;
    },
  });
  Object.defineProperty(_t, 'createPatch', {
    enumerable: !0,
    get: function () {
      return pw.createPatch;
    },
  });
  Object.defineProperty(_t, 'convertChangesToDMP', {
    enumerable: !0,
    get: function () {
      return cZ.convertChangesToDMP;
    },
  });
  Object.defineProperty(_t, 'convertChangesToXML', {
    enumerable: !0,
    get: function () {
      return uZ.convertChangesToXML;
    },
  });
  var tZ = lZ(Or()),
    iZ = YD(),
    RF = QD(),
    TF = Eh(),
    nZ = eF(),
    rZ = tF(),
    OF = nF(),
    sZ = rF(),
    kF = cF(),
    oZ = Ch(),
    aZ = _F(),
    pw = sw(),
    cZ = SF(),
    uZ = CF();
  function lZ(t) {
    return t && t.__esModule ? t : { default: t };
  }
});
var DF = P((pt) => {
  'use strict';
  Object.defineProperty(pt, '__esModule', { value: !0 });
  pt.setupContext =
    pt.createEvalAwarePartialHost =
    pt.EvalState =
    pt.createRepl =
    pt.REPL_NAME =
    pt.REPL_FILENAME =
    pt.STDIN_NAME =
    pt.STDIN_FILENAME =
    pt.EVAL_NAME =
    pt.EVAL_FILENAME =
      void 0;
  var pZ = require('os'),
    fw = require('path'),
    dw = require('repl'),
    fZ = require('vm'),
    Ah = fc(),
    IF = require('fs'),
    dZ = require('console'),
    hZ = require('assert'),
    mZ = require('module'),
    hw;
  function gZ() {
    return hw === void 0 && ({ processTopLevelAwait: hw } = WD()), hw;
  }
  var mw;
  function xZ() {
    return mw === void 0 && (mw = AF()), mw.diffLines;
  }
  pt.EVAL_FILENAME = '[eval].ts';
  pt.EVAL_NAME = '[eval]';
  pt.STDIN_FILENAME = '[stdin].ts';
  pt.STDIN_NAME = '[stdin]';
  pt.REPL_FILENAME = '<repl>.ts';
  pt.REPL_NAME = '<repl>';
  function yZ(t = {}) {
    var e, i, n, r, s;
    let { ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl: o = !0 } = t,
      c = t.service,
      u,
      l,
      p = (e = t.state) !== null && e !== void 0 ? e : new Rl((0, fw.join)(process.cwd(), pt.REPL_FILENAME)),
      d = LF(p, t.composeWithEvalAwarePartialHost),
      x = (i = t.stdin) !== null && i !== void 0 ? i : process.stdin,
      b = (n = t.stdout) !== null && n !== void 0 ? n : process.stdout,
      g = (r = t.stderr) !== null && r !== void 0 ? r : process.stderr,
      y = b === process.stdout && g === process.stderr ? console : new dZ.Console(b, g),
      h = {
        state: (s = t.state) !== null && s !== void 0 ? s : new Rl((0, fw.join)(process.cwd(), pt.EVAL_FILENAME)),
        setService: v,
        evalCode: C,
        evalCodeInternal: _,
        nodeEval: m,
        evalAwarePartialHost: d,
        start: O,
        startInternal: N,
        stdin: x,
        stdout: b,
        stderr: g,
        console: y,
      };
    return h;
    function v(D) {
      (c = D),
        o &&
          c.addDiagnosticFilter({
            appliesToAllFiles: !1,
            filenamesAbsolute: [p.path],
            diagnosticsIgnored: [2393, 6133, 7027, ...(c.shouldReplAwait ? PF : [])],
          });
    }
    function C(D) {
      let z = gw({ service: c, state: p, input: D, context: l, overrideIsCompletion: !1 });
      return hZ(z.containsTopLevelAwait === !1), z.value;
    }
    function _(D) {
      let { code: z, enableTopLevelAwait: H, context: F } = D;
      return gw({ service: c, state: p, input: z, enableTopLevelAwait: H, context: F });
    }
    function m(D, z, H, F) {
      if (D === '.scope') {
        F(null);
        return;
      }
      try {
        let le = _({ code: D, enableTopLevelAwait: !0, context: z });
        le.containsTopLevelAwait
          ? (async () => {
              try {
                F(null, await le.valuePromise);
              } catch (V) {
                ne(V);
              }
            })()
          : F(null, le.value);
      } catch (le) {
        ne(le);
      }
      function ne(le) {
        var V, W;
        let K = c.options.experimentalReplAwait !== !1 && !c.shouldReplAwait;
        if (le instanceof Ah.TSError)
          if (dw.Recoverable && wZ(le)) {
            F(new dw.Recoverable(le));
            return;
          } else y.error(le), K && le.diagnosticCodes.some((q) => PF.includes(q)) && y.error(pe()), F(null);
        else {
          let q = le;
          if (
            K &&
            q instanceof SyntaxError &&
            !((V = q.message) === null || V === void 0) &&
            V.includes('await is only valid')
          )
            try {
              (q.message += `

${pe()}`),
                (q.stack =
                  (W = q.stack) === null || W === void 0
                    ? void 0
                    : W.replace(
                        /(SyntaxError:.*)/,
                        (B, ee) => `${ee}

${pe()}`
                      ));
            } catch {}
          F(q);
        }
      }
      function pe() {
        return `Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ${
          c.ts.version
        } and target ${c.ts.ScriptTarget[c.config.options.target]}.`;
      }
    }
    function O(D) {
      N({ code: D });
    }
    function N(D) {
      let { code: z, forceToBeModule: H = !0, ...F } = D ?? {};
      if (z)
        try {
          C(`${z}
`);
        } catch (V) {
          y.error(V), process.exit(1);
        }
      c == null || c.compile('', p.path);
      let ne = (0, dw.start)({
        prompt: '> ',
        input: h.stdin,
        output: h.stdout,
        terminal: b.isTTY && !parseInt(Ah.env.NODE_NO_READLINE, 10),
        eval: m,
        useGlobal: !0,
        ...F,
      });
      (u = ne), (l = ne.context);
      let pe = yw(p, '');
      function le() {
        pe(),
          xw('exports = module.exports', p.path, l),
          H &&
            (p.input += `export {};void 0;
`),
          (c != null && c.transpileOnly) ||
            (p.input += `// @ts-ignore
${mZ.builtinModules
  .filter((V) => !V.startsWith('_') && !V.includes('/') && !['console', 'module', 'process'].includes(V))
  .map((V) => `declare import ${V} = require('${V}')`)
  .join(';')}
`);
      }
      if (
        (le(),
        ne.on('reset', le),
        ne.defineCommand('type', {
          help: 'Check the type of a TypeScript identifier',
          action: function (V) {
            if (!V) {
              ne.displayPrompt();
              return;
            }
            let W = yw(p, V),
              { name: K, comment: q } = c.getTypeInfo(p.input, p.path, p.input.length);
            W(),
              K &&
                ne.outputStream.write(`${K}
`),
              q &&
                ne.outputStream.write(`${q}
`),
              ne.displayPrompt();
          },
        }),
        ne.setupHistory)
      ) {
        let V = Ah.env.TS_NODE_HISTORY || (0, fw.join)((0, pZ.homedir)(), '.ts_node_repl_history');
        ne.setupHistory(V, (W) => {
          W && (y.error(W), process.exit(1));
        });
      }
      return ne;
    }
  }
  pt.createRepl = yZ;
  var Rl = class {
    constructor(e) {
      (this.path = e), (this.input = ''), (this.output = ''), (this.version = 0), (this.lines = 0);
    }
  };
  pt.EvalState = Rl;
  function LF(t, e) {
    function i(r) {
      if (r === t.path) return t.input;
      if (e != null && e.readFile) return e.readFile(r);
      try {
        return (0, IF.readFileSync)(r, 'utf8');
      } catch {}
    }
    function n(r) {
      if (r === t.path) return !0;
      if (e != null && e.fileExists) return e.fileExists(r);
      try {
        let s = (0, IF.statSync)(r);
        return s.isFile() || s.isFIFO();
      } catch {
        return !1;
      }
    }
    return { readFile: i, fileExists: n };
  }
  pt.createEvalAwarePartialHost = LF;
  var NF = /\/\/# ?sourceMappingURL=\S+[\s\r\n]*$/;
  function gw(t) {
    let { service: e, state: i, wrappedErr: n, enableTopLevelAwait: r = !1, context: s, overrideIsCompletion: o } = t,
      { input: c } = t,
      u = !1;
    !n &&
      /^\s*{/.test(c) &&
      !/;\s*$/.test(c) &&
      ((c = `(${c.trim()})
`),
      (u = !0));
    let l = i.lines,
      p = o ?? !/\n$/.test(c),
      d = yw(i, c),
      x;
    function b(_) {
      return _.replace(/^"use strict";/, '"use strict"; void 0;');
    }
    try {
      x = e.compile(i.input, i.path, -l);
    } catch (_) {
      if ((d(), u)) {
        if (_ instanceof Ah.TSError && _.diagnosticCodes[0] === 2339) throw _;
        return gw({ ...t, wrappedErr: _ });
      }
      throw n || _;
    }
    x = b(x);
    let g = x.replace(NF, ''),
      y = i.output.replace(NF, ''),
      h = xZ()(y, g);
    p
      ? d()
      : ((i.output = x),
        (i.input = i.input.replace(/([^\n\s])([\n\s]*)$/, (_, m, O) => (m !== ';' ? `${m};${O}` : _))));
    let v = [],
      C = !1;
    for (let _ of h)
      if (_.added) {
        if (r && e.shouldReplAwait && _.value.indexOf('await') > -1) {
          let O = gZ()(
            _.value +
              `
`
          );
          if (O !== null) {
            (C = !0), v.push({ mustAwait: !0, execCommand: () => xw(O, i.path, s) });
            continue;
          }
        }
        v.push({ execCommand: () => xw(_.value, i.path, s) });
      }
    return C
      ? {
          containsTopLevelAwait: C,
          valuePromise: (async () => {
            let _;
            for (let m of v) {
              let O = m.execCommand();
              _ = m.mustAwait ? await O : O;
            }
            return _;
          })(),
        }
      : { containsTopLevelAwait: !1, value: v.reduce((_, m) => m.execCommand(), void 0) };
  }
  function xw(t, e, i) {
    let n = new fZ.Script(t, { filename: e });
    return i === void 0 || i === global ? n.runInThisContext() : n.runInContext(i);
  }
  function yw(t, e) {
    let i = t.input,
      n = t.version,
      r = t.output,
      s = t.lines;
    return (
      (t.input += e),
      (t.lines += bZ(e)),
      t.version++,
      function () {
        (t.input = i), (t.output = r), (t.version = n), (t.lines = s);
      }
    );
  }
  function bZ(t) {
    let e = 0;
    for (let i of t)
      i ===
        `
` && e++;
    return e;
  }
  var vZ = new Map([
      [1003, null],
      [1005, null],
      [1109, null],
      [1126, null],
      [1136, new Set([1005])],
      [1160, null],
      [1161, null],
      [2355, null],
      [2391, null],
      [7010, new Set([1005])],
    ]),
    PF = [1375, 1378, 1431, 1432];
  function wZ(t) {
    return t.diagnosticCodes.every((e) => {
      let i = vZ.get(e);
      return i === null || (i && t.diagnosticCodes.some((n) => i.has(n)));
    });
  }
  function EZ(t, e, i) {
    i && ((t.__dirname = '.'), (t.__filename = `[${i}]`)),
      (t.module = e),
      (t.exports = e.exports),
      (t.require = e.require.bind(e));
  }
  pt.setupContext = EZ;
});
var FF = P((Bpe, _Z) => {
  _Z.exports = {
    name: 'ts-node',
    version: '10.9.1',
    description: 'TypeScript execution environment and REPL for node.js, with source map support',
    main: 'dist/index.js',
    exports: {
      '.': './dist/index.js',
      './package': './package.json',
      './package.json': './package.json',
      './dist/bin': './dist/bin.js',
      './dist/bin.js': './dist/bin.js',
      './dist/bin-transpile': './dist/bin-transpile.js',
      './dist/bin-transpile.js': './dist/bin-transpile.js',
      './dist/bin-script': './dist/bin-script.js',
      './dist/bin-script.js': './dist/bin-script.js',
      './dist/bin-cwd': './dist/bin-cwd.js',
      './dist/bin-cwd.js': './dist/bin-cwd.js',
      './dist/bin-esm': './dist/bin-esm.js',
      './dist/bin-esm.js': './dist/bin-esm.js',
      './register': './register/index.js',
      './register/files': './register/files.js',
      './register/transpile-only': './register/transpile-only.js',
      './register/type-check': './register/type-check.js',
      './esm': './esm.mjs',
      './esm.mjs': './esm.mjs',
      './esm/transpile-only': './esm/transpile-only.mjs',
      './esm/transpile-only.mjs': './esm/transpile-only.mjs',
      './child-loader.mjs': './child-loader.mjs',
      './transpilers/swc': './transpilers/swc.js',
      './transpilers/swc-experimental': './transpilers/swc-experimental.js',
      './node10/tsconfig.json': './node10/tsconfig.json',
      './node12/tsconfig.json': './node12/tsconfig.json',
      './node14/tsconfig.json': './node14/tsconfig.json',
      './node16/tsconfig.json': './node16/tsconfig.json',
    },
    types: 'dist/index.d.ts',
    bin: {
      'ts-node': 'dist/bin.js',
      'ts-node-cwd': 'dist/bin-cwd.js',
      'ts-node-esm': 'dist/bin-esm.js',
      'ts-node-script': 'dist/bin-script.js',
      'ts-node-transpile-only': 'dist/bin-transpile.js',
      'ts-script': 'dist/bin-script-deprecated.js',
    },
    files: [
      '/transpilers/',
      '/dist/',
      '!/dist/test',
      '/dist-raw/NODE-LICENSE.md',
      '/dist-raw/**.js',
      '/register/',
      '/esm/',
      '/esm.mjs',
      '/child-loader.mjs',
      '/LICENSE',
      '/tsconfig.schema.json',
      '/tsconfig.schemastore-schema.json',
      '/node10/',
      '/node12/',
      '/node14/',
      '/node16/',
    ],
    scripts: {
      lint: 'dprint check',
      'lint-fix': 'dprint fmt',
      clean:
        'rimraf temp dist tsconfig.schema.json tsconfig.schemastore-schema.json tsconfig.tsbuildinfo tests/ts-node-packed.tgz tests/node_modules tests/tmp',
      rebuild: 'npm run clean && npm run build',
      build: 'npm run build-nopack && npm run build-pack',
      'build-nopack': 'npm run build-tsc && npm run build-configSchema',
      'build-tsc': 'tsc -b ./tsconfig.build-dist.json',
      'build-configSchema':
        'typescript-json-schema --topRef --refs --validationKeywords allOf --out tsconfig.schema.json tsconfig.build-schema.json TsConfigSchema && node --require ./register ./scripts/create-merged-schema',
      'build-pack': 'node ./scripts/build-pack.js',
      'test-spec': 'ava',
      'test-cov': 'nyc ava',
      test: 'npm run build && npm run lint && npm run test-cov --',
      'test-local': 'npm run lint-fix && npm run build-tsc && npm run build-pack && npm run test-spec --',
      'pre-debug': 'npm run build-tsc && npm run build-pack',
      'coverage-report': 'nyc report --reporter=lcov',
      prepare: 'npm run clean && npm run build-nopack',
      'api-extractor': 'api-extractor run --local --verbose',
      'esm-usage-example':
        'npm run build-tsc && cd esm-usage-example && node --experimental-specifier-resolution node --loader ../esm.mjs ./index',
      'esm-usage-example2':
        'npm run build-tsc && cd tests && TS_NODE_PROJECT=./module-types/override-to-cjs/tsconfig.json node --loader ../esm.mjs ./module-types/override-to-cjs/test.cjs',
    },
    repository: { type: 'git', url: 'git://github.com/TypeStrong/ts-node.git' },
    keywords: ['typescript', 'node', 'runtime', 'environment', 'ts', 'compiler'],
    author: { name: 'Blake Embrey', email: 'hello@blakeembrey.com', url: 'http://blakeembrey.me' },
    contributors: [{ name: 'Andrew Bradley', email: 'cspotcode@gmail.com', url: 'https://github.com/cspotcode' }],
    license: 'MIT',
    bugs: { url: 'https://github.com/TypeStrong/ts-node/issues' },
    homepage: 'https://typestrong.org/ts-node',
    devDependencies: {
      '@microsoft/api-extractor': '^7.19.4',
      '@swc/core': '>=1.2.205',
      '@swc/wasm': '>=1.2.205',
      '@types/diff': '^4.0.2',
      '@types/lodash': '^4.14.151',
      '@types/node': '13.13.5',
      '@types/proper-lockfile': '^4.1.2',
      '@types/proxyquire': '^1.3.28',
      '@types/react': '^16.14.19',
      '@types/rimraf': '^3.0.0',
      '@types/semver': '^7.1.0',
      '@yarnpkg/fslib': '^2.4.0',
      ava: '^3.15.0',
      axios: '^0.21.1',
      dprint: '^0.25.0',
      expect: '^27.0.2',
      'get-stream': '^6.0.0',
      lodash: '^4.17.15',
      ntypescript: '^1.201507091536.1',
      nyc: '^15.0.1',
      outdent: '^0.8.0',
      'proper-lockfile': '^4.1.2',
      proxyquire: '^2.0.0',
      react: '^16.14.0',
      rimraf: '^3.0.0',
      semver: '^7.1.3',
      throat: '^6.0.1',
      typedoc: '^0.22.10',
      typescript: '4.7.4',
      'typescript-json-schema': '^0.53.0',
      'util.promisify': '^1.0.1',
    },
    peerDependencies: { '@swc/core': '>=1.2.50', '@swc/wasm': '>=1.2.50', '@types/node': '*', typescript: '>=2.7' },
    peerDependenciesMeta: { '@swc/core': { optional: !0 }, '@swc/wasm': { optional: !0 } },
    dependencies: {
      '@cspotcode/source-map-support': '^0.8.0',
      '@tsconfig/node10': '^1.0.7',
      '@tsconfig/node12': '^1.0.7',
      '@tsconfig/node14': '^1.0.0',
      '@tsconfig/node16': '^1.0.2',
      acorn: '^8.4.1',
      'acorn-walk': '^8.1.1',
      arg: '^4.1.0',
      'create-require': '^1.1.0',
      diff: '^4.0.1',
      'make-error': '^1.1.1',
      'v8-compile-cache-lib': '^3.0.1',
      yn: '3.1.1',
    },
    prettier: { singleQuote: !0 },
    volta: { node: '18.1.0', npm: '6.14.15' },
  };
});
var MF = P((Ih, jF) => {
  'use strict';
  (function (t, e) {
    typeof Ih == 'object' && typeof jF < 'u'
      ? e(Ih)
      : typeof define == 'function' && define.amd
      ? define(['exports'], e)
      : ((t = typeof globalThis < 'u' ? globalThis : t || self), e((t.sourcemapCodec = {})));
  })(Ih, function (t) {
    'use strict';
    let n = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
      r = new Uint8Array(64),
      s = new Uint8Array(128);
    for (let y = 0; y < n.length; y++) {
      let h = n.charCodeAt(y);
      (r[y] = h), (s[h] = y);
    }
    let o =
      typeof TextDecoder < 'u'
        ? new TextDecoder()
        : typeof Buffer < 'u'
        ? {
            decode(y) {
              return Buffer.from(y.buffer, y.byteOffset, y.byteLength).toString();
            },
          }
        : {
            decode(y) {
              let h = '';
              for (let v = 0; v < y.length; v++) h += String.fromCharCode(y[v]);
              return h;
            },
          };
    function c(y) {
      let h = new Int32Array(5),
        v = [],
        C = 0;
      do {
        let _ = u(y, C),
          m = [],
          O = !0,
          N = 0;
        h[0] = 0;
        for (let D = C; D < _; D++) {
          let z;
          D = l(y, D, h, 0);
          let H = h[0];
          H < N && (O = !1),
            (N = H),
            p(y, D, _)
              ? ((D = l(y, D, h, 1)),
                (D = l(y, D, h, 2)),
                (D = l(y, D, h, 3)),
                p(y, D, _) ? ((D = l(y, D, h, 4)), (z = [H, h[1], h[2], h[3], h[4]])) : (z = [H, h[1], h[2], h[3]]))
              : (z = [H]),
            m.push(z);
        }
        O || d(m), v.push(m), (C = _ + 1);
      } while (C <= y.length);
      return v;
    }
    function u(y, h) {
      let v = y.indexOf(';', h);
      return v === -1 ? y.length : v;
    }
    function l(y, h, v, C) {
      let _ = 0,
        m = 0,
        O = 0;
      do {
        let D = y.charCodeAt(h++);
        (O = s[D]), (_ |= (O & 31) << m), (m += 5);
      } while (O & 32);
      let N = _ & 1;
      return (_ >>>= 1), N && (_ = -2147483648 | -_), (v[C] += _), h;
    }
    function p(y, h, v) {
      return h >= v ? !1 : y.charCodeAt(h) !== 44;
    }
    function d(y) {
      y.sort(x);
    }
    function x(y, h) {
      return y[0] - h[0];
    }
    function b(y) {
      let h = new Int32Array(5),
        v = 1024 * 16,
        C = v - 36,
        _ = new Uint8Array(v),
        m = _.subarray(0, C),
        O = 0,
        N = '';
      for (let D = 0; D < y.length; D++) {
        let z = y[D];
        if ((D > 0 && (O === v && ((N += o.decode(_)), (O = 0)), (_[O++] = 59)), z.length !== 0)) {
          h[0] = 0;
          for (let H = 0; H < z.length; H++) {
            let F = z[H];
            O > C && ((N += o.decode(m)), _.copyWithin(0, C, O), (O -= C)),
              H > 0 && (_[O++] = 44),
              (O = g(_, O, h, F, 0)),
              F.length !== 1 &&
                ((O = g(_, O, h, F, 1)),
                (O = g(_, O, h, F, 2)),
                (O = g(_, O, h, F, 3)),
                F.length !== 4 && (O = g(_, O, h, F, 4)));
          }
        }
      }
      return N + o.decode(_.subarray(0, O));
    }
    function g(y, h, v, C, _) {
      let m = C[_],
        O = m - v[_];
      (v[_] = m), (O = O < 0 ? (-O << 1) | 1 : O << 1);
      do {
        let N = O & 31;
        (O >>>= 5), O > 0 && (N |= 32), (y[h++] = r[N]);
      } while (O > 0);
      return h;
    }
    (t.decode = c), (t.encode = b), Object.defineProperty(t, '__esModule', { value: !0 });
  });
});
var UF = P((bw, vw) => {
  'use strict';
  (function (t, e) {
    typeof bw == 'object' && typeof vw < 'u'
      ? (vw.exports = e())
      : typeof define == 'function' && define.amd
      ? define(e)
      : ((t = typeof globalThis < 'u' ? globalThis : t || self), (t.resolveURI = e()));
  })(bw, function () {
    'use strict';
    let t = /^[\w+.-]+:\/\//,
      e = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,
      i = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var n;
    (function (v) {
      (v[(v.Empty = 1)] = 'Empty'),
        (v[(v.Hash = 2)] = 'Hash'),
        (v[(v.Query = 3)] = 'Query'),
        (v[(v.RelativePath = 4)] = 'RelativePath'),
        (v[(v.AbsolutePath = 5)] = 'AbsolutePath'),
        (v[(v.SchemeRelative = 6)] = 'SchemeRelative'),
        (v[(v.Absolute = 7)] = 'Absolute');
    })(n || (n = {}));
    function r(v) {
      return t.test(v);
    }
    function s(v) {
      return v.startsWith('//');
    }
    function o(v) {
      return v.startsWith('/');
    }
    function c(v) {
      return v.startsWith('file:');
    }
    function u(v) {
      return /^[.?#]/.test(v);
    }
    function l(v) {
      let C = e.exec(v);
      return d(C[1], C[2] || '', C[3], C[4] || '', C[5] || '/', C[6] || '', C[7] || '');
    }
    function p(v) {
      let C = i.exec(v),
        _ = C[2];
      return d('file:', '', C[1] || '', '', o(_) ? _ : '/' + _, C[3] || '', C[4] || '');
    }
    function d(v, C, _, m, O, N, D) {
      return { scheme: v, user: C, host: _, port: m, path: O, query: N, hash: D, type: n.Absolute };
    }
    function x(v) {
      if (s(v)) {
        let _ = l('http:' + v);
        return (_.scheme = ''), (_.type = n.SchemeRelative), _;
      }
      if (o(v)) {
        let _ = l('http://foo.com' + v);
        return (_.scheme = ''), (_.host = ''), (_.type = n.AbsolutePath), _;
      }
      if (c(v)) return p(v);
      if (r(v)) return l(v);
      let C = l('http://foo.com/' + v);
      return (
        (C.scheme = ''),
        (C.host = ''),
        (C.type = v ? (v.startsWith('?') ? n.Query : v.startsWith('#') ? n.Hash : n.RelativePath) : n.Empty),
        C
      );
    }
    function b(v) {
      if (v.endsWith('/..')) return v;
      let C = v.lastIndexOf('/');
      return v.slice(0, C + 1);
    }
    function g(v, C) {
      y(C, C.type), v.path === '/' ? (v.path = C.path) : (v.path = b(C.path) + v.path);
    }
    function y(v, C) {
      let _ = C <= n.RelativePath,
        m = v.path.split('/'),
        O = 1,
        N = 0,
        D = !1;
      for (let H = 1; H < m.length; H++) {
        let F = m[H];
        if (!F) {
          D = !0;
          continue;
        }
        if (((D = !1), F !== '.')) {
          if (F === '..') {
            N ? ((D = !0), N--, O--) : _ && (m[O++] = F);
            continue;
          }
          (m[O++] = F), N++;
        }
      }
      let z = '';
      for (let H = 1; H < O; H++) z += '/' + m[H];
      (!z || (D && !z.endsWith('/..'))) && (z += '/'), (v.path = z);
    }
    function h(v, C) {
      if (!v && !C) return '';
      let _ = x(v),
        m = _.type;
      if (C && m !== n.Absolute) {
        let N = x(C),
          D = N.type;
        switch (m) {
          case n.Empty:
            _.hash = N.hash;
          case n.Hash:
            _.query = N.query;
          case n.Query:
          case n.RelativePath:
            g(_, N);
          case n.AbsolutePath:
            (_.user = N.user), (_.host = N.host), (_.port = N.port);
          case n.SchemeRelative:
            _.scheme = N.scheme;
        }
        D > m && (m = D);
      }
      y(_, m);
      let O = _.query + _.hash;
      switch (m) {
        case n.Hash:
        case n.Query:
          return O;
        case n.RelativePath: {
          let N = _.path.slice(1);
          return N ? (u(C || v) && !u(N) ? './' + N + O : N + O) : O || '.';
        }
        case n.AbsolutePath:
          return _.path + O;
        default:
          return _.scheme + '//' + _.user + _.host + _.port + _.path + O;
      }
    }
    return h;
  });
});
var BF = P((Nh, qF) => {
  'use strict';
  (function (t, e) {
    typeof Nh == 'object' && typeof qF < 'u'
      ? e(Nh, MF(), UF())
      : typeof define == 'function' && define.amd
      ? define(['exports', '@jridgewell/sourcemap-codec', '@jridgewell/resolve-uri'], e)
      : ((t = typeof globalThis < 'u' ? globalThis : t || self),
        e((t.traceMapping = {}), t.sourcemapCodec, t.resolveURI));
  })(Nh, function (t, e, i) {
    'use strict';
    function n(I) {
      return I && typeof I == 'object' && 'default' in I ? I : { default: I };
    }
    var r = n(i);
    function s(I, X) {
      return X && !X.endsWith('/') && (X += '/'), r.default(I, X);
    }
    function o(I) {
      if (!I) return '';
      let X = I.lastIndexOf('/');
      return I.slice(0, X + 1);
    }
    let c = 0,
      u = 1,
      l = 2,
      p = 3,
      d = 4,
      x = 1,
      b = 2;
    function g(I, X) {
      let Q = y(I, 0);
      if (Q === I.length) return I;
      X || (I = I.slice());
      for (let ae = Q; ae < I.length; ae = y(I, ae + 1)) I[ae] = v(I[ae], X);
      return I;
    }
    function y(I, X) {
      for (let Q = X; Q < I.length; Q++) if (!h(I[Q])) return Q;
      return I.length;
    }
    function h(I) {
      for (let X = 1; X < I.length; X++) if (I[X][c] < I[X - 1][c]) return !1;
      return !0;
    }
    function v(I, X) {
      return X || (I = I.slice()), I.sort(C);
    }
    function C(I, X) {
      return I[c] - X[c];
    }
    let _ = !1;
    function m(I, X, Q, ae) {
      for (; Q <= ae; ) {
        let ce = Q + ((ae - Q) >> 1),
          ye = I[ce][c] - X;
        if (ye === 0) return (_ = !0), ce;
        ye < 0 ? (Q = ce + 1) : (ae = ce - 1);
      }
      return (_ = !1), Q - 1;
    }
    function O(I, X, Q) {
      for (let ae = Q + 1; ae < I.length && I[ae][c] === X; ae++, Q++);
      return Q;
    }
    function N(I, X, Q) {
      for (let ae = Q - 1; ae >= 0 && I[ae][c] === X; ae--, Q--);
      return Q;
    }
    function D() {
      return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
    }
    function z(I, X, Q, ae) {
      let { lastKey: ce, lastNeedle: ye, lastIndex: ve } = Q,
        Ce = 0,
        Oe = I.length - 1;
      if (ae === ce) {
        if (X === ye) return (_ = ve !== -1 && I[ve][c] === X), ve;
        X >= ye ? (Ce = ve === -1 ? 0 : ve) : (Oe = ve);
      }
      return (Q.lastKey = ae), (Q.lastNeedle = X), (Q.lastIndex = m(I, X, Ce, Oe));
    }
    function H(I, X) {
      let Q = X.map(ne);
      for (let ae = 0; ae < I.length; ae++) {
        let ce = I[ae];
        for (let ye = 0; ye < ce.length; ye++) {
          let ve = ce[ye];
          if (ve.length === 1) continue;
          let Ce = ve[u],
            Oe = ve[l],
            ke = ve[p],
            ze = Q[Ce],
            R = ze[Oe] || (ze[Oe] = []),
            w = X[Ce],
            A = O(R, ke, z(R, ke, w, Oe));
          F(R, (w.lastIndex = A + 1), [ke, ae, ve[c]]);
        }
      }
      return Q;
    }
    function F(I, X, Q) {
      for (let ae = I.length; ae > X; ae--) I[ae] = I[ae - 1];
      I[X] = Q;
    }
    function ne() {
      return { __proto__: null };
    }
    let pe = function (I, X) {
      let Q = typeof I == 'string' ? JSON.parse(I) : I;
      if (!('sections' in Q)) return new Z(Q, X);
      let ae = [],
        ce = [],
        ye = [],
        ve = [],
        { sections: Ce } = Q,
        Oe = 0;
      for (; Oe < Ce.length - 1; Oe++) {
        let ze = Ce[Oe + 1].offset;
        le(Ce[Oe], X, ae, ce, ye, ve, ze.line, ze.column);
      }
      Ce.length > 0 && le(Ce[Oe], X, ae, ce, ye, ve, 1 / 0, 1 / 0);
      let ke = { version: 3, file: Q.file, names: ve, sources: ce, sourcesContent: ye, mappings: ae };
      return t.presortedDecodedMap(ke);
    };
    function le(I, X, Q, ae, ce, ye, ve, Ce) {
      let Oe = pe(I.map, X),
        { line: ke, column: ze } = I.offset,
        R = ae.length,
        w = ye.length,
        A = t.decodedMappings(Oe),
        { resolvedSources: k } = Oe;
      V(ae, k), V(ce, Oe.sourcesContent || W(k.length)), V(ye, Oe.names);
      for (let j = Q.length; j <= ke; j++) Q.push([]);
      let S = ve - ke,
        M = Math.min(A.length, S + 1);
      for (let j = 0; j < M; j++) {
        let U = A[j],
          re = j === 0 ? Q[ke] : (Q[ke + j] = []),
          se = j === 0 ? ze : 0;
        for (let fe = 0; fe < U.length; fe++) {
          let De = U[fe],
            Ne = se + De[c];
          if (j === S && Ne >= Ce) break;
          if (De.length === 1) {
            re.push([Ne]);
            continue;
          }
          let me = R + De[u],
            _e = De[l],
            Me = De[p];
          if (De.length === 4) {
            re.push([Ne, me, _e, Me]);
            continue;
          }
          re.push([Ne, me, _e, Me, w + De[d]]);
        }
      }
    }
    function V(I, X) {
      for (let Q = 0; Q < X.length; Q++) I.push(X[Q]);
    }
    function W(I) {
      let X = [];
      for (let Q = 0; Q < I; Q++) X[Q] = null;
      return X;
    }
    let K = Object.freeze({ source: null, line: null, column: null, name: null }),
      q = Object.freeze({ line: null, column: null }),
      B = '`line` must be greater than 0 (lines start at line 1)',
      ee = '`column` must be greater than or equal to 0 (columns start at column 0)',
      xe = -1,
      de = 1;
    (t.encodedMappings = void 0),
      (t.decodedMappings = void 0),
      (t.traceSegment = void 0),
      (t.originalPositionFor = void 0),
      (t.generatedPositionFor = void 0),
      (t.eachMapping = void 0),
      (t.presortedDecodedMap = void 0),
      (t.decodedMap = void 0),
      (t.encodedMap = void 0);
    class Z {
      constructor(X, Q) {
        (this._decodedMemo = D()), (this._bySources = void 0), (this._bySourceMemos = void 0);
        let ae = typeof X == 'string';
        if (!ae && X.constructor === Z) return X;
        let ce = ae ? JSON.parse(X) : X,
          { version: ye, file: ve, names: Ce, sourceRoot: Oe, sources: ke, sourcesContent: ze } = ce;
        if (
          ((this.version = ye),
          (this.file = ve),
          (this.names = Ce),
          (this.sourceRoot = Oe),
          (this.sources = ke),
          (this.sourcesContent = ze),
          Oe || Q)
        ) {
          let w = s(Oe || '', o(Q));
          this.resolvedSources = ke.map((A) => s(A || '', w));
        } else this.resolvedSources = ke.map((w) => w || '');
        let { mappings: R } = ce;
        typeof R == 'string'
          ? ((this._encoded = R), (this._decoded = void 0))
          : ((this._encoded = void 0), (this._decoded = g(R, ae)));
      }
    }
    (t.encodedMappings = (I) => {
      var X;
      return (X = I._encoded) !== null && X !== void 0 ? X : (I._encoded = e.encode(I._decoded));
    }),
      (t.decodedMappings = (I) => I._decoded || (I._decoded = e.decode(I._encoded))),
      (t.traceSegment = (I, X, Q) => {
        let ae = t.decodedMappings(I);
        return X >= ae.length ? null : oe(ae[X], I._decodedMemo, X, Q, de);
      }),
      (t.originalPositionFor = (I, { line: X, column: Q, bias: ae }) => {
        if ((X--, X < 0)) throw new Error(B);
        if (Q < 0) throw new Error(ee);
        let ce = t.decodedMappings(I);
        if (X >= ce.length) return K;
        let ye = oe(ce[X], I._decodedMemo, X, Q, ae || de);
        if (ye == null || ye.length == 1) return K;
        let { names: ve, resolvedSources: Ce } = I;
        return { source: Ce[ye[u]], line: ye[l] + 1, column: ye[p], name: ye.length === 5 ? ve[ye[d]] : null };
      }),
      (t.generatedPositionFor = (I, { source: X, line: Q, column: ae, bias: ce }) => {
        if ((Q--, Q < 0)) throw new Error(B);
        if (ae < 0) throw new Error(ee);
        let { sources: ye, resolvedSources: ve } = I,
          Ce = ye.indexOf(X);
        if ((Ce === -1 && (Ce = ve.indexOf(X)), Ce === -1)) return q;
        let Oe = I._bySources || (I._bySources = H(t.decodedMappings(I), (I._bySourceMemos = ye.map(D)))),
          ke = I._bySourceMemos,
          ze = Oe[Ce][Q];
        if (ze == null) return q;
        let R = oe(ze, ke[Ce], Q, ae, ce || de);
        return R == null ? q : { line: R[x] + 1, column: R[b] };
      }),
      (t.eachMapping = (I, X) => {
        let Q = t.decodedMappings(I),
          { names: ae, resolvedSources: ce } = I;
        for (let ye = 0; ye < Q.length; ye++) {
          let ve = Q[ye];
          for (let Ce = 0; Ce < ve.length; Ce++) {
            let Oe = ve[Ce],
              ke = ye + 1,
              ze = Oe[0],
              R = null,
              w = null,
              A = null,
              k = null;
            Oe.length !== 1 && ((R = ce[Oe[1]]), (w = Oe[2] + 1), (A = Oe[3])),
              Oe.length === 5 && (k = ae[Oe[4]]),
              X({ generatedLine: ke, generatedColumn: ze, source: R, originalLine: w, originalColumn: A, name: k });
          }
        }
      }),
      (t.presortedDecodedMap = (I, X) => {
        let Q = Object.assign({}, I);
        Q.mappings = [];
        let ae = new Z(Q, X);
        return (ae._decoded = I.mappings), ae;
      }),
      (t.decodedMap = (I) => ({
        version: 3,
        file: I.file,
        names: I.names,
        sourceRoot: I.sourceRoot,
        sources: I.sources,
        sourcesContent: I.sourcesContent,
        mappings: t.decodedMappings(I),
      })),
      (t.encodedMap = (I) => ({
        version: 3,
        file: I.file,
        names: I.names,
        sourceRoot: I.sourceRoot,
        sources: I.sources,
        sourcesContent: I.sourcesContent,
        mappings: t.encodedMappings(I),
      }));
    function oe(I, X, Q, ae, ce) {
      let ye = z(I, ae, X, Q);
      return _ ? (ye = (ce === xe ? O : N)(I, ae, ye)) : ce === xe && ye++, ye === -1 || ye === I.length ? null : I[ye];
    }
    (t.AnyMap = pe),
      (t.GREATEST_LOWER_BOUND = de),
      (t.LEAST_UPPER_BOUND = xe),
      (t.TraceMap = Z),
      Object.defineProperty(t, '__esModule', { value: !0 });
  });
});
var JF = P((Cs, Lh) => {
  'use strict';
  var { TraceMap: Hpe, originalPositionFor: SZ, AnyMap: CZ } = BF(),
    kr = require('path'),
    { fileURLToPath: Ph, pathToFileURL: Sw } = require('url'),
    RZ = require('util'),
    $n;
  try {
    ($n = require('fs')), (!$n.existsSync || !$n.readFileSync) && ($n = null);
  } catch {}
  function ww(t, e) {
    return t.require(e);
  }
  var HF = 1;
  function TZ(t) {
    var e = 'source-map-support/sharedData';
    typeof Symbol < 'u' && (e = Symbol.for(e));
    var i = this[e];
    if (
      (i ||
        ((i = { version: HF }), Object.defineProperty ? Object.defineProperty(this, e, { value: i }) : (this[e] = i)),
      HF !== i.version)
    )
      throw new Error('Multiple incompatible instances of source-map-support were loaded');
    for (var n in t) n in i || (i[n] = t[n]);
    return i;
  }
  var Re = TZ({
      errorPrepareStackTraceHook: void 0,
      processEmitHook: void 0,
      moduleResolveFilenameHook: void 0,
      onConflictingLibraryRedirectArr: [],
      emptyCacheBetweenOperations: !1,
      fileContentsCache: Object.create(null),
      sourceMapCache: Object.create(null),
      retrieveFileHandlers: [],
      retrieveMapHandlers: [],
      internalRetrieveFileHandlers: [],
      internalRetrieveMapHandlers: [],
    }),
    Tl = 'auto',
    OZ = /^data:application\/json[^,]+base64,/;
  function Cw() {
    return Tl === 'browser'
      ? !0
      : Tl === 'node'
      ? !1
      : typeof window < 'u' &&
        typeof XMLHttpRequest == 'function' &&
        !(window.require && window.module && window.process && window.process.type === 'renderer');
  }
  function kZ() {
    return typeof process == 'object' && process !== null && typeof process.on == 'function';
  }
  function Rw(t) {
    return Tw(t) ? Ph(t) : t;
  }
  function Tw(t) {
    return t.startsWith('file:');
  }
  function Lo(t) {
    return AZ.test(t);
  }
  var AZ = /^[\w+.-]+:\/\//;
  function Do(t) {
    return t.startsWith('//');
  }
  function Ol(t) {
    if (t.startsWith('node:')) return t;
    if (Tw(t)) return new URL(t).toString();
    try {
      return Sw(t).toString();
    } catch {
      return t;
    }
  }
  function IZ(t) {
    return Re.fileContentsCache[Ol(t)];
  }
  function NZ(t) {
    return Object.prototype.hasOwnProperty.call(Re.fileContentsCache, t);
  }
  function PZ(t) {
    return Re.fileContentsCache[t];
  }
  function Ow(t, e) {
    return (Re.fileContentsCache[Ol(t)] = e);
  }
  function LZ(t) {
    return Re.sourceMapCache[Ol(t)];
  }
  function Ew(t, e) {
    return (Re.sourceMapCache[Ol(t)] = e);
  }
  function DZ() {
    (Re.fileContentsCache = Object.create(null)), (Re.sourceMapCache = Object.create(null));
  }
  function zF(t, e) {
    return function (i) {
      for (var n = 0; n < t.length; n++) {
        var r = t[n](i);
        if (r) return r;
      }
      for (var n = 0; n < e.length; n++) {
        var r = e[n](i);
        if (r) return r;
      }
      return null;
    };
  }
  var VF = zF(Re.retrieveFileHandlers, Re.internalRetrieveFileHandlers);
  Re.internalRetrieveFileHandlers.push(function (t) {
    (t = t.trim()),
      /^file:/.test(t) &&
        (t = t.replace(/file:\/\/\/(\w:)?/, function (r, s) {
          return s ? '' : '/';
        }));
    let e = Ol(t);
    if (NZ(e)) return PZ(e);
    var i = '';
    try {
      if ($n) $n.existsSync(t) && (i = $n.readFileSync(t, 'utf8'));
      else {
        var n = new XMLHttpRequest();
        n.open('GET', t, !1), n.send(null), n.readyState === 4 && n.status === 200 && (i = n.responseText);
      }
    } catch {}
    return Ow(t, i);
  });
  function $F(t, e) {
    if (!t) return e;
    try {
      return Lo(t) || Do(t)
        ? Lo(e) || Do(e)
          ? new URL(e, t).toString()
          : kr.isAbsolute(e)
          ? new URL(Sw(e), t).toString()
          : new URL(e.replace(/\\/g, '/'), t).toString()
        : kr.isAbsolute(t)
        ? Tw(e)
          ? Ph(e)
          : Do(e)
          ? Ph(new URL(e, 'file://'))
          : Lo(e)
          ? e
          : kr.isAbsolute(e)
          ? kr.normalize(e)
          : kr.join(t, '..', decodeURI(e))
        : Lo(e) || Do(e)
        ? e
        : kr.join(t, '..', e);
    } catch {
      return e;
    }
  }
  function FZ(t, e) {
    try {
      if (Lo(t) || Do(t)) {
        if (Lo(e) || Do(e)) return e;
        if (kr.isAbsolute(e)) return Sw(e).toString();
      } else if (kr.isAbsolute(t) && (Lo(e) || Do(e))) return Ph(new URL(e, 'file://'));
      return e;
    } catch {
      return e;
    }
  }
  function jZ(t) {
    var e;
    if (Cw())
      try {
        var i = new XMLHttpRequest();
        i.open('GET', t, !1), i.send(null), (e = i.readyState === 4 ? i.responseText : null);
        var n = i.getResponseHeader('SourceMap') || i.getResponseHeader('X-SourceMap');
        if (n) return n;
      } catch {}
    e = VF(Rw(t));
    for (
      var r =
          /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/gm,
        s,
        o;
      (o = r.exec(e));

    )
      s = o;
    return s ? s[1] : null;
  }
  var WF = zF(Re.retrieveMapHandlers, Re.internalRetrieveMapHandlers);
  Re.internalRetrieveMapHandlers.push(function (t) {
    var e = jZ(t);
    if (!e) return null;
    var i;
    if (OZ.test(e)) {
      var n = e.slice(e.indexOf(',') + 1);
      (i = Buffer.from(n, 'base64').toString()), (e = t);
    } else (e = $F(t, e)), (i = VF(Rw(e)));
    return i ? { url: e, map: i } : null;
  });
  function kw(t) {
    var e = LZ(t.source);
    if (!e) {
      var i = WF(t.source);
      i
        ? ((e = Ew(t.source, { url: i.url, map: new CZ(i.map, i.url) })),
          (e.map.resolvedSources = e.map.sources.map((r) => $F(e.url, r))),
          e.map.sourcesContent &&
            e.map.resolvedSources.forEach(function (r, s) {
              var o = e.map.sourcesContent[s];
              o && Ow(r, o);
            }))
        : (e = Ew(t.source, { url: null, map: null }));
    }
    if (e && e.map) {
      var n = SZ(e.map, t);
      if (n.source !== null) return (n.source = FZ(t.source, n.source)), n;
    }
    return t;
  }
  function KF(t) {
    var e = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(t);
    if (e) {
      var i = kw({ source: e[2], line: +e[3], column: e[4] - 1 });
      return 'eval at ' + e[1] + ' (' + i.source + ':' + i.line + ':' + (i.column + 1) + ')';
    }
    return (e = /^eval at ([^(]+) \((.+)\)$/.exec(t)), e ? 'eval at ' + e[1] + ' (' + KF(e[2]) + ')' : t;
  }
  function MZ() {
    var t,
      e = '';
    if (this.isNative()) e = 'native';
    else {
      (t = this.getScriptNameOrSourceURL()),
        !t && this.isEval() && ((e = this.getEvalOrigin()), (e += ', ')),
        t ? (e += t) : (e += '<anonymous>');
      var i = this.getLineNumber();
      if (i != null) {
        e += ':' + i;
        var n = this.getColumnNumber();
        n && (e += ':' + n);
      }
    }
    var r = '',
      s = this.isAsync ? this.isAsync() : !1;
    if (s) {
      r += 'async ';
      var o = this.isPromiseAll ? this.isPromiseAll() : !1,
        c = this.isPromiseAny ? this.isPromiseAny() : !1;
      if (c || o) {
        r += o ? 'Promise.all (index ' : 'Promise.any (index ';
        var u = this.getPromiseIndex();
        r += u + ')';
      }
    }
    var l = this.getFunctionName(),
      p = !0,
      d = this.isConstructor(),
      x = !(this.isToplevel() || d);
    if (x) {
      var b = this.getTypeName();
      b === '[object Object]' && (b = 'null');
      var g = this.getMethodName();
      l
        ? (b && l.indexOf(b) != 0 && (r += b + '.'),
          (r += l),
          g && l.indexOf('.' + g) != l.length - g.length - 1 && (r += ' [as ' + g + ']'))
        : (r += b + '.' + (g || '<anonymous>'));
    } else d ? (r += 'new ' + (l || '<anonymous>')) : l ? (r += l) : ((r += e), (p = !1));
    return p && (r += ' (' + e + ')'), r;
  }
  function GF(t) {
    var e = {};
    return (
      Object.getOwnPropertyNames(Object.getPrototypeOf(t)).forEach(function (i) {
        e[i] = /^(?:is|get)/.test(i)
          ? function () {
              return t[i].call(t);
            }
          : t[i];
      }),
      (e.toString = MZ),
      e
    );
  }
  function XF(t, e) {
    if ((e === void 0 && (e = { nextPosition: null, curPosition: null }), t.isNative()))
      return (e.curPosition = null), t;
    var i = t.getFileName() || t.getScriptNameOrSourceURL();
    if (i) {
      if (i.startsWith('wasm://')) return (e.curPosition = null), t;
      var n = t.getLineNumber(),
        r = t.getColumnNumber() - 1,
        s = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/,
        o = s.test(process.version) ? 0 : 62;
      n === 1 && r > o && !Cw() && !t.isEval() && (r -= o);
      var c = kw({ source: i, line: n, column: r });
      (e.curPosition = c), (t = GF(t));
      var u = t.getFunctionName;
      return (
        (t.getFunctionName = function () {
          return e.nextPosition == null ? u() : e.nextPosition.name || u();
        }),
        (t.getFileName = function () {
          return c.source;
        }),
        (t.getLineNumber = function () {
          return c.line;
        }),
        (t.getColumnNumber = function () {
          return c.column + 1;
        }),
        (t.getScriptNameOrSourceURL = function () {
          return c.source;
        }),
        t
      );
    }
    var l = t.isEval() && t.getEvalOrigin();
    return (
      l &&
        ((l = KF(l)),
        (t = GF(t)),
        (t.getEvalOrigin = function () {
          return l;
        })),
      t
    );
  }
  var _w = void 0;
  try {
    kr.resolve(123);
  } catch (t) {
    let i = Object.getOwnPropertySymbols(t).find(function (n) {
      return n.toString().indexOf('kIsNodeError') >= 0;
    });
    i && (_w = i);
  }
  var UZ = (t) => Error.prototype.toString.call(t);
  function qZ(t) {
    return e;
    function e(i, n) {
      if (!t.enabled) return t.originalValue.apply(this, arguments);
      Re.emptyCacheBetweenOperations && DZ();
      var r;
      if (_w) _w in i ? (r = `${i.name} [${i.code}]: ${i.message}`) : (r = UZ(i));
      else {
        var s = i.name || 'Error',
          o = i.message || '';
        r = o ? s + ': ' + o : s;
      }
      for (var c = { nextPosition: null, curPosition: null }, u = [], l = n.length - 1; l >= 0; l--)
        u.push(
          `
    at ` + XF(n[l], c)
        ),
          (c.nextPosition = c.curPosition);
      return (c.curPosition = c.nextPosition = null), r + u.reverse().join('');
    }
  }
  function YF(t) {
    var e = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(t.stack);
    if (e) {
      var i = e[1],
        n = +e[2],
        r = +e[3],
        s = IZ(i);
      let c = Rw(i);
      if (!s && $n && $n.existsSync(c))
        try {
          s = $n.readFileSync(c, 'utf8');
        } catch {
          s = '';
        }
      if (s) {
        var o = s.split(/(?:\r\n|\r|\n)/)[n - 1];
        if (o)
          return (
            i +
            ':' +
            n +
            `
` +
            o +
            `
` +
            new Array(r).join(' ') +
            '^'
          );
      }
    }
    return null;
  }
  function BZ(t) {
    var e = YF(t);
    process.stderr._handle && process.stderr._handle.setBlocking && process.stderr._handle.setBlocking(!0),
      e && console.error(e),
      console.error(RZ.inspect(t, { customInspect: !1, colors: process.stderr.isTTY }));
  }
  function HZ() {
    let t = process.emit;
    var e = (Re.processEmitHook = { enabled: !0, originalValue: t, installedValue: void 0 }),
      i = !1,
      n;
    process.emit = Re.processEmitHook.installedValue = function (r) {
      let s = t.apply(this, arguments);
      return (
        e.enabled &&
          (r === 'uncaughtException' && !s && ((i = !0), (n = arguments[1]), process.exit(1)),
          r === 'exit' && i && BZ(n)),
        s
      );
    };
  }
  var Gpe = Re.retrieveFileHandlers.slice(0),
    zpe = Re.retrieveMapHandlers.slice(0);
  Cs.wrapCallSite = XF;
  Cs.getErrorSource = YF;
  Cs.mapSourcePosition = kw;
  Cs.retrieveSourceMap = WF;
  Cs.install = function (t) {
    if (((t = t || {}), t.environment && ((Tl = t.environment), ['node', 'browser', 'auto'].indexOf(Tl) === -1)))
      throw new Error('environment ' + Tl + ' was unknown. Available options are {auto, browser, node}');
    var e = ww(Lh, 'module');
    let { redirectConflictingLibrary: i = !0, onConflictingLibraryRedirect: n } = t;
    if (i) {
      if (!Re.moduleResolveFilenameHook) {
        let c = e._resolveFilename,
          u = (Re.moduleResolveFilenameHook = { enabled: !0, originalValue: c, installedValue: void 0 });
        e._resolveFilename = Re.moduleResolveFilenameHook.installedValue = function (l, p, d, x) {
          if (u.enabled) {
            let b;
            if (
              (l === 'source-map-support' ? (b = './') : l === 'source-map-support/register' && (b = './register'),
              b !== void 0)
            ) {
              let g = require.resolve(b);
              for (let y of Re.onConflictingLibraryRedirectArr) y(l, p, d, x, g);
              l = g;
            }
          }
          return c.call(this, l, p, d, x);
        };
      }
      n && Re.onConflictingLibraryRedirectArr.push(n);
    }
    if (
      (t.retrieveFile &&
        (t.overrideRetrieveFile && (Re.retrieveFileHandlers.length = 0),
        Re.retrieveFileHandlers.unshift(t.retrieveFile)),
      t.retrieveSourceMap &&
        (t.overrideRetrieveSourceMap && (Re.retrieveMapHandlers.length = 0),
        Re.retrieveMapHandlers.unshift(t.retrieveSourceMap)),
      t.hookRequire && !Cw())
    ) {
      var r = e.prototype._compile;
      r.__sourceMapSupport ||
        ((e.prototype._compile = function (c, u) {
          return Ow(u, c), Ew(u, void 0), r.call(this, c, u);
        }),
        (e.prototype._compile.__sourceMapSupport = !0));
    }
    if (
      (Re.emptyCacheBetweenOperations ||
        (Re.emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in t ? t.emptyCacheBetweenOperations : !1),
      !Re.errorPrepareStackTraceHook)
    ) {
      let c = Error.prepareStackTrace;
      (Re.errorPrepareStackTraceHook = { enabled: !0, originalValue: c, installedValue: void 0 }),
        (Error.prepareStackTrace = Re.errorPrepareStackTraceHook.installedValue = qZ(Re.errorPrepareStackTraceHook));
    }
    if (!Re.processEmitHook) {
      var s = 'handleUncaughtExceptions' in t ? t.handleUncaughtExceptions : !0;
      try {
        var o = ww(Lh, 'worker_threads');
        o.isMainThread === !1 && (s = !1);
      } catch {}
      s && kZ() && HZ();
    }
  };
  Cs.uninstall = function () {
    if (
      (Re.processEmitHook &&
        ((Re.processEmitHook.enabled = !1),
        process.emit === Re.processEmitHook.installedValue && (process.emit = Re.processEmitHook.originalValue),
        (Re.processEmitHook = void 0)),
      Re.errorPrepareStackTraceHook &&
        ((Re.errorPrepareStackTraceHook.enabled = !1),
        (Error.prepareStackTrace === Re.errorPrepareStackTraceHook.installedValue ||
          typeof Re.errorPrepareStackTraceHook.originalValue != 'function') &&
          (Error.prepareStackTrace = Re.errorPrepareStackTraceHook.originalValue),
        (Re.errorPrepareStackTraceHook = void 0)),
      Re.moduleResolveFilenameHook)
    ) {
      Re.moduleResolveFilenameHook.enabled = !1;
      var t = ww(Lh, 'module');
      t._resolveFilename === Re.moduleResolveFilenameHook.installedValue &&
        (t._resolveFilename = Re.moduleResolveFilenameHook.originalValue),
        (Re.moduleResolveFilenameHook = void 0);
    }
    Re.onConflictingLibraryRedirectArr.length = 0;
  };
  Cs.resetRetrieveHandlers = function () {
    (Re.retrieveFileHandlers.length = 0), (Re.retrieveMapHandlers.length = 0);
  };
});
var o2 = P((Vpe, s2) => {
  'use strict';
  var { versionGteLt: Hh } = Vn(),
    ZF = Hh(process.versions.node, '14.13.1') || Hh(process.versions.node, '12.20.0', '13.0.0') ? 'node:' : 'nodejs:',
    {
      ArrayIsArray: Aw,
      ArrayPrototypeJoin: QF,
      ArrayPrototypeShift: GZ,
      JSONParse: zZ,
      JSONStringify: VZ,
      ObjectFreeze: $Z,
      ObjectGetOwnPropertyNames: Dh,
      ObjectPrototypeHasOwnProperty: e2,
      RegExpPrototypeTest: Iw,
      SafeMap: t2,
      SafeSet: Bh,
      StringPrototypeEndsWith: Fh,
      StringPrototypeIndexOf: Nw,
      StringPrototypeLastIndexOf: WZ,
      StringPrototypeReplace: Pw,
      StringPrototypeSlice: Ar,
      StringPrototypeSplit: i2,
      StringPrototypeStartsWith: cn,
      StringPrototypeSubstr: n2,
    } = Io(),
    KZ = require('module'),
    { NativeModule: XZ } = F0(),
    { realpathSync: YZ, statSync: r2, Stats: JZ } = require('fs'),
    { getOptionValue: yc } = ml(),
    Lw = null,
    { sep: jh, relative: ZZ } = require('path'),
    QZ = yc('--preserve-symlinks'),
    eQ = yc('--preserve-symlinks-main'),
    tQ = yc('--input-type'),
    { URL: rt, pathToFileURL: Mh, fileURLToPath: Je } = require('url'),
    {
      ERR_INPUT_TYPE_NOT_ALLOWED: iQ,
      ERR_INVALID_ARG_VALUE: nQ,
      ERR_INVALID_MODULE_SPECIFIER: Uh,
      ERR_INVALID_PACKAGE_CONFIG: Dw,
      ERR_INVALID_PACKAGE_TARGET: rQ,
      ERR_MANIFEST_DEPENDENCY_MISSING: sQ,
      ERR_MODULE_NOT_FOUND: qh,
      ERR_PACKAGE_IMPORT_NOT_DEFINED: oQ,
      ERR_PACKAGE_PATH_NOT_EXPORTED: aQ,
      ERR_UNSUPPORTED_DIR_IMPORT: cQ,
      ERR_UNSUPPORTED_ESM_URL_SCHEME: uQ,
    } = gl().codes,
    Fw = KZ,
    lQ = q0(),
    pQ = yc('--conditions'),
    jw = $Z(['node', 'import', ...pQ]),
    fQ = new Bh(jw),
    dQ = yc('--pending-deprecation');
  function hQ(t) {
    let { preferTsExts: e, tsNodeExperimentalSpecifierResolution: i, extensions: n } = t,
      r = n.experimentalSpecifierResolutionAddsIfOmitted,
      {
        legacyMainResolveAddsIfOmitted: s,
        replacementsForCjs: o,
        replacementsForJs: c,
        replacementsForMjs: u,
        replacementsForJsx: l,
      } = n,
      p = i ?? yc('--experimental-specifier-resolution'),
      d = new Bh();
    function x(w, A, k, S) {
      let M = Je(A);
      if (!dQ) {
        let j = WZ(M, '/node_modules/');
        if (j !== -1) {
          let U = Ar(M, j + 14, -13);
          try {
            let { packageSubpath: re } = ce(U);
            if (re === '.') return;
          } catch {}
        }
      }
      d.has(M + '|' + w) ||
        (d.add(M + '|' + w),
        process.emitWarning(
          `Use of deprecated folder mapping "${w}" in the ${
            k ? '"exports"' : '"imports"'
          } field module resolution of the package at ${M}${S ? ` imported from ${Je(S)}` : ''}.
Update this package.json to use a subpath pattern like "${w}*".`,
          'DeprecationWarning',
          'DEP0148'
        ));
    }
    function b(w) {
      if (w !== void 0 && w !== jw) {
        if (!Aw(w)) throw new nQ('conditions', w, 'expected an array');
        return new Bh(w);
      }
      return fQ;
    }
    let g = new t2(),
      y = new t2(),
      v = Hh(process.versions.node, '15.3.0') || Hh(process.versions.node, '14.17.0', '15.0.0') ? _ : m,
      C = new JZ();
    function _(w) {
      let A = r2(w, { throwIfNoEntry: !1 });
      return A ?? C;
    }
    function m(w) {
      try {
        return r2(w);
      } catch {
        return C;
      }
    }
    function O(w, A, k) {
      let S = y.get(w);
      if (S !== void 0) return S;
      let M = lQ.read(w).string;
      if (M === void 0) {
        let me = {
          pjsonPath: w,
          exists: !1,
          main: void 0,
          name: void 0,
          type: 'none',
          exports: void 0,
          imports: void 0,
        };
        return y.set(w, me), me;
      }
      let j;
      try {
        j = zZ(M);
      } catch (me) {
        throw new Dw(w, (k ? `"${A}" from ` : '') + Je(k || A), me.message);
      }
      let { imports: U, main: re, name: se, type: fe } = j,
        { exports: De } = j;
      (typeof U != 'object' || U === null) && (U = void 0),
        typeof re != 'string' && (re = void 0),
        typeof se != 'string' && (se = void 0),
        fe !== 'module' && fe !== 'commonjs' && (fe = 'none');
      let Ne = { pjsonPath: w, exists: !0, main: re, name: se, type: fe, exports: De, imports: U };
      return y.set(w, Ne), Ne;
    }
    function N(w) {
      let A = new rt('./package.json', w);
      for (;;) {
        let M = A.pathname;
        if (Fh(M, 'node_modules/package.json')) break;
        let j = O(Je(A), w);
        if (j.exists) return j;
        let U = A;
        if (((A = new rt('../package.json', A)), A.pathname === U.pathname)) break;
      }
      let k = Je(A),
        S = { pjsonPath: k, exists: !1, main: void 0, name: void 0, type: 'none', exports: void 0, imports: void 0 };
      return y.set(k, S), S;
    }
    function D(w) {
      return v(Je(w)).isFile();
    }
    function z(w, A, k) {
      let S;
      if (A.main !== void 0) {
        if ((S = ne(new rt(`./${A.main}`, w))) || D((S = new rt(`./${A.main}`, w)))) return S;
        for (let M of s) if (D((S = new rt(`./${A.main}${M}`, w)))) return S;
        for (let M of s) if (D((S = new rt(`./${A.main}/index${M}`, w)))) return S;
      }
      for (let M of s) if (D((S = new rt(`./index${M}`, w)))) return S;
      throw new qh(Je(new rt('.', w)), Je(k));
    }
    function H(w) {
      let A = ne(w);
      return A || (D(w) ? w : F(w));
    }
    function F(w) {
      for (let A = 0; A < r.length; A++) {
        let k = r[A],
          S = new rt(`${w.pathname}${k}`, w);
        if (D(S)) return S;
      }
    }
    function ne(w) {
      let A = w.pathname.lastIndexOf('.');
      if (A >= 0) {
        let k = w.pathname.slice(A);
        if (k === '.js' || k === '.jsx' || k === '.mjs' || k === '.cjs') {
          let S = w.pathname.slice(0, A),
            M = k === '.js' ? c : k === '.jsx' ? l : k === '.mjs' ? u : o,
            j = new rt(w.toString());
          for (let U = 0; U < M.length; U++) {
            let re = M[U];
            if (((j.pathname = `${S}${re}`), D(j))) return j;
          }
        }
      }
    }
    function pe(w) {
      return F(new rt('index', w));
    }
    let le = /%2F|%2C/i;
    function V(w, A) {
      if (Iw(le, w.pathname)) throw new Uh(w.pathname, 'must not include encoded "/" or "\\" characters', Je(A));
      if (p === 'node') {
        let j = Je(w),
          U = H(w);
        if (U !== void 0) return U;
        if (Fh(j, '/')) return pe(w) || w;
        if (((U = pe(new rt(`${w}/`))), U !== void 0)) return U;
        throw new qh(w.pathname, Je(A), 'module');
      }
      let k = ne(w) || w,
        S = Je(k),
        M = v(Fh(S, '/') ? Ar(S, -1) : S);
      if (M.isDirectory()) {
        let j = new cQ(S, Je(A));
        throw ((j.url = String(w)), j);
      } else if (!M.isFile()) throw new qh(S || w.pathname, Je(A), 'module');
      return k;
    }
    function W(w, A, k) {
      throw new oQ(w, A && Je(new rt('.', A)), Je(k));
    }
    function K(w, A, k) {
      throw new aQ(Je(new rt('.', A)), w, k && Je(k));
    }
    function q(w, A, k, S) {
      let M = `request is not a valid subpath for the "${k ? 'imports' : 'exports'}" resolution of ${Je(A)}`;
      throw new Uh(w, M, S && Je(S));
    }
    function B(w, A, k, S, M) {
      throw (
        (typeof A == 'object' && A !== null ? (A = VZ(A, null, '')) : (A = `${A}`),
        new rQ(Je(new rt('.', k)), w, A, S, M && Je(M)))
      );
    }
    let ee = /(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/,
      xe = /\*/g;
    function de(w, A, k, S, M, j, U, re) {
      if ((A !== '' && !j && w[w.length - 1] !== '/' && B(k, w, S, U, M), !cn(w, './'))) {
        if (U && !cn(w, '../') && !cn(w, '/')) {
          let Ne = !1;
          try {
            new rt(w), (Ne = !0);
          } catch {}
          if (!Ne) {
            let me = j ? Pw(w, xe, A) : w + A;
            return ye(me, S, re);
          }
        }
        B(k, w, S, U, M);
      }
      Iw(ee, Ar(w, 2)) && B(k, w, S, U, M);
      let se = new rt(w, S),
        fe = se.pathname,
        De = new rt('.', S).pathname;
      return (
        cn(fe, De) || B(k, w, S, U, M),
        A === '' ? se : (Iw(ee, A) && q(k + A, S, U, M), j ? new rt(Pw(se.href, xe, A)) : new rt(A, se))
      );
    }
    function Z(w) {
      let A = +w;
      return `${A}` !== w ? !1 : A >= 0 && A < 4294967295;
    }
    function oe(w, A, k, S, M, j, U, re) {
      if (typeof A == 'string') return de(A, k, S, w, M, j, U, re);
      if (Aw(A)) {
        if (A.length === 0) return null;
        let se;
        for (let fe = 0; fe < A.length; fe++) {
          let De = A[fe],
            Ne;
          try {
            Ne = oe(w, De, k, S, M, j, U, re);
          } catch (me) {
            if (((se = me), me.code === 'ERR_INVALID_PACKAGE_TARGET')) continue;
            throw me;
          }
          if (Ne !== void 0) {
            if (Ne === null) {
              se = null;
              continue;
            }
            return Ne;
          }
        }
        if (se == null) return se;
        throw se;
      } else if (typeof A == 'object' && A !== null) {
        let se = Dh(A);
        for (let fe = 0; fe < se.length; fe++) {
          let De = se[fe];
          if (Z(De)) throw new Dw(Je(w), M, '"exports" cannot contain numeric property keys.');
        }
        for (let fe = 0; fe < se.length; fe++) {
          let De = se[fe];
          if (De === 'default' || re.has(De)) {
            let Ne = A[De],
              me = oe(w, Ne, k, S, M, j, U, re);
            if (me === void 0) continue;
            return me;
          }
        }
        return;
      } else if (A === null) return null;
      B(S, A, w, U, M);
    }
    function I(w, A, k) {
      if (typeof w == 'string' || Aw(w)) return !0;
      if (typeof w != 'object' || w === null) return !1;
      let S = Dh(w),
        M = !1,
        j = 0;
      for (let U = 0; U < S.length; U++) {
        let re = S[U],
          se = re === '' || re[0] !== '.';
        if (j++ === 0) M = se;
        else if (M !== se)
          throw new Dw(
            Je(A),
            k,
            `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
          );
      }
      return M;
    }
    function X(w, A, k, S, M) {
      let j = k.exports;
      if ((I(j, w, S) && (j = { '.': j }), e2(j, A))) {
        let se = j[A],
          fe = oe(w, se, '', A, S, !1, !1, M);
        return fe == null && K(A, w, S), { resolved: fe, exact: !0 };
      }
      let U = '',
        re = Dh(j);
      for (let se = 0; se < re.length; se++) {
        let fe = re[se];
        ((fe[fe.length - 1] === '*' && cn(A, Ar(fe, 0, -1)) && A.length >= fe.length && fe.length > U.length) ||
          (fe[fe.length - 1] === '/' && cn(A, fe) && fe.length > U.length)) &&
          (U = fe);
      }
      if (U) {
        let se = j[U],
          fe = U[U.length - 1] === '*',
          De = n2(A, U.length - (fe ? 1 : 0)),
          Ne = oe(w, se, De, U, S, fe, !1, M);
        return Ne == null && K(A, w, S), fe || x(U, w, !0, S), { resolved: Ne, exact: fe };
      }
      K(A, w, S);
    }
    function Q(w, A, k) {
      if (w === '#' || cn(w, '#/')) {
        let j = 'is not a valid internal imports specifier name';
        throw new Uh(w, j, Je(A));
      }
      let S,
        M = N(A);
      if (M.exists) {
        S = Mh(M.pjsonPath);
        let j = M.imports;
        if (j)
          if (e2(j, w)) {
            let U = oe(S, j[w], '', w, A, !1, !0, k);
            if (U !== null) return { resolved: U, exact: !0 };
          } else {
            let U = '',
              re = Dh(j);
            for (let se = 0; se < re.length; se++) {
              let fe = re[se];
              ((fe[fe.length - 1] === '*' && cn(w, Ar(fe, 0, -1)) && w.length >= fe.length && fe.length > U.length) ||
                (fe[fe.length - 1] === '/' && cn(w, fe) && fe.length > U.length)) &&
                (U = fe);
            }
            if (U) {
              let se = j[U],
                fe = U[U.length - 1] === '*',
                De = n2(w, U.length - (fe ? 1 : 0)),
                Ne = oe(S, se, De, U, A, fe, !0, k);
              if (Ne !== null) return fe || x(U, S, !1, A), { resolved: Ne, exact: fe };
            }
          }
      }
      W(w, S, A);
    }
    function ae(w) {
      return N(w).type;
    }
    function ce(w, A) {
      let k = Nw(w, '/'),
        S = !0,
        M = !1;
      w[0] === '@' && ((M = !0), k === -1 || w.length === 0 ? (S = !1) : (k = Nw(w, '/', k + 1)));
      let j = k === -1 ? w : Ar(w, 0, k);
      for (let re = 0; re < j.length; re++)
        if (j[re] === '%' || j[re] === '\\') {
          S = !1;
          break;
        }
      if (!S) throw new Uh(w, 'is not a valid package name', Je(A));
      let U = '.' + (k === -1 ? '' : Ar(w, k));
      return { packageName: j, packageSubpath: U, isScoped: M };
    }
    function ye(w, A, k) {
      let { packageName: S, packageSubpath: M, isScoped: j } = ce(w, A),
        U = N(A);
      if (U.exists) {
        let De = Mh(U.pjsonPath);
        if (U.name === S && U.exports !== void 0 && U.exports !== null) return X(De, M, U, A, k).resolved;
      }
      let re = new rt('./node_modules/' + S + '/package.json', A),
        se = Je(re),
        fe;
      do {
        if (!v(Ar(se, 0, se.length - 13)).isDirectory()) {
          (fe = se),
            (re = new rt((j ? '../../../../node_modules/' : '../../../node_modules/') + S + '/package.json', re)),
            (se = Je(re));
          continue;
        }
        let Ne = O(se, w, A);
        return Ne.exports !== void 0 && Ne.exports !== null
          ? X(re, M, Ne, A, k).resolved
          : M === '.'
          ? z(re, Ne, A)
          : new rt(M, re);
      } while (se.length !== fe.length);
      throw new qh(S, Je(A));
    }
    function ve(w) {
      return w[0] && w[0] !== '/' && w[0] !== '.';
    }
    function Ce(w) {
      return w[0] === '.' && (w.length === 1 || w[1] === '/' || (w[1] === '.' && (w.length === 2 || w[2] === '/')));
    }
    function Oe(w) {
      return w === '' ? !1 : w[0] === '/' ? !0 : Ce(w);
    }
    function ke(w, A, k) {
      let S;
      if (Oe(w)) S = new rt(w, A);
      else if (w[0] === '#') ({ resolved: S } = Q(w, A, k));
      else
        try {
          S = new rt(w);
        } catch {
          S = ye(w, A, k);
        }
      return V(S, A);
    }
    function ze(w, A) {
      try {
        let k = Je(A),
          S = new Fw(k, null);
        S.paths = Fw._nodeModulePaths(k);
        let M = Fw._resolveFilename(w, S, !1);
        if (Ce(w)) (M = ZZ(k, M)), cn(M, `..${jh}`) || (M = `.${jh}${M}`);
        else if (ve(w)) {
          let j = i2(w, '/')[0],
            U = Nw(M, j);
          U !== -1 && (M = Ar(M, U));
        }
        return process.platform === 'win32' && (M = Pw(M, new RegExp(`\\${jh}`, 'g'), '/')), M;
      } catch {
        return !1;
      }
    }
    function R(w, A = {}, k) {
      let { parentURL: S, conditions: M } = A;
      if (S && Lw != null && Lw.manifest) {
        let se = Lw.manifest.getDependencyMapper(S);
        if (se) {
          let { resolve: fe, reaction: De } = se,
            Ne = fe(w, new Bh(M)),
            me = !0;
          if (Ne === !0) me = !1;
          else if (Ne) return { url: Ne.href };
          me && De(new sQ(S, w, QF([...M], ', ')));
        }
      }
      let j;
      try {
        if (((j = new rt(w)), j.protocol === 'data:')) return { url: w };
      } catch {}
      if (j && j.protocol === ZF) return { url: w };
      if (j && j.protocol !== 'file:' && j.protocol !== 'data:') throw new uQ(j);
      if (XZ.canBeRequiredByUsers(w)) return { url: ZF + w };
      S && cn(S, 'data:') && new rt(w, S);
      let U = S === void 0;
      if (U && ((S = Mh(`${process.cwd()}/`).href), tQ)) throw new iQ();
      M = b(M);
      let re;
      try {
        re = ke(w, S, M);
      } catch (se) {
        if (se.code === 'ERR_MODULE_NOT_FOUND' || se.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {
          cn(w, 'file://') && (w = Je(w));
          let fe = ze(w, S);
          if (fe) {
            let De = i2(
                se.stack,
                `
`
              ),
              Ne = `Did you mean to import ${fe}?`;
            (se.stack =
              GZ(De) +
              `
` +
              Ne +
              `
` +
              QF(
                De,
                `
`
              )),
              (se.message += `
${Ne}`);
          }
        }
        throw se;
      }
      if (U ? !eQ : !QZ) {
        let se = Je(re),
          fe = YZ(se, {}),
          De = re;
        (re = Mh(fe + (Fh(se, jh) ? '/' : ''))), (re.search = De.search), (re.hash = De.hash);
      }
      return { url: `${re}` };
    }
    return {
      DEFAULT_CONDITIONS: jw,
      defaultResolve: R,
      encodedSepRegEx: le,
      getPackageType: ae,
      packageExportsResolve: X,
      packageImportsResolve: Q,
    };
  }
  s2.exports = { createResolve: hQ };
});
var p2 = P(($pe, l2) => {
  'use strict';
  var { RegExpPrototypeExec: mQ, StringPrototypeStartsWith: gQ } = Io(),
    { extname: xQ } = require('path'),
    { getOptionValue: Uw } = ml(),
    [Mw, a2] = process.versions.node.split('.').map((t) => parseInt(t, 10)),
    c2 = Mw > 17 || (Mw === 17 && a2 >= 5) || (Mw === 16 && a2 >= 15) || Uw('--experimental-json-modules'),
    u2 = Uw('--experimental-wasm-modules'),
    { URL: yQ, fileURLToPath: bQ } = require('url'),
    { ERR_UNKNOWN_FILE_EXTENSION: vQ } = gl().codes,
    qw = { __proto__: null, '.cjs': 'commonjs', '.js': 'module', '.mjs': 'module' },
    Bw = {
      __proto__: null,
      '.cjs': 'commonjs',
      '.js': 'commonjs',
      '.json': 'commonjs',
      '.mjs': 'module',
      '.node': 'commonjs',
    };
  u2 && (qw['.wasm'] = Bw['.wasm'] = 'wasm');
  c2 && (qw['.json'] = Bw['.json'] = 'json');
  function wQ(t, e) {
    let i = t ?? Uw('--experimental-specifier-resolution'),
      { getPackageType: n } = e;
    function r(s, o, c) {
      if (gQ(s, 'node:')) return { format: 'builtin' };
      let u = new yQ(s);
      if (u.protocol === 'data:') {
        let [, l] = mQ(/^([^/]+\/[^;,]+)(?:[^,]*?)(;base64)?,/, u.pathname) || [null, null, null];
        return {
          format:
            {
              __proto__: null,
              'text/javascript': 'module',
              'application/json': c2 ? 'json' : null,
              'application/wasm': u2 ? 'wasm' : null,
            }[l] || null,
        };
      } else if (u.protocol === 'file:') {
        let l = xQ(u.pathname),
          p;
        if ((l === '.js' ? (p = n(u.href) === 'module' ? 'module' : 'commonjs') : (p = qw[l]), !p))
          if (i === 'node')
            process.emitWarning('The Node.js specifier resolution in ESM is experimental.', 'ExperimentalWarning'),
              (p = Bw[l]);
          else throw new vQ(l, bQ(s));
        return { format: p || null };
      }
      return { format: null };
    }
    return { defaultGetFormat: r };
  }
  l2.exports = { createGetFormat: wQ };
});
var g2 = P((Rs) => {
  'use strict';
  Object.defineProperty(Rs, '__esModule', { value: !0 });
  Rs.createEsmHooks = Rs.registerAndCreateEsmHooks = Rs.filterHooksByAPIVersion = void 0;
  var EQ = fc(),
    Ir = require('url'),
    _Q = require('path'),
    SQ = require('assert'),
    d2 = Vn(),
    CQ = require('module'),
    RQ = (0, d2.versionGteLt)(process.versions.node, '16.12.0');
  function h2(t) {
    let { getFormat: e, load: i, resolve: n, transformSource: r } = t;
    return RQ
      ? { resolve: n, load: i, getFormat: void 0, transformSource: void 0 }
      : { resolve: n, getFormat: e, transformSource: r, load: void 0 };
  }
  Rs.filterHooksByAPIVersion = h2;
  function TQ(t) {
    let e = (0, EQ.register)(t);
    return m2(e);
  }
  Rs.registerAndCreateEsmHooks = TQ;
  function m2(t) {
    t.enableExperimentalEsmLoaderInterop();
    let e = t.getNodeEsmResolver(),
      i = t.getNodeEsmGetFormat(),
      n = t.extensions,
      r = h2({ resolve: l, load: p, getFormat: d, transformSource: x });
    function s(b) {
      let { protocol: g } = b;
      return g === null || g === 'file:';
    }
    function o(b, g) {
      return g === void 0 && b.startsWith('file://');
    }
    let c = new Set(),
      u = new Set();
    async function l(b, g, y) {
      let h = async () => await y(b, g, y);
      async function v(C) {
        try {
          let _ = await C();
          return _ != null && _.url && o(b, g.parentURL) && c.add(_.url), _;
        } catch (_) {
          if (!o(b, g.parentURL)) throw _;
          try {
            let m = b;
            try {
              b.startsWith('file://') && (m = (0, Ir.fileURLToPath)(b));
            } catch {}
            let O = (0, Ir.pathToFileURL)((0, CQ.createRequire)(process.cwd()).resolve(m)).toString();
            return c.add(O), u.add(O), { url: O, format: 'commonjs' };
          } catch {
            throw _;
          }
        }
      }
      return f2(async () => {
        let C = (0, Ir.parse)(b),
          { pathname: _, protocol: m, hostname: O } = C;
        return !s(C) || (m !== null && m !== 'file:') || O ? v(h) : v(() => e.defaultResolve(b, g, y));
      });
    }
    async function p(b, g, y) {
      return f2(async () => {
        var h;
        let v = (h = g.format) !== null && h !== void 0 ? h : (await d(b, g, i.defaultGetFormat)).format,
          C;
        if (v !== 'builtin' && v !== 'commonjs') {
          let { source: _ } = await y(b, { ...g, format: v }, y);
          if (_ == null) throw new Error(`Failed to load raw source: Format was '${v}' and url was '${b}''.`);
          let m = async (N, D, z) => ({ source: N }),
            { source: O } = await x(_, { url: b, format: v }, m);
          C = O;
        }
        return { format: v, source: C };
      });
    }
    async function d(b, g, y) {
      let h = (H = b) => y(H, g, y);
      async function v(H) {
        try {
          return await H();
        } catch (F) {
          if (!c.has(b)) throw F;
          return { format: 'commonjs' };
        }
      }
      let C = (0, Ir.parse)(b);
      if (!s(C)) return v(h);
      let { pathname: _ } = C;
      SQ(_ !== null, 'ESM getFormat() hook: URL should never have null pathname');
      let m = (0, Ir.fileURLToPath)(b),
        O,
        N = (0, _Q.extname)(m),
        D = t.ignored(m),
        z = n.nodeEquivalents.get(N);
      if (z && !D) O = await v(() => h((0, Ir.format)((0, Ir.pathToFileURL)(m + z))));
      else
        try {
          O = await v(h);
        } catch (H) {
          throw (
            (H instanceof Error &&
              D &&
              n.nodeDoesNotUnderstand.includes(N) &&
              (H.message += `

Hint:
ts-node is configured to ignore this file.
If you want ts-node to handle this file, consider enabling the "skipIgnore" option or adjusting your "ignore" patterns.
https://typestrong.org/ts-node/docs/scope
`),
            H)
          );
        }
      if (!t.ignored(m) && (O.format === 'commonjs' || O.format === 'module')) {
        let { moduleType: H } = t.moduleTypeClassifier.classifyModuleByModuleTypeOverrides((0, d2.normalizeSlashes)(m));
        if (H === 'cjs') return { format: 'commonjs' };
        if (H === 'esm') return { format: 'module' };
      }
      return O;
    }
    async function x(b, g, y) {
      if (b == null) throw new Error('No source');
      let h = () => y(b, g, y),
        v = typeof b == 'string' ? b : b.toString('utf8'),
        { url: C } = g,
        _ = (0, Ir.parse)(C);
      if (!s(_)) return h();
      let m = (0, Ir.fileURLToPath)(C);
      return t.ignored(m) ? h() : { source: t.compile(v, m) };
    }
    return r;
  }
  Rs.createEsmHooks = m2;
  async function f2(t) {
    let e = await t();
    return e == null ? e : { ...e, shortCircuit: !0 };
  }
});
var fc = P((Te) => {
  'use strict';
  var Hw, Gw;
  Object.defineProperty(Te, '__esModule', { value: !0 });
  Te.createEsmHooks =
    Te.createFromPreloadedConfig =
    Te.create =
    Te.register =
    Te.TSError =
    Te.DEFAULTS =
    Te.VERSION =
    Te.debug =
    Te.INSPECT_CUSTOM =
    Te.env =
    Te.REGISTER_INSTANCE =
    Te.createRepl =
      void 0;
  var un = require('path'),
    OQ = require('module'),
    kQ = require('util'),
    AQ = require('url'),
    IQ = AL(),
    Pe = Vn(),
    y2 = lD(),
    NQ = pD(),
    x2 = fD(),
    PQ = dD(),
    LQ = FD(),
    DQ = jD(),
    FQ = MD(),
    jQ = DF();
  Object.defineProperty(Te, 'createRepl', {
    enumerable: !0,
    get: function () {
      return jQ.createRepl;
    },
  });
  var MQ = parseInt(process.versions.node.split('.')[0], 10) >= 12,
    UQ = MQ ? hh().assertScriptCanLoadAsCJSImpl : () => {};
  Te.REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');
  Te.env = process.env;
  Te.INSPECT_CUSTOM = kQ.inspect.custom || 'inspect';
  var b2 = (0, Pe.yn)(Te.env.TS_NODE_DEBUG);
  Te.debug = b2 ? (...t) => console.log(`[ts-node ${new Date().toISOString()}]`, ...t) : () => {};
  var Wn = b2
    ? (t, e) => {
        let i = 0;
        return (n) => ((0, Te.debug)(t, n, ++i), e(n));
      }
    : (t, e) => e;
  Te.VERSION = FF().version;
  Te.DEFAULTS = {
    cwd: (Hw = Te.env.TS_NODE_CWD) !== null && Hw !== void 0 ? Hw : Te.env.TS_NODE_DIR,
    emit: (0, Pe.yn)(Te.env.TS_NODE_EMIT),
    scope: (0, Pe.yn)(Te.env.TS_NODE_SCOPE),
    scopeDir: Te.env.TS_NODE_SCOPE_DIR,
    files: (0, Pe.yn)(Te.env.TS_NODE_FILES),
    pretty: (0, Pe.yn)(Te.env.TS_NODE_PRETTY),
    compiler: Te.env.TS_NODE_COMPILER,
    compilerOptions: (0, Pe.parse)(Te.env.TS_NODE_COMPILER_OPTIONS),
    ignore: (0, Pe.split)(Te.env.TS_NODE_IGNORE),
    project: Te.env.TS_NODE_PROJECT,
    skipProject: (0, Pe.yn)(Te.env.TS_NODE_SKIP_PROJECT),
    skipIgnore: (0, Pe.yn)(Te.env.TS_NODE_SKIP_IGNORE),
    preferTsExts: (0, Pe.yn)(Te.env.TS_NODE_PREFER_TS_EXTS),
    ignoreDiagnostics: (0, Pe.split)(Te.env.TS_NODE_IGNORE_DIAGNOSTICS),
    transpileOnly: (0, Pe.yn)(Te.env.TS_NODE_TRANSPILE_ONLY),
    typeCheck: (0, Pe.yn)(Te.env.TS_NODE_TYPE_CHECK),
    compilerHost: (0, Pe.yn)(Te.env.TS_NODE_COMPILER_HOST),
    logError: (0, Pe.yn)(Te.env.TS_NODE_LOG_ERROR),
    experimentalReplAwait:
      (Gw = (0, Pe.yn)(Te.env.TS_NODE_EXPERIMENTAL_REPL_AWAIT)) !== null && Gw !== void 0 ? Gw : void 0,
    tsTrace: console.log.bind(console),
  };
  var zh = class extends IQ.BaseError {
    constructor(e, i, n = []) {
      super(`\u2A2F Unable to compile TypeScript:
${e}`),
        (this.diagnosticCodes = i),
        (this.name = 'TSError'),
        Object.defineProperty(this, 'diagnosticText', { configurable: !0, writable: !0, value: e }),
        Object.defineProperty(this, 'diagnostics', { configurable: !0, writable: !0, value: n });
    }
    [Te.INSPECT_CUSTOM]() {
      return this.diagnosticText;
    }
  };
  Te.TSError = zh;
  var v2 = Symbol('TS_NODE_SERVICE_BRAND');
  function qQ(t) {
    let e = t;
    (t != null && t[v2]) || (e = w2(t ?? {}));
    let i = require.extensions['.js'];
    return (
      (process[Te.REGISTER_INSTANCE] = e),
      HQ(e.options.preferTsExts, e.extensions.compiled, e, i),
      (0, PQ.installCommonjsResolveHooksIfNecessary)(e),
      OQ.Module._preloadModules(e.options.require),
      e
    );
  }
  Te.register = qQ;
  function w2(t = {}) {
    let e = (0, y2.findAndReadConfig)(t);
    return E2(e);
  }
  Te.create = w2;
  function E2(t) {
    var e, i, n, r;
    let {
        configFilePath: s,
        cwd: o,
        options: c,
        config: u,
        compiler: l,
        projectLocalResolveDir: p,
        optionBasePaths: d,
      } = t,
      x = (0, Pe.createProjectLocalResolveHelper)(p),
      b = (0, y2.loadCompiler)(l),
      g = u.options.target >= b.ScriptTarget.ES2018;
    if (c.experimentalReplAwait === !0 && !g)
      throw new Error('Experimental REPL await is not compatible with targets lower than ES2018');
    let y = (0, Pe.versionGteLt)(b.version, '3.8.0');
    if (c.experimentalReplAwait === !0 && !y)
      throw new Error('Experimental REPL await is not compatible with TypeScript versions older than 3.8');
    let h = c.experimentalReplAwait !== !1 && y && g;
    if (c.swc && !c.typeCheck) {
      if (c.transpileOnly === !1)
        throw new Error("Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.");
      if (c.transpiler)
        throw new Error("Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.");
    }
    let v = c.readFile || b.sys.readFile,
      C = c.fileExists || b.sys.fileExists,
      _ = (c.transpileOnly === !0 || c.swc === !0) && c.typeCheck !== !0,
      m,
      O;
    c.transpiler
      ? ((m = c.transpiler), (O = d.transpiler))
      : c.swc && ((m = require.resolve('./transpilers/swc.js')), (O = d.swc));
    let N = c.transformers || void 0,
      D = [
        {
          appliesToAllFiles: !0,
          filenamesAbsolute: [],
          diagnosticsIgnored: [
            6059,
            18002,
            18003,
            ...(c.experimentalTsImportSpecifiers ? [2691] : []),
            ...(c.ignoreDiagnostics || []),
          ].map(Number),
        },
      ],
      z = Gh(u.errors, D),
      H = new Map(),
      F = s ? (0, un.dirname)(s) : null,
      ne =
        (n =
          (i = (e = c.scopeDir) !== null && e !== void 0 ? e : u.options.rootDir) !== null && i !== void 0 ? i : F) !==
          null && n !== void 0
          ? n
          : o,
      pe = F ?? o,
      le = c.scope ? (_e) => (0, un.relative)(ne, _e).charAt(0) !== '.' : () => !0,
      V = BQ(pe, c.skipIgnore ? [] : (c.ignore || ['(?:^|/)node_modules/']).map((_e) => new RegExp(_e))),
      W = {
        getNewLine: () => b.sys.newLine,
        getCurrentDirectory: () => o,
        getCanonicalFileName: b.sys.useCaseSensitiveFileNames ? (_e) => _e : (_e) => _e.toLowerCase(),
      };
    if (c.transpileOnly && typeof N == 'function')
      throw new TypeError('Transformers function is unavailable in "--transpile-only"');
    let K = q();
    function q() {
      var _e;
      if (m) {
        let St = function (bt, lt) {
          return yt == null
            ? void 0
            : yt({
                service: { options: c, config: { ...u, options: bt }, projectLocalResolveHelper: x },
                transpilerConfigLocalResolveHelper: Ie,
                nodeModuleEmitKind: lt,
                ...xt,
              });
        };
        if (!_) throw new Error('Custom transpiler can only be used when transpileOnly is enabled.');
        let Me = typeof m == 'string' ? m : m[0],
          xt = typeof m == 'string' ? {} : (_e = m[1]) !== null && _e !== void 0 ? _e : {},
          Ie = O ? (0, Pe.createProjectLocalResolveHelper)(O) : x,
          st = Ie(Me, !0),
          yt = require(st).create;
        return St;
      }
    }
    let B = !1;
    function ee() {
      B = !0;
    }
    xe();
    function xe() {
      JF().install({
        environment: 'node',
        retrieveFile(Me) {
          var xt;
          let Ie = Me;
          if (B && Ie.startsWith('file://'))
            try {
              Ie = (0, AQ.fileURLToPath)(Ie);
            } catch {}
          return (
            (Ie = (0, Pe.normalizeSlashes)(Ie)),
            ((xt = H.get(Ie)) === null || xt === void 0 ? void 0 : xt.content) || ''
          );
        },
        redirectConflictingLibrary: !0,
        onConflictingLibraryRedirect(Me, xt, Ie, st, yt) {
          (0, Te.debug)(
            `Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  "${xt.filename}" attempted to require or resolve "${Me}" and was redirected to "${yt}".`
          );
        },
      });
    }
    let Z =
      ((c.pretty === void 0 ? process.stdout.isTTY : c.pretty) && b.formatDiagnosticsWithColorAndContext) ||
      b.formatDiagnostics;
    function oe(_e) {
      let Me = Z(_e, W),
        xt = _e.map((Ie) => Ie.code);
      return new zh(Me, xt, _e);
    }
    function I(_e) {
      let Me = oe(_e);
      if (c.logError) console.error('\x1B[31m%s\x1B[0m', Me);
      else throw Me;
    }
    z.length && I(z);
    let X = u.options.jsx === b.JsxEmit.Preserve;
    function Q(_e) {
      let Me = _e.lastIndexOf('.');
      if (Me >= 0)
        switch (_e.slice(Me)) {
          case '.js':
          case '.ts':
            return '.js';
          case '.jsx':
          case '.tsx':
            return X ? '.jsx' : '.js';
          case '.mjs':
          case '.mts':
            return '.mjs';
          case '.cjs':
          case '.cts':
            return '.cjs';
        }
      return '.js';
    }
    let ae,
      ce,
      ye = b.createGetCanonicalFileName(b.sys.useCaseSensitiveFileNames),
      ve = (0, NQ.createModuleTypeClassifier)({
        basePath: (r = c.optionBasePaths) === null || r === void 0 ? void 0 : r.moduleTypes,
        patterns: c.moduleTypes,
      }),
      Ce = (0, DQ.getExtensions)(u, c, b.version);
    if (_)
      ce = () => {
        throw new TypeError('Type information is unavailable in "--transpile-only"');
      };
    else {
      let _e = new Map(),
        Me = new Set(u.fileNames),
        xt = (0, Pe.cachedLookup)(Wn('readFile', v));
      if (c.compilerHost) {
        let Ie = {
            ...b.sys,
            ...W,
            readFile: (Ee) => {
              let Ze = _e.get(Ee);
              if (Ze !== void 0) return Ze;
              let Ht = xt(Ee);
              return Ht && _e.set(Ee, Ht), Ht;
            },
            readDirectory: b.sys.readDirectory,
            getDirectories: (0, Pe.cachedLookup)(Wn('getDirectories', b.sys.getDirectories)),
            fileExists: (0, Pe.cachedLookup)(Wn('fileExists', C)),
            directoryExists: (0, Pe.cachedLookup)(Wn('directoryExists', b.sys.directoryExists)),
            resolvePath: (0, Pe.cachedLookup)(Wn('resolvePath', b.sys.resolvePath)),
            realpath: b.sys.realpath ? (0, Pe.cachedLookup)(Wn('realpath', b.sys.realpath)) : void 0,
          },
          st = b.createIncrementalCompilerHost
            ? b.createIncrementalCompilerHost(u.options, Ie)
            : {
                ...Ie,
                getSourceFile: (Ee, Ze) => {
                  let Ht = Ie.readFile(Ee);
                  if (Ht !== void 0) return b.createSourceFile(Ee, Ht, Ze);
                },
                getDefaultLibLocation: () => (0, Pe.normalizeSlashes)((0, un.dirname)(l)),
                getDefaultLibFileName: () =>
                  (0, Pe.normalizeSlashes)((0, un.join)((0, un.dirname)(l), b.getDefaultLibFileName(u.options))),
                useCaseSensitiveFileNames: () => Ie.useCaseSensitiveFileNames,
              };
        st.trace = c.tsTrace;
        let {
          resolveModuleNames: yt,
          resolveTypeReferenceDirectives: St,
          isFileKnownToBeInternal: bt,
          markBucketOfFilenameInternal: lt,
        } = (0, x2.createResolverFunctions)({
          host: st,
          cwd: o,
          config: u,
          ts: b,
          getCanonicalFileName: ye,
          projectLocalResolveHelper: x,
          options: c,
          extensions: Ce,
        });
        (st.resolveModuleNames = yt), (st.resolveTypeReferenceDirectives = St);
        let Qe = b.createIncrementalProgram
            ? b.createIncrementalProgram({
                rootNames: Array.from(Me),
                options: u.options,
                host: st,
                configFileParsingDiagnostics: u.errors,
                projectReferences: u.projectReferences,
              })
            : b.createEmitAndSemanticDiagnosticsBuilderProgram(
                Array.from(Me),
                u.options,
                st,
                void 0,
                u.errors,
                u.projectReferences
              ),
          et = typeof N == 'function' ? N(Qe.getProgram()) : N,
          fn = (Ee, Ze) => {
            let oi = _e.get(Ze) !== Ee;
            oi && _e.set(Ze, Ee);
            let Ue = !1;
            !Me.has(Ze) && !bt(Ze) && (lt(Ze), Me.add(Ze), (Ue = !0)),
              (Ue || oi) &&
                (Qe = b.createEmitAndSemanticDiagnosticsBuilderProgram(
                  Array.from(Me),
                  u.options,
                  st,
                  Qe,
                  u.errors,
                  u.projectReferences
                ));
          };
        (ae = (Ee, Ze) => {
          let Ht = '',
            oi = '';
          fn(Ee, Ze);
          let Ue = Qe.getSourceFile(Ze);
          if (!Ue) throw new TypeError(`Unable to read file: ${Ze}`);
          let Ve = Qe.getProgram(),
            Ot = b.getPreEmitDiagnostics(Ve, Ue),
            dt = Gh(Ot, D);
          if (
            (dt.length && I(dt),
            Qe.emit(
              Ue,
              (Li, Di, $l) => {
                Li.endsWith('.map') ? (oi = Di) : (Ht = Di), c.emit && Ie.writeFile(Li, Di, $l);
              },
              void 0,
              void 0,
              et
            ).emitSkipped)
          )
            return [void 0, void 0, !0];
          if (Ht === '')
            throw Ve.isSourceFileFromExternalLibrary(Ue)
              ? new TypeError(`Unable to compile file from external library: ${(0, un.relative)(o, Ze)}`)
              : new TypeError(`Unable to require file: ${(0, un.relative)(o, Ze)}
This is usually the result of a faulty configuration or import. Make sure there is a \`.js\`, \`.json\` or other executable extension with loader attached before \`ts-node\` available.`);
          return [Ht, oi, !1];
        }),
          (ce = (Ee, Ze, Ht) => {
            let oi = (0, Pe.normalizeSlashes)(Ze);
            fn(Ee, oi);
            let Ue = Qe.getSourceFile(oi);
            if (!Ue) throw new TypeError(`Unable to read file: ${Ze}`);
            let Ve = $Q(b, Ue, Ht),
              Ot = Qe.getProgram().getTypeChecker(),
              dt = Ot.getSymbolAtLocation(Ve);
            if (!dt) return { name: '', comment: '' };
            let vi = Ot.getTypeOfSymbolAtLocation(dt, Ve),
              Li = [...vi.getConstructSignatures(), ...vi.getCallSignatures()];
            return {
              name: Li.length
                ? Li.map((Di) => Ot.signatureToString(Di)).join(`
`)
                : Ot.typeToString(vi),
              comment: b.displayPartsToString(dt ? dt.getDocumentationComment(Ot) : []),
            };
          }),
          c.emit &&
            u.options.incremental &&
            process.on('exit', () => {
              Qe.getProgram().emitBuildInfo();
            });
      } else {
        let Ie = 1,
          st = new Map(Array.from(Me).map((Ue) => [Ue, 0])),
          yt = () => {
            if (typeof N == 'function') {
              let Ue = Ze.getProgram();
              return Ue ? N(Ue) : void 0;
            }
            return N;
          },
          St = {
            getProjectVersion: () => String(Ie),
            getScriptFileNames: () => Array.from(Me),
            getScriptVersion: (Ue) => {
              let Ve = st.get(Ue);
              return Ve ? Ve.toString() : '';
            },
            getScriptSnapshot(Ue) {
              let Ve = _e.get(Ue);
              if (Ve === void 0) {
                if (((Ve = xt(Ue)), Ve === void 0)) return;
                st.set(Ue, 1), _e.set(Ue, Ve), Ie++;
              }
              return b.ScriptSnapshot.fromString(Ve);
            },
            readFile: xt,
            readDirectory: b.sys.readDirectory,
            getDirectories: (0, Pe.cachedLookup)(Wn('getDirectories', b.sys.getDirectories)),
            fileExists: (0, Pe.cachedLookup)(Wn('fileExists', C)),
            directoryExists: (0, Pe.cachedLookup)(Wn('directoryExists', b.sys.directoryExists)),
            realpath: b.sys.realpath ? (0, Pe.cachedLookup)(Wn('realpath', b.sys.realpath)) : void 0,
            getNewLine: () => b.sys.newLine,
            useCaseSensitiveFileNames: () => b.sys.useCaseSensitiveFileNames,
            getCurrentDirectory: () => o,
            getCompilationSettings: () => u.options,
            getDefaultLibFileName: () => b.getDefaultLibFilePath(u.options),
            getCustomTransformers: yt,
            trace: c.tsTrace,
          },
          {
            resolveModuleNames: bt,
            getResolvedModuleWithFailedLookupLocationsFromCache: lt,
            resolveTypeReferenceDirectives: Qe,
            isFileKnownToBeInternal: et,
            markBucketOfFilenameInternal: fn,
          } = (0, x2.createResolverFunctions)({
            host: St,
            getCanonicalFileName: ye,
            ts: b,
            cwd: o,
            config: u,
            projectLocalResolveHelper: x,
            options: c,
            extensions: Ce,
          });
        (St.resolveModuleNames = bt),
          (St.getResolvedModuleWithFailedLookupLocationsFromCache = lt),
          (St.resolveTypeReferenceDirectives = Qe);
        let Ee = b.createDocumentRegistry(b.sys.useCaseSensitiveFileNames, o),
          Ze = b.createLanguageService(St, Ee),
          Ht = (Ue, Ve) => {
            !Me.has(Ve) && !et(Ve) && (fn(Ve), Me.add(Ve), Ie++);
            let Ot = st.get(Ve) || 0,
              dt = _e.get(Ve);
            Ue !== dt && (st.set(Ve, Ot + 1), _e.set(Ve, Ue), Ie++);
          },
          oi;
        (ae = (Ue, Ve) => {
          Ht(Ue, Ve);
          let Ot = Ze.getProgram();
          Ot !== oi && (0, Te.debug)(`compiler rebuilt Program instance when getting output for ${Ve}`);
          let dt = Ze.getEmitOutput(Ve),
            vi = Ze.getSemanticDiagnostics(Ve).concat(Ze.getSyntacticDiagnostics(Ve)),
            Li = Ze.getProgram();
          (0, Te.debug)(
            'invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ',
            Ot === Li
          ),
            (oi = Li);
          let Di = Gh(vi, D);
          if ((Di.length && I(Di), dt.emitSkipped)) return [void 0, void 0, !0];
          if (dt.outputFiles.length === 0)
            throw new TypeError(`Unable to require file: ${(0, un.relative)(o, Ve)}
This is usually the result of a faulty configuration or import. Make sure there is a \`.js\`, \`.json\` or other executable extension with loader attached before \`ts-node\` available.`);
          return [dt.outputFiles[1].text, dt.outputFiles[0].text, !1];
        }),
          (ce = (Ue, Ve, Ot) => {
            let dt = (0, Pe.normalizeSlashes)(Ve);
            Ht(Ue, dt);
            let vi = Ze.getQuickInfoAtPosition(dt, Ot),
              Li = b.displayPartsToString(vi ? vi.displayParts : []),
              Di = b.displayPartsToString(vi ? vi.documentation : []);
            return { name: Li, comment: Di };
          });
      }
    }
    function Oe(_e, Me) {
      let xt = { ...u.options };
      _e !== void 0 && (xt.module = _e);
      let Ie = K == null ? void 0 : K(xt, Me),
        st = (0, Pe.versionGteLt)(b.version, '4.7.0')
          ? (0, FQ.createTsTranspileModule)(b, { compilerOptions: xt, reportDiagnostics: !0, transformers: N })
          : void 0;
      return (yt, St) => {
        let bt;
        Ie
          ? (bt = Ie.transpile(yt, { fileName: St }))
          : st
          ? (bt = st(yt, { fileName: St }, Me === 'nodeesm' ? 'module' : 'commonjs'))
          : (bt = b.transpileModule(yt, { fileName: St, compilerOptions: xt, reportDiagnostics: !0, transformers: N }));
        let lt = Gh(bt.diagnostics || [], D);
        return lt.length && I(lt), [bt.outputText, bt.sourceMapText, !1];
      };
    }
    let ke = u.options.module !== b.ModuleKind.CommonJS,
      ze = !(
        u.options.module === b.ModuleKind.ES2015 ||
        (b.ModuleKind.ES2020 && u.options.module === b.ModuleKind.ES2020) ||
        (b.ModuleKind.ES2022 && u.options.module === b.ModuleKind.ES2022) ||
        u.options.module === b.ModuleKind.ESNext
      ),
      R =
        (b.ModuleKind.Node16 && u.options.module === b.ModuleKind.Node16) ||
        (b.ModuleKind.NodeNext && u.options.module === b.ModuleKind.NodeNext),
      w = Oe(b.ModuleKind.CommonJS),
      A = Oe(b.ModuleKind.NodeNext, 'nodecjs'),
      k = Oe(b.ModuleKind.NodeNext, 'nodeesm'),
      S = Oe(b.ModuleKind.ES2022 || b.ModuleKind.ES2020 || b.ModuleKind.ES2015),
      M = Oe();
    function j(_e, Me, xt = 0) {
      let Ie = (0, Pe.normalizeSlashes)(Me),
        st = ve.classifyModuleByModuleTypeOverrides(Ie),
        yt = '',
        St = '',
        bt = !0;
      if ((ae && ([yt, St, bt] = ae(_e, Ie)), st.moduleType === 'cjs' && (ke || bt))) [yt, St] = w(_e, Ie);
      else if (st.moduleType === 'esm' && (ze || bt)) [yt, St] = S(_e, Ie);
      else if (bt) {
        let Qe = (0, LQ.classifyModule)(Me, R);
        [yt, St] =
          Qe === 'nodecjs'
            ? A(_e, Ie)
            : Qe === 'nodeesm'
            ? k(_e, Ie)
            : Qe === 'cjs'
            ? w(_e, Ie)
            : Qe === 'esm'
            ? S(_e, Ie)
            : M(_e, Ie);
      }
      let lt = zQ(yt, Ie, St, Q);
      return H.set(Ie, { content: lt }), lt;
    }
    let U = !0,
      re = (_e) => (_e === void 0 ? U : (U = !!_e)),
      se = (_e) => {
        if (!U) return !0;
        let Me = (0, un.extname)(_e);
        return Ce.compiled.includes(Me) ? !le(_e) || V(_e) : !0;
      };
    function fe(_e) {
      D.push({ ..._e, filenamesAbsolute: _e.filenamesAbsolute.map((Me) => (0, Pe.normalizeSlashes)(Me)) });
    }
    let De = (0, Pe.once)(() =>
        o2().createResolve({
          extensions: Ce,
          preferTsExts: c.preferTsExts,
          tsNodeExperimentalSpecifierResolution: c.experimentalSpecifierResolution,
        })
      ),
      Ne = (0, Pe.once)(() => p2().createGetFormat(c.experimentalSpecifierResolution, De())),
      me = (0, Pe.once)(() =>
        hh().createCjsLoader({ extensions: Ce, preferTsExts: c.preferTsExts, nodeEsmResolver: De() })
      );
    return {
      [v2]: !0,
      ts: b,
      compilerPath: l,
      config: u,
      compile: j,
      getTypeInfo: ce,
      ignored: se,
      enabled: re,
      options: c,
      configFilePath: s,
      moduleTypeClassifier: ve,
      shouldReplAwait: h,
      addDiagnosticFilter: fe,
      installSourceMapSupport: xe,
      enableExperimentalEsmLoaderInterop: ee,
      transpileOnly: _,
      projectLocalResolveHelper: x,
      getNodeEsmResolver: De,
      getNodeEsmGetFormat: Ne,
      getNodeCjsLoader: me,
      extensions: Ce,
    };
  }
  Te.createFromPreloadedConfig = E2;
  function BQ(t, e) {
    return (i) => {
      let n = (0, un.relative)(t, i),
        r = (0, Pe.normalizeSlashes)(n);
      return e.some((s) => s.test(r));
    };
  }
  function HQ(t, e, i, n) {
    let r = new Set(e);
    for (let s of ['.mts', '.cts', '.mjs', '.cjs'])
      r.has(s) && !(0, Pe.hasOwnProperty)(require.extensions, s) && (r.add('.js'), r.delete(s));
    for (let s of r) GQ(s, i, n);
    if (t) {
      let s = new Set([...r, ...Object.keys(require.extensions)]);
      for (let o of s) {
        let c = Object.getOwnPropertyDescriptor(require.extensions, o);
        delete require.extensions[o], Object.defineProperty(require.extensions, o, c);
      }
    }
  }
  function GQ(t, e, i) {
    let n = require.extensions[t] || i;
    require.extensions[t] = function (r, s) {
      if (e.ignored(s)) return n(r, s);
      UQ(e, r, s);
      let o = r._compile;
      return (
        (r._compile = function (c, u) {
          (0, Te.debug)('module._compile', u);
          let l = e.compile(c, u);
          return o.call(this, l, u);
        }),
        n(r, s)
      );
    };
  }
  function zQ(t, e, i, n) {
    let s = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${Buffer.from(VQ(i, e), 'utf8').toString(
        'base64'
      )}`,
      o = '//# sourceMappingURL=',
      c = o.length,
      u = (0, un.basename)(e),
      l = (0, un.extname)(e),
      p = n(e),
      d = u.slice(0, -l.length) + p + '.map',
      x = c + d.length;
    if (t.substr(-x, c) === o) return t.slice(0, -x) + s;
    let b = c + encodeURI(d).length;
    return t.substr(-b, c) === o
      ? t.slice(0, -b) + s
      : `${t}
${s}`;
  }
  function VQ(t, e) {
    let i = JSON.parse(t);
    return (i.file = e), (i.sources = [e]), delete i.sourceRoot, JSON.stringify(i);
  }
  function Gh(t, e) {
    return t.filter((i) =>
      e.every((n) => {
        var r;
        return (
          (!n.appliesToAllFiles &&
            n.filenamesAbsolute.indexOf((r = i.file) === null || r === void 0 ? void 0 : r.fileName) === -1) ||
          n.diagnosticsIgnored.indexOf(i.code) === -1
        );
      })
    );
  }
  function $Q(t, e, i) {
    let n = e;
    e: for (;;) {
      for (let r of n.getChildren(e)) {
        if (r.getFullStart() > i) break;
        let o = r.getEnd();
        if (i <= o) {
          n = r;
          continue e;
        }
      }
      return n;
    }
  }
  var WQ = (t) => g2().createEsmHooks(t);
  Te.createEsmHooks = WQ;
});
var Vw = {};
Ft(Vw, { startAgent: () => YQ });
async function YQ() {
  try {
    fc();
  } catch {}
  let t = It(),
    e = Ct(),
    i = At(),
    n = kt(),
    r = Md(),
    s = Ud();
  process.env.NX_CLOUD_CLIENT_INSTANCE_ID = S2.default.v4();
  let o = Nr.runner ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? 'default';
  rn(e, i) || (sn(), process.exit(1)),
    Nr.targets && Nr.targets.length
      ? zw.note({ title: `Starting an agent for running Nx target(s) [${Nr.targets.join(', ')}]` })
      : zw.note({ title: `Starting Agent '${r}' for running Nx tasks` });
  let { nxCloudOptions: c } = vt(o);
  (await _o(c)) ||
    (zw.error({
      title: 'Nx Cloud: Workspace is disabled',
      bodyLines: [
        'Distributed Task Execution is disabled when your workspace is disabled',
        '',
        "Organization administrators can find more information on the 'Billing' page in the Nx Cloud Webapp",
      ],
    }),
    process.exit(1));
  let l = new cc(c, t, e, i, n, r, s);
  qd(l, c, r);
  let p = new Ci(Fi || c.encryptionKey),
    d = new Si(c),
    x = new zn(new Ai(p, d, c, 'dte-agent'), _2),
    b = XQ ? await Bd(c, _2, o) : await zd(o);
  return xL(r, l, x, b, Nr.targets)
    .then(async (g) => g)
    .catch(async (g) => {
      await l.completeRunGroupWithError(`Critical Error in Agent: "${g.message}"`), process.exit(1);
    });
}
var S2,
  KQ,
  zw,
  XQ,
  _2,
  Nr,
  $w = te(() => {
    'use strict';
    S2 = je(Vu());
    al();
    Le();
    $i();
    Rd();
    Ks();
    So();
    Xs();
    yo();
    d0();
    h0();
    m0();
    g0();
    yL();
    (KQ = Xd()),
      ({ output: zw } = Ae()),
      ({ initTasksRunner: XQ, cacheDirectory: _2 } = ri()),
      (Nr = KQ(process.argv, { array: ['targets'], string: ['runner'], default: {} }));
    Nr.targets && Nr.targets.length === 1 && (Nr.targets = Nr.targets[0].split(',').map((t) => t.trim()));
  });
async function C2(t, e, i, n, r) {
  let s = 0,
    o = null,
    c = bs({ title: `No new messages received after ${Wo / 1e3} seconds`, timeout: Wo }),
    u = [],
    l = new Date(),
    p = !1,
    d = {};
  for (;;) {
    ie && kl.note({ title: `${t} fetching tasks...` }),
      (o = await e.tasksV2(
        o ? o.executionId : null,
        s,
        u,
        process.env.NX_CLOUD_DTE_V2_FORCE_DOWNLOAD_ALL_ARTIFACTS === 'true',
        r
      ));
    let x = o.tasks.map((g) => ({
      id: g.id,
      target: g.target,
      overrides: g.overrides,
      projectRoot: g.projectRoot,
      cache: g.cache,
      outputs: g.outputs,
      parallelism: g.parallelism ?? !0,
    }));
    if (
      (ie &&
        kl.note({
          title: `${t} received an API Response`,
          bodyLines: [
            `completed: ${o.completed}`,
            `status: ${o.status}`,
            `retryDuring: ${o.retryDuring}`,
            `executionId: ${o.executionId}`,
            `number of tasks: ${o.tasks.length}`,
            `error: ${o.criticalErrorMessage}`,
            `maxParallel: ${o.maxParallel}`,
            `taskRunnerConfiguration: ${o.taskRunnerConfiguration}`,
          ],
        }),
      o.criticalErrorMessage &&
        (kl.error({ title: 'Distributed Execution Terminated', bodyLines: ['Error:', o.criticalErrorMessage] }),
        process.exit(1)),
      o != null &&
        o.retryDuring &&
        (o == null ? void 0 : o.retryDuring) !== 0 &&
        !p &&
        new Date().getTime() - l.getTime() > o.retryDuring)
    ) {
      await wt(2e4);
      continue;
    }
    if ((o == null ? void 0 : o.status) !== void 0) {
      if (o.status === 'RUN_GROUP_COMPLETED' || o.status === 'NO_FURTHER_TASKS_TO_RUN') return;
    } else if (o.completed) return;
    if ((c(o.tasks.map((g) => g.id).join('')), !o.executionId)) {
      ie && kl.note({ title: `${t} waiting...` }), await wt(5e3), (s = 0), (u = []);
      continue;
    }
    if (((p = !0), o.taskDependencies))
      for (let g of o.taskDependencies) {
        if (d[g.taskId]) continue;
        kl.note({ title: `${t} downloading artifacts for ${g.taskId} Hash: ${g.hash}}` });
        let y = [{ remoteUrl: g.url, fileType: 'artifact' }];
        g.terminalOutputUrl && y.push({ remoteUrl: g.terminalOutputUrl, fileType: 'terminalOutput' }),
          await i.retrieveAndExtract(g.hash, y),
          (d[g.taskId] = !0);
      }
    let b = await n(o.executionId, x, o.maxParallel, o.taskRunnerConfiguration);
    for (let g of b.completedTasks) d[g.taskId] = !0;
    (s = b.completedStatusCode), (u = b.completedTasks);
  }
}
var kl,
  R2 = te(() => {
    'use strict';
    cl();
    Le();
    Pn();
    ({ output: kl } = Ae());
  });
var k2 = {};
Ft(k2, { startAgent: () => ZQ });
async function ZQ() {
  try {
    fc();
  } catch {}
  let t = It(),
    e = Ct(),
    i = At(),
    n = kt(),
    r = Md(),
    s = Ud();
  process.env.NX_CLOUD_CLIENT_INSTANCE_ID = O2.default.v4();
  let o = Al.runner ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? 'default';
  rn(e, i) || (sn(), process.exit(1)),
    Al.targets && Al.targets.length
      ? Ww.note({ title: `Starting a V2 agent for running Nx target(s) [${Al.targets.join(', ')}]` })
      : Ww.note({ title: `Starting Agent '${r}' for running Nx tasks` });
  let { nxCloudOptions: c } = vt(o);
  (await _o(c)) ||
    (Ww.error({
      title: 'Nx Cloud: Workspace is disabled',
      bodyLines: [
        'Distributed Task Execution is disabled when your workspace is disabled',
        '',
        "Organization administrators can find more information on the 'Billing' page in the Nx Cloud Webapp",
      ],
    }),
    process.exit(1));
  let l = new cc(c, t, e, i, n, r, s);
  qd(l, c, r);
  let p = new Ci(Fi || c.encryptionKey),
    d = new Si(c),
    x = new zn(new Ai(p, d, c, 'dte-agent'), T2),
    b = JQ ? await Bd(c, T2, o) : await zd(o);
  return C2(r, l, x, b, Al.targets)
    .then(async (g) => g)
    .catch(async (g) => {
      await l.completeRunGroupWithError(g.message), process.exit(1);
    });
}
var O2,
  Ww,
  JQ,
  T2,
  Al,
  A2 = te(() => {
    'use strict';
    O2 = je(Vu());
    pl();
    al();
    Le();
    $i();
    Rd();
    Ks();
    So();
    Xs();
    yo();
    d0();
    h0();
    m0();
    g0();
    R2();
    ({ output: Ww } = Ae()),
      ({ initTasksRunner: JQ, cacheDirectory: T2 } = ri()),
      (Al = vs(process.argv, { array: ['targets'], string: ['runner'], default: {} }));
  });
function I2(t, e) {
  if (t.includes('*')) return 100;
  let i = {};
  Object.values(e.dependencies)
    .flat()
    .forEach((l) => {
      i.hasOwnProperty(l.target) ? i[l.target].add(l.source) : (i[l.target] = new Set([l.source]));
    });
  let r = new Set(),
    s = [...t];
  for (;;) {
    let l = s.shift();
    if (!l) break;
    if (r.has(l)) continue;
    r.add(l);
    let p = i[l] || new Array();
    s.unshift(...p);
  }
  let o = r.size,
    c = Object.keys(e.nodes).length,
    u = Math.floor((o / c) * 100);
  return (
    ie &&
      QQ.note({
        title: 'Calculated affected project ratio',
        bodyLines: [`based on ${t}, the affected project ratio is ${u}`],
      }),
    u
  );
}
var QQ,
  N2 = te(() => {
    'use strict';
    Le();
    ({ output: QQ } = Ae());
  });
function eee(t) {
  return t
    .replace(/^[A-Z]:/, '')
    .split('\\')
    .join('/');
}
function tee(t) {
  return (t = t === '' ? '.' : t), t && t.endsWith('/') ? t.substring(0, t.length - 1) : t;
}
function iee(t, e) {
  let i = eee(t);
  for (; i != (0, Kw.dirname)(i); i = (0, Kw.dirname)(i)) {
    let n = e.get(i);
    if (n) return n;
  }
  return e.get(i);
}
function nee(t) {
  let e = new Map();
  for (let i of Object.keys(t)) {
    let n = t[i].data.root;
    e.set(tee(n), i);
  }
  return e;
}
function L2(t, e) {
  let i = [...oee(t), 'nx.json', 'package.json', 'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml'],
    n = ree();
  return see(e.nodes, i, n);
}
function ree() {
  let t = process.env.NX_BASE || 'HEAD~1',
    e = process.env.NX_HEAD || 'HEAD';
  ie && (console.log('Evaluating touched files from Git'), console.log(`Base: ${t}`), console.log(`Head: ${e}`));
  let i = [];
  try {
    i = (0, P2.execSync)(`git diff --name-only ${t} ${e}`)
      .toString()
      .split(
        `
`
      )
      .filter((n) => n.length !== 0);
  } catch {}
  return ie && (console.log('The following files were touched:'), i.forEach((n) => console.log(`- ${n}`))), i;
}
function see(t, e, i) {
  let n = new Set(),
    r = nee(t);
  return (
    ie && console.log('Touched files result in the following affected projects'),
    i.forEach((s) => {
      for (let c = 0; c < e.length; c++)
        if (s === e[c]) {
          ie && console.log(`- ${s} affects all projects`), n.add('*');
          break;
        }
      let o = iee(s, r);
      o && n.add(o);
    }),
    Array.from(n)
  );
}
function oee(t) {
  let e = [];
  return e.push(...aee(t.namedInputs)), e.push(...cee(t.targetDefaults)), e;
}
function aee(t) {
  let e = [];
  for (let i of Object.values(t || {})) e.push(...D2(i));
  return e;
}
function cee(t) {
  let e = [];
  for (let i of Object.values(t || {})) i.inputs && e.push(...D2(i.inputs));
  return e;
}
function D2(t) {
  let e = [];
  for (let i of t)
    typeof i == 'string' && i.startsWith('{workspaceRoot}/')
      ? e.push(i.substring(16))
      : i.fileset && i.fileset.startsWith('{workspaceRoot}/') && e.push(i.fileset.substring(16));
  return e;
}
var P2,
  Kw,
  F2 = te(() => {
    'use strict';
    (P2 = require('child_process')), (Kw = require('path'));
    Le();
  });
var Xw = {};
Ft(Xw, { startCiRun: () => pee });
async function lee(t) {
  var e, i;
  try {
    return (i = (e = await t.fetchProjectGraph()) == null ? void 0 : e.data) == null ? void 0 : i.projectGraph;
  } catch {
    return null;
  }
}
async function pee() {
  var _, m;
  let t = Ni.runner ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? 'default',
    { nxJson: e, nxCloudOptions: i } = vt(t),
    n = It(),
    r = Ct(),
    s = At(),
    o = kt(),
    c = Qt(),
    u = ep(),
    l = qi(),
    p = mee(Ni),
    d = Ni.distribution === !1 ? !1 : Ni.useDteByDefault,
    x = SS(Ni.withEnvVars);
  rn(r, s) || (sn(), process.exit(1)),
    !Ni.force && d && fee(n, l),
    Ni.distribution == null && Ni.distributeOn == null && dee(),
    ie &&
      Ts.note({
        title: `Creating run group. branch: ${n}, ciExecutionId: ${s}, ciExecutionEnv: ${o}, runGroup: ${r}, commitSha: ${c}, requireExplicitCompletion: ${Ni.requireExplicitCompletion}`,
      }),
    Ni.commandCount &&
      (Ts.error({
        title: '--command-count is deprecated. Use --stop-agents-after instead.',
        bodyLines: ['E.g., npx nx-cloud start-ci-run --stop-agents-after="e2e"'],
      }),
      process.exit(1));
  let b = new Gr(i),
    g = await lee(b),
    y = [],
    h = 100;
  g != null
    ? ((y = L2(e, g)),
      (h = I2(y, g)),
      ie && Ts.note({ title: 'The following projects were touched during recent changes', bodyLines: y }))
    : p &&
      hee(p) &&
      Ts.warn({
        title: 'Nx Cloud was unable to retrieve a project graph to compare against.',
        bodyLines: ['This CI Pipeline execution may still be recoverable, but auto-sizing will', 'not be used.'],
      });
  let v = 0,
    C = !1;
  for (;;) {
    let O = await b.createRunGroup(
      n,
      r,
      s,
      o,
      Ni.stopAgentsOnFailure,
      Ni.agentCount,
      Ni.stopAgentsAfter,
      p,
      c,
      u,
      h,
      x,
      Ni.requireExplicitCompletion,
      y
    );
    if (O.status === 202) {
      let N =
          ((_ = O == null ? void 0 : O.data) == null
            ? void 0
            : _.split(`
`)) || [],
        D = (m = N[1]) == null ? void 0 : m.includes('Your setup is almost complete');
      D && C && (N.length = 0),
        v < j2
          ? Ts.note({ title: `Action Required - Retrying in 30 seconds (Attempt ${v + 1} of ${j2})`, bodyLines: N })
          : (Ts.error({ title: 'Action Required - Finish your Nx Cloud setup then restart this job.', bodyLines: N }),
            process.exit(1)),
        (C = D || C),
        v++,
        await wt(3e4);
    } else break;
  }
  d && oP();
}
function fee(t, e) {
  (!t || !e) &&
    Ts.error({
      title: 'This command may not be needed in your current environment.',
      bodyLines: [
        '- "nx-cloud start-ci-run" places a marker file on your system that will result in all commands attempting to run as distributed executions.',
        '- If you are not in a CI environment, this is unnecessary.',
        '- If you run this command locally, use "nx-cloud cleanup" to remove any generated files.',
        '- Use the "--force" flag to bypass this check.',
      ],
    });
}
function dee() {
  Ts.warn({
    title: 'Nx Cloud Warning: Ambiguous Distribution Configuration',
    bodyLines: [
      '`nx-cloud start-ci-run` was invoked without either `--distribute-on` or `--no-distribution`. This can result in unexpected behavior.',
      '',
      '- To enable distribution with Nx Agents, use the `--distribute-on` with a quantity of agents and a launch template name.',
      '- To disable distribution, use the `--no-distribution` flag.',
      '- Legacy DTE setups can set `--distribute-on="manual"` to disable this warning.',
    ],
  });
}
function hee(t) {
  return t.endsWith('.yaml') || t.endsWith('.yml');
}
function mee(t) {
  let e = t.distributeOn ? t.distributeOn : t.distributesOn;
  if (e !== 'manual') return e;
}
var uee,
  Ts,
  qfe,
  Ni,
  j2,
  Yw = te(() => {
    'use strict';
    Cd();
    Le();
    N2();
    $i();
    sa();
    F2();
    Pn();
    vp();
    So();
    (uee = Xd()),
      ({ output: Ts, workspaceRoot: qfe } = Ae()),
      (Ni = uee(process.argv, {
        boolean: [
          'stop-agents-on-failure',
          'use-dte-by-default',
          'require-explicit-completion',
          'force',
          'distribution',
        ],
        number: ['agent-count', 'command-count'],
        string: ['stop-agents-after', 'with-env-vars', 'distributes-on', 'distribute-on', 'runner'],
        default: { useDteByDefault: !0 },
      })),
      (j2 = 20);
  });
var Vh = {};
Ft(Vh, { stopAllAgents: () => xee });
async function xee() {
  let t = It(),
    e = Ct(),
    i = At(),
    n = kt();
  rn(e, i) || (sn(), process.exit(1)),
    ie &&
      gee.note({
        title: `Stopping all agents running tasks for run group. branch: ${t}, ciExecutionId: ${i}, ciExecutionEnv: ${n}, runGroup: ${e}`,
      });
  let r = sc(process.argv) ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? 'default',
    { nxCloudOptions: s } = vt(r);
  await new Gr(s).completeRunGroup(t, e, i, n);
}
var gee,
  $h = te(() => {
    'use strict';
    Le();
    $i();
    oc();
    vp();
    So();
    ({ output: gee } = Ae());
  });
var Zw = P(($fe, U2) => {
  'use strict';
  var M2 = require('fs'),
    Jw;
  function yee() {
    try {
      return M2.statSync('/.dockerenv'), !0;
    } catch {
      return !1;
    }
  }
  function bee() {
    try {
      return M2.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
    } catch {
      return !1;
    }
  }
  U2.exports = () => (Jw === void 0 && (Jw = yee() || bee()), Jw);
});
var H2 = P((Wfe, Qw) => {
  'use strict';
  var vee = require('os'),
    wee = require('fs'),
    q2 = Zw(),
    B2 = () => {
      if (process.platform !== 'linux') return !1;
      if (vee.release().toLowerCase().includes('microsoft')) return !q2();
      try {
        return wee.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ? !q2() : !1;
      } catch {
        return !1;
      }
    };
  process.env.__IS_WSL_TEST__ ? (Qw.exports = B2) : (Qw.exports = B2());
});
var z2 = P((Kfe, G2) => {
  'use strict';
  G2.exports = (t, e, i) => {
    let n = (r) => Object.defineProperty(t, e, { value: r, enumerable: !0, writable: !0 });
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        enumerable: !0,
        get() {
          let r = i();
          return n(r), r;
        },
        set(r) {
          n(r);
        },
      }),
      t
    );
  };
});
var rE = P((Xfe, Y2) => {
  'use strict';
  var Eee = require('path'),
    _ee = require('child_process'),
    { promises: Kh, constants: X2 } = require('fs'),
    Wh = H2(),
    See = Zw(),
    tE = z2(),
    V2 = Eee.join(__dirname, 'xdg-open'),
    { platform: bc, arch: $2 } = process,
    Cee = () => {
      try {
        return Kh.statSync('/run/.containerenv'), !0;
      } catch {
        return !1;
      }
    },
    eE;
  function Ree() {
    return eE === void 0 && (eE = Cee() || See()), eE;
  }
  var Tee = (() => {
      let t = '/mnt/',
        e;
      return async function () {
        if (e) return e;
        let i = '/etc/wsl.conf',
          n = !1;
        try {
          await Kh.access(i, X2.F_OK), (n = !0);
        } catch {}
        if (!n) return t;
        let r = await Kh.readFile(i, { encoding: 'utf8' }),
          s = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(r);
        return s ? ((e = s.groups.mountPoint.trim()), (e = e.endsWith('/') ? e : `${e}/`), e) : t;
      };
    })(),
    W2 = async (t, e) => {
      let i;
      for (let n of t)
        try {
          return await e(n);
        } catch (r) {
          i = r;
        }
      throw i;
    },
    Xh = async (t) => {
      if (((t = { wait: !1, background: !1, newInstance: !1, allowNonzeroExitCode: !1, ...t }), Array.isArray(t.app)))
        return W2(t.app, (c) => Xh({ ...t, app: c }));
      let { name: e, arguments: i = [] } = t.app || {};
      if (((i = [...i]), Array.isArray(e))) return W2(e, (c) => Xh({ ...t, app: { name: c, arguments: i } }));
      let n,
        r = [],
        s = {};
      if (bc === 'darwin')
        (n = 'open'),
          t.wait && r.push('--wait-apps'),
          t.background && r.push('--background'),
          t.newInstance && r.push('--new'),
          e && r.push('-a', e);
      else if (bc === 'win32' || (Wh && !Ree() && !e)) {
        let c = await Tee();
        (n = Wh
          ? `${c}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`
          : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`),
          r.push('-NoProfile', '-NonInteractive', '\u2013ExecutionPolicy', 'Bypass', '-EncodedCommand'),
          Wh || (s.windowsVerbatimArguments = !0);
        let u = ['Start'];
        t.wait && u.push('-Wait'),
          e
            ? (u.push(`"\`"${e}\`""`, '-ArgumentList'), t.target && i.unshift(t.target))
            : t.target && u.push(`"${t.target}"`),
          i.length > 0 && ((i = i.map((l) => `"\`"${l}\`""`)), u.push(i.join(','))),
          (t.target = Buffer.from(u.join(' '), 'utf16le').toString('base64'));
      } else {
        if (e) n = e;
        else {
          let c = !__dirname || __dirname === '/',
            u = !1;
          try {
            await Kh.access(V2, X2.X_OK), (u = !0);
          } catch {}
          n = process.versions.electron || bc === 'android' || c || !u ? 'xdg-open' : V2;
        }
        i.length > 0 && r.push(...i), t.wait || ((s.stdio = 'ignore'), (s.detached = !0));
      }
      t.target && r.push(t.target), bc === 'darwin' && i.length > 0 && r.push('--args', ...i);
      let o = _ee.spawn(n, r, s);
      return t.wait
        ? new Promise((c, u) => {
            o.once('error', u),
              o.once('close', (l) => {
                if (!t.allowNonzeroExitCode && l > 0) {
                  u(new Error(`Exited with code ${l}`));
                  return;
                }
                c(o);
              });
          })
        : (o.unref(), o);
    },
    iE = (t, e) => {
      if (typeof t != 'string') throw new TypeError('Expected a `target`');
      return Xh({ ...e, target: t });
    },
    Oee = (t, e) => {
      if (typeof t != 'string') throw new TypeError('Expected a `name`');
      let { arguments: i = [] } = e || {};
      if (i != null && !Array.isArray(i)) throw new TypeError('Expected `appArguments` as Array type');
      return Xh({ ...e, app: { name: t, arguments: i } });
    };
  function K2(t) {
    if (typeof t == 'string' || Array.isArray(t)) return t;
    let { [$2]: e } = t;
    if (!e) throw new Error(`${$2} is not supported`);
    return e;
  }
  function nE({ [bc]: t }, { wsl: e }) {
    if (e && Wh) return K2(e);
    if (!t) throw new Error(`${bc} is not supported`);
    return K2(t);
  }
  var Yh = {};
  tE(Yh, 'chrome', () =>
    nE(
      { darwin: 'google chrome', win32: 'chrome', linux: ['google-chrome', 'google-chrome-stable', 'chromium'] },
      {
        wsl: {
          ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
          x64: [
            '/mnt/c/Program Files/Google/Chrome/Application/chrome.exe',
            '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
          ],
        },
      }
    )
  );
  tE(Yh, 'firefox', () =>
    nE(
      { darwin: 'firefox', win32: 'C:\\Program Files\\Mozilla Firefox\\firefox.exe', linux: 'firefox' },
      { wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe' }
    )
  );
  tE(Yh, 'edge', () =>
    nE(
      { darwin: 'microsoft edge', win32: 'msedge', linux: ['microsoft-edge', 'microsoft-edge-dev'] },
      { wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe' }
    )
  );
  iE.apps = Yh;
  iE.openApp = Oee;
  Y2.exports = iE;
});
function J2() {
  let { output: t } = Ae();
  t.error({
    title: 'Connections to Nx Cloud are disabled for this workspace',
    bodyLines: [
      'This was an intentional decision by someone on your team.',
      'Nx Cloud cannot and will not be enabled.',
      '',
      "To allow connections to Nx Cloud again, remove the 'neverConnectToCloud'",
      'property in nx.json.',
    ],
  });
}
var Z2 = te(() => {
  'use strict';
});
var sE = {};
Ft(sE, { uploadAndShowRunDetails: () => Nee });
async function Iee(t) {
  let e = new Ka(t),
    i = {},
    n = Hs(),
    r = new Ja(e, i, t, n),
    s = new ms(t.maskedProperties),
    o = JSON.parse((0, Q2.readFileSync)((0, tj.join)(Aee, 'run.json')).toString()),
    c = o.tasks.map((l) => ({ ...l, terminalOutput: '' })),
    u = hd();
  return (
    await r.endRun(
      o.run,
      c,
      { branch: null, runGroup: null, ciExecutionId: null, ciExecutionEnv: null },
      void 0,
      void 0,
      u
    ),
    `${Ep(t.url || 'https://nx.app')}/runs/${u}`
  );
}
async function Nee() {
  let t = sc(process.argv) ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? 'default',
    { nxJson: e, nxCloudOptions: i } = vt(t);
  e.neverConnectToCloud && (J2(), process.exit(1));
  let n = await Iee(i);
  kee.success({ title: 'Successfully uploaded the run details', bodyLines: [`View run details at ${n}`] }),
    (0, ej.default)(n);
}
var Q2,
  ej,
  tj,
  kee,
  Aee,
  oE = te(() => {
    'use strict';
    (Q2 = require('fs')), (ej = je(rE())), (tj = require('path'));
    Le();
    $i();
    Z2();
    $g();
    oc();
    Zb();
    Qb();
    Ub();
    od();
    ({ output: kee } = Ae()), ({ cacheDirectory: Aee } = ri());
  });
var cE = {};
Ft(cE, { login: () => Lee });
async function Lee() {
  let t = Pee(process.argv),
    { nxJson: e, nxCloudOptions: i } = vt('default');
  i.accessToken &&
    (Il.warn({
      title: 'Nx Cloud ID required to use "nx-cloud login"',
      bodyLines: [
        'To use "nx-cloud login", you must have an Nx Cloud ID configured in your workspace.',
        'Run "nx-cloud convert-to-nx-cloud-id" to replace your workspaces Nx Cloud Access Token with Nx Cloud ID instead.',
      ],
    }),
    process.exit(1));
  let n = Bee(t) ?? i.url,
    r = new In(n, !0);
  r.getPersonalAccessTokenFromNxCloudUrl(n) &&
    (Il.warn({
      title: 'You are already logged in',
      bodyLines: [
        'There is already a personal access token allocated to your workspace.',
        "If you would like to log in with a different token, run 'nx-cloud logout' to revoke your existing token.",
      ],
    }),
    process.exit(1)),
    ie && Il.note({ title: `Starting login process for ${r.getNxCloudUrl()}` });
  let s = await jee(),
    o = `http://localhost:${s}`,
    c = `${r.getNxCloudUrl()}/profile/login?nxLoginUrl=${o}/redirect&name=${Mee()}`,
    u = Dee(r, c, r.getNxCloudUrl());
  await (0, rj.default)(o), await Fee(u, s);
}
function Dee(t, e, i) {
  return ij.createServer((n, r) => {
    var s;
    if (n.url === '/') {
      let o = Uee(e, i);
      r.writeHead(200, { 'Content-Type': 'text/html' }), r.end(o);
    } else if ((s = n.url) != null && s.startsWith('/redirect')) {
      let c = sj.default.parse(n.url, !0).query.token;
      if (!c || typeof c != 'string') {
        let u = 'Invalid token. Please try logging in again.';
        r.writeHead(404, { 'Content-Type': 'text/html' }), r.end(u), n.socket.emit('invalid-token', u);
      } else {
        let u = qee(i);
        t.setPersonalAccessToken(c),
          r.writeHead(200, { 'Content-Type': 'text/html' }),
          r.end(u),
          n.socket.emit('login-complete');
      }
    } else r.writeHead(404), r.end('Page not found');
  });
}
async function Fee(t, e) {
  return new Promise((i, n) => {
    t.listen(e, () => {
      Il.note({
        title: 'Opening the browser for login...',
        bodyLines: [`Follow the link to begin your login process: http://localhost:${e}`],
      });
    }),
      t.on('connection', (r) => {
        r.on('invalid-token', (s) => {
          n(s);
        }),
          r.on('login-complete', () => {
            Il.success({ title: 'Successfully logged into Nx Cloud' }), i(!0);
          });
      }),
      t.on('close', () => {
        i(!0);
      }),
      t.on('error', (r) => {
        n(r);
      });
  });
}
async function jee() {
  return new Promise((t, e) => {
    let i = nj.default.createServer();
    i.listen(0, () => {
      let n = i.address().port;
      i.close(() => t(n));
    });
  });
}
function Mee() {
  let t = Jh.type(),
    e = Jh.arch();
  return `${t}-${e}-${new Date().toISOString()}`;
}
function Uee(t, e) {
  let i = (0, aE.readFileSync)(`${__dirname}/static/login-start.html`, 'utf-8');
  return (i = i.replaceAll('{{ redirectUrl }}', t)), i.replaceAll('{{ nxCloudUrl }}', e);
}
function qee(t) {
  return (0, aE.readFileSync)(`${__dirname}/static/login-end.html`, 'utf-8').replace('{{ nxCloudUrl }}', t);
}
function Bee(t) {
  let e = t._.indexOf('login');
  return e != -1 && e + 1 < t._.length ? t._[e + 1] : process.env.NX_CLOUD_API ?? void 0;
}
var aE,
  ij,
  nj,
  Jh,
  rj,
  sj,
  Il,
  Pee,
  uE = te(() => {
    'use strict';
    (aE = require('fs')),
      (ij = je(require('http'))),
      (nj = je(require('net'))),
      (Jh = je(require('os'))),
      (rj = je(rE())),
      (sj = je(require('url')));
    Le();
    $i();
    Mc();
    ({ output: Il } = Ae()), (Pee = Xd());
  });
var lE = {};
Ft(lE, { configure: () => Hee });
async function Hee() {
  let t = vs(process.argv, {
    string: ['personal-access-token', 'nx-cloud-url'],
    default: { personalAccessToken: null, nxCloudUrl: void 0 },
  });
  t.personalAccessToken ||
    (oj.error({
      title: 'No personal access token provided',
      bodyLines: [
        'Please provide a personal access token using the --personal-access-token flag.',
        'To specify a specific instance to connect to, use the --nx-cloud-url flag.',
        'Example: nx-cloud configure --personal-access-token=<pat> --nx-cloud-url=<nx-cloud-url>',
      ],
    }),
    process.exit(1));
  let e = new In(t.nxCloudUrl);
  e.getPersonalAccessTokenFromNxCloudUrl() &&
    oj.note({
      title: `Personal access token already exists for ${t.nxCloudUrl}`,
      bodyLines: [
        'Please run "nx logout" to first remove the existing personal access token before configuring a new one.',
      ],
    }),
    e.setPersonalAccessToken(t.personalAccessToken);
}
var oj,
  pE = te(() => {
    'use strict';
    pl();
    Mc();
    ({ output: oj } = Ae());
  });
var dE = {};
Ft(dE, { convertToNxCloudId: () => Vee });
async function Vee() {
  let { nxJson: t, nxCloudOptions: e } = vt('default');
  e.nxCloudId &&
    (Kn.note({
      title: 'Nx Cloud already configured',
      bodyLines: ['You already have an Nx Cloud ID configured for this workspace. No action is required.'],
    }),
    process.exit(0)),
    e.accessToken ||
      (Kn.error({
        title: 'No connection to Nx Cloud found',
        bodyLines: ['Please ensure that your workspace is configured with Nx Cloud by running "npx nx connect".'],
      }),
      process.exit(1)),
    Kn.note({
      title: 'Migrating to authentication with Nx Cloud ID',
      bodyLines: [
        'Your workspace will now be configured to use an Nx Cloud ID for authentication.',
        'This command will replace the access token in your nx.json with a new field called "nxCloudId".',
      ],
    });
  let i = zt(e),
    n = await $ee(i),
    r = CS();
  Wee(t, n, r),
    r || (Kee(), Xee()),
    await Yee(),
    Kn.note({
      title: 'Nx Cloud ID configured',
      bodyLines: ['Your workspace is now configured to use an Nx Cloud ID for authentication.'],
    });
}
async function $ee(t) {
  var e, i;
  try {
    return (await t.get('/nx-cloud/nx-cloud-id')).data.nxCloudId;
  } catch (n) {
    Kn.error({
      title: n.message,
      bodyLines:
        ((i = (e = n.response) == null ? void 0 : e.data) == null
          ? void 0
          : i.split(`
`)) || [],
    }),
      process.exit(1);
  }
}
function Wee(t, e, i) {
  var n, r, s, o, c, u, l, p, d;
  Kn.note({
    title: 'Updating nx.json with Nx Cloud ID',
    bodyLines: ['Your nx.json has been updated to use an Nx Cloud ID for authentication.'],
  }),
    t == null || delete t.nxCloudId,
    (s =
      (r = (n = t == null ? void 0 : t.tasksRunnerOptions) == null ? void 0 : n.default) == null
        ? void 0
        : r.options) == null || delete s.nxCloudId,
    (u =
      (c = (o = t == null ? void 0 : t.tasksRunnerOptions) == null ? void 0 : o.default) == null
        ? void 0
        : c.options) == null || delete u.accessToken,
    t == null || delete t.nxCloudAccessToken,
    i
      ? (t.nxCloudId = e)
      : (t.tasksRunnerOptions = {
          ...(t == null ? void 0 : t.tasksRunnerOptions),
          default: {
            ...((l = t == null ? void 0 : t.tasksRunnerOptions) == null ? void 0 : l.default),
            runner: 'nx-cloud',
            options: {
              ...((d = (p = t == null ? void 0 : t.tasksRunnerOptions) == null ? void 0 : p.default) == null
                ? void 0
                : d.options),
              nxCloudId: e,
            },
          },
        }),
    cj((0, Zh.join)(vc, 'nx.json'), t);
}
function Kee() {
  let t = JSON.parse(Gs((0, aj.readFileSync)((0, Zh.join)(vc, 'package.json')).toString(), { trailingCommas: !0 }));
  (t.devDependencies = { ...t.devDependencies, 'nx-cloud': 'latest' }), cj((0, Zh.join)(vc, 'package.json'), t);
}
function Xee() {
  try {
    Kn.note({
      title: 'Updating package.json with Nx Cloud package',
      bodyLines: [
        'Your version of Nx does not currently support authenticating to Nx Cloud with an Nx Cloud ID.',
        'The Nx Cloud package has been added to your dev dependencies to enable this feature.',
      ],
    });
    let t = zee(),
      e = Gee(t);
    (0, fE.execSync)(e.install, { stdio: [0, 1, 2] });
  } catch {
    Kn.note({
      title: 'Your workspace is almost ready for login',
      bodyLines: [
        'Your nx.json has been updated to use an Nx Cloud ID for authentication, but additional action is required.',
        'Please run "install" with your package manager to install the latest version of Nx Cloud.',
      ],
    }),
      process.exit(1);
  }
}
async function Yee() {
  try {
    Kn.note({ title: 'Formatting changed files in workspace' }),
      (0, fE.execSync)(`npx nx format ${vc}/nx.json ${vc}/package.json ${vc}/*.lock`, { stdio: [0, 1, 2] });
  } catch (t) {
    Kn.note({
      title: 'Error formatting files',
      bodyLines: [
        "There was an error formatting the nx.json or package.json file in your workspace. Please run 'npx nx format' manually.",
        t,
      ],
    });
  }
}
var fE,
  aj,
  Zh,
  vc,
  Kn,
  Gee,
  zee,
  cj,
  hE = te(() => {
    'use strict';
    (fE = require('child_process')), (aj = require('fs')), (Zh = require('path'));
    ip();
    mn();
    Le();
    $i();
    ({ workspaceRoot: vc, output: Kn } = Ae()),
      ({ getPackageManagerCommand: Gee, detectPackageManager: zee, writeJsonFile: cj } = ri());
  });
function Nl(t, e) {
  return function () {
    return t.apply(e, arguments);
  };
}
var mE = te(() => {
  'use strict';
});
function Zee(t) {
  return (
    t !== null &&
    !Pl(t) &&
    t.constructor !== null &&
    !Pl(t.constructor) &&
    ln(t.constructor.isBuffer) &&
    t.constructor.isBuffer(t)
  );
}
function Qee(t) {
  let e;
  return (
    typeof ArrayBuffer < 'u' && ArrayBuffer.isView ? (e = ArrayBuffer.isView(t)) : (e = t && t.buffer && pj(t.buffer)),
    e
  );
}
function Ll(t, e, { allOwnKeys: i = !1 } = {}) {
  if (t === null || typeof t > 'u') return;
  let n, r;
  if ((typeof t != 'object' && (t = [t]), wc(t))) for (n = 0, r = t.length; n < r; n++) e.call(null, t[n], n, t);
  else {
    let s = i ? Object.getOwnPropertyNames(t) : Object.keys(t),
      o = s.length,
      c;
    for (n = 0; n < o; n++) (c = s[n]), e.call(null, t[c], c, t);
  }
}
function dj(t, e) {
  e = e.toLowerCase();
  let i = Object.keys(t),
    n = i.length,
    r;
  for (; n-- > 0; ) if (((r = i[n]), e === r.toLowerCase())) return r;
  return null;
}
function xE() {
  let { caseless: t } = (mj(this) && this) || {},
    e = {},
    i = (n, r) => {
      let s = (t && dj(e, r)) || r;
      Qh(e[s]) && Qh(n) ? (e[s] = xE(e[s], n)) : Qh(n) ? (e[s] = xE({}, n)) : wc(n) ? (e[s] = n.slice()) : (e[s] = n);
    };
  for (let n = 0, r = arguments.length; n < r; n++) arguments[n] && Ll(arguments[n], i);
  return e;
}
function Tte(t) {
  return !!(t && ln(t.append) && t[Symbol.toStringTag] === 'FormData' && t[Symbol.iterator]);
}
var Jee,
  yE,
  em,
  Xn,
  tm,
  wc,
  Pl,
  pj,
  ete,
  ln,
  fj,
  im,
  tte,
  Qh,
  ite,
  nte,
  rte,
  ste,
  ote,
  ate,
  cte,
  ute,
  hj,
  mj,
  lte,
  pte,
  fte,
  dte,
  hte,
  mte,
  gte,
  xte,
  yte,
  bte,
  vte,
  uj,
  wte,
  gj,
  Ete,
  _te,
  Ste,
  Cte,
  gE,
  lj,
  xj,
  Rte,
  Ote,
  kte,
  Ate,
  G,
  ft = te(() => {
    'use strict';
    mE();
    ({ toString: Jee } = Object.prototype),
      ({ getPrototypeOf: yE } = Object),
      (em = ((t) => (e) => {
        let i = Jee.call(e);
        return t[i] || (t[i] = i.slice(8, -1).toLowerCase());
      })(Object.create(null))),
      (Xn = (t) => ((t = t.toLowerCase()), (e) => em(e) === t)),
      (tm = (t) => (e) => typeof e === t),
      ({ isArray: wc } = Array),
      (Pl = tm('undefined'));
    pj = Xn('ArrayBuffer');
    (ete = tm('string')),
      (ln = tm('function')),
      (fj = tm('number')),
      (im = (t) => t !== null && typeof t == 'object'),
      (tte = (t) => t === !0 || t === !1),
      (Qh = (t) => {
        if (em(t) !== 'object') return !1;
        let e = yE(t);
        return (
          (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) &&
          !(Symbol.toStringTag in t) &&
          !(Symbol.iterator in t)
        );
      }),
      (ite = Xn('Date')),
      (nte = Xn('File')),
      (rte = Xn('Blob')),
      (ste = Xn('FileList')),
      (ote = (t) => im(t) && ln(t.pipe)),
      (ate = (t) => {
        let e;
        return (
          t &&
          ((typeof FormData == 'function' && t instanceof FormData) ||
            (ln(t.append) &&
              ((e = em(t)) === 'formdata' ||
                (e === 'object' && ln(t.toString) && t.toString() === '[object FormData]'))))
        );
      }),
      (cte = Xn('URLSearchParams')),
      (ute = (t) => (t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')));
    (hj = typeof globalThis < 'u' ? globalThis : typeof self < 'u' ? self : typeof window < 'u' ? window : global),
      (mj = (t) => !Pl(t) && t !== hj);
    (lte = (t, e, i, { allOwnKeys: n } = {}) => (
      Ll(
        e,
        (r, s) => {
          i && ln(r) ? (t[s] = Nl(r, i)) : (t[s] = r);
        },
        { allOwnKeys: n }
      ),
      t
    )),
      (pte = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t)),
      (fte = (t, e, i, n) => {
        (t.prototype = Object.create(e.prototype, n)),
          (t.prototype.constructor = t),
          Object.defineProperty(t, 'super', { value: e.prototype }),
          i && Object.assign(t.prototype, i);
      }),
      (dte = (t, e, i, n) => {
        let r,
          s,
          o,
          c = {};
        if (((e = e || {}), t == null)) return e;
        do {
          for (r = Object.getOwnPropertyNames(t), s = r.length; s-- > 0; )
            (o = r[s]), (!n || n(o, t, e)) && !c[o] && ((e[o] = t[o]), (c[o] = !0));
          t = i !== !1 && yE(t);
        } while (t && (!i || i(t, e)) && t !== Object.prototype);
        return e;
      }),
      (hte = (t, e, i) => {
        (t = String(t)), (i === void 0 || i > t.length) && (i = t.length), (i -= e.length);
        let n = t.indexOf(e, i);
        return n !== -1 && n === i;
      }),
      (mte = (t) => {
        if (!t) return null;
        if (wc(t)) return t;
        let e = t.length;
        if (!fj(e)) return null;
        let i = new Array(e);
        for (; e-- > 0; ) i[e] = t[e];
        return i;
      }),
      (gte = (
        (t) => (e) =>
          t && e instanceof t
      )(typeof Uint8Array < 'u' && yE(Uint8Array))),
      (xte = (t, e) => {
        let n = (t && t[Symbol.iterator]).call(t),
          r;
        for (; (r = n.next()) && !r.done; ) {
          let s = r.value;
          e.call(t, s[0], s[1]);
        }
      }),
      (yte = (t, e) => {
        let i,
          n = [];
        for (; (i = t.exec(e)) !== null; ) n.push(i);
        return n;
      }),
      (bte = Xn('HTMLFormElement')),
      (vte = (t) =>
        t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (i, n, r) {
          return n.toUpperCase() + r;
        })),
      (uj = (
        ({ hasOwnProperty: t }) =>
        (e, i) =>
          t.call(e, i)
      )(Object.prototype)),
      (wte = Xn('RegExp')),
      (gj = (t, e) => {
        let i = Object.getOwnPropertyDescriptors(t),
          n = {};
        Ll(i, (r, s) => {
          let o;
          (o = e(r, s, t)) !== !1 && (n[s] = o || r);
        }),
          Object.defineProperties(t, n);
      }),
      (Ete = (t) => {
        gj(t, (e, i) => {
          if (ln(t) && ['arguments', 'caller', 'callee'].indexOf(i) !== -1) return !1;
          let n = t[i];
          if (ln(n)) {
            if (((e.enumerable = !1), 'writable' in e)) {
              e.writable = !1;
              return;
            }
            e.set ||
              (e.set = () => {
                throw Error("Can not rewrite read-only method '" + i + "'");
              });
          }
        });
      }),
      (_te = (t, e) => {
        let i = {},
          n = (r) => {
            r.forEach((s) => {
              i[s] = !0;
            });
          };
        return wc(t) ? n(t) : n(String(t).split(e)), i;
      }),
      (Ste = () => {}),
      (Cte = (t, e) => ((t = +t), Number.isFinite(t) ? t : e)),
      (gE = 'abcdefghijklmnopqrstuvwxyz'),
      (lj = '0123456789'),
      (xj = { DIGIT: lj, ALPHA: gE, ALPHA_DIGIT: gE + gE.toUpperCase() + lj }),
      (Rte = (t = 16, e = xj.ALPHA_DIGIT) => {
        let i = '',
          { length: n } = e;
        for (; t--; ) i += e[(Math.random() * n) | 0];
        return i;
      });
    (Ote = (t) => {
      let e = new Array(10),
        i = (n, r) => {
          if (im(n)) {
            if (e.indexOf(n) >= 0) return;
            if (!('toJSON' in n)) {
              e[r] = n;
              let s = wc(n) ? [] : {};
              return (
                Ll(n, (o, c) => {
                  let u = i(o, r + 1);
                  !Pl(u) && (s[c] = u);
                }),
                (e[r] = void 0),
                s
              );
            }
          }
          return n;
        };
      return i(t, 0);
    }),
      (kte = Xn('AsyncFunction')),
      (Ate = (t) => t && (im(t) || ln(t)) && ln(t.then) && ln(t.catch)),
      (G = {
        isArray: wc,
        isArrayBuffer: pj,
        isBuffer: Zee,
        isFormData: ate,
        isArrayBufferView: Qee,
        isString: ete,
        isNumber: fj,
        isBoolean: tte,
        isObject: im,
        isPlainObject: Qh,
        isUndefined: Pl,
        isDate: ite,
        isFile: nte,
        isBlob: rte,
        isRegExp: wte,
        isFunction: ln,
        isStream: ote,
        isURLSearchParams: cte,
        isTypedArray: gte,
        isFileList: ste,
        forEach: Ll,
        merge: xE,
        extend: lte,
        trim: ute,
        stripBOM: pte,
        inherits: fte,
        toFlatObject: dte,
        kindOf: em,
        kindOfTest: Xn,
        endsWith: hte,
        toArray: mte,
        forEachEntry: xte,
        matchAll: yte,
        isHTMLForm: bte,
        hasOwnProperty: uj,
        hasOwnProp: uj,
        reduceDescriptors: gj,
        freezeMethods: Ete,
        toObjectSet: _te,
        toCamelCase: vte,
        noop: Ste,
        toFiniteNumber: Cte,
        findKey: dj,
        global: hj,
        isContextDefined: mj,
        ALPHABET: xj,
        generateString: Rte,
        isSpecCompliantForm: Tte,
        toJSONObject: Ote,
        isAsyncFn: kte,
        isThenable: Ate,
      });
  });
function Ec(t, e, i, n, r) {
  Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error().stack),
    (this.message = t),
    (this.name = 'AxiosError'),
    e && (this.code = e),
    i && (this.config = i),
    n && (this.request = n),
    r && (this.response = r);
}
var yj,
  bj,
  be,
  Rn = te(() => {
    'use strict';
    ft();
    G.inherits(Ec, Error, {
      toJSON: function () {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: G.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null,
        };
      },
    });
    (yj = Ec.prototype), (bj = {});
    [
      'ERR_BAD_OPTION_VALUE',
      'ERR_BAD_OPTION',
      'ECONNABORTED',
      'ETIMEDOUT',
      'ERR_NETWORK',
      'ERR_FR_TOO_MANY_REDIRECTS',
      'ERR_DEPRECATED',
      'ERR_BAD_RESPONSE',
      'ERR_BAD_REQUEST',
      'ERR_CANCELED',
      'ERR_NOT_SUPPORT',
      'ERR_INVALID_URL',
    ].forEach((t) => {
      bj[t] = { value: t };
    });
    Object.defineProperties(Ec, bj);
    Object.defineProperty(yj, 'isAxiosError', { value: !0 });
    Ec.from = (t, e, i, n, r, s) => {
      let o = Object.create(yj);
      return (
        G.toFlatObject(
          t,
          o,
          function (u) {
            return u !== Error.prototype;
          },
          (c) => c !== 'isAxiosError'
        ),
        Ec.call(o, t.message, e, i, n, r),
        (o.cause = t),
        (o.name = t.name),
        s && Object.assign(o, s),
        o
      );
    };
    be = Ec;
  });
var vj,
  nm,
  bE = te(() => {
    'use strict';
    (vj = je(Qm(), 1)), (nm = vj.default);
  });
function vE(t) {
  return G.isPlainObject(t) || G.isArray(t);
}
function Ej(t) {
  return G.endsWith(t, '[]') ? t.slice(0, -2) : t;
}
function wj(t, e, i) {
  return t
    ? t
        .concat(e)
        .map(function (r, s) {
          return (r = Ej(r)), !i && s ? '[' + r + ']' : r;
        })
        .join(i ? '.' : '')
    : e;
}
function Ite(t) {
  return G.isArray(t) && !t.some(vE);
}
function Pte(t, e, i) {
  if (!G.isObject(t)) throw new TypeError('target must be an object');
  (e = e || new (nm || FormData)()),
    (i = G.toFlatObject(i, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (y, h) {
      return !G.isUndefined(h[y]);
    }));
  let n = i.metaTokens,
    r = i.visitor || p,
    s = i.dots,
    o = i.indexes,
    u = (i.Blob || (typeof Blob < 'u' && Blob)) && G.isSpecCompliantForm(e);
  if (!G.isFunction(r)) throw new TypeError('visitor must be a function');
  function l(g) {
    if (g === null) return '';
    if (G.isDate(g)) return g.toISOString();
    if (!u && G.isBlob(g)) throw new be('Blob is not supported. Use a Buffer instead.');
    return G.isArrayBuffer(g) || G.isTypedArray(g)
      ? u && typeof Blob == 'function'
        ? new Blob([g])
        : Buffer.from(g)
      : g;
  }
  function p(g, y, h) {
    let v = g;
    if (g && !h && typeof g == 'object') {
      if (G.endsWith(y, '{}')) (y = n ? y : y.slice(0, -2)), (g = JSON.stringify(g));
      else if ((G.isArray(g) && Ite(g)) || ((G.isFileList(g) || G.endsWith(y, '[]')) && (v = G.toArray(g))))
        return (
          (y = Ej(y)),
          v.forEach(function (_, m) {
            !(G.isUndefined(_) || _ === null) && e.append(o === !0 ? wj([y], m, s) : o === null ? y : y + '[]', l(_));
          }),
          !1
        );
    }
    return vE(g) ? !0 : (e.append(wj(h, y, s), l(g)), !1);
  }
  let d = [],
    x = Object.assign(Nte, { defaultVisitor: p, convertValue: l, isVisitable: vE });
  function b(g, y) {
    if (!G.isUndefined(g)) {
      if (d.indexOf(g) !== -1) throw Error('Circular reference detected in ' + y.join('.'));
      d.push(g),
        G.forEach(g, function (v, C) {
          (!(G.isUndefined(v) || v === null) && r.call(e, v, G.isString(C) ? C.trim() : C, y, x)) === !0 &&
            b(v, y ? y.concat(C) : [C]);
        }),
        d.pop();
    }
  }
  if (!G.isObject(t)) throw new TypeError('data must be an object');
  return b(t), e;
}
var Nte,
  Os,
  Dl = te(() => {
    'use strict';
    ft();
    Rn();
    bE();
    Nte = G.toFlatObject(G, {}, null, function (e) {
      return /^is[A-Z]/.test(e);
    });
    Os = Pte;
  });
function _j(t) {
  let e = { '!': '%21', "'": '%27', '(': '%28', ')': '%29', '~': '%7E', '%20': '+', '%00': '\0' };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (n) {
    return e[n];
  });
}
function Sj(t, e) {
  (this._pairs = []), t && Os(t, this, e);
}
var Cj,
  Rj,
  Tj = te(() => {
    'use strict';
    Dl();
    Cj = Sj.prototype;
    Cj.append = function (e, i) {
      this._pairs.push([e, i]);
    };
    Cj.toString = function (e) {
      let i = e
        ? function (n) {
            return e.call(this, n, _j);
          }
        : _j;
      return this._pairs
        .map(function (r) {
          return i(r[0]) + '=' + i(r[1]);
        }, '')
        .join('&');
    };
    Rj = Sj;
  });
function Lte(t) {
  return encodeURIComponent(t)
    .replace(/%3A/gi, ':')
    .replace(/%24/g, '$')
    .replace(/%2C/gi, ',')
    .replace(/%20/g, '+')
    .replace(/%5B/gi, '[')
    .replace(/%5D/gi, ']');
}
function Fo(t, e, i) {
  if (!e) return t;
  let n = (i && i.encode) || Lte,
    r = i && i.serialize,
    s;
  if ((r ? (s = r(e, i)) : (s = G.isURLSearchParams(e) ? e.toString() : new Rj(e, i).toString(n)), s)) {
    let o = t.indexOf('#');
    o !== -1 && (t = t.slice(0, o)), (t += (t.indexOf('?') === -1 ? '?' : '&') + s);
  }
  return t;
}
var rm = te(() => {
  'use strict';
  ft();
  Tj();
});
var wE,
  EE,
  Oj = te(() => {
    'use strict';
    ft();
    (wE = class {
      constructor() {
        this.handlers = [];
      }
      use(e, i, n) {
        return (
          this.handlers.push({
            fulfilled: e,
            rejected: i,
            synchronous: n ? n.synchronous : !1,
            runWhen: n ? n.runWhen : null,
          }),
          this.handlers.length - 1
        );
      }
      eject(e) {
        this.handlers[e] && (this.handlers[e] = null);
      }
      clear() {
        this.handlers && (this.handlers = []);
      }
      forEach(e) {
        G.forEach(this.handlers, function (n) {
          n !== null && e(n);
        });
      }
    }),
      (EE = wE);
  });
var _c,
  sm = te(() => {
    'use strict';
    _c = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 };
  });
var kj,
  Aj,
  Ij = te(() => {
    'use strict';
    (kj = je(require('url'), 1)), (Aj = kj.default.URLSearchParams);
  });
var Nj,
  Pj = te(() => {
    'use strict';
    Ij();
    bE();
    Nj = {
      isNode: !0,
      classes: { URLSearchParams: Aj, FormData: nm, Blob: (typeof Blob < 'u' && Blob) || null },
      protocols: ['http', 'https', 'file', 'data'],
    };
  });
var _E = {};
Ft(_E, { hasBrowserEnv: () => Lj, hasStandardBrowserEnv: () => Dte, hasStandardBrowserWebWorkerEnv: () => Fte });
var Lj,
  Dte,
  Fte,
  Dj = te(() => {
    'use strict';
    (Lj = typeof window < 'u' && typeof document < 'u'),
      (Dte = ((t) => Lj && ['ReactNative', 'NativeScript', 'NS'].indexOf(t) < 0)(
        typeof navigator < 'u' && navigator.product
      )),
      (Fte =
        typeof WorkerGlobalScope < 'u' && self instanceof WorkerGlobalScope && typeof self.importScripts == 'function');
  });
var Ut,
  ks = te(() => {
    'use strict';
    Pj();
    Dj();
    Ut = { ..._E, ...Nj };
  });
function SE(t, e) {
  return Os(
    t,
    new Ut.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (i, n, r, s) {
          return Ut.isNode && G.isBuffer(i)
            ? (this.append(n, i.toString('base64')), !1)
            : s.defaultVisitor.apply(this, arguments);
        },
      },
      e
    )
  );
}
var Fj = te(() => {
  'use strict';
  ft();
  Dl();
  ks();
});
function jte(t) {
  return G.matchAll(/\w+|\[(\w*)]/g, t).map((e) => (e[0] === '[]' ? '' : e[1] || e[0]));
}
function Mte(t) {
  let e = {},
    i = Object.keys(t),
    n,
    r = i.length,
    s;
  for (n = 0; n < r; n++) (s = i[n]), (e[s] = t[s]);
  return e;
}
function Ute(t) {
  function e(i, n, r, s) {
    let o = i[s++];
    if (o === '__proto__') return !0;
    let c = Number.isFinite(+o),
      u = s >= i.length;
    return (
      (o = !o && G.isArray(r) ? r.length : o),
      u
        ? (G.hasOwnProp(r, o) ? (r[o] = [r[o], n]) : (r[o] = n), !c)
        : ((!r[o] || !G.isObject(r[o])) && (r[o] = []), e(i, n, r[o], s) && G.isArray(r[o]) && (r[o] = Mte(r[o])), !c)
    );
  }
  if (G.isFormData(t) && G.isFunction(t.entries)) {
    let i = {};
    return (
      G.forEachEntry(t, (n, r) => {
        e(jte(n), r, i, 0);
      }),
      i
    );
  }
  return null;
}
var om,
  CE = te(() => {
    'use strict';
    ft();
    om = Ute;
  });
function qte(t, e, i) {
  if (G.isString(t))
    try {
      return (e || JSON.parse)(t), G.trim(t);
    } catch (n) {
      if (n.name !== 'SyntaxError') throw n;
    }
  return (i || JSON.stringify)(t);
}
var RE,
  Sc,
  am = te(() => {
    'use strict';
    ft();
    Rn();
    sm();
    Dl();
    Fj();
    ks();
    CE();
    RE = {
      transitional: _c,
      adapter: ['xhr', 'http'],
      transformRequest: [
        function (e, i) {
          let n = i.getContentType() || '',
            r = n.indexOf('application/json') > -1,
            s = G.isObject(e);
          if ((s && G.isHTMLForm(e) && (e = new FormData(e)), G.isFormData(e))) return r ? JSON.stringify(om(e)) : e;
          if (G.isArrayBuffer(e) || G.isBuffer(e) || G.isStream(e) || G.isFile(e) || G.isBlob(e)) return e;
          if (G.isArrayBufferView(e)) return e.buffer;
          if (G.isURLSearchParams(e))
            return i.setContentType('application/x-www-form-urlencoded;charset=utf-8', !1), e.toString();
          let c;
          if (s) {
            if (n.indexOf('application/x-www-form-urlencoded') > -1) return SE(e, this.formSerializer).toString();
            if ((c = G.isFileList(e)) || n.indexOf('multipart/form-data') > -1) {
              let u = this.env && this.env.FormData;
              return Os(c ? { 'files[]': e } : e, u && new u(), this.formSerializer);
            }
          }
          return s || r ? (i.setContentType('application/json', !1), qte(e)) : e;
        },
      ],
      transformResponse: [
        function (e) {
          let i = this.transitional || RE.transitional,
            n = i && i.forcedJSONParsing,
            r = this.responseType === 'json';
          if (e && G.isString(e) && ((n && !this.responseType) || r)) {
            let o = !(i && i.silentJSONParsing) && r;
            try {
              return JSON.parse(e);
            } catch (c) {
              if (o) throw c.name === 'SyntaxError' ? be.from(c, be.ERR_BAD_RESPONSE, this, null, this.response) : c;
            }
          }
          return e;
        },
      ],
      timeout: 0,
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
      maxContentLength: -1,
      maxBodyLength: -1,
      env: { FormData: Ut.classes.FormData, Blob: Ut.classes.Blob },
      validateStatus: function (e) {
        return e >= 200 && e < 300;
      },
      headers: { common: { Accept: 'application/json, text/plain, */*', 'Content-Type': void 0 } },
    };
    G.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (t) => {
      RE.headers[t] = {};
    });
    Sc = RE;
  });
var Bte,
  jj,
  Mj = te(() => {
    'use strict';
    ft();
    (Bte = G.toObjectSet([
      'age',
      'authorization',
      'content-length',
      'content-type',
      'etag',
      'expires',
      'from',
      'host',
      'if-modified-since',
      'if-unmodified-since',
      'last-modified',
      'location',
      'max-forwards',
      'proxy-authorization',
      'referer',
      'retry-after',
      'user-agent',
    ])),
      (jj = (t) => {
        let e = {},
          i,
          n,
          r;
        return (
          t &&
            t
              .split(
                `
`
              )
              .forEach(function (o) {
                (r = o.indexOf(':')),
                  (i = o.substring(0, r).trim().toLowerCase()),
                  (n = o.substring(r + 1).trim()),
                  !(!i || (e[i] && Bte[i])) &&
                    (i === 'set-cookie' ? (e[i] ? e[i].push(n) : (e[i] = [n])) : (e[i] = e[i] ? e[i] + ', ' + n : n));
              }),
          e
        );
      });
  });
function Fl(t) {
  return t && String(t).trim().toLowerCase();
}
function cm(t) {
  return t === !1 || t == null ? t : G.isArray(t) ? t.map(cm) : String(t);
}
function Hte(t) {
  let e = Object.create(null),
    i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g,
    n;
  for (; (n = i.exec(t)); ) e[n[1]] = n[2];
  return e;
}
function TE(t, e, i, n, r) {
  if (G.isFunction(n)) return n.call(this, e, i);
  if ((r && (e = i), !!G.isString(e))) {
    if (G.isString(n)) return e.indexOf(n) !== -1;
    if (G.isRegExp(n)) return n.test(e);
  }
}
function zte(t) {
  return t
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (e, i, n) => i.toUpperCase() + n);
}
function Vte(t, e) {
  let i = G.toCamelCase(' ' + e);
  ['get', 'set', 'has'].forEach((n) => {
    Object.defineProperty(t, n + i, {
      value: function (r, s, o) {
        return this[n].call(this, e, r, s, o);
      },
      configurable: !0,
    });
  });
}
var Uj,
  Gte,
  Cc,
  qt,
  As = te(() => {
    'use strict';
    ft();
    Mj();
    Uj = Symbol('internals');
    Gte = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
    Cc = class {
      constructor(e) {
        e && this.set(e);
      }
      set(e, i, n) {
        let r = this;
        function s(c, u, l) {
          let p = Fl(u);
          if (!p) throw new Error('header name must be a non-empty string');
          let d = G.findKey(r, p);
          (!d || r[d] === void 0 || l === !0 || (l === void 0 && r[d] !== !1)) && (r[d || u] = cm(c));
        }
        let o = (c, u) => G.forEach(c, (l, p) => s(l, p, u));
        return (
          G.isPlainObject(e) || e instanceof this.constructor
            ? o(e, i)
            : G.isString(e) && (e = e.trim()) && !Gte(e)
            ? o(jj(e), i)
            : e != null && s(i, e, n),
          this
        );
      }
      get(e, i) {
        if (((e = Fl(e)), e)) {
          let n = G.findKey(this, e);
          if (n) {
            let r = this[n];
            if (!i) return r;
            if (i === !0) return Hte(r);
            if (G.isFunction(i)) return i.call(this, r, n);
            if (G.isRegExp(i)) return i.exec(r);
            throw new TypeError('parser must be boolean|regexp|function');
          }
        }
      }
      has(e, i) {
        if (((e = Fl(e)), e)) {
          let n = G.findKey(this, e);
          return !!(n && this[n] !== void 0 && (!i || TE(this, this[n], n, i)));
        }
        return !1;
      }
      delete(e, i) {
        let n = this,
          r = !1;
        function s(o) {
          if (((o = Fl(o)), o)) {
            let c = G.findKey(n, o);
            c && (!i || TE(n, n[c], c, i)) && (delete n[c], (r = !0));
          }
        }
        return G.isArray(e) ? e.forEach(s) : s(e), r;
      }
      clear(e) {
        let i = Object.keys(this),
          n = i.length,
          r = !1;
        for (; n--; ) {
          let s = i[n];
          (!e || TE(this, this[s], s, e, !0)) && (delete this[s], (r = !0));
        }
        return r;
      }
      normalize(e) {
        let i = this,
          n = {};
        return (
          G.forEach(this, (r, s) => {
            let o = G.findKey(n, s);
            if (o) {
              (i[o] = cm(r)), delete i[s];
              return;
            }
            let c = e ? zte(s) : String(s).trim();
            c !== s && delete i[s], (i[c] = cm(r)), (n[c] = !0);
          }),
          this
        );
      }
      concat(...e) {
        return this.constructor.concat(this, ...e);
      }
      toJSON(e) {
        let i = Object.create(null);
        return (
          G.forEach(this, (n, r) => {
            n != null && n !== !1 && (i[r] = e && G.isArray(n) ? n.join(', ') : n);
          }),
          i
        );
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([e, i]) => e + ': ' + i).join(`
`);
      }
      get [Symbol.toStringTag]() {
        return 'AxiosHeaders';
      }
      static from(e) {
        return e instanceof this ? e : new this(e);
      }
      static concat(e, ...i) {
        let n = new this(e);
        return i.forEach((r) => n.set(r)), n;
      }
      static accessor(e) {
        let n = (this[Uj] = this[Uj] = { accessors: {} }).accessors,
          r = this.prototype;
        function s(o) {
          let c = Fl(o);
          n[c] || (Vte(r, o), (n[c] = !0));
        }
        return G.isArray(e) ? e.forEach(s) : s(e), this;
      }
    };
    Cc.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);
    G.reduceDescriptors(Cc.prototype, ({ value: t }, e) => {
      let i = e[0].toUpperCase() + e.slice(1);
      return {
        get: () => t,
        set(n) {
          this[i] = n;
        },
      };
    });
    G.freezeMethods(Cc);
    qt = Cc;
  });
function jl(t, e) {
  let i = this || Sc,
    n = e || i,
    r = qt.from(n.headers),
    s = n.data;
  return (
    G.forEach(t, function (c) {
      s = c.call(i, s, r.normalize(), e ? e.status : void 0);
    }),
    r.normalize(),
    s
  );
}
var qj = te(() => {
  'use strict';
  ft();
  am();
  As();
});
function Ml(t) {
  return !!(t && t.__CANCEL__);
}
var OE = te(() => {
  'use strict';
});
function Bj(t, e, i) {
  be.call(this, t ?? 'canceled', be.ERR_CANCELED, e, i), (this.name = 'CanceledError');
}
var Tn,
  Rc = te(() => {
    'use strict';
    Rn();
    ft();
    G.inherits(Bj, be, { __CANCEL__: !0 });
    Tn = Bj;
  });
function Is(t, e, i) {
  let n = i.config.validateStatus;
  !i.status || !n || n(i.status)
    ? t(i)
    : e(
        new be(
          'Request failed with status code ' + i.status,
          [be.ERR_BAD_REQUEST, be.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4],
          i.config,
          i.request,
          i
        )
      );
}
var kE = te(() => {
  'use strict';
  Rn();
});
function AE(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
var Hj = te(() => {
  'use strict';
});
function IE(t, e) {
  return e ? t.replace(/\/?\/$/, '') + '/' + e.replace(/^\/+/, '') : t;
}
var Gj = te(() => {
  'use strict';
});
function jo(t, e) {
  return t && !AE(e) ? IE(t, e) : e;
}
var um = te(() => {
  'use strict';
  Hj();
  Gj();
});
var Mo,
  lm = te(() => {
    'use strict';
    Mo = '1.6.7';
  });
function Ul(t) {
  let e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return (e && e[1]) || '';
}
var NE = te(() => {
  'use strict';
});
function PE(t, e, i) {
  let n = (i && i.Blob) || Ut.classes.Blob,
    r = Ul(t);
  if ((e === void 0 && n && (e = !0), r === 'data')) {
    t = r.length ? t.slice(r.length + 1) : t;
    let s = $te.exec(t);
    if (!s) throw new be('Invalid URL', be.ERR_INVALID_URL);
    let o = s[1],
      c = s[2],
      u = s[3],
      l = Buffer.from(decodeURIComponent(u), c ? 'base64' : 'utf8');
    if (e) {
      if (!n) throw new be('Blob is not supported', be.ERR_NOT_SUPPORT);
      return new n([l], { type: o });
    }
    return l;
  }
  throw new be('Unsupported protocol ' + r, be.ERR_NOT_SUPPORT);
}
var $te,
  zj = te(() => {
    'use strict';
    Rn();
    NE();
    ks();
    $te = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
  });
function Wte(t, e) {
  let i = 0,
    n = 1e3 / e,
    r = null;
  return function (o, c) {
    let u = Date.now();
    if (o || u - i > n) return r && (clearTimeout(r), (r = null)), (i = u), t.apply(null, c);
    r || (r = setTimeout(() => ((r = null), (i = Date.now()), t.apply(null, c)), n - (u - i)));
  };
}
var Vj,
  $j = te(() => {
    'use strict';
    Vj = Wte;
  });
function Kte(t, e) {
  t = t || 10;
  let i = new Array(t),
    n = new Array(t),
    r = 0,
    s = 0,
    o;
  return (
    (e = e !== void 0 ? e : 1e3),
    function (u) {
      let l = Date.now(),
        p = n[s];
      o || (o = l), (i[r] = u), (n[r] = l);
      let d = s,
        x = 0;
      for (; d !== r; ) (x += i[d++]), (d = d % t);
      if (((r = (r + 1) % t), r === s && (s = (s + 1) % t), l - o < e)) return;
      let b = p && l - p;
      return b ? Math.round((x * 1e3) / b) : void 0;
    }
  );
}
var pm,
  LE = te(() => {
    'use strict';
    pm = Kte;
  });
var Wj,
  fm,
  DE,
  FE,
  Kj = te(() => {
    'use strict';
    Wj = je(require('stream'), 1);
    ft();
    $j();
    LE();
    (fm = Symbol('internals')),
      (DE = class extends Wj.default.Transform {
        constructor(e) {
          (e = G.toFlatObject(
            e,
            { maxRate: 0, chunkSize: 64 * 1024, minChunkSize: 100, timeWindow: 500, ticksRate: 2, samplesCount: 15 },
            null,
            (c, u) => !G.isUndefined(u[c])
          )),
            super({ readableHighWaterMark: e.chunkSize });
          let i = this,
            n = (this[fm] = {
              length: e.length,
              timeWindow: e.timeWindow,
              ticksRate: e.ticksRate,
              chunkSize: e.chunkSize,
              maxRate: e.maxRate,
              minChunkSize: e.minChunkSize,
              bytesSeen: 0,
              isCaptured: !1,
              notifiedBytesLoaded: 0,
              ts: Date.now(),
              bytes: 0,
              onReadCallback: null,
            }),
            r = pm(n.ticksRate * e.samplesCount, n.timeWindow);
          this.on('newListener', (c) => {
            c === 'progress' && (n.isCaptured || (n.isCaptured = !0));
          });
          let s = 0;
          n.updateProgress = Vj(function () {
            let u = n.length,
              l = n.bytesSeen,
              p = l - s;
            if (!p || i.destroyed) return;
            let d = r(p);
            (s = l),
              process.nextTick(() => {
                i.emit('progress', {
                  loaded: l,
                  total: u,
                  progress: u ? l / u : void 0,
                  bytes: p,
                  rate: d || void 0,
                  estimated: d && u && l <= u ? (u - l) / d : void 0,
                });
              });
          }, n.ticksRate);
          let o = () => {
            n.updateProgress(!0);
          };
          this.once('end', o), this.once('error', o);
        }
        _read(e) {
          let i = this[fm];
          return i.onReadCallback && i.onReadCallback(), super._read(e);
        }
        _transform(e, i, n) {
          let r = this,
            s = this[fm],
            o = s.maxRate,
            c = this.readableHighWaterMark,
            u = s.timeWindow,
            l = 1e3 / u,
            p = o / l,
            d = s.minChunkSize !== !1 ? Math.max(s.minChunkSize, p * 0.01) : 0;
          function x(g, y) {
            let h = Buffer.byteLength(g);
            (s.bytesSeen += h),
              (s.bytes += h),
              s.isCaptured && s.updateProgress(),
              r.push(g)
                ? process.nextTick(y)
                : (s.onReadCallback = () => {
                    (s.onReadCallback = null), process.nextTick(y);
                  });
          }
          let b = (g, y) => {
            let h = Buffer.byteLength(g),
              v = null,
              C = c,
              _,
              m = 0;
            if (o) {
              let O = Date.now();
              (!s.ts || (m = O - s.ts) >= u) && ((s.ts = O), (_ = p - s.bytes), (s.bytes = _ < 0 ? -_ : 0), (m = 0)),
                (_ = p - s.bytes);
            }
            if (o) {
              if (_ <= 0)
                return setTimeout(() => {
                  y(null, g);
                }, u - m);
              _ < C && (C = _);
            }
            C && h > C && h - C > d && ((v = g.subarray(C)), (g = g.subarray(0, C))),
              x(
                g,
                v
                  ? () => {
                      process.nextTick(y, null, v);
                    }
                  : y
              );
          };
          b(e, function g(y, h) {
            if (y) return n(y);
            h ? b(h, g) : n(null);
          });
        }
        setLength(e) {
          return (this[fm].length = +e), this;
        }
      }),
      (FE = DE);
  });
var Xj,
  Xte,
  dm,
  jE = te(() => {
    'use strict';
    ({ asyncIterator: Xj } = Symbol),
      (Xte = async function* (t) {
        t.stream ? yield* t.stream() : t.arrayBuffer ? yield await t.arrayBuffer() : t[Xj] ? yield* t[Xj]() : yield t;
      }),
      (dm = Xte);
  });
var Yj,
  Jj,
  Yte,
  ql,
  Ns,
  Jte,
  Zte,
  ME,
  Qte,
  Zj,
  Qj = te(() => {
    'use strict';
    (Yj = require('util')), (Jj = require('stream'));
    ft();
    jE();
    (Yte = G.ALPHABET.ALPHA_DIGIT + '-_'),
      (ql = new Yj.TextEncoder()),
      (Ns = `\r
`),
      (Jte = ql.encode(Ns)),
      (Zte = 2),
      (ME = class {
        constructor(e, i) {
          let { escapeName: n } = this.constructor,
            r = G.isString(i),
            s = `Content-Disposition: form-data; name="${n(e)}"${!r && i.name ? `; filename="${n(i.name)}"` : ''}${Ns}`;
          r
            ? (i = ql.encode(String(i).replace(/\r?\n|\r\n?/g, Ns)))
            : (s += `Content-Type: ${i.type || 'application/octet-stream'}${Ns}`),
            (this.headers = ql.encode(s + Ns)),
            (this.contentLength = r ? i.byteLength : i.size),
            (this.size = this.headers.byteLength + this.contentLength + Zte),
            (this.name = e),
            (this.value = i);
        }
        async *encode() {
          yield this.headers;
          let { value: e } = this;
          G.isTypedArray(e) ? yield e : yield* dm(e), yield Jte;
        }
        static escapeName(e) {
          return String(e).replace(/[\r\n"]/g, (i) => ({ '\r': '%0D', '\n': '%0A', '"': '%22' }[i]));
        }
      }),
      (Qte = (t, e, i) => {
        let { tag: n = 'form-data-boundary', size: r = 25, boundary: s = n + '-' + G.generateString(r, Yte) } = i || {};
        if (!G.isFormData(t)) throw TypeError('FormData instance required');
        if (s.length < 1 || s.length > 70) throw Error('boundary must be 10-70 characters long');
        let o = ql.encode('--' + s + Ns),
          c = ql.encode('--' + s + '--' + Ns + Ns),
          u = c.byteLength,
          l = Array.from(t.entries()).map(([d, x]) => {
            let b = new ME(d, x);
            return (u += b.size), b;
          });
        (u += o.byteLength * l.length), (u = G.toFiniteNumber(u));
        let p = { 'Content-Type': `multipart/form-data; boundary=${s}` };
        return (
          Number.isFinite(u) && (p['Content-Length'] = u),
          e && e(p),
          Jj.Readable.from(
            (async function* () {
              for (let d of l) yield o, yield* d.encode();
              yield c;
            })()
          )
        );
      }),
      (Zj = Qte);
  });
var eM,
  UE,
  tM,
  iM = te(() => {
    'use strict';
    (eM = je(require('stream'), 1)),
      (UE = class extends eM.default.Transform {
        __transform(e, i, n) {
          this.push(e), n();
        }
        _transform(e, i, n) {
          if (e.length !== 0 && ((this._transform = this.__transform), e[0] !== 120)) {
            let r = Buffer.alloc(2);
            (r[0] = 120), (r[1] = 156), this.push(r, i);
          }
          this.__transform(e, i, n);
        }
      }),
      (tM = UE);
  });
var eie,
  nM,
  rM = te(() => {
    'use strict';
    ft();
    (eie = (t, e) =>
      G.isAsyncFn(t)
        ? function (...i) {
            let n = i.pop();
            t.apply(this, i).then((r) => {
              try {
                e ? n(null, ...e(r)) : n(null, r);
              } catch (s) {
                n(s);
              }
            }, n);
          }
        : t),
      (nM = eie);
  });
function sie(t, e) {
  t.beforeRedirects.proxy && t.beforeRedirects.proxy(t), t.beforeRedirects.config && t.beforeRedirects.config(t, e);
}
function mM(t, e, i) {
  let n = e;
  if (!n && n !== !1) {
    let r = (0, uM.getProxyForUrl)(i);
    r && (n = new URL(r));
  }
  if (n) {
    if ((n.username && (n.auth = (n.username || '') + ':' + (n.password || '')), n.auth)) {
      (n.auth.username || n.auth.password) && (n.auth = (n.auth.username || '') + ':' + (n.auth.password || ''));
      let s = Buffer.from(n.auth, 'utf8').toString('base64');
      t.headers['Proxy-Authorization'] = 'Basic ' + s;
    }
    t.headers.host = t.hostname + (t.port ? ':' + t.port : '');
    let r = n.hostname || n.host;
    (t.hostname = r),
      (t.host = r),
      (t.port = n.port),
      (t.path = i),
      n.protocol && (t.protocol = n.protocol.includes(':') ? n.protocol : `${n.protocol}:`);
  }
  t.beforeRedirects.proxy = function (s) {
    mM(s, e, s.href);
  };
}
var uM,
  lM,
  pM,
  fM,
  dM,
  Pr,
  Uo,
  hM,
  sM,
  tie,
  oM,
  iie,
  nie,
  rie,
  aM,
  oie,
  aie,
  cie,
  cM,
  gM,
  xM = te(() => {
    'use strict';
    ft();
    kE();
    um();
    rm();
    (uM = je(eg(), 1)),
      (lM = je(require('http'), 1)),
      (pM = je(require('https'), 1)),
      (fM = je(require('util'), 1)),
      (dM = je(xg(), 1)),
      (Pr = je(require('zlib'), 1));
    lm();
    sm();
    Rn();
    Rc();
    ks();
    zj();
    Uo = je(require('stream'), 1);
    As();
    Kj();
    hM = je(require('events'), 1);
    Qj();
    jE();
    iM();
    rM();
    (sM = { flush: Pr.default.constants.Z_SYNC_FLUSH, finishFlush: Pr.default.constants.Z_SYNC_FLUSH }),
      (tie = {
        flush: Pr.default.constants.BROTLI_OPERATION_FLUSH,
        finishFlush: Pr.default.constants.BROTLI_OPERATION_FLUSH,
      }),
      (oM = G.isFunction(Pr.default.createBrotliDecompress)),
      ({ http: iie, https: nie } = dM.default),
      (rie = /https:?/),
      (aM = Ut.protocols.map((t) => t + ':'));
    (oie = typeof process < 'u' && G.kindOf(process) === 'process'),
      (aie = (t) =>
        new Promise((e, i) => {
          let n,
            r,
            s = (u, l) => {
              r || ((r = !0), n && n(u, l));
            },
            o = (u) => {
              s(u), e(u);
            },
            c = (u) => {
              s(u, !0), i(u);
            };
          t(o, c, (u) => (n = u)).catch(c);
        })),
      (cie = ({ address: t, family: e }) => {
        if (!G.isString(t)) throw TypeError('address must be a string');
        return { address: t, family: e || (t.indexOf('.') < 0 ? 6 : 4) };
      }),
      (cM = (t, e) => cie(G.isObject(t) ? t : { address: t, family: e })),
      (gM =
        oie &&
        function (e) {
          return aie(async function (n, r, s) {
            let { data: o, lookup: c, family: u } = e,
              { responseType: l, responseEncoding: p } = e,
              d = e.method.toUpperCase(),
              x,
              b = !1,
              g;
            if (c) {
              let q = nM(c, (B) => (G.isArray(B) ? B : [B]));
              c = (B, ee, xe) => {
                q(B, ee, (de, Z, oe) => {
                  if (de) return xe(de);
                  let I = G.isArray(Z) ? Z.map((X) => cM(X)) : [cM(Z, oe)];
                  ee.all ? xe(de, I) : xe(de, I[0].address, I[0].family);
                });
              };
            }
            let y = new hM.default(),
              h = () => {
                e.cancelToken && e.cancelToken.unsubscribe(v),
                  e.signal && e.signal.removeEventListener('abort', v),
                  y.removeAllListeners();
              };
            s((q, B) => {
              (x = !0), B && ((b = !0), h());
            });
            function v(q) {
              y.emit('abort', !q || q.type ? new Tn(null, e, g) : q);
            }
            y.once('abort', r),
              (e.cancelToken || e.signal) &&
                (e.cancelToken && e.cancelToken.subscribe(v),
                e.signal && (e.signal.aborted ? v() : e.signal.addEventListener('abort', v)));
            let C = jo(e.baseURL, e.url),
              _ = new URL(C, 'http://localhost'),
              m = _.protocol || aM[0];
            if (m === 'data:') {
              let q;
              if (d !== 'GET')
                return Is(n, r, { status: 405, statusText: 'method not allowed', headers: {}, config: e });
              try {
                q = PE(e.url, l === 'blob', { Blob: e.env && e.env.Blob });
              } catch (B) {
                throw be.from(B, be.ERR_BAD_REQUEST, e);
              }
              return (
                l === 'text'
                  ? ((q = q.toString(p)), (!p || p === 'utf8') && (q = G.stripBOM(q)))
                  : l === 'stream' && (q = Uo.default.Readable.from(q)),
                Is(n, r, { data: q, status: 200, statusText: 'OK', headers: new qt(), config: e })
              );
            }
            if (aM.indexOf(m) === -1) return r(new be('Unsupported protocol ' + m, be.ERR_BAD_REQUEST, e));
            let O = qt.from(e.headers).normalize();
            O.set('User-Agent', 'axios/' + Mo, !1);
            let N = e.onDownloadProgress,
              D = e.onUploadProgress,
              z = e.maxRate,
              H,
              F;
            if (G.isSpecCompliantForm(o)) {
              let q = O.getContentType(/boundary=([-_\w\d]{10,70})/i);
              o = Zj(
                o,
                (B) => {
                  O.set(B);
                },
                { tag: `axios-${Mo}-boundary`, boundary: (q && q[1]) || void 0 }
              );
            } else if (G.isFormData(o) && G.isFunction(o.getHeaders)) {
              if ((O.set(o.getHeaders()), !O.hasContentLength()))
                try {
                  let q = await fM.default.promisify(o.getLength).call(o);
                  Number.isFinite(q) && q >= 0 && O.setContentLength(q);
                } catch {}
            } else if (G.isBlob(o))
              o.size && O.setContentType(o.type || 'application/octet-stream'),
                O.setContentLength(o.size || 0),
                (o = Uo.default.Readable.from(dm(o)));
            else if (o && !G.isStream(o)) {
              if (!Buffer.isBuffer(o))
                if (G.isArrayBuffer(o)) o = Buffer.from(new Uint8Array(o));
                else if (G.isString(o)) o = Buffer.from(o, 'utf-8');
                else
                  return r(
                    new be(
                      'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
                      be.ERR_BAD_REQUEST,
                      e
                    )
                  );
              if ((O.setContentLength(o.length, !1), e.maxBodyLength > -1 && o.length > e.maxBodyLength))
                return r(new be('Request body larger than maxBodyLength limit', be.ERR_BAD_REQUEST, e));
            }
            let ne = G.toFiniteNumber(O.getContentLength());
            G.isArray(z) ? ((H = z[0]), (F = z[1])) : (H = F = z),
              o &&
                (D || H) &&
                (G.isStream(o) || (o = Uo.default.Readable.from(o, { objectMode: !1 })),
                (o = Uo.default.pipeline([o, new FE({ length: ne, maxRate: G.toFiniteNumber(H) })], G.noop)),
                D &&
                  o.on('progress', (q) => {
                    D(Object.assign(q, { upload: !0 }));
                  }));
            let pe;
            if (e.auth) {
              let q = e.auth.username || '',
                B = e.auth.password || '';
              pe = q + ':' + B;
            }
            if (!pe && _.username) {
              let q = _.username,
                B = _.password;
              pe = q + ':' + B;
            }
            pe && O.delete('authorization');
            let le;
            try {
              le = Fo(_.pathname + _.search, e.params, e.paramsSerializer).replace(/^\?/, '');
            } catch (q) {
              let B = new Error(q.message);
              return (B.config = e), (B.url = e.url), (B.exists = !0), r(B);
            }
            O.set('Accept-Encoding', 'gzip, compress, deflate' + (oM ? ', br' : ''), !1);
            let V = {
              path: le,
              method: d,
              headers: O.toJSON(),
              agents: { http: e.httpAgent, https: e.httpsAgent },
              auth: pe,
              protocol: m,
              family: u,
              beforeRedirect: sie,
              beforeRedirects: {},
            };
            !G.isUndefined(c) && (V.lookup = c),
              e.socketPath
                ? (V.socketPath = e.socketPath)
                : ((V.hostname = _.hostname),
                  (V.port = _.port),
                  mM(V, e.proxy, m + '//' + _.hostname + (_.port ? ':' + _.port : '') + V.path));
            let W,
              K = rie.test(V.protocol);
            if (
              ((V.agent = K ? e.httpsAgent : e.httpAgent),
              e.transport
                ? (W = e.transport)
                : e.maxRedirects === 0
                ? (W = K ? pM.default : lM.default)
                : (e.maxRedirects && (V.maxRedirects = e.maxRedirects),
                  e.beforeRedirect && (V.beforeRedirects.config = e.beforeRedirect),
                  (W = K ? nie : iie)),
              e.maxBodyLength > -1 ? (V.maxBodyLength = e.maxBodyLength) : (V.maxBodyLength = 1 / 0),
              e.insecureHTTPParser && (V.insecureHTTPParser = e.insecureHTTPParser),
              (g = W.request(V, function (B) {
                if (g.destroyed) return;
                let ee = [B],
                  xe = +B.headers['content-length'];
                if (N) {
                  let X = new FE({ length: G.toFiniteNumber(xe), maxRate: G.toFiniteNumber(F) });
                  N &&
                    X.on('progress', (Q) => {
                      N(Object.assign(Q, { download: !0 }));
                    }),
                    ee.push(X);
                }
                let de = B,
                  Z = B.req || g;
                if (e.decompress !== !1 && B.headers['content-encoding'])
                  switch (
                    ((d === 'HEAD' || B.statusCode === 204) && delete B.headers['content-encoding'],
                    (B.headers['content-encoding'] || '').toLowerCase())
                  ) {
                    case 'gzip':
                    case 'x-gzip':
                    case 'compress':
                    case 'x-compress':
                      ee.push(Pr.default.createUnzip(sM)), delete B.headers['content-encoding'];
                      break;
                    case 'deflate':
                      ee.push(new tM()), ee.push(Pr.default.createUnzip(sM)), delete B.headers['content-encoding'];
                      break;
                    case 'br':
                      oM && (ee.push(Pr.default.createBrotliDecompress(tie)), delete B.headers['content-encoding']);
                  }
                de = ee.length > 1 ? Uo.default.pipeline(ee, G.noop) : ee[0];
                let oe = Uo.default.finished(de, () => {
                    oe(), h();
                  }),
                  I = {
                    status: B.statusCode,
                    statusText: B.statusMessage,
                    headers: new qt(B.headers),
                    config: e,
                    request: Z,
                  };
                if (l === 'stream') (I.data = de), Is(n, r, I);
                else {
                  let X = [],
                    Q = 0;
                  de.on('data', function (ce) {
                    X.push(ce),
                      (Q += ce.length),
                      e.maxContentLength > -1 &&
                        Q > e.maxContentLength &&
                        ((b = !0),
                        de.destroy(),
                        r(
                          new be(
                            'maxContentLength size of ' + e.maxContentLength + ' exceeded',
                            be.ERR_BAD_RESPONSE,
                            e,
                            Z
                          )
                        ));
                  }),
                    de.on('aborted', function () {
                      if (b) return;
                      let ce = new be(
                        'maxContentLength size of ' + e.maxContentLength + ' exceeded',
                        be.ERR_BAD_RESPONSE,
                        e,
                        Z
                      );
                      de.destroy(ce), r(ce);
                    }),
                    de.on('error', function (ce) {
                      g.destroyed || r(be.from(ce, null, e, Z));
                    }),
                    de.on('end', function () {
                      try {
                        let ce = X.length === 1 ? X[0] : Buffer.concat(X);
                        l !== 'arraybuffer' && ((ce = ce.toString(p)), (!p || p === 'utf8') && (ce = G.stripBOM(ce))),
                          (I.data = ce);
                      } catch (ce) {
                        return r(be.from(ce, null, e, I.request, I));
                      }
                      Is(n, r, I);
                    });
                }
                y.once('abort', (X) => {
                  de.destroyed || (de.emit('error', X), de.destroy());
                });
              })),
              y.once('abort', (q) => {
                r(q), g.destroy(q);
              }),
              g.on('error', function (B) {
                r(be.from(B, null, e, g));
              }),
              g.on('socket', function (B) {
                B.setKeepAlive(!0, 1e3 * 60);
              }),
              e.timeout)
            ) {
              let q = parseInt(e.timeout, 10);
              if (Number.isNaN(q)) {
                r(new be('error trying to parse `config.timeout` to int', be.ERR_BAD_OPTION_VALUE, e, g));
                return;
              }
              g.setTimeout(q, function () {
                if (x) return;
                let ee = e.timeout ? 'timeout of ' + e.timeout + 'ms exceeded' : 'timeout exceeded',
                  xe = e.transitional || _c;
                e.timeoutErrorMessage && (ee = e.timeoutErrorMessage),
                  r(new be(ee, xe.clarifyTimeoutError ? be.ETIMEDOUT : be.ECONNABORTED, e, g)),
                  v();
              });
            }
            if (G.isStream(o)) {
              let q = !1,
                B = !1;
              o.on('end', () => {
                q = !0;
              }),
                o.once('error', (ee) => {
                  (B = !0), g.destroy(ee);
                }),
                o.on('close', () => {
                  !q && !B && v(new Tn('Request stream has been aborted', e, g));
                }),
                o.pipe(g);
            } else g.end(o);
          });
        });
  });
var yM,
  bM = te(() => {
    'use strict';
    ft();
    ks();
    yM = Ut.hasStandardBrowserEnv
      ? {
          write(t, e, i, n, r, s) {
            let o = [t + '=' + encodeURIComponent(e)];
            G.isNumber(i) && o.push('expires=' + new Date(i).toGMTString()),
              G.isString(n) && o.push('path=' + n),
              G.isString(r) && o.push('domain=' + r),
              s === !0 && o.push('secure'),
              (document.cookie = o.join('; '));
          },
          read(t) {
            let e = document.cookie.match(new RegExp('(^|;\\s*)(' + t + ')=([^;]*)'));
            return e ? decodeURIComponent(e[3]) : null;
          },
          remove(t) {
            this.write(t, '', Date.now() - 864e5);
          },
        }
      : {
          write() {},
          read() {
            return null;
          },
          remove() {},
        };
  });
var vM,
  wM = te(() => {
    'use strict';
    ft();
    ks();
    vM = Ut.hasStandardBrowserEnv
      ? (function () {
          let e = /(msie|trident)/i.test(navigator.userAgent),
            i = document.createElement('a'),
            n;
          function r(s) {
            let o = s;
            return (
              e && (i.setAttribute('href', o), (o = i.href)),
              i.setAttribute('href', o),
              {
                href: i.href,
                protocol: i.protocol ? i.protocol.replace(/:$/, '') : '',
                host: i.host,
                search: i.search ? i.search.replace(/^\?/, '') : '',
                hash: i.hash ? i.hash.replace(/^#/, '') : '',
                hostname: i.hostname,
                port: i.port,
                pathname: i.pathname.charAt(0) === '/' ? i.pathname : '/' + i.pathname,
              }
            );
          }
          return (
            (n = r(window.location.href)),
            function (o) {
              let c = G.isString(o) ? r(o) : o;
              return c.protocol === n.protocol && c.host === n.host;
            }
          );
        })()
      : (function () {
          return function () {
            return !0;
          };
        })();
  });
function EM(t, e) {
  let i = 0,
    n = pm(50, 250);
  return (r) => {
    let s = r.loaded,
      o = r.lengthComputable ? r.total : void 0,
      c = s - i,
      u = n(c),
      l = s <= o;
    i = s;
    let p = {
      loaded: s,
      total: o,
      progress: o ? s / o : void 0,
      bytes: c,
      rate: u || void 0,
      estimated: u && o && l ? (o - s) / u : void 0,
      event: r,
    };
    (p[e ? 'download' : 'upload'] = !0), t(p);
  };
}
var uie,
  _M,
  SM = te(() => {
    'use strict';
    ft();
    kE();
    bM();
    rm();
    um();
    wM();
    sm();
    Rn();
    Rc();
    NE();
    ks();
    As();
    LE();
    (uie = typeof XMLHttpRequest < 'u'),
      (_M =
        uie &&
        function (t) {
          return new Promise(function (i, n) {
            let r = t.data,
              s = qt.from(t.headers).normalize(),
              { responseType: o, withXSRFToken: c } = t,
              u;
            function l() {
              t.cancelToken && t.cancelToken.unsubscribe(u), t.signal && t.signal.removeEventListener('abort', u);
            }
            let p;
            if (G.isFormData(r)) {
              if (Ut.hasStandardBrowserEnv || Ut.hasStandardBrowserWebWorkerEnv) s.setContentType(!1);
              else if ((p = s.getContentType()) !== !1) {
                let [y, ...h] = p
                  ? p
                      .split(';')
                      .map((v) => v.trim())
                      .filter(Boolean)
                  : [];
                s.setContentType([y || 'multipart/form-data', ...h].join('; '));
              }
            }
            let d = new XMLHttpRequest();
            if (t.auth) {
              let y = t.auth.username || '',
                h = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : '';
              s.set('Authorization', 'Basic ' + btoa(y + ':' + h));
            }
            let x = jo(t.baseURL, t.url);
            d.open(t.method.toUpperCase(), Fo(x, t.params, t.paramsSerializer), !0), (d.timeout = t.timeout);
            function b() {
              if (!d) return;
              let y = qt.from('getAllResponseHeaders' in d && d.getAllResponseHeaders()),
                v = {
                  data: !o || o === 'text' || o === 'json' ? d.responseText : d.response,
                  status: d.status,
                  statusText: d.statusText,
                  headers: y,
                  config: t,
                  request: d,
                };
              Is(
                function (_) {
                  i(_), l();
                },
                function (_) {
                  n(_), l();
                },
                v
              ),
                (d = null);
            }
            if (
              ('onloadend' in d
                ? (d.onloadend = b)
                : (d.onreadystatechange = function () {
                    !d ||
                      d.readyState !== 4 ||
                      (d.status === 0 && !(d.responseURL && d.responseURL.indexOf('file:') === 0)) ||
                      setTimeout(b);
                  }),
              (d.onabort = function () {
                d && (n(new be('Request aborted', be.ECONNABORTED, t, d)), (d = null));
              }),
              (d.onerror = function () {
                n(new be('Network Error', be.ERR_NETWORK, t, d)), (d = null);
              }),
              (d.ontimeout = function () {
                let h = t.timeout ? 'timeout of ' + t.timeout + 'ms exceeded' : 'timeout exceeded',
                  v = t.transitional || _c;
                t.timeoutErrorMessage && (h = t.timeoutErrorMessage),
                  n(new be(h, v.clarifyTimeoutError ? be.ETIMEDOUT : be.ECONNABORTED, t, d)),
                  (d = null);
              }),
              Ut.hasStandardBrowserEnv && (c && G.isFunction(c) && (c = c(t)), c || (c !== !1 && vM(x))))
            ) {
              let y = t.xsrfHeaderName && t.xsrfCookieName && yM.read(t.xsrfCookieName);
              y && s.set(t.xsrfHeaderName, y);
            }
            r === void 0 && s.setContentType(null),
              'setRequestHeader' in d &&
                G.forEach(s.toJSON(), function (h, v) {
                  d.setRequestHeader(v, h);
                }),
              G.isUndefined(t.withCredentials) || (d.withCredentials = !!t.withCredentials),
              o && o !== 'json' && (d.responseType = t.responseType),
              typeof t.onDownloadProgress == 'function' && d.addEventListener('progress', EM(t.onDownloadProgress, !0)),
              typeof t.onUploadProgress == 'function' &&
                d.upload &&
                d.upload.addEventListener('progress', EM(t.onUploadProgress)),
              (t.cancelToken || t.signal) &&
                ((u = (y) => {
                  d && (n(!y || y.type ? new Tn(null, t, d) : y), d.abort(), (d = null));
                }),
                t.cancelToken && t.cancelToken.subscribe(u),
                t.signal && (t.signal.aborted ? u() : t.signal.addEventListener('abort', u)));
            let g = Ul(x);
            if (g && Ut.protocols.indexOf(g) === -1) {
              n(new be('Unsupported protocol ' + g + ':', be.ERR_BAD_REQUEST, t));
              return;
            }
            d.send(r || null);
          });
        });
  });
var qE,
  CM,
  lie,
  hm,
  BE = te(() => {
    'use strict';
    ft();
    xM();
    SM();
    Rn();
    qE = { http: gM, xhr: _M };
    G.forEach(qE, (t, e) => {
      if (t) {
        try {
          Object.defineProperty(t, 'name', { value: e });
        } catch {}
        Object.defineProperty(t, 'adapterName', { value: e });
      }
    });
    (CM = (t) => `- ${t}`),
      (lie = (t) => G.isFunction(t) || t === null || t === !1),
      (hm = {
        getAdapter: (t) => {
          t = G.isArray(t) ? t : [t];
          let { length: e } = t,
            i,
            n,
            r = {};
          for (let s = 0; s < e; s++) {
            i = t[s];
            let o;
            if (((n = i), !lie(i) && ((n = qE[(o = String(i)).toLowerCase()]), n === void 0)))
              throw new be(`Unknown adapter '${o}'`);
            if (n) break;
            r[o || '#' + s] = n;
          }
          if (!n) {
            let s = Object.entries(r).map(
                ([c, u]) =>
                  `adapter ${c} ` + (u === !1 ? 'is not supported by the environment' : 'is not available in the build')
              ),
              o = e
                ? s.length > 1
                  ? `since :
` +
                    s.map(CM).join(`
`)
                  : ' ' + CM(s[0])
                : 'as no adapter specified';
            throw new be('There is no suitable adapter to dispatch the request ' + o, 'ERR_NOT_SUPPORT');
          }
          return n;
        },
        adapters: qE,
      });
  });
function HE(t) {
  if ((t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)) throw new Tn(null, t);
}
function mm(t) {
  return (
    HE(t),
    (t.headers = qt.from(t.headers)),
    (t.data = jl.call(t, t.transformRequest)),
    ['post', 'put', 'patch'].indexOf(t.method) !== -1 &&
      t.headers.setContentType('application/x-www-form-urlencoded', !1),
    hm
      .getAdapter(t.adapter || Sc.adapter)(t)
      .then(
        function (n) {
          return HE(t), (n.data = jl.call(t, t.transformResponse, n)), (n.headers = qt.from(n.headers)), n;
        },
        function (n) {
          return (
            Ml(n) ||
              (HE(t),
              n &&
                n.response &&
                ((n.response.data = jl.call(t, t.transformResponse, n.response)),
                (n.response.headers = qt.from(n.response.headers)))),
            Promise.reject(n)
          );
        }
      )
  );
}
var RM = te(() => {
  'use strict';
  qj();
  OE();
  am();
  Rc();
  As();
  BE();
});
function Lr(t, e) {
  e = e || {};
  let i = {};
  function n(l, p, d) {
    return G.isPlainObject(l) && G.isPlainObject(p)
      ? G.merge.call({ caseless: d }, l, p)
      : G.isPlainObject(p)
      ? G.merge({}, p)
      : G.isArray(p)
      ? p.slice()
      : p;
  }
  function r(l, p, d) {
    if (G.isUndefined(p)) {
      if (!G.isUndefined(l)) return n(void 0, l, d);
    } else return n(l, p, d);
  }
  function s(l, p) {
    if (!G.isUndefined(p)) return n(void 0, p);
  }
  function o(l, p) {
    if (G.isUndefined(p)) {
      if (!G.isUndefined(l)) return n(void 0, l);
    } else return n(void 0, p);
  }
  function c(l, p, d) {
    if (d in e) return n(l, p);
    if (d in t) return n(void 0, l);
  }
  let u = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: c,
    headers: (l, p) => r(TM(l), TM(p), !0),
  };
  return (
    G.forEach(Object.keys(Object.assign({}, t, e)), function (p) {
      let d = u[p] || r,
        x = d(t[p], e[p], p);
      (G.isUndefined(x) && d !== c) || (i[p] = x);
    }),
    i
  );
}
var TM,
  GE = te(() => {
    'use strict';
    ft();
    As();
    TM = (t) => (t instanceof qt ? t.toJSON() : t);
  });
function pie(t, e, i) {
  if (typeof t != 'object') throw new be('options must be an object', be.ERR_BAD_OPTION_VALUE);
  let n = Object.keys(t),
    r = n.length;
  for (; r-- > 0; ) {
    let s = n[r],
      o = e[s];
    if (o) {
      let c = t[s],
        u = c === void 0 || o(c, s, t);
      if (u !== !0) throw new be('option ' + s + ' must be ' + u, be.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (i !== !0) throw new be('Unknown option ' + s, be.ERR_BAD_OPTION);
  }
}
var zE,
  OM,
  gm,
  kM = te(() => {
    'use strict';
    lm();
    Rn();
    zE = {};
    ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((t, e) => {
      zE[t] = function (n) {
        return typeof n === t || 'a' + (e < 1 ? 'n ' : ' ') + t;
      };
    });
    OM = {};
    zE.transitional = function (e, i, n) {
      function r(s, o) {
        return '[Axios v' + Mo + "] Transitional option '" + s + "'" + o + (n ? '. ' + n : '');
      }
      return (s, o, c) => {
        if (e === !1) throw new be(r(o, ' has been removed' + (i ? ' in ' + i : '')), be.ERR_DEPRECATED);
        return (
          i &&
            !OM[o] &&
            ((OM[o] = !0),
            console.warn(r(o, ' has been deprecated since v' + i + ' and will be removed in the near future'))),
          e ? e(s, o, c) : !0
        );
      };
    };
    gm = { assertOptions: pie, validators: zE };
  });
var Ps,
  Tc,
  Bl,
  AM = te(() => {
    'use strict';
    ft();
    rm();
    Oj();
    RM();
    GE();
    um();
    kM();
    As();
    (Ps = gm.validators),
      (Tc = class {
        constructor(e) {
          (this.defaults = e), (this.interceptors = { request: new EE(), response: new EE() });
        }
        async request(e, i) {
          try {
            return await this._request(e, i);
          } catch (n) {
            if (n instanceof Error) {
              let r;
              Error.captureStackTrace ? Error.captureStackTrace((r = {})) : (r = new Error());
              let s = r.stack ? r.stack.replace(/^.+\n/, '') : '';
              n.stack
                ? s &&
                  !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, '')) &&
                  (n.stack +=
                    `
` + s)
                : (n.stack = s);
            }
            throw n;
          }
        }
        _request(e, i) {
          typeof e == 'string' ? ((i = i || {}), (i.url = e)) : (i = e || {}), (i = Lr(this.defaults, i));
          let { transitional: n, paramsSerializer: r, headers: s } = i;
          n !== void 0 &&
            gm.assertOptions(
              n,
              {
                silentJSONParsing: Ps.transitional(Ps.boolean),
                forcedJSONParsing: Ps.transitional(Ps.boolean),
                clarifyTimeoutError: Ps.transitional(Ps.boolean),
              },
              !1
            ),
            r != null &&
              (G.isFunction(r)
                ? (i.paramsSerializer = { serialize: r })
                : gm.assertOptions(r, { encode: Ps.function, serialize: Ps.function }, !0)),
            (i.method = (i.method || this.defaults.method || 'get').toLowerCase());
          let o = s && G.merge(s.common, s[i.method]);
          s &&
            G.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], (g) => {
              delete s[g];
            }),
            (i.headers = qt.concat(o, s));
          let c = [],
            u = !0;
          this.interceptors.request.forEach(function (y) {
            (typeof y.runWhen == 'function' && y.runWhen(i) === !1) ||
              ((u = u && y.synchronous), c.unshift(y.fulfilled, y.rejected));
          });
          let l = [];
          this.interceptors.response.forEach(function (y) {
            l.push(y.fulfilled, y.rejected);
          });
          let p,
            d = 0,
            x;
          if (!u) {
            let g = [mm.bind(this), void 0];
            for (g.unshift.apply(g, c), g.push.apply(g, l), x = g.length, p = Promise.resolve(i); d < x; )
              p = p.then(g[d++], g[d++]);
            return p;
          }
          x = c.length;
          let b = i;
          for (d = 0; d < x; ) {
            let g = c[d++],
              y = c[d++];
            try {
              b = g(b);
            } catch (h) {
              y.call(this, h);
              break;
            }
          }
          try {
            p = mm.call(this, b);
          } catch (g) {
            return Promise.reject(g);
          }
          for (d = 0, x = l.length; d < x; ) p = p.then(l[d++], l[d++]);
          return p;
        }
        getUri(e) {
          e = Lr(this.defaults, e);
          let i = jo(e.baseURL, e.url);
          return Fo(i, e.params, e.paramsSerializer);
        }
      });
    G.forEach(['delete', 'get', 'head', 'options'], function (e) {
      Tc.prototype[e] = function (i, n) {
        return this.request(Lr(n || {}, { method: e, url: i, data: (n || {}).data }));
      };
    });
    G.forEach(['post', 'put', 'patch'], function (e) {
      function i(n) {
        return function (s, o, c) {
          return this.request(
            Lr(c || {}, { method: e, headers: n ? { 'Content-Type': 'multipart/form-data' } : {}, url: s, data: o })
          );
        };
      }
      (Tc.prototype[e] = i()), (Tc.prototype[e + 'Form'] = i(!0));
    });
    Bl = Tc;
  });
var VE,
  IM,
  NM = te(() => {
    'use strict';
    Rc();
    (VE = class t {
      constructor(e) {
        if (typeof e != 'function') throw new TypeError('executor must be a function.');
        let i;
        this.promise = new Promise(function (s) {
          i = s;
        });
        let n = this;
        this.promise.then((r) => {
          if (!n._listeners) return;
          let s = n._listeners.length;
          for (; s-- > 0; ) n._listeners[s](r);
          n._listeners = null;
        }),
          (this.promise.then = (r) => {
            let s,
              o = new Promise((c) => {
                n.subscribe(c), (s = c);
              }).then(r);
            return (
              (o.cancel = function () {
                n.unsubscribe(s);
              }),
              o
            );
          }),
          e(function (s, o, c) {
            n.reason || ((n.reason = new Tn(s, o, c)), i(n.reason));
          });
      }
      throwIfRequested() {
        if (this.reason) throw this.reason;
      }
      subscribe(e) {
        if (this.reason) {
          e(this.reason);
          return;
        }
        this._listeners ? this._listeners.push(e) : (this._listeners = [e]);
      }
      unsubscribe(e) {
        if (!this._listeners) return;
        let i = this._listeners.indexOf(e);
        i !== -1 && this._listeners.splice(i, 1);
      }
      static source() {
        let e;
        return {
          token: new t(function (r) {
            e = r;
          }),
          cancel: e,
        };
      }
    }),
      (IM = VE);
  });
function $E(t) {
  return function (i) {
    return t.apply(null, i);
  };
}
var PM = te(() => {
  'use strict';
});
function WE(t) {
  return G.isObject(t) && t.isAxiosError === !0;
}
var LM = te(() => {
  'use strict';
  ft();
});
var KE,
  DM,
  FM = te(() => {
    'use strict';
    KE = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
    };
    Object.entries(KE).forEach(([t, e]) => {
      KE[e] = t;
    });
    DM = KE;
  });
function jM(t) {
  let e = new Bl(t),
    i = Nl(Bl.prototype.request, e);
  return (
    G.extend(i, Bl.prototype, e, { allOwnKeys: !0 }),
    G.extend(i, e, null, { allOwnKeys: !0 }),
    (i.create = function (r) {
      return jM(Lr(t, r));
    }),
    i
  );
}
var Lt,
  xm,
  MM = te(() => {
    'use strict';
    ft();
    mE();
    AM();
    GE();
    am();
    CE();
    Rc();
    NM();
    OE();
    lm();
    Dl();
    Rn();
    PM();
    LM();
    As();
    BE();
    FM();
    Lt = jM(Sc);
    Lt.Axios = Bl;
    Lt.CanceledError = Tn;
    Lt.CancelToken = IM;
    Lt.isCancel = Ml;
    Lt.VERSION = Mo;
    Lt.toFormData = Os;
    Lt.AxiosError = be;
    Lt.Cancel = Lt.CanceledError;
    Lt.all = function (e) {
      return Promise.all(e);
    };
    Lt.spread = $E;
    Lt.isAxiosError = WE;
    Lt.mergeConfig = Lr;
    Lt.AxiosHeaders = qt;
    Lt.formToJSON = (t) => om(G.isHTMLForm(t) ? new FormData(t) : t);
    Lt.getAdapter = hm.getAdapter;
    Lt.HttpStatusCode = DM;
    Lt.default = Lt;
    xm = Lt;
  });
var bge,
  vge,
  wge,
  Ege,
  _ge,
  Sge,
  Cge,
  Rge,
  Tge,
  Oge,
  kge,
  Age,
  Ige,
  Nge,
  Pge,
  Lge,
  UM = te(() => {
    'use strict';
    MM();
    ({
      Axios: bge,
      AxiosError: vge,
      CanceledError: wge,
      isCancel: Ege,
      CancelToken: _ge,
      VERSION: Sge,
      all: Cge,
      Cancel: Rge,
      isAxiosError: Tge,
      spread: Oge,
      toFormData: kge,
      AxiosHeaders: Age,
      HttpStatusCode: Ige,
      formToJSON: Nge,
      getAdapter: Pge,
      mergeConfig: Lge,
    } = xm);
  });
var GM = P((Fge, Hl) => {
  'use strict';
  var fie = typeof process < 'u' && process.env.TERM_PROGRAM === 'Hyper',
    die = typeof process < 'u' && process.platform === 'win32',
    qM = typeof process < 'u' && process.platform === 'linux',
    XE = {
      ballotDisabled: '\u2612',
      ballotOff: '\u2610',
      ballotOn: '\u2611',
      bullet: '\u2022',
      bulletWhite: '\u25E6',
      fullBlock: '\u2588',
      heart: '\u2764',
      identicalTo: '\u2261',
      line: '\u2500',
      mark: '\u203B',
      middot: '\xB7',
      minus: '\uFF0D',
      multiplication: '\xD7',
      obelus: '\xF7',
      pencilDownRight: '\u270E',
      pencilRight: '\u270F',
      pencilUpRight: '\u2710',
      percent: '%',
      pilcrow2: '\u2761',
      pilcrow: '\xB6',
      plusMinus: '\xB1',
      question: '?',
      section: '\xA7',
      starsOff: '\u2606',
      starsOn: '\u2605',
      upDownArrow: '\u2195',
    },
    BM = Object.assign({}, XE, {
      check: '\u221A',
      cross: '\xD7',
      ellipsisLarge: '...',
      ellipsis: '...',
      info: 'i',
      questionSmall: '?',
      pointer: '>',
      pointerSmall: '\xBB',
      radioOff: '( )',
      radioOn: '(*)',
      warning: '\u203C',
    }),
    HM = Object.assign({}, XE, {
      ballotCross: '\u2718',
      check: '\u2714',
      cross: '\u2716',
      ellipsisLarge: '\u22EF',
      ellipsis: '\u2026',
      info: '\u2139',
      questionFull: '\uFF1F',
      questionSmall: '\uFE56',
      pointer: qM ? '\u25B8' : '\u276F',
      pointerSmall: qM ? '\u2023' : '\u203A',
      radioOff: '\u25EF',
      radioOn: '\u25C9',
      warning: '\u26A0',
    });
  Hl.exports = die && !fie ? BM : HM;
  Reflect.defineProperty(Hl.exports, 'common', { enumerable: !1, value: XE });
  Reflect.defineProperty(Hl.exports, 'windows', { enumerable: !1, value: BM });
  Reflect.defineProperty(Hl.exports, 'other', { enumerable: !1, value: HM });
});
var ym = P((jge, YE) => {
  'use strict';
  var hie = (t) => t !== null && typeof t == 'object' && !Array.isArray(t),
    mie =
      /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g,
    gie = () => (typeof process < 'u' ? process.env.FORCE_COLOR !== '0' : !1),
    zM = () => {
      let t = { enabled: gie(), visible: !0, styles: {}, keys: {} },
        e = (s) => {
          let o = (s.open = `\x1B[${s.codes[0]}m`),
            c = (s.close = `\x1B[${s.codes[1]}m`),
            u = (s.regex = new RegExp(`\\u001b\\[${s.codes[1]}m`, 'g'));
          return (
            (s.wrap = (l, p) => {
              l.includes(c) && (l = l.replace(u, c + o));
              let d = o + l + c;
              return p ? d.replace(/\r*\n/g, `${c}$&${o}`) : d;
            }),
            s
          );
        },
        i = (s, o, c) => (typeof s == 'function' ? s(o) : s.wrap(o, c)),
        n = (s, o) => {
          if (s === '' || s == null) return '';
          if (t.enabled === !1) return s;
          if (t.visible === !1) return '';
          let c = '' + s,
            u = c.includes(`
`),
            l = o.length;
          for (l > 0 && o.includes('unstyle') && (o = [...new Set(['unstyle', ...o])].reverse()); l-- > 0; )
            c = i(t.styles[o[l]], c, u);
          return c;
        },
        r = (s, o, c) => {
          (t.styles[s] = e({ name: s, codes: o })),
            (t.keys[c] || (t.keys[c] = [])).push(s),
            Reflect.defineProperty(t, s, {
              configurable: !0,
              enumerable: !0,
              set(l) {
                t.alias(s, l);
              },
              get() {
                let l = (p) => n(p, l.stack);
                return Reflect.setPrototypeOf(l, t), (l.stack = this.stack ? this.stack.concat(s) : [s]), l;
              },
            });
        };
      return (
        r('reset', [0, 0], 'modifier'),
        r('bold', [1, 22], 'modifier'),
        r('dim', [2, 22], 'modifier'),
        r('italic', [3, 23], 'modifier'),
        r('underline', [4, 24], 'modifier'),
        r('inverse', [7, 27], 'modifier'),
        r('hidden', [8, 28], 'modifier'),
        r('strikethrough', [9, 29], 'modifier'),
        r('black', [30, 39], 'color'),
        r('red', [31, 39], 'color'),
        r('green', [32, 39], 'color'),
        r('yellow', [33, 39], 'color'),
        r('blue', [34, 39], 'color'),
        r('magenta', [35, 39], 'color'),
        r('cyan', [36, 39], 'color'),
        r('white', [37, 39], 'color'),
        r('gray', [90, 39], 'color'),
        r('grey', [90, 39], 'color'),
        r('bgBlack', [40, 49], 'bg'),
        r('bgRed', [41, 49], 'bg'),
        r('bgGreen', [42, 49], 'bg'),
        r('bgYellow', [43, 49], 'bg'),
        r('bgBlue', [44, 49], 'bg'),
        r('bgMagenta', [45, 49], 'bg'),
        r('bgCyan', [46, 49], 'bg'),
        r('bgWhite', [47, 49], 'bg'),
        r('blackBright', [90, 39], 'bright'),
        r('redBright', [91, 39], 'bright'),
        r('greenBright', [92, 39], 'bright'),
        r('yellowBright', [93, 39], 'bright'),
        r('blueBright', [94, 39], 'bright'),
        r('magentaBright', [95, 39], 'bright'),
        r('cyanBright', [96, 39], 'bright'),
        r('whiteBright', [97, 39], 'bright'),
        r('bgBlackBright', [100, 49], 'bgBright'),
        r('bgRedBright', [101, 49], 'bgBright'),
        r('bgGreenBright', [102, 49], 'bgBright'),
        r('bgYellowBright', [103, 49], 'bgBright'),
        r('bgBlueBright', [104, 49], 'bgBright'),
        r('bgMagentaBright', [105, 49], 'bgBright'),
        r('bgCyanBright', [106, 49], 'bgBright'),
        r('bgWhiteBright', [107, 49], 'bgBright'),
        (t.ansiRegex = mie),
        (t.hasColor = t.hasAnsi =
          (s) => ((t.ansiRegex.lastIndex = 0), typeof s == 'string' && s !== '' && t.ansiRegex.test(s))),
        (t.alias = (s, o) => {
          let c = typeof o == 'string' ? t[o] : o;
          if (typeof c != 'function')
            throw new TypeError('Expected alias to be the name of an existing color (string) or a function');
          c.stack || (Reflect.defineProperty(c, 'name', { value: s }), (t.styles[s] = c), (c.stack = [s])),
            Reflect.defineProperty(t, s, {
              configurable: !0,
              enumerable: !0,
              set(u) {
                t.alias(s, u);
              },
              get() {
                let u = (l) => n(l, u.stack);
                return Reflect.setPrototypeOf(u, t), (u.stack = this.stack ? this.stack.concat(c.stack) : c.stack), u;
              },
            });
        }),
        (t.theme = (s) => {
          if (!hie(s)) throw new TypeError('Expected theme to be an object');
          for (let o of Object.keys(s)) t.alias(o, s[o]);
          return t;
        }),
        t.alias('unstyle', (s) =>
          typeof s == 'string' && s !== '' ? ((t.ansiRegex.lastIndex = 0), s.replace(t.ansiRegex, '')) : ''
        ),
        t.alias('noop', (s) => s),
        (t.none = t.clear = t.noop),
        (t.stripColor = t.unstyle),
        (t.symbols = GM()),
        (t.define = r),
        t
      );
    };
  YE.exports = zM();
  YE.exports.create = zM;
});
var hi = P((Ge) => {
  'use strict';
  var xie = Object.prototype.toString,
    pn = ym(),
    VM = !1,
    Gl = new Set(),
    $M = {
      yellow: 'blue',
      cyan: 'red',
      green: 'magenta',
      black: 'white',
      blue: 'yellow',
      red: 'cyan',
      magenta: 'green',
      white: 'black',
    };
  Ge.longest = (t, e) => t.reduce((i, n) => Math.max(i, e ? n[e].length : n.length), 0);
  Ge.hasColor = (t) => !!t && pn.hasColor(t);
  var bm = (Ge.isObject = (t) => t !== null && typeof t == 'object' && !Array.isArray(t));
  Ge.nativeType = (t) => xie.call(t).slice(8, -1).toLowerCase().replace(/\s/g, '');
  Ge.isAsyncFn = (t) => Ge.nativeType(t) === 'asyncfunction';
  Ge.isPrimitive = (t) => t != null && typeof t != 'object' && typeof t != 'function';
  Ge.resolve = (t, e, ...i) => (typeof e == 'function' ? e.call(t, ...i) : e);
  Ge.scrollDown = (t = []) => [...t.slice(1), t[0]];
  Ge.scrollUp = (t = []) => [t.pop(), ...t];
  Ge.reorder = (t = []) => {
    let e = t.slice();
    return e.sort((i, n) => (i.index > n.index ? 1 : i.index < n.index ? -1 : 0)), e;
  };
  Ge.swap = (t, e, i) => {
    let n = t.length,
      r = i === n ? 0 : i < 0 ? n - 1 : i,
      s = t[e];
    (t[e] = t[r]), (t[r] = s);
  };
  Ge.width = (t, e = 80) => {
    let i = t && t.columns ? t.columns : e;
    return (
      t && typeof t.getWindowSize == 'function' && (i = t.getWindowSize()[0]), process.platform === 'win32' ? i - 1 : i
    );
  };
  Ge.height = (t, e = 20) => {
    let i = t && t.rows ? t.rows : e;
    return t && typeof t.getWindowSize == 'function' && (i = t.getWindowSize()[1]), i;
  };
  Ge.wordWrap = (t, e = {}) => {
    if (!t) return t;
    typeof e == 'number' && (e = { width: e });
    let {
        indent: i = '',
        newline: n = `
` + i,
        width: r = 80,
      } = e,
      s = (n + i).match(/[^\S\n]/g) || [];
    r -= s.length;
    let o = `.{1,${r}}([\\s\\u200B]+|$)|[^\\s\\u200B]+?([\\s\\u200B]+|$)`,
      c = t.trim(),
      u = new RegExp(o, 'g'),
      l = c.match(u) || [];
    return (
      (l = l.map((p) => p.replace(/\n$/, ''))),
      e.padEnd && (l = l.map((p) => p.padEnd(r, ' '))),
      e.padStart && (l = l.map((p) => p.padStart(r, ' '))),
      i + l.join(n)
    );
  };
  Ge.unmute = (t) => {
    let e = t.stack.find((n) => pn.keys.color.includes(n));
    return e ? pn[e] : t.stack.find((n) => n.slice(2) === 'bg') ? pn[e.slice(2)] : (n) => n;
  };
  Ge.pascal = (t) => (t ? t[0].toUpperCase() + t.slice(1) : '');
  Ge.inverse = (t) => {
    if (!t || !t.stack) return t;
    let e = t.stack.find((n) => pn.keys.color.includes(n));
    if (e) {
      let n = pn['bg' + Ge.pascal(e)];
      return n ? n.black : t;
    }
    let i = t.stack.find((n) => n.slice(0, 2) === 'bg');
    return i ? pn[i.slice(2).toLowerCase()] || t : pn.none;
  };
  Ge.complement = (t) => {
    if (!t || !t.stack) return t;
    let e = t.stack.find((n) => pn.keys.color.includes(n)),
      i = t.stack.find((n) => n.slice(0, 2) === 'bg');
    if (e && !i) return pn[$M[e] || e];
    if (i) {
      let n = i.slice(2).toLowerCase(),
        r = $M[n];
      return (r && pn['bg' + Ge.pascal(r)]) || t;
    }
    return pn.none;
  };
  Ge.meridiem = (t) => {
    let e = t.getHours(),
      i = t.getMinutes(),
      n = e >= 12 ? 'pm' : 'am';
    e = e % 12;
    let r = e === 0 ? 12 : e,
      s = i < 10 ? '0' + i : i;
    return r + ':' + s + ' ' + n;
  };
  Ge.set = (t = {}, e = '', i) =>
    e.split('.').reduce((n, r, s, o) => {
      let c = o.length - 1 > s ? n[r] || {} : i;
      return !Ge.isObject(c) && s < o.length - 1 && (c = {}), (n[r] = c);
    }, t);
  Ge.get = (t = {}, e = '', i) => {
    let n = t[e] == null ? e.split('.').reduce((r, s) => r && r[s], t) : t[e];
    return n ?? i;
  };
  Ge.mixin = (t, e) => {
    if (!bm(t)) return e;
    if (!bm(e)) return t;
    for (let i of Object.keys(e)) {
      let n = Object.getOwnPropertyDescriptor(e, i);
      if (hasOwnProperty.call(n, 'value'))
        if (hasOwnProperty.call(t, i) && bm(n.value)) {
          let r = Object.getOwnPropertyDescriptor(t, i);
          bm(r.value) && r.value !== n.value ? (t[i] = Ge.merge({}, t[i], e[i])) : Reflect.defineProperty(t, i, n);
        } else Reflect.defineProperty(t, i, n);
      else Reflect.defineProperty(t, i, n);
    }
    return t;
  };
  Ge.merge = (...t) => {
    let e = {};
    for (let i of t) Ge.mixin(e, i);
    return e;
  };
  Ge.mixinEmitter = (t, e) => {
    let i = e.constructor.prototype;
    for (let n of Object.keys(i)) {
      let r = i[n];
      typeof r == 'function' ? Ge.define(t, n, r.bind(e)) : Ge.define(t, n, r);
    }
  };
  var vm = (t, e) => {
      VM || ((VM = !0), Gl.forEach((i) => i()), t === !0 && process.exit(128 + e));
    },
    WM = vm.bind(null, !0, 15),
    KM = vm.bind(null, !0, 2);
  Ge.onExit = (t) => (
    Gl.size === 0 && (process.once('SIGTERM', WM), process.once('SIGINT', KM), process.once('exit', vm)),
    Gl.add(t),
    () => {
      Gl.delete(t), Gl.size === 0 && (process.off('SIGTERM', WM), process.off('SIGINT', KM), process.off('exit', vm));
    }
  );
  Ge.define = (t, e, i) => {
    Reflect.defineProperty(t, e, { value: i });
  };
  Ge.defineExport = (t, e, i) => {
    let n;
    Reflect.defineProperty(t, e, {
      enumerable: !0,
      configurable: !0,
      set(r) {
        n = r;
      },
      get() {
        return n ? n() : i();
      },
    });
  };
});
var YM = P((Uge, XM) => {
  'use strict';
  XM.exports = ({ onlyFirst: t = !1 } = {}) => {
    let e = [
      '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
      '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))',
    ].join('|');
    return new RegExp(e, t ? void 0 : 'g');
  };
});
var Ls = P((qge, JM) => {
  'use strict';
  var yie = YM();
  JM.exports = (t) => (typeof t == 'string' ? t.replace(yie(), '') : t);
});
var ZM = P((Oc) => {
  'use strict';
  Oc.ctrl = {
    a: 'first',
    b: 'backward',
    c: 'cancel',
    d: 'deleteForward',
    e: 'last',
    f: 'forward',
    g: 'reset',
    i: 'tab',
    k: 'cutForward',
    l: 'reset',
    n: 'newItem',
    m: 'cancel',
    j: 'submit',
    p: 'search',
    r: 'remove',
    s: 'save',
    u: 'undo',
    w: 'cutLeft',
    x: 'toggleCursor',
    v: 'paste',
  };
  Oc.shift = { up: 'shiftUp', down: 'shiftDown', left: 'shiftLeft', right: 'shiftRight', tab: 'prev' };
  Oc.fn = { up: 'pageUp', down: 'pageDown', left: 'pageLeft', right: 'pageRight', delete: 'deleteForward' };
  Oc.option = { b: 'backward', f: 'forward', d: 'cutRight', left: 'cutLeft', up: 'altUp', down: 'altDown' };
  Oc.keys = {
    pageup: 'pageUp',
    pagedown: 'pageDown',
    home: 'home',
    end: 'end',
    cancel: 'cancel',
    delete: 'deleteForward',
    backspace: 'delete',
    down: 'down',
    enter: 'submit',
    escape: 'cancel',
    left: 'left',
    space: 'space',
    number: 'number',
    return: 'submit',
    right: 'right',
    tab: 'next',
    up: 'up',
  };
});
var eU = P((Gge, QM) => {
  'use strict';
  QM.exports = class {
    _queue = [];
    _executing = !1;
    _jobRunner = null;
    constructor(e) {
      this._jobRunner = e;
    }
    enqueue = (...e) => {
      this._queue.push(e), this._dequeue();
    };
    destroy() {
      (this._queue.length = 0), (this._jobRunner = null);
    }
    _dequeue() {
      this._executing ||
        !this._queue.length ||
        ((this._executing = !0),
        this._jobRunner(...this._queue.shift()),
        setTimeout(() => {
          (this._executing = !1), this._dequeue();
        }));
    }
  };
});
var JE = P((zge, iU) => {
  'use strict';
  var tU = require('readline'),
    bie = ZM(),
    vie = eU(),
    wie = /^(?:\x1b)([a-zA-Z0-9])$/,
    Eie = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/,
    _ie = {
      OP: 'f1',
      OQ: 'f2',
      OR: 'f3',
      OS: 'f4',
      '[11~': 'f1',
      '[12~': 'f2',
      '[13~': 'f3',
      '[14~': 'f4',
      '[[A': 'f1',
      '[[B': 'f2',
      '[[C': 'f3',
      '[[D': 'f4',
      '[[E': 'f5',
      '[15~': 'f5',
      '[17~': 'f6',
      '[18~': 'f7',
      '[19~': 'f8',
      '[20~': 'f9',
      '[21~': 'f10',
      '[23~': 'f11',
      '[24~': 'f12',
      '[A': 'up',
      '[B': 'down',
      '[C': 'right',
      '[D': 'left',
      '[E': 'clear',
      '[F': 'end',
      '[H': 'home',
      OA: 'up',
      OB: 'down',
      OC: 'right',
      OD: 'left',
      OE: 'clear',
      OF: 'end',
      OH: 'home',
      '[1~': 'home',
      '[2~': 'insert',
      '[3~': 'delete',
      '[4~': 'end',
      '[5~': 'pageup',
      '[6~': 'pagedown',
      '[[5~': 'pageup',
      '[[6~': 'pagedown',
      '[7~': 'home',
      '[8~': 'end',
      '[a': 'up',
      '[b': 'down',
      '[c': 'right',
      '[d': 'left',
      '[e': 'clear',
      '[2$': 'insert',
      '[3$': 'delete',
      '[5$': 'pageup',
      '[6$': 'pagedown',
      '[7$': 'home',
      '[8$': 'end',
      Oa: 'up',
      Ob: 'down',
      Oc: 'right',
      Od: 'left',
      Oe: 'clear',
      '[2^': 'insert',
      '[3^': 'delete',
      '[5^': 'pageup',
      '[6^': 'pagedown',
      '[7^': 'home',
      '[8^': 'end',
      '[Z': 'tab',
    };
  function Sie(t) {
    return ['[a', '[b', '[c', '[d', '[e', '[2$', '[3$', '[5$', '[6$', '[7$', '[8$', '[Z'].includes(t);
  }
  function Cie(t) {
    return ['Oa', 'Ob', 'Oc', 'Od', 'Oe', '[2^', '[3^', '[5^', '[6^', '[7^', '[8^'].includes(t);
  }
  var wm = (t = '', e = {}) => {
    let i,
      n = { name: e.name, ctrl: !1, meta: !1, shift: !1, option: !1, sequence: t, raw: t, ...e };
    if (
      (Buffer.isBuffer(t)
        ? t[0] > 127 && t[1] === void 0
          ? ((t[0] -= 128), (t = '\x1B' + String(t)))
          : (t = String(t))
        : t !== void 0 && typeof t != 'string'
        ? (t = String(t))
        : t || (t = n.sequence || ''),
      (n.sequence = n.sequence || t || n.name),
      t === '\r')
    )
      (n.raw = void 0), (n.name = 'return');
    else if (
      t ===
      `
`
    )
      n.name = 'enter';
    else if (t === '	') n.name = 'tab';
    else if (t === '\b' || t === '\x7F' || t === '\x1B\x7F' || t === '\x1B\b')
      (n.name = 'backspace'), (n.meta = t.charAt(0) === '\x1B');
    else if (t === '\x1B' || t === '\x1B\x1B') (n.name = 'escape'), (n.meta = t.length === 2);
    else if (t === ' ' || t === '\x1B ') (n.name = 'space'), (n.meta = t.length === 2);
    else if (t <= '') (n.name = String.fromCharCode(t.charCodeAt(0) + 97 - 1)), (n.ctrl = !0);
    else if (t.length === 1 && t >= '0' && t <= '9') n.name = 'number';
    else if (t.length === 1 && t >= 'a' && t <= 'z') n.name = t;
    else if (t.length === 1 && t >= 'A' && t <= 'Z') (n.name = t.toLowerCase()), (n.shift = !0);
    else if ((i = wie.exec(t))) (n.meta = !0), (n.shift = /^[A-Z]$/.test(i[1]));
    else if ((i = Eie.exec(t))) {
      let r = [...t];
      r[0] === '\x1B' && r[1] === '\x1B' && (n.option = !0);
      let s = [i[1], i[2], i[4], i[6]].filter(Boolean).join(''),
        o = (i[3] || i[5] || 1) - 1;
      (n.ctrl = !!(o & 4)),
        (n.meta = !!(o & 10)),
        (n.shift = !!(o & 1)),
        (n.code = s),
        (n.name = _ie[s]),
        (n.shift = Sie(s) || n.shift),
        (n.ctrl = Cie(s) || n.ctrl);
    }
    return n;
  };
  wm.listen = (t = {}, e) => {
    let { stdin: i } = t;
    if (!i || (i !== process.stdin && !i.isTTY)) throw new Error('Invalid stream passed');
    let n = tU.createInterface({ terminal: !0, input: i });
    tU.emitKeypressEvents(i, n);
    let r = new vie((c, u) => e(c, wm(c, u), n)),
      s = i.isRaw;
    return (
      i.isTTY && i.setRawMode(!0),
      i.on('keypress', r.enqueue),
      n.resume(),
      () => {
        i.isTTY && i.setRawMode(s), i.removeListener('keypress', r.enqueue), r.destroy(), n.pause(), n.close();
      }
    );
  };
  wm.action = (t, e, i) => {
    let n = { ...bie, ...i };
    return e.ctrl
      ? ((e.action = n.ctrl[e.name]), e)
      : e.option && n.option
      ? ((e.action = n.option[e.name]), e)
      : e.shift
      ? ((e.action = n.shift[e.name]), e)
      : ((e.action = n.keys[e.name]), e);
  };
  iU.exports = wm;
});
var rU = P((Vge, nU) => {
  'use strict';
  nU.exports = (t) => {
    t.timers = t.timers || {};
    let e = t.options.timers;
    if (e)
      for (let i of Object.keys(e)) {
        let n = e[i];
        typeof n == 'number' && (n = { interval: n }), Rie(t, i, n);
      }
  };
  function Rie(t, e, i = {}) {
    let n = (t.timers[e] = { name: e, start: Date.now(), ms: 0, tick: 0 }),
      r = i.interval || 120;
    (n.frames = i.frames || []), (n.loading = !0);
    let s = setInterval(() => {
      (n.ms = Date.now() - n.start), n.tick++, t.render();
    }, r);
    return (
      (n.stop = () => {
        (n.loading = !1), clearInterval(s);
      }),
      Reflect.defineProperty(n, 'interval', { value: s }),
      t.once('close', () => n.stop()),
      n.stop
    );
  }
});
var oU = P(($ge, sU) => {
  'use strict';
  var { define: Tie, width: Oie } = hi(),
    ZE = class {
      constructor(e) {
        let i = e.options;
        Tie(this, '_prompt', e),
          (this.type = e.type),
          (this.name = e.name),
          (this.message = ''),
          (this.header = ''),
          (this.footer = ''),
          (this.error = ''),
          (this.hint = ''),
          (this.input = ''),
          (this.cursor = 0),
          (this.index = 0),
          (this.lines = 0),
          (this.tick = 0),
          (this.prompt = ''),
          (this.buffer = ''),
          (this.width = Oie(i.stdout || process.stdout)),
          Object.assign(this, i),
          (this.name = this.name || this.message),
          (this.message = this.message || this.name),
          (this.symbols = e.symbols),
          (this.styles = e.styles),
          (this.required = new Set()),
          (this.cancelled = !1),
          (this.submitted = !1);
      }
      clone() {
        let e = { ...this };
        return (e.status = this.status), (e.buffer = Buffer.from(e.buffer)), delete e.clone, e;
      }
      set color(e) {
        this._color = e;
      }
      get color() {
        let e = this.prompt.styles;
        if (this.cancelled) return e.cancelled;
        if (this.submitted) return e.submitted;
        let i = this._color || e[this.status];
        return typeof i == 'function' ? i : e.pending;
      }
      set loading(e) {
        this._loading = e;
      }
      get loading() {
        return typeof this._loading == 'boolean' ? this._loading : this.loadingChoices ? 'choices' : !1;
      }
      get status() {
        return this.cancelled ? 'cancelled' : this.submitted ? 'submitted' : 'pending';
      }
    };
  sU.exports = ZE;
});
var cU = P((Wge, aU) => {
  'use strict';
  var QE = hi(),
    si = ym(),
    e_ = {
      default: si.noop,
      noop: si.noop,
      set inverse(t) {
        this._inverse = t;
      },
      get inverse() {
        return this._inverse || QE.inverse(this.primary);
      },
      set complement(t) {
        this._complement = t;
      },
      get complement() {
        return this._complement || QE.complement(this.primary);
      },
      primary: si.cyan,
      success: si.green,
      danger: si.magenta,
      strong: si.bold,
      warning: si.yellow,
      muted: si.dim,
      disabled: si.gray,
      dark: si.dim.gray,
      underline: si.underline,
      set info(t) {
        this._info = t;
      },
      get info() {
        return this._info || this.primary;
      },
      set em(t) {
        this._em = t;
      },
      get em() {
        return this._em || this.primary.underline;
      },
      set heading(t) {
        this._heading = t;
      },
      get heading() {
        return this._heading || this.muted.underline;
      },
      set pending(t) {
        this._pending = t;
      },
      get pending() {
        return this._pending || this.primary;
      },
      set submitted(t) {
        this._submitted = t;
      },
      get submitted() {
        return this._submitted || this.success;
      },
      set cancelled(t) {
        this._cancelled = t;
      },
      get cancelled() {
        return this._cancelled || this.danger;
      },
      set typing(t) {
        this._typing = t;
      },
      get typing() {
        return this._typing || this.dim;
      },
      set placeholder(t) {
        this._placeholder = t;
      },
      get placeholder() {
        return this._placeholder || this.primary.dim;
      },
      set highlight(t) {
        this._highlight = t;
      },
      get highlight() {
        return this._highlight || this.inverse;
      },
    };
  e_.merge = (t = {}) => {
    t.styles && typeof t.styles.enabled == 'boolean' && (si.enabled = t.styles.enabled),
      t.styles && typeof t.styles.visible == 'boolean' && (si.visible = t.styles.visible);
    let e = QE.merge({}, e_, t.styles);
    delete e.merge;
    for (let i of Object.keys(si)) hasOwnProperty.call(e, i) || Reflect.defineProperty(e, i, { get: () => si[i] });
    for (let i of Object.keys(si.styles))
      hasOwnProperty.call(e, i) || Reflect.defineProperty(e, i, { get: () => si[i] });
    return e;
  };
  aU.exports = e_;
});
var lU = P((Kge, uU) => {
  'use strict';
  var t_ = process.platform === 'win32',
    Dr = ym(),
    kie = hi(),
    i_ = {
      ...Dr.symbols,
      upDownDoubleArrow: '\u21D5',
      upDownDoubleArrow2: '\u2B0D',
      upDownArrow: '\u2195',
      asterisk: '*',
      asterism: '\u2042',
      bulletWhite: '\u25E6',
      electricArrow: '\u2301',
      ellipsisLarge: '\u22EF',
      ellipsisSmall: '\u2026',
      fullBlock: '\u2588',
      identicalTo: '\u2261',
      indicator: Dr.symbols.check,
      leftAngle: '\u2039',
      mark: '\u203B',
      minus: '\u2212',
      multiplication: '\xD7',
      obelus: '\xF7',
      percent: '%',
      pilcrow: '\xB6',
      pilcrow2: '\u2761',
      pencilUpRight: '\u2710',
      pencilDownRight: '\u270E',
      pencilRight: '\u270F',
      plus: '+',
      plusMinus: '\xB1',
      pointRight: '\u261E',
      rightAngle: '\u203A',
      section: '\xA7',
      hexagon: { off: '\u2B21', on: '\u2B22', disabled: '\u2B22' },
      ballot: { on: '\u2611', off: '\u2610', disabled: '\u2612' },
      stars: { on: '\u2605', off: '\u2606', disabled: '\u2606' },
      folder: { on: '\u25BC', off: '\u25B6', disabled: '\u25B6' },
      prefix: { pending: Dr.symbols.question, submitted: Dr.symbols.check, cancelled: Dr.symbols.cross },
      separator: { pending: Dr.symbols.pointerSmall, submitted: Dr.symbols.middot, cancelled: Dr.symbols.middot },
      radio: { off: t_ ? '( )' : '\u25EF', on: t_ ? '(*)' : '\u25C9', disabled: t_ ? '(|)' : '\u24BE' },
      numbers: [
        '\u24EA',
        '\u2460',
        '\u2461',
        '\u2462',
        '\u2463',
        '\u2464',
        '\u2465',
        '\u2466',
        '\u2467',
        '\u2468',
        '\u2469',
        '\u246A',
        '\u246B',
        '\u246C',
        '\u246D',
        '\u246E',
        '\u246F',
        '\u2470',
        '\u2471',
        '\u2472',
        '\u2473',
        '\u3251',
        '\u3252',
        '\u3253',
        '\u3254',
        '\u3255',
        '\u3256',
        '\u3257',
        '\u3258',
        '\u3259',
        '\u325A',
        '\u325B',
        '\u325C',
        '\u325D',
        '\u325E',
        '\u325F',
        '\u32B1',
        '\u32B2',
        '\u32B3',
        '\u32B4',
        '\u32B5',
        '\u32B6',
        '\u32B7',
        '\u32B8',
        '\u32B9',
        '\u32BA',
        '\u32BB',
        '\u32BC',
        '\u32BD',
        '\u32BE',
        '\u32BF',
      ],
    };
  i_.merge = (t) => {
    let e = kie.merge({}, Dr.symbols, i_, t.symbols);
    return delete e.merge, e;
  };
  uU.exports = i_;
});
var fU = P((Xge, pU) => {
  'use strict';
  var Aie = cU(),
    Iie = lU(),
    Nie = hi();
  pU.exports = (t) => {
    (t.options = Nie.merge({}, t.options.theme, t.options)),
      (t.symbols = Iie.merge(t.options)),
      (t.styles = Aie.merge(t.options));
  };
});
var xU = P((mU, gU) => {
  'use strict';
  var dU = process.env.TERM_PROGRAM === 'Apple_Terminal',
    Pie = Ls(),
    n_ = hi(),
    On = (gU.exports = mU),
    gt = '\x1B[',
    hU = '\x07',
    r_ = !1,
    Ds = (On.code = {
      bell: hU,
      beep: hU,
      beginning: `${gt}G`,
      down: `${gt}J`,
      esc: gt,
      getPosition: `${gt}6n`,
      hide: `${gt}?25l`,
      line: `${gt}2K`,
      lineEnd: `${gt}K`,
      lineStart: `${gt}1K`,
      restorePosition: gt + (dU ? '8' : 'u'),
      savePosition: gt + (dU ? '7' : 's'),
      screen: `${gt}2J`,
      show: `${gt}?25h`,
      up: `${gt}1J`,
    }),
    qo = (On.cursor = {
      get hidden() {
        return r_;
      },
      hide() {
        return (r_ = !0), Ds.hide;
      },
      show() {
        return (r_ = !1), Ds.show;
      },
      forward: (t = 1) => `${gt}${t}C`,
      backward: (t = 1) => `${gt}${t}D`,
      nextLine: (t = 1) => `${gt}E`.repeat(t),
      prevLine: (t = 1) => `${gt}F`.repeat(t),
      up: (t = 1) => (t ? `${gt}${t}A` : ''),
      down: (t = 1) => (t ? `${gt}${t}B` : ''),
      right: (t = 1) => (t ? `${gt}${t}C` : ''),
      left: (t = 1) => (t ? `${gt}${t}D` : ''),
      to(t, e) {
        return e ? `${gt}${e + 1};${t + 1}H` : `${gt}${t + 1}G`;
      },
      move(t = 0, e = 0) {
        let i = '';
        return (
          (i += t < 0 ? qo.left(-t) : t > 0 ? qo.right(t) : ''), (i += e < 0 ? qo.up(-e) : e > 0 ? qo.down(e) : ''), i
        );
      },
      strLen(t) {
        for (var e = 0, i = t.length, n = -1, r = 0; r < i; r++)
          (n = t.charCodeAt(r)), n >= 0 && n <= 128 ? (e += 1) : (e += 2);
        return e;
      },
      restore(t = {}) {
        let { after: e, cursor: i, initial: n, input: r, prompt: s, size: o, value: c } = t;
        if (
          ((n = n_.isPrimitive(n) ? String(n) : ''),
          (r = n_.isPrimitive(r) ? String(r) : ''),
          (c = n_.isPrimitive(c) ? String(c) : ''),
          o)
        ) {
          let u = On.cursor.up(o) + On.cursor.to(this.strLen(s)),
            l = r.length - i;
          return l > 0 && (u += On.cursor.left(l)), u;
        }
        if (c || e) {
          let u = !r && n ? -this.strLen(n) : -this.strLen(r) + i;
          return (
            e && (u -= this.strLen(e)), r === '' && n && !s.includes(n) && (u += this.strLen(n)), On.cursor.move(u)
          );
        }
      },
    }),
    s_ = (On.erase = {
      screen: Ds.screen,
      up: Ds.up,
      down: Ds.down,
      line: Ds.line,
      lineEnd: Ds.lineEnd,
      lineStart: Ds.lineStart,
      lines(t) {
        let e = '';
        for (let i = 0; i < t; i++) e += On.erase.line + (i < t - 1 ? On.cursor.up(1) : '');
        return t && (e += On.code.beginning), e;
      },
    });
  On.clear = (t = '', e = process.stdout.columns) => {
    if (!e) return s_.line + qo.to(0);
    let i = (s) => [...Pie(s)].length,
      n = t.split(/\r?\n/),
      r = 0;
    for (let s of n) r += 1 + Math.floor(Math.max(i(s) - 1, 0) / e);
    return (s_.line + qo.prevLine()).repeat(r - 1) + s_.line + qo.to(0);
  };
});
var kc = P((Yge, bU) => {
  'use strict';
  var Lie = require('events'),
    yU = Ls(),
    o_ = JE(),
    Die = rU(),
    Fie = oU(),
    jie = fU(),
    Pi = hi(),
    Bo = xU(),
    a_ = class t extends Lie {
      constructor(e = {}) {
        super(),
          (this.name = e.name),
          (this.type = e.type),
          (this.options = e),
          jie(this),
          Die(this),
          (this.state = new Fie(this)),
          (this.initial = [e.initial, e.default].find((i) => i != null)),
          (this.stdout = e.stdout || process.stdout),
          (this.stdin = e.stdin || process.stdin),
          (this.scale = e.scale || 1),
          (this.term = this.options.term || process.env.TERM_PROGRAM),
          (this.margin = Uie(this.options.margin)),
          this.setMaxListeners(0),
          Mie(this);
      }
      async keypress(e, i = {}) {
        this.keypressed = !0;
        let n = o_.action(e, o_(e, i), this.options.actions);
        (this.state.keypress = n), this.emit('keypress', e, n), this.emit('state', this.state.clone());
        let r = this.options[n.action] || this[n.action] || this.dispatch;
        if (typeof r == 'function') return await r.call(this, e, n);
        this.alert();
      }
      alert() {
        delete this.state.alert, this.options.show === !1 ? this.emit('alert') : this.stdout.write(Bo.code.beep);
      }
      cursorHide() {
        this.stdout.write(Bo.cursor.hide());
        let e = Pi.onExit(() => this.cursorShow());
        this.on('close', () => {
          this.cursorShow(), e();
        });
      }
      cursorShow() {
        this.stdout.write(Bo.cursor.show());
      }
      write(e) {
        e && (this.stdout && this.state.show !== !1 && this.stdout.write(e), (this.state.buffer += e));
      }
      clear(e = 0) {
        let i = this.state.buffer;
        (this.state.buffer = ''),
          !((!i && !e) || this.options.show === !1) && this.stdout.write(Bo.cursor.down(e) + Bo.clear(i, this.width));
      }
      restore() {
        if (this.state.closed || this.options.show === !1) return;
        let { prompt: e, after: i, rest: n } = this.sections(),
          { cursor: r, initial: s = '', input: o = '', value: c = '' } = this,
          u = (this.state.size = n.length),
          l = { after: i, cursor: r, initial: s, input: o, prompt: e, size: u, value: c },
          p = Bo.cursor.restore(l);
        p && this.stdout.write(p);
      }
      sections() {
        let { buffer: e, input: i, prompt: n } = this.state;
        n = yU(n);
        let r = yU(e),
          s = r.indexOf(n),
          o = r.slice(0, s),
          u = r.slice(s).split(`
`),
          l = u[0],
          p = u[u.length - 1],
          x = (n + (i ? ' ' + i : '')).length,
          b = x < l.length ? l.slice(x + 1) : '';
        return { header: o, prompt: l, after: b, rest: u.slice(1), last: p };
      }
      async submit() {
        (this.state.submitted = !0),
          (this.state.validating = !0),
          this.options.onSubmit && (await this.options.onSubmit.call(this, this.name, this.value, this));
        let e = this.state.error || (await this.validate(this.value, this.state));
        if (e !== !0) {
          let i =
            `
` +
            this.symbols.pointer +
            ' ';
          typeof e == 'string' ? (i += e.trim()) : (i += 'Invalid input'),
            (this.state.error =
              `
` + this.styles.danger(i)),
            (this.state.submitted = !1),
            await this.render(),
            await this.alert(),
            (this.state.validating = !1),
            (this.state.error = void 0);
          return;
        }
        (this.state.validating = !1),
          await this.render(),
          await this.close(),
          (this.value = await this.result(this.value)),
          this.emit('submit', this.value);
      }
      async cancel(e) {
        (this.state.cancelled = this.state.submitted = !0),
          await this.render(),
          await this.close(),
          typeof this.options.onCancel == 'function' &&
            (await this.options.onCancel.call(this, this.name, this.value, this)),
          this.emit('cancel', await this.error(e));
      }
      async close() {
        this.state.closed = !0;
        try {
          let e = this.sections(),
            i = Math.ceil(e.prompt.length / this.width);
          e.rest && this.write(Bo.cursor.down(e.rest.length)),
            this.write(
              `
`.repeat(i)
            );
        } catch {}
        this.emit('close');
      }
      start() {
        !this.stop &&
          this.options.show !== !1 &&
          ((this.stop = o_.listen(this, this.keypress.bind(this))),
          this.once('close', this.stop),
          this.emit('start', this));
      }
      async skip() {
        return (
          (this.skipped = this.options.skip === !0),
          typeof this.options.skip == 'function' &&
            (this.skipped = await this.options.skip.call(this, this.name, this.value)),
          this.skipped
        );
      }
      async initialize() {
        let { format: e, options: i, result: n } = this;
        if (
          ((this.format = () => e.call(this, this.value)),
          (this.result = () => n.call(this, this.value)),
          typeof i.initial == 'function' && (this.initial = await i.initial.call(this, this)),
          typeof i.onRun == 'function' && (await i.onRun.call(this, this)),
          typeof i.onSubmit == 'function')
        ) {
          let r = i.onSubmit.bind(this),
            s = this.submit.bind(this);
          delete this.options.onSubmit, (this.submit = async () => (await r(this.name, this.value, this), s()));
        }
        await this.start(), await this.render();
      }
      render() {
        throw new Error('expected prompt to have a custom render method');
      }
      run() {
        return new Promise(async (e, i) => {
          if ((this.once('submit', e), this.once('cancel', i), await this.skip()))
            return (this.render = () => {}), this.submit();
          await this.initialize(), this.emit('run');
        });
      }
      async element(e, i, n) {
        let { options: r, state: s, symbols: o, timers: c } = this,
          u = c && c[e];
        s.timer = u;
        let l = r[e] || s[e] || o[e],
          p = i && i[e] != null ? i[e] : await l;
        if (p === '') return p;
        let d = await this.resolve(p, s, i, n);
        return !d && i && i[e] ? this.resolve(l, s, i, n) : d;
      }
      async prefix() {
        let e = (await this.element('prefix')) || this.symbols,
          i = this.timers && this.timers.prefix,
          n = this.state;
        return (
          (n.timer = i),
          Pi.isObject(e) && (e = e[n.status] || e.pending),
          Pi.hasColor(e) ? e : (this.styles[n.status] || this.styles.pending)(e)
        );
      }
      async message() {
        let e = await this.element('message');
        return Pi.hasColor(e) ? e : this.styles.strong(e);
      }
      async separator() {
        let e = (await this.element('separator')) || this.symbols,
          i = this.timers && this.timers.separator,
          n = this.state;
        n.timer = i;
        let r = e[n.status] || e.pending || n.separator,
          s = await this.resolve(r, n);
        return Pi.isObject(s) && (s = s[n.status] || s.pending), Pi.hasColor(s) ? s : this.styles.muted(s);
      }
      async pointer(e, i) {
        let n = await this.element('pointer', e, i);
        if (typeof n == 'string' && Pi.hasColor(n)) return n;
        if (n) {
          let r = this.styles,
            s = this.index === i,
            o = s ? r.primary : (l) => l,
            c = await this.resolve(n[s ? 'on' : 'off'] || n, this.state),
            u = Pi.hasColor(c) ? c : o(c);
          return s ? u : ' '.repeat(c.length);
        }
      }
      async indicator(e, i) {
        let n = await this.element('indicator', e, i);
        if (typeof n == 'string' && Pi.hasColor(n)) return n;
        if (n) {
          let r = this.styles,
            s = e.enabled === !0,
            o = s ? r.success : r.dark,
            c = n[s ? 'on' : 'off'] || n;
          return Pi.hasColor(c) ? c : o(c);
        }
        return '';
      }
      body() {
        return null;
      }
      footer() {
        if (this.state.status === 'pending') return this.element('footer');
      }
      header() {
        if (this.state.status === 'pending') return this.element('header');
      }
      async hint() {
        if (this.state.status === 'pending' && !this.isValue(this.state.input)) {
          let e = await this.element('hint');
          return Pi.hasColor(e) ? e : this.styles.muted(e);
        }
      }
      error(e) {
        return this.state.submitted ? '' : e || this.state.error;
      }
      format(e) {
        return e;
      }
      result(e) {
        return e;
      }
      validate(e) {
        return this.options.required === !0 ? this.isValue(e) : !0;
      }
      isValue(e) {
        return e != null && e !== '';
      }
      resolve(e, ...i) {
        return Pi.resolve(this, e, ...i);
      }
      get base() {
        return t.prototype;
      }
      get style() {
        return this.styles[this.state.status];
      }
      get height() {
        return this.options.rows || Pi.height(this.stdout, 25);
      }
      get width() {
        return this.options.columns || Pi.width(this.stdout, 80);
      }
      get size() {
        return { width: this.width, height: this.height };
      }
      set cursor(e) {
        this.state.cursor = e;
      }
      get cursor() {
        return this.state.cursor;
      }
      set input(e) {
        this.state.input = e;
      }
      get input() {
        return this.state.input;
      }
      set value(e) {
        this.state.value = e;
      }
      get value() {
        let { input: e, value: i } = this.state,
          n = [i, e].find(this.isValue.bind(this));
        return this.isValue(n) ? n : this.initial;
      }
      static get prompt() {
        return (e) => new this(e).run();
      }
    };
  function Mie(t) {
    let e = (r) => t[r] === void 0 || typeof t[r] == 'function',
      i = ['actions', 'choices', 'initial', 'margin', 'roles', 'styles', 'symbols', 'theme', 'timers', 'value'],
      n = ['body', 'footer', 'error', 'header', 'hint', 'indicator', 'message', 'prefix', 'separator', 'skip'];
    for (let r of Object.keys(t.options)) {
      if (i.includes(r) || /^on[A-Z]/.test(r)) continue;
      let s = t.options[r];
      typeof s == 'function' && e(r) ? n.includes(r) || (t[r] = s.bind(t)) : typeof t[r] != 'function' && (t[r] = s);
    }
  }
  function Uie(t) {
    typeof t == 'number' && (t = [t, t, t, t]);
    let e = [].concat(t || []),
      i = (r) =>
        r % 2 === 0
          ? `
`
          : ' ',
      n = [];
    for (let r = 0; r < 4; r++) {
      let s = i(r);
      e[r] ? n.push(s.repeat(e[r])) : n.push('');
    }
    return n;
  }
  bU.exports = a_;
});
var EU = P((Jge, wU) => {
  'use strict';
  var qie = hi(),
    vU = {
      default(t, e) {
        return e;
      },
      checkbox(t, e) {
        throw new Error('checkbox role is not implemented yet');
      },
      editable(t, e) {
        throw new Error('editable role is not implemented yet');
      },
      expandable(t, e) {
        throw new Error('expandable role is not implemented yet');
      },
      heading(t, e) {
        return (
          (e.disabled = ''), (e.indicator = [e.indicator, ' '].find((i) => i != null)), (e.message = e.message || ''), e
        );
      },
      input(t, e) {
        throw new Error('input role is not implemented yet');
      },
      option(t, e) {
        return vU.default(t, e);
      },
      radio(t, e) {
        throw new Error('radio role is not implemented yet');
      },
      separator(t, e) {
        return (
          (e.disabled = ''),
          (e.indicator = [e.indicator, ' '].find((i) => i != null)),
          (e.message = e.message || t.symbols.line.repeat(5)),
          e
        );
      },
      spacer(t, e) {
        return e;
      },
    };
  wU.exports = (t, e = {}) => {
    let i = qie.merge({}, vU, e.roles);
    return i[t] || i.default;
  };
});
var zl = P((Zge, CU) => {
  'use strict';
  var Bie = Ls(),
    Hie = kc(),
    Gie = EU(),
    Em = hi(),
    { reorder: c_, scrollUp: zie, scrollDown: Vie, isObject: _U, swap: $ie } = Em,
    u_ = class extends Hie {
      constructor(e) {
        super(e),
          this.cursorHide(),
          (this.maxSelected = e.maxSelected || 1 / 0),
          (this.multiple = e.multiple || !1),
          (this.initial = e.initial || 0),
          (this.delay = e.delay || 0),
          (this.longest = 0),
          (this.num = '');
      }
      async initialize() {
        typeof this.options.initial == 'function' && (this.initial = await this.options.initial.call(this)),
          await this.reset(!0),
          await super.initialize();
      }
      async reset() {
        let { choices: e, initial: i, autofocus: n, suggest: r } = this.options;
        if (
          ((this.state._choices = []),
          (this.state.choices = []),
          (this.choices = await Promise.all(await this.toChoices(e))),
          this.choices.forEach((s) => (s.enabled = !1)),
          typeof r != 'function' && this.selectable.length === 0)
        )
          throw new Error('At least one choice must be selectable');
        _U(i) && (i = Object.keys(i)),
          Array.isArray(i)
            ? (n != null && (this.index = this.findIndex(n)),
              i.forEach((s) => this.enable(this.find(s))),
              await this.render())
            : (n != null && (i = n),
              typeof i == 'string' && (i = this.findIndex(i)),
              typeof i == 'number' &&
                i > -1 &&
                ((this.index = Math.max(0, Math.min(i, this.choices.length))), this.enable(this.find(this.index)))),
          this.isDisabled(this.focused) && (await this.down());
      }
      async toChoices(e, i) {
        this.state.loadingChoices = !0;
        let n = [],
          r = 0,
          s = async (o, c) => {
            typeof o == 'function' && (o = await o.call(this)), o instanceof Promise && (o = await o);
            for (let u = 0; u < o.length; u++) {
              let l = (o[u] = await this.toChoice(o[u], r++, c));
              n.push(l), l.choices && (await s(l.choices, l));
            }
            return n;
          };
        return s(e, i).then((o) => ((this.state.loadingChoices = !1), o));
      }
      async toChoice(e, i, n) {
        if (
          (typeof e == 'function' && (e = await e.call(this, this)),
          e instanceof Promise && (e = await e),
          typeof e == 'string' && (e = { name: e }),
          e.normalized)
        )
          return e;
        e.normalized = !0;
        let r = e.value;
        if (
          ((e = Gie(e.role, this.options)(this, e)),
          typeof e.disabled == 'string' && !e.hint && ((e.hint = e.disabled), (e.disabled = !0)),
          e.disabled === !0 && e.hint == null && (e.hint = '(disabled)'),
          e.index != null)
        )
          return e;
        (e.name = e.name || e.key || e.title || e.value || e.message),
          (e.message = e.message || e.name || ''),
          (e.value = [e.value, e.name].find(this.isValue.bind(this))),
          (e.input = ''),
          (e.index = i),
          (e.cursor = 0),
          Em.define(e, 'parent', n),
          (e.level = n ? n.level + 1 : 1),
          e.indent == null && (e.indent = n ? n.indent + '  ' : e.indent || ''),
          (e.path = n ? n.path + '.' + e.name : e.name),
          (e.enabled = !!(this.multiple && !this.isDisabled(e) && (e.enabled || this.isSelected(e)))),
          this.isDisabled(e) || (this.longest = Math.max(this.longest, Bie(e.message).length));
        let o = { ...e };
        return (
          (e.reset = (c = o.input, u = o.value) => {
            for (let l of Object.keys(o)) e[l] = o[l];
            (e.input = c), (e.value = u);
          }),
          r == null && typeof e.initial == 'function' && (e.input = await e.initial.call(this, this.state, e, i)),
          e
        );
      }
      async onChoice(e, i) {
        this.emit('choice', e, i, this),
          typeof e.onChoice == 'function' && (await e.onChoice.call(this, this.state, e, i));
      }
      async addChoice(e, i, n) {
        let r = await this.toChoice(e, i, n);
        return this.choices.push(r), (this.index = this.choices.length - 1), (this.limit = this.choices.length), r;
      }
      async newItem(e, i, n) {
        let r = { name: 'New choice name?', editable: !0, newChoice: !0, ...e },
          s = await this.addChoice(r, i, n);
        return (
          (s.updateChoice = () => {
            delete s.newChoice, (s.name = s.message = s.input), (s.input = ''), (s.cursor = 0);
          }),
          this.render()
        );
      }
      indent(e) {
        return e.indent == null ? (e.level > 1 ? '  '.repeat(e.level - 1) : '') : e.indent;
      }
      dispatch(e, i) {
        if (this.multiple && this[i.name]) return this[i.name]();
        this.alert();
      }
      focus(e, i) {
        return (
          typeof i != 'boolean' && (i = e.enabled),
          i && !e.enabled && this.selected.length >= this.maxSelected
            ? this.alert()
            : ((this.index = e.index), (e.enabled = i && !this.isDisabled(e)), e)
        );
      }
      space() {
        if (!this.multiple) return this.alert();
        if (this.focused) return this.toggle(this.focused), this.render();
      }
      a() {
        if (this.maxSelected < this.choices.length) return this.alert();
        let e = this.selectable.every((i) => i.enabled);
        return this.choices.forEach((i) => (i.enabled = !e)), this.render();
      }
      i() {
        return this.choices.length - this.selected.length > this.maxSelected
          ? this.alert()
          : (this.choices.forEach((e) => (e.enabled = !e.enabled)), this.render());
      }
      g() {
        if (!this.choices.some((i) => !!i.parent)) return this.a();
        let e = this.focused;
        return this.toggle(e.parent && !e.choices ? e.parent : e), this.render();
      }
      toggle(e, i) {
        if (!e.enabled && this.selected.length >= this.maxSelected) return this.alert();
        typeof i != 'boolean' && (i = !e.enabled),
          (e.enabled = i),
          e.choices && e.choices.forEach((r) => this.toggle(r, i));
        let n = e.parent;
        for (; n; ) {
          let r = n.choices.filter((s) => this.isDisabled(s));
          (n.enabled = r.every((s) => s.enabled === !0)), (n = n.parent);
        }
        return SU(this, this.choices), this.emit('toggle', e, this), e;
      }
      enable(e) {
        return this.selected.length >= this.maxSelected
          ? this.alert()
          : ((e.enabled = !this.isDisabled(e)), e.choices && e.choices.forEach(this.enable.bind(this)), e);
      }
      disable(e) {
        return (e.enabled = !1), e.choices && e.choices.forEach(this.disable.bind(this)), e;
      }
      number(e) {
        this.num += e;
        let i = (n) => {
          let r = Number(n);
          if (r > this.choices.length - 1) return this.alert();
          let s = this.focused,
            o = this.choices.find((c) => r === c.index);
          if (!o.enabled && this.selected.length >= this.maxSelected) return this.alert();
          if (this.visible.indexOf(o) === -1) {
            let c = c_(this.choices),
              u = c.indexOf(o);
            if (s.index > u) {
              let l = c.slice(u, u + this.limit),
                p = c.filter((d) => !l.includes(d));
              this.choices = l.concat(p);
            } else {
              let l = u - this.limit + 1;
              this.choices = c.slice(l).concat(c.slice(0, l));
            }
          }
          return (this.index = this.choices.indexOf(o)), this.toggle(this.focused), this.render();
        };
        return (
          clearTimeout(this.numberTimeout),
          new Promise((n) => {
            let r = this.choices.length,
              s = this.num,
              o = (c = !1, u) => {
                clearTimeout(this.numberTimeout), c && (u = i(s)), (this.num = ''), n(u);
              };
            if (s === '0' || (s.length === 1 && +(s + '0') > r)) return o(!0);
            if (Number(s) > r) return o(!1, this.alert());
            this.numberTimeout = setTimeout(() => o(!0), this.delay);
          })
        );
      }
      home() {
        return (this.choices = c_(this.choices)), (this.index = 0), this.render();
      }
      end() {
        let e = this.choices.length - this.limit,
          i = c_(this.choices);
        return (this.choices = i.slice(e).concat(i.slice(0, e))), (this.index = this.limit - 1), this.render();
      }
      first() {
        return (this.index = 0), this.render();
      }
      last() {
        return (this.index = this.visible.length - 1), this.render();
      }
      prev() {
        return this.visible.length <= 1 ? this.alert() : this.up();
      }
      next() {
        return this.visible.length <= 1 ? this.alert() : this.down();
      }
      right() {
        return this.cursor >= this.input.length ? this.alert() : (this.cursor++, this.render());
      }
      left() {
        return this.cursor <= 0 ? this.alert() : (this.cursor--, this.render());
      }
      up() {
        let e = this.choices.length,
          i = this.visible.length,
          n = this.index;
        return this.options.scroll === !1 && n === 0
          ? this.alert()
          : e > i && n === 0
          ? this.scrollUp()
          : ((this.index = (n - (1 % e) + e) % e),
            this.isDisabled() && !this.allChoicesAreDisabled() ? this.up() : this.render());
      }
      down() {
        let e = this.choices.length,
          i = this.visible.length,
          n = this.index;
        return this.options.scroll === !1 && n === i - 1
          ? this.alert()
          : e > i && n === i - 1
          ? this.scrollDown()
          : ((this.index = (n + 1) % e),
            this.isDisabled() && !this.allChoicesAreDisabled() ? this.down() : this.render());
      }
      scrollUp(e = 0) {
        return (this.choices = zie(this.choices)), (this.index = e), this.isDisabled() ? this.up() : this.render();
      }
      scrollDown(e = this.visible.length - 1) {
        return (this.choices = Vie(this.choices)), (this.index = e), this.isDisabled() ? this.down() : this.render();
      }
      async shiftUp() {
        if (this.options.sort === !0) {
          (this.sorting = !0), this.swap(this.index - 1), await this.up(), (this.sorting = !1);
          return;
        }
        return this.scrollUp(this.index);
      }
      async shiftDown() {
        if (this.options.sort === !0) {
          (this.sorting = !0), this.swap(this.index + 1), await this.down(), (this.sorting = !1);
          return;
        }
        return this.scrollDown(this.index);
      }
      pageUp() {
        return this.visible.length <= 1
          ? this.alert()
          : ((this.limit = Math.max(this.limit - 1, 0)),
            (this.index = Math.min(this.limit - 1, this.index)),
            (this._limit = this.limit),
            this.isDisabled() ? this.up() : this.render());
      }
      pageDown() {
        return this.visible.length >= this.choices.length
          ? this.alert()
          : ((this.index = Math.max(0, this.index)),
            (this.limit = Math.min(this.limit + 1, this.choices.length)),
            (this._limit = this.limit),
            this.isDisabled() ? this.down() : this.render());
      }
      swap(e) {
        $ie(this.choices, this.index, e);
      }
      allChoicesAreDisabled(e = this.choices) {
        return e.every((i) => this.isDisabled(i));
      }
      isDisabled(e = this.focused) {
        return e && ['disabled', 'collapsed', 'hidden', 'completing', 'readonly'].some((n) => e[n] === !0)
          ? !0
          : e && e.role === 'heading';
      }
      isEnabled(e = this.focused) {
        if (Array.isArray(e)) return e.every((i) => this.isEnabled(i));
        if (e.choices) {
          let i = e.choices.filter((n) => !this.isDisabled(n));
          return e.enabled && i.every((n) => this.isEnabled(n));
        }
        return e.enabled && !this.isDisabled(e);
      }
      isChoice(e, i) {
        return e.name === i || e.index === Number(i);
      }
      isSelected(e) {
        return Array.isArray(this.initial)
          ? this.initial.some((i) => this.isChoice(e, i))
          : this.isChoice(e, this.initial);
      }
      map(e = [], i = 'value') {
        return [].concat(e || []).reduce((n, r) => ((n[r] = this.find(r, i)), n), {});
      }
      filter(e, i) {
        let r = typeof e == 'function' ? e : (c, u) => [c.name, u].includes(e),
          o = (this.options.multiple ? this.state._choices : this.choices).filter(r);
        return i ? o.map((c) => c[i]) : o;
      }
      find(e, i) {
        if (_U(e)) return i ? e[i] : e;
        let r = typeof e == 'function' ? e : (o, c) => [o.name, c].includes(e),
          s = this.choices.find(r);
        if (s) return i ? s[i] : s;
      }
      findIndex(e) {
        return this.choices.indexOf(this.find(e));
      }
      async submit() {
        let e = this.focused;
        if (!e) return this.alert();
        if (e.newChoice) return e.input ? (e.updateChoice(), this.render()) : this.alert();
        if (this.choices.some((o) => o.newChoice)) return this.alert();
        let { reorder: i, sort: n } = this.options,
          r = this.multiple === !0,
          s = this.selected;
        return s === void 0
          ? this.alert()
          : (Array.isArray(s) && i !== !1 && n !== !0 && (s = Em.reorder(s)),
            (this.value = r ? s.map((o) => o.name) : s.name),
            super.submit());
      }
      set choices(e = []) {
        (this.state._choices = this.state._choices || []), (this.state.choices = e);
        for (let i of e) this.state._choices.some((n) => n.name === i.name) || this.state._choices.push(i);
        if (!this._initial && this.options.initial) {
          this._initial = !0;
          let i = this.initial;
          if (typeof i == 'string' || typeof i == 'number') {
            let n = this.find(i);
            n && ((this.initial = n.index), this.focus(n, !0));
          }
        }
      }
      get choices() {
        return SU(this, this.state.choices || []);
      }
      set visible(e) {
        this.state.visible = e;
      }
      get visible() {
        return (this.state.visible || this.choices).slice(0, this.limit);
      }
      set limit(e) {
        this.state.limit = e;
      }
      get limit() {
        let { state: e, options: i, choices: n } = this,
          r = e.limit || this._limit || i.limit || n.length;
        return Math.min(r, this.height);
      }
      set value(e) {
        super.value = e;
      }
      get value() {
        return typeof super.value != 'string' && super.value === this.initial ? this.input : super.value;
      }
      set index(e) {
        this.state.index = e;
      }
      get index() {
        return Math.max(0, this.state ? this.state.index : 0);
      }
      get enabled() {
        return this.filter(this.isEnabled.bind(this));
      }
      get focused() {
        let e = this.choices[this.index];
        return e && this.state.submitted && this.multiple !== !0 && (e.enabled = !0), e;
      }
      get selectable() {
        return this.choices.filter((e) => !this.isDisabled(e));
      }
      get selected() {
        return this.multiple ? this.enabled : this.focused;
      }
    };
  function SU(t, e) {
    if (e instanceof Promise) return e;
    if (typeof e == 'function') {
      if (Em.isAsyncFn(e)) return e;
      e = e.call(t, t);
    }
    for (let i of e) {
      if (Array.isArray(i.choices)) {
        let n = i.choices.filter((r) => !t.isDisabled(r));
        i.enabled = n.every((r) => r.enabled === !0);
      }
      t.isDisabled(i) === !0 && delete i.enabled;
    }
    return e;
  }
  CU.exports = u_;
});
var Fs = P((Qge, RU) => {
  'use strict';
  var Wie = zl(),
    l_ = hi(),
    p_ = class extends Wie {
      constructor(e) {
        super(e), (this.emptyError = this.options.emptyError || 'No items were selected');
      }
      async dispatch(e, i) {
        if (this.multiple) return this[i.name] ? await this[i.name](e, i) : await super.dispatch(e, i);
        this.alert();
      }
      separator() {
        if (this.options.separator) return super.separator();
        let e = this.styles.muted(this.symbols.ellipsis);
        return this.state.submitted ? super.separator() : e;
      }
      pointer(e, i) {
        return !this.multiple || this.options.pointer ? super.pointer(e, i) : '';
      }
      indicator(e, i) {
        return this.multiple ? super.indicator(e, i) : '';
      }
      choiceMessage(e, i) {
        let n = this.resolve(e.message, this.state, e, i);
        return (
          e.role === 'heading' && !l_.hasColor(n) && (n = this.styles.strong(n)), this.resolve(n, this.state, e, i)
        );
      }
      choiceSeparator() {
        return ':';
      }
      async renderChoice(e, i) {
        await this.onChoice(e, i);
        let n = this.index === i,
          r = await this.pointer(e, i),
          s = (await this.indicator(e, i)) + (e.pad || ''),
          o = await this.resolve(e.hint, this.state, e, i);
        o && !l_.hasColor(o) && (o = this.styles.muted(o));
        let c = this.indent(e),
          u = await this.choiceMessage(e, i),
          l = () => [this.margin[3], c + r + s, u, this.margin[1], o].filter(Boolean).join(' ');
        return e.role === 'heading'
          ? l()
          : e.disabled
          ? (l_.hasColor(u) || (u = this.styles.disabled(u)), l())
          : (n && (u = this.styles.em(u)), l());
      }
      async renderChoices() {
        if (this.state.loading === 'choices') return this.styles.warning('Loading choices');
        if (this.state.submitted) return '';
        let e = this.visible.map(async (s, o) => await this.renderChoice(s, o)),
          i = await Promise.all(e);
        i.length || i.push(this.styles.danger('No matching choices'));
        let n =
            this.margin[0] +
            i.join(`
`),
          r;
        return (
          this.options.choicesHeader && (r = await this.resolve(this.options.choicesHeader, this.state)),
          [r, n].filter(Boolean).join(`
`)
        );
      }
      format() {
        return !this.state.submitted || this.state.cancelled
          ? ''
          : Array.isArray(this.selected)
          ? this.selected.map((e) => this.styles.primary(e.name)).join(', ')
          : this.styles.primary(this.selected.name);
      }
      async render() {
        let { submitted: e, size: i } = this.state,
          n = '',
          r = await this.header(),
          s = await this.prefix(),
          o = await this.separator(),
          c = await this.message();
        this.options.promptLine !== !1 && ((n = [s, c, o, ''].join(' ')), (this.state.prompt = n));
        let u = await this.format(),
          l = (await this.error()) || (await this.hint()),
          p = await this.renderChoices(),
          d = await this.footer();
        u && (n += u),
          l && !n.includes(l) && (n += ' ' + l),
          e &&
            !u &&
            !p.trim() &&
            this.multiple &&
            this.emptyError != null &&
            (n += this.styles.danger(this.emptyError)),
          this.clear(i),
          this.write(
            [r, n, p, d].filter(Boolean).join(`
`)
          ),
          this.write(this.margin[2]),
          this.restore();
      }
    };
  RU.exports = p_;
});
var OU = P((exe, TU) => {
  'use strict';
  var Kie = Fs(),
    Xie = (t, e) => {
      let i = t ? new RegExp(t, 'ig') : /$^/;
      return (n) => (t ? n.replace(i, (r) => e(r)) : n);
    },
    f_ = class extends Kie {
      constructor(e) {
        super(e), this.cursorShow();
      }
      moveCursor(e) {
        this.state.cursor += e;
      }
      dispatch(e) {
        return this.append(e);
      }
      space(e) {
        return this.options.multiple ? super.space(e) : this.append(e);
      }
      append(e) {
        let { cursor: i, input: n } = this.state;
        return (this.input = n.slice(0, i) + e + n.slice(i)), this.moveCursor(1), this.complete();
      }
      delete() {
        let { cursor: e, input: i } = this.state;
        return i ? ((this.input = i.slice(0, e - 1) + i.slice(e)), this.moveCursor(-1), this.complete()) : this.alert();
      }
      deleteForward() {
        let { cursor: e, input: i } = this.state;
        return i[e] === void 0
          ? this.alert()
          : ((this.input = `${i}`.slice(0, e) + `${i}`.slice(e + 1)), this.complete());
      }
      number(e) {
        return this.append(e);
      }
      async complete() {
        (this.completing = !0),
          (this.choices = await this.suggest(this.input, this.state._choices)),
          (this.state.limit = void 0),
          (this.index = Math.min(Math.max(this.visible.length - 1, 0), this.index)),
          await this.render(),
          (this.completing = !1);
      }
      suggest(e = this.input, i = this.state._choices) {
        if (typeof this.options.suggest == 'function') return this.options.suggest.call(this, e, i);
        let n = e.toLowerCase();
        return i.filter((r) => r.message.toLowerCase().includes(n));
      }
      pointer() {
        return '';
      }
      format() {
        if (!this.focused) return this.input;
        if (this.options.multiple && this.state.submitted)
          return this.selected.map((e) => this.styles.primary(e.message)).join(', ');
        if (this.state.submitted) {
          let e = (this.value = this.input = this.focused.value);
          return this.styles.primary(e);
        }
        return this.input;
      }
      async render() {
        if (this.state.status !== 'pending') return super.render();
        let e = this.options.highlight || this.styles.complement,
          i = (s, o) => s && (e.stack ? e(s) : e.call(this, s)),
          n = Xie(this.input, i),
          r = this.choices;
        (this.choices = r.map((s) => ({ ...s, message: n(s.message) }))), await super.render(), (this.choices = r);
      }
      submit() {
        return this.options.multiple && (this.value = this.selected.map((e) => e.name)), super.submit();
      }
    };
  TU.exports = f_;
});
var h_ = P((txe, kU) => {
  'use strict';
  var d_ = hi();
  kU.exports = (t, e = {}) => {
    t.cursorHide();
    let { input: i = '', initial: n = '', pos: r, showCursor: s = !0, color: o } = e,
      c = o || t.styles.placeholder,
      u = d_.inverse(t.styles.primary),
      l = (y) => u(t.styles.black(y)),
      p = i,
      d = ' ',
      x = l(d);
    if ((t.blink && t.blink.off === !0 && ((l = (y) => y), (x = '')), s && r === 0 && n === '' && i === ''))
      return l(d);
    if (s && r === 0 && (i === n || i === '')) return l(n[0]) + c(n.slice(1));
    (n = d_.isPrimitive(n) ? `${n}` : ''), (i = d_.isPrimitive(i) ? `${i}` : '');
    let b = n && n.startsWith(i) && n !== i,
      g = b ? l(n[i.length]) : x;
    if (
      (r !== i.length && s === !0 && ((p = i.slice(0, r) + l(i[r]) + i.slice(r + 1)), (g = '')),
      s === !1 && (g = ''),
      b)
    ) {
      let y = t.styles.unstyle(p + g);
      return p + g + c(n.slice(y.length));
    }
    return p + g;
  };
});
var _m = P((ixe, AU) => {
  'use strict';
  var Yie = Ls(),
    Jie = Fs(),
    Zie = h_(),
    m_ = class extends Jie {
      constructor(e) {
        super({ ...e, multiple: !0 }),
          (this.type = 'form'),
          (this.initial = this.options.initial),
          (this.align = [this.options.align, 'right'].find((i) => i != null)),
          (this.emptyError = ''),
          (this.values = {});
      }
      async reset(e) {
        return (
          await super.reset(),
          e === !0 && (this._index = this.index),
          (this.index = this._index),
          (this.values = {}),
          this.choices.forEach((i) => i.reset && i.reset()),
          this.render()
        );
      }
      dispatch(e) {
        return !!e && this.append(e);
      }
      append(e) {
        let i = this.focused;
        if (!i) return this.alert();
        let { cursor: n, input: r } = i;
        return (i.value = i.input = r.slice(0, n) + e + r.slice(n)), i.cursor++, this.render();
      }
      delete() {
        let e = this.focused;
        if (!e || e.cursor <= 0) return this.alert();
        let { cursor: i, input: n } = e;
        return (e.value = e.input = n.slice(0, i - 1) + n.slice(i)), e.cursor--, this.render();
      }
      deleteForward() {
        let e = this.focused;
        if (!e) return this.alert();
        let { cursor: i, input: n } = e;
        if (n[i] === void 0) return this.alert();
        let r = `${n}`.slice(0, i) + `${n}`.slice(i + 1);
        return (e.value = e.input = r), this.render();
      }
      right() {
        let e = this.focused;
        return e ? (e.cursor >= e.input.length ? this.alert() : (e.cursor++, this.render())) : this.alert();
      }
      left() {
        let e = this.focused;
        return e ? (e.cursor <= 0 ? this.alert() : (e.cursor--, this.render())) : this.alert();
      }
      space(e, i) {
        return this.dispatch(e, i);
      }
      number(e, i) {
        return this.dispatch(e, i);
      }
      next() {
        let e = this.focused;
        if (!e) return this.alert();
        let { initial: i, input: n } = e;
        return i && i.startsWith(n) && n !== i
          ? ((e.value = e.input = i), (e.cursor = e.value.length), this.render())
          : super.next();
      }
      prev() {
        let e = this.focused;
        return e
          ? e.cursor === 0
            ? super.prev()
            : ((e.value = e.input = ''), (e.cursor = 0), this.render())
          : this.alert();
      }
      separator() {
        return '';
      }
      format(e) {
        return this.state.submitted ? '' : super.format(e);
      }
      pointer() {
        return '';
      }
      indicator(e) {
        return e.input ? '\u29BF' : '\u2299';
      }
      async choiceSeparator(e, i) {
        let n = (await this.resolve(e.separator, this.state, e, i)) || ':';
        return n ? ' ' + this.styles.disabled(n) : '';
      }
      async renderChoice(e, i) {
        await this.onChoice(e, i);
        let { state: n, styles: r } = this,
          { cursor: s, initial: o = '', name: c, input: u = '' } = e,
          { muted: l, submitted: p, primary: d, danger: x } = r,
          b = this.index === i,
          g = e.validate || (() => !0),
          y = await this.choiceSeparator(e, i),
          h = e.message;
        this.align === 'right' && (h = h.padStart(this.longest + 1, ' ')),
          this.align === 'left' && (h = h.padEnd(this.longest + 1, ' '));
        let v = (this.values[c] = u || o),
          C = u ? 'success' : 'dark';
        (await g.call(e, v, this.state)) !== !0 && (C = 'danger');
        let _ = r[C],
          m = _(await this.indicator(e, i)) + (e.pad || ''),
          O = this.indent(e),
          N = () => [O, m, h + y, u].filter(Boolean).join(' ');
        if (n.submitted) return (h = Yie(h)), (u = p(u)), N();
        if (e.format) u = await e.format.call(this, u, e, i);
        else {
          let D = this.styles.muted;
          u = Zie(this, { input: u, initial: o, pos: s, showCursor: b, color: D });
        }
        return (
          this.isValue(u) || (u = this.styles.muted(this.symbols.ellipsis)),
          e.result && (this.values[c] = await e.result.call(this, v, e, i)),
          b && (h = d(h)),
          e.error ? (u += (u ? ' ' : '') + x(e.error.trim())) : e.hint && (u += (u ? ' ' : '') + l(e.hint.trim())),
          N()
        );
      }
      async submit() {
        return (this.value = this.values), super.base.submit.call(this);
      }
    };
  AU.exports = m_;
});
var g_ = P((nxe, NU) => {
  'use strict';
  var Qie = _m(),
    ene = () => {
      throw new Error('expected prompt to have a custom authenticate method');
    },
    IU = (t = ene) => {
      class e extends Qie {
        constructor(n) {
          super(n);
        }
        async submit() {
          (this.value = await t.call(this, this.values, this.state)), super.base.submit.call(this);
        }
        static create(n) {
          return IU(n);
        }
      }
      return e;
    };
  NU.exports = IU();
});
var DU = P((rxe, LU) => {
  'use strict';
  var tne = g_();
  function ine(t, e) {
    return t.username === this.options.username && t.password === this.options.password;
  }
  var PU = (t = ine) => {
    let e = [
      { name: 'username', message: 'username' },
      {
        name: 'password',
        message: 'password',
        format(n) {
          return this.options.showPassword
            ? n
            : (this.state.submitted ? this.styles.primary : this.styles.muted)(this.symbols.asterisk.repeat(n.length));
        },
      },
    ];
    class i extends tne.create(t) {
      constructor(r) {
        super({ ...r, choices: e });
      }
      static create(r) {
        return PU(r);
      }
    }
    return i;
  };
  LU.exports = PU();
});
var Sm = P((sxe, FU) => {
  'use strict';
  var nne = kc(),
    { isPrimitive: rne, hasColor: sne } = hi(),
    x_ = class extends nne {
      constructor(e) {
        super(e), this.cursorHide();
      }
      async initialize() {
        let e = await this.resolve(this.initial, this.state);
        (this.input = await this.cast(e)), await super.initialize();
      }
      dispatch(e) {
        return this.isValue(e) ? ((this.input = e), this.submit()) : this.alert();
      }
      format(e) {
        let { styles: i, state: n } = this;
        return n.submitted ? i.success(e) : i.primary(e);
      }
      cast(e) {
        return this.isTrue(e);
      }
      isTrue(e) {
        return /^[ty1]/i.test(e);
      }
      isFalse(e) {
        return /^[fn0]/i.test(e);
      }
      isValue(e) {
        return rne(e) && (this.isTrue(e) || this.isFalse(e));
      }
      async hint() {
        if (this.state.status === 'pending') {
          let e = await this.element('hint');
          return sne(e) ? e : this.styles.muted(e);
        }
      }
      async render() {
        let { input: e, size: i } = this.state,
          n = await this.prefix(),
          r = await this.separator(),
          s = await this.message(),
          o = this.styles.muted(this.default),
          c = [n, s, o, r].filter(Boolean).join(' ');
        this.state.prompt = c;
        let u = await this.header(),
          l = (this.value = this.cast(e)),
          p = await this.format(l),
          d = (await this.error()) || (await this.hint()),
          x = await this.footer();
        d && !c.includes(d) && (p += ' ' + d),
          (c += ' ' + p),
          this.clear(i),
          this.write(
            [u, c, x].filter(Boolean).join(`
`)
          ),
          this.restore();
      }
      set value(e) {
        super.value = e;
      }
      get value() {
        return this.cast(super.value);
      }
    };
  FU.exports = x_;
});
var MU = P((oxe, jU) => {
  'use strict';
  var one = Sm(),
    y_ = class extends one {
      constructor(e) {
        super(e), (this.default = this.options.default || (this.initial ? '(Y/n)' : '(y/N)'));
      }
    };
  jU.exports = y_;
});
var qU = P((axe, UU) => {
  'use strict';
  var ane = Fs(),
    cne = _m(),
    Ac = cne.prototype,
    b_ = class extends ane {
      constructor(e) {
        super({ ...e, multiple: !0 }),
          (this.align = [this.options.align, 'left'].find((i) => i != null)),
          (this.emptyError = ''),
          (this.values = {});
      }
      dispatch(e, i) {
        let n = this.focused,
          r = n.parent || {};
        return !n.editable && !r.editable && (e === 'a' || e === 'i') ? super[e]() : Ac.dispatch.call(this, e, i);
      }
      append(e, i) {
        return Ac.append.call(this, e, i);
      }
      delete(e, i) {
        return Ac.delete.call(this, e, i);
      }
      space(e) {
        return this.focused.editable ? this.append(e) : super.space();
      }
      number(e) {
        return this.focused.editable ? this.append(e) : super.number(e);
      }
      next() {
        return this.focused.editable ? Ac.next.call(this) : super.next();
      }
      prev() {
        return this.focused.editable ? Ac.prev.call(this) : super.prev();
      }
      async indicator(e, i) {
        let n = e.indicator || '',
          r = e.editable ? n : super.indicator(e, i);
        return (await this.resolve(r, this.state, e, i)) || '';
      }
      indent(e) {
        return e.role === 'heading' ? '' : e.editable ? ' ' : '  ';
      }
      async renderChoice(e, i) {
        return (e.indent = ''), e.editable ? Ac.renderChoice.call(this, e, i) : super.renderChoice(e, i);
      }
      error() {
        return '';
      }
      footer() {
        return this.state.error;
      }
      async validate() {
        let e = !0;
        for (let i of this.choices) {
          if (typeof i.validate != 'function' || i.role === 'heading') continue;
          let n = i.parent ? this.value[i.parent.name] : this.value;
          if (
            (i.editable
              ? (n = i.value === i.name ? i.initial || '' : i.value)
              : this.isDisabled(i) || (n = i.enabled === !0),
            (e = await i.validate(n, this.state)),
            e !== !0)
          )
            break;
        }
        return e !== !0 && (this.state.error = typeof e == 'string' ? e : 'Invalid Input'), e;
      }
      submit() {
        if (this.focused.newChoice === !0) return super.submit();
        if (this.choices.some((e) => e.newChoice)) return this.alert();
        this.value = {};
        for (let e of this.choices) {
          let i = e.parent ? this.value[e.parent.name] : this.value;
          if (e.role === 'heading') {
            this.value[e.name] = {};
            continue;
          }
          e.editable
            ? (i[e.name] = e.value === e.name ? e.initial || '' : e.value)
            : this.isDisabled(e) || (i[e.name] = e.enabled === !0);
        }
        return this.base.submit.call(this);
      }
    };
  UU.exports = b_;
});
var Ho = P((cxe, BU) => {
  'use strict';
  var une = kc(),
    lne = JE(),
    pne = h_(),
    { isPrimitive: fne } = hi(),
    v_ = class extends une {
      constructor(e) {
        super(e),
          (this.initial = fne(this.initial) ? String(this.initial) : ''),
          this.initial && this.cursorHide(),
          (this.state.prevCursor = 0),
          (this.state.clipboard = []),
          (this.keypressTimeout = this.options.keypressTimeout !== void 0 ? this.options.keypressTimeout : null);
      }
      async keypress(e, i = e ? lne(e, {}) : {}) {
        let n = Date.now(),
          r = n - this.lastKeypress;
        this.lastKeypress = n;
        let s = i.name === 'return' || i.name === 'enter',
          o = this.state.prevKeypress,
          c;
        if (((this.state.prevKeypress = i), this.keypressTimeout != null && s)) {
          if (r < this.keypressTimeout) return this.submit();
          (this.state.multilineBuffer = this.state.multilineBuffer || ''),
            (this.state.multilineBuffer += e),
            (c = !0),
            (o = null);
        }
        return (c || (this.options.multiline && s)) && (!o || o.name !== 'return')
          ? this.append(
              `
`,
              i
            )
          : super.keypress(e, i);
      }
      moveCursor(e) {
        this.cursor += e;
      }
      reset() {
        return (this.input = this.value = ''), (this.cursor = 0), this.render();
      }
      dispatch(e, i) {
        if (!e || i.ctrl || i.code) return this.alert();
        this.append(e);
      }
      append(e) {
        let { cursor: i, input: n } = this.state;
        (this.input = `${n}`.slice(0, i) + e + `${n}`.slice(i)), this.moveCursor(String(e).length), this.render();
      }
      insert(e) {
        this.append(e);
      }
      delete() {
        let { cursor: e, input: i } = this.state;
        if (e <= 0) return this.alert();
        (this.input = `${i}`.slice(0, e - 1) + `${i}`.slice(e)), this.moveCursor(-1), this.render();
      }
      deleteForward() {
        let { cursor: e, input: i } = this.state;
        if (i[e] === void 0) return this.alert();
        (this.input = `${i}`.slice(0, e) + `${i}`.slice(e + 1)), this.render();
      }
      cutForward() {
        let e = this.cursor;
        if (this.input.length <= e) return this.alert();
        this.state.clipboard.push(this.input.slice(e)), (this.input = this.input.slice(0, e)), this.render();
      }
      cutLeft() {
        let e = this.cursor;
        if (e === 0) return this.alert();
        let i = this.input.slice(0, e),
          n = this.input.slice(e),
          r = i.split(' ');
        this.state.clipboard.push(r.pop()),
          (this.input = r.join(' ')),
          (this.cursor = this.input.length),
          (this.input += n),
          this.render();
      }
      paste() {
        if (!this.state.clipboard.length) return this.alert();
        this.insert(this.state.clipboard.pop()), this.render();
      }
      toggleCursor() {
        this.state.prevCursor
          ? ((this.cursor = this.state.prevCursor), (this.state.prevCursor = 0))
          : ((this.state.prevCursor = this.cursor), (this.cursor = 0)),
          this.render();
      }
      first() {
        (this.cursor = 0), this.render();
      }
      last() {
        (this.cursor = this.input.length - 1), this.render();
      }
      next() {
        let e = this.initial != null ? String(this.initial) : '';
        if (!e || !e.startsWith(this.input)) return this.alert();
        (this.input = this.initial), (this.cursor = this.initial.length), this.render();
      }
      prev() {
        if (!this.input) return this.alert();
        this.reset();
      }
      backward() {
        return this.left();
      }
      forward() {
        return this.right();
      }
      right() {
        return this.cursor >= this.input.length ? this.alert() : (this.moveCursor(1), this.render());
      }
      left() {
        return this.cursor <= 0 ? this.alert() : (this.moveCursor(-1), this.render());
      }
      isValue(e) {
        return !!e;
      }
      async format(e = this.value) {
        let i = await this.resolve(this.initial, this.state);
        return this.state.submitted
          ? this.styles.submitted(e || i)
          : pne(this, { input: e, initial: i, pos: this.cursor });
      }
      async render() {
        let e = this.state.size,
          i = await this.prefix(),
          n = await this.separator(),
          r = await this.message(),
          s = [i, r, n].filter(Boolean).join(' ');
        this.state.prompt = s;
        let o = await this.header(),
          c = await this.format(),
          u = (await this.error()) || (await this.hint()),
          l = await this.footer();
        u && !c.includes(u) && (c += ' ' + u),
          (s += ' ' + c),
          this.clear(e),
          this.write(
            [o, s, l].filter(Boolean).join(`
`)
          ),
          this.restore();
      }
    };
  BU.exports = v_;
});
var GU = P((uxe, HU) => {
  'use strict';
  var dne = (t) => t.filter((e, i) => t.lastIndexOf(e) === i),
    Cm = (t) => dne(t).filter(Boolean);
  HU.exports = (t, e = {}, i = '') => {
    let { past: n = [], present: r = '' } = e,
      s,
      o;
    switch (t) {
      case 'prev':
      case 'undo':
        return (s = n.slice(0, n.length - 1)), (o = n[n.length - 1] || ''), { past: Cm([i, ...s]), present: o };
      case 'next':
      case 'redo':
        return (s = n.slice(1)), (o = n[0] || ''), { past: Cm([...s, i]), present: o };
      case 'save':
        return { past: Cm([...n, i]), present: '' };
      case 'remove':
        return (o = Cm(n.filter((c) => c !== i))), (r = ''), o.length && (r = o.pop()), { past: o, present: r };
      default:
        throw new Error(`Invalid action: "${t}"`);
    }
  };
});
var E_ = P((lxe, VU) => {
  'use strict';
  var hne = Ho(),
    zU = GU(),
    w_ = class extends hne {
      constructor(e) {
        super(e);
        let i = this.options.history;
        if (i && i.store) {
          let n = i.values || this.initial;
          (this.autosave = !!i.autosave),
            (this.store = i.store),
            (this.data = this.store.get('values') || { past: [], present: n }),
            (this.initial = this.data.present || this.data.past[this.data.past.length - 1]);
        }
      }
      completion(e) {
        return this.store
          ? ((this.data = zU(e, this.data, this.input)),
            this.data.present
              ? ((this.input = this.data.present), (this.cursor = this.input.length), this.render())
              : this.alert())
          : this.alert();
      }
      altUp() {
        return this.completion('prev');
      }
      altDown() {
        return this.completion('next');
      }
      prev() {
        return this.save(), super.prev();
      }
      save() {
        this.store && ((this.data = zU('save', this.data, this.input)), this.store.set('values', this.data));
      }
      submit() {
        return this.store && this.autosave === !0 && this.save(), super.submit();
      }
    };
  VU.exports = w_;
});
var WU = P((pxe, $U) => {
  'use strict';
  var mne = Ho(),
    __ = class extends mne {
      format() {
        return '';
      }
    };
  $U.exports = __;
});
var XU = P((fxe, KU) => {
  'use strict';
  var gne = Ho(),
    S_ = class extends gne {
      constructor(e = {}) {
        super(e), (this.sep = this.options.separator || /, */), (this.initial = e.initial || '');
      }
      split(e = this.value) {
        return e ? String(e).split(this.sep) : [];
      }
      format() {
        let e = this.state.submitted ? this.styles.primary : (i) => i;
        return this.list.map(e).join(', ');
      }
      async submit(e) {
        let i = this.state.error || (await this.validate(this.list, this.state));
        return i !== !0 ? ((this.state.error = i), super.submit()) : ((this.value = this.list), super.submit());
      }
      get list() {
        return this.split();
      }
    };
  KU.exports = S_;
});
var JU = P((dxe, YU) => {
  'use strict';
  var xne = Fs(),
    C_ = class extends xne {
      constructor(e) {
        super({ ...e, multiple: !0 });
      }
    };
  YU.exports = C_;
});
var T_ = P((hxe, ZU) => {
  'use strict';
  var yne = Ho(),
    R_ = class extends yne {
      constructor(e = {}) {
        super({ style: 'number', ...e }),
          (this.min = this.isValue(e.min) ? this.toNumber(e.min) : -1 / 0),
          (this.max = this.isValue(e.max) ? this.toNumber(e.max) : 1 / 0),
          (this.delay = e.delay != null ? e.delay : 1e3),
          (this.float = e.float !== !1),
          (this.round = e.round === !0 || e.float === !1),
          (this.major = e.major || 10),
          (this.minor = e.minor || 1),
          (this.initial = e.initial != null ? e.initial : ''),
          (this.input = String(this.initial)),
          (this.cursor = this.input.length),
          this.cursorShow();
      }
      append(e) {
        return !/[-+.]/.test(e) || (e === '.' && this.input.includes('.'))
          ? this.alert('invalid number')
          : super.append(e);
      }
      number(e) {
        return super.append(e);
      }
      next() {
        return this.input && this.input !== this.initial
          ? this.alert()
          : this.isValue(this.initial)
          ? ((this.input = this.initial), (this.cursor = String(this.initial).length), this.render())
          : this.alert();
      }
      up(e) {
        let i = e || this.minor,
          n = this.toNumber(this.input);
        return n > this.max + i ? this.alert() : ((this.input = `${n + i}`), this.render());
      }
      down(e) {
        let i = e || this.minor,
          n = this.toNumber(this.input);
        return n < this.min - i ? this.alert() : ((this.input = `${n - i}`), this.render());
      }
      shiftDown() {
        return this.down(this.major);
      }
      shiftUp() {
        return this.up(this.major);
      }
      format(e = this.input) {
        return typeof this.options.format == 'function' ? this.options.format.call(this, e) : this.styles.info(e);
      }
      toNumber(e = '') {
        return this.float ? +e : Math.round(+e);
      }
      isValue(e) {
        return /^[-+]?[0-9]+((\.)|(\.[0-9]+))?$/.test(e);
      }
      submit() {
        let e = [this.input, this.initial].find((i) => this.isValue(i));
        return (this.value = this.toNumber(e || 0)), super.submit();
      }
    };
  ZU.exports = R_;
});
var eq = P((mxe, QU) => {
  'use strict';
  QU.exports = T_();
});
var iq = P((gxe, tq) => {
  'use strict';
  var bne = Ho(),
    O_ = class extends bne {
      constructor(e) {
        super(e), this.cursorShow();
      }
      format(e = this.input) {
        return this.keypressed
          ? (this.state.submitted ? this.styles.primary : this.styles.muted)(this.symbols.asterisk.repeat(e.length))
          : '';
      }
    };
  tq.exports = O_;
});
var sq = P((xxe, rq) => {
  'use strict';
  var vne = Ls(),
    wne = zl(),
    nq = hi(),
    k_ = class extends wne {
      constructor(e = {}) {
        super(e),
          (this.widths = [].concat(e.messageWidth || 50)),
          (this.align = [].concat(e.align || 'left')),
          (this.linebreak = e.linebreak || !1),
          (this.edgeLength = e.edgeLength || 3),
          (this.newline =
            e.newline ||
            `
   `);
        let i = e.startNumber || 1;
        typeof this.scale == 'number' &&
          ((this.scaleKey = !1),
          (this.scale = Array(this.scale)
            .fill(0)
            .map((n, r) => ({ name: r + i }))));
      }
      async reset() {
        return (this.tableized = !1), await super.reset(), this.render();
      }
      tableize() {
        if (this.tableized === !0) return;
        this.tableized = !0;
        let e = 0;
        for (let i of this.choices) {
          (e = Math.max(e, i.message.length)), (i.scaleIndex = i.initial || 2), (i.scale = []);
          for (let n = 0; n < this.scale.length; n++) i.scale.push({ index: n });
        }
        this.widths[0] = Math.min(this.widths[0], e + 3);
      }
      async dispatch(e, i) {
        if (this.multiple) return this[i.name] ? await this[i.name](e, i) : await super.dispatch(e, i);
        this.alert();
      }
      heading(e, i, n) {
        return this.styles.strong(e);
      }
      separator() {
        return this.styles.muted(this.symbols.ellipsis);
      }
      right() {
        let e = this.focused;
        return e.scaleIndex >= this.scale.length - 1 ? this.alert() : (e.scaleIndex++, this.render());
      }
      left() {
        let e = this.focused;
        return e.scaleIndex <= 0 ? this.alert() : (e.scaleIndex--, this.render());
      }
      indent() {
        return '';
      }
      format() {
        return this.state.submitted ? this.choices.map((i) => this.styles.info(i.index)).join(', ') : '';
      }
      pointer() {
        return '';
      }
      renderScaleKey() {
        return this.scaleKey === !1 || this.state.submitted
          ? ''
          : ['', ...this.scale.map((n) => `   ${n.name} - ${n.message}`)].map((n) => this.styles.muted(n)).join(`
`);
      }
      renderScaleHeading(e) {
        let i = this.scale.map((u) => u.name);
        typeof this.options.renderScaleHeading == 'function' && (i = this.options.renderScaleHeading.call(this, e));
        let n = this.scaleLength - i.join('').length,
          r = Math.round(n / (i.length - 1)),
          o = i.map((u) => this.styles.strong(u)).join(' '.repeat(r)),
          c = ' '.repeat(this.widths[0]);
        return this.margin[3] + c + this.margin[1] + o;
      }
      scaleIndicator(e, i, n) {
        if (typeof this.options.scaleIndicator == 'function') return this.options.scaleIndicator.call(this, e, i, n);
        let r = e.scaleIndex === i.index;
        return i.disabled
          ? this.styles.hint(this.symbols.radio.disabled)
          : r
          ? this.styles.success(this.symbols.radio.on)
          : this.symbols.radio.off;
      }
      renderScale(e, i) {
        let n = e.scale.map((s) => this.scaleIndicator(e, s, i)),
          r = this.term === 'Hyper' ? '' : ' ';
        return n.join(r + this.symbols.line.repeat(this.edgeLength));
      }
      async renderChoice(e, i) {
        await this.onChoice(e, i);
        let n = this.index === i,
          r = await this.pointer(e, i),
          s = await e.hint;
        s && !nq.hasColor(s) && (s = this.styles.muted(s));
        let o = (g) => this.margin[3] + g.replace(/\s+$/, '').padEnd(this.widths[0], ' '),
          c = this.newline,
          u = this.indent(e),
          l = await this.resolve(e.message, this.state, e, i),
          p = await this.renderScale(e, i),
          d = this.margin[1] + this.margin[3];
        (this.scaleLength = vne(p).length),
          (this.widths[0] = Math.min(this.widths[0], this.width - this.scaleLength - d.length));
        let b = nq
          .wordWrap(l, { width: this.widths[0], newline: c })
          .split(
            `
`
          )
          .map((g) => o(g) + this.margin[1]);
        return (
          n && ((p = this.styles.info(p)), (b = b.map((g) => this.styles.info(g)))),
          (b[0] += p),
          this.linebreak && b.push(''),
          [
            u + r,
            b.join(`
`),
          ].filter(Boolean)
        );
      }
      async renderChoices() {
        if (this.state.submitted) return '';
        this.tableize();
        let e = this.visible.map(async (r, s) => await this.renderChoice(r, s)),
          i = await Promise.all(e),
          n = await this.renderScaleHeading();
        return (
          this.margin[0] +
          [n, ...i.map((r) => r.join(' '))].join(`
`)
        );
      }
      async render() {
        let { submitted: e, size: i } = this.state,
          n = await this.prefix(),
          r = await this.separator(),
          s = await this.message(),
          o = '';
        this.options.promptLine !== !1 && ((o = [n, s, r, ''].join(' ')), (this.state.prompt = o));
        let c = await this.header(),
          u = await this.format(),
          l = await this.renderScaleKey(),
          p = (await this.error()) || (await this.hint()),
          d = await this.renderChoices(),
          x = await this.footer(),
          b = this.emptyError;
        u && (o += u),
          p && !o.includes(p) && (o += ' ' + p),
          e && !u && !d.trim() && this.multiple && b != null && (o += this.styles.danger(b)),
          this.clear(i),
          this.write(
            [c, o, l, d, x].filter(Boolean).join(`
`)
          ),
          this.state.submitted || this.write(this.margin[2]),
          this.restore();
      }
      submit() {
        this.value = {};
        for (let e of this.choices) this.value[e.name] = e.scaleIndex;
        return this.base.submit.call(this);
      }
    };
  rq.exports = k_;
});
var cq = P((yxe, aq) => {
  'use strict';
  var oq = Ls(),
    Ene = (t = '') => (typeof t == 'string' ? t.replace(/^['"]|['"]$/g, '') : ''),
    I_ = class {
      constructor(e) {
        (this.name = e.key),
          (this.field = e.field || {}),
          (this.value = Ene(e.initial || this.field.initial || '')),
          (this.message = e.message || this.name),
          (this.cursor = 0),
          (this.input = ''),
          (this.lines = []);
      }
    },
    _ne = async (t = {}, e = {}, i = (n) => n) => {
      let n = new Set(),
        r = t.fields || [],
        s = t.template,
        o = [],
        c = [],
        u = [],
        l = 1;
      typeof s == 'function' && (s = await s());
      let p = -1,
        d = () => s[++p],
        x = () => s[p + 1],
        b = (g) => {
          (g.line = l), o.push(g);
        };
      for (b({ type: 'bos', value: '' }); p < s.length - 1; ) {
        let g = d();
        if (/^[^\S\n ]$/.test(g)) {
          b({ type: 'text', value: g });
          continue;
        }
        if (
          g ===
          `
`
        ) {
          b({ type: 'newline', value: g }), l++;
          continue;
        }
        if (g === '\\') {
          (g += d()), b({ type: 'text', value: g });
          continue;
        }
        if ((g === '$' || g === '#' || g === '{') && x() === '{') {
          let h = d();
          g += h;
          let v = { type: 'template', open: g, inner: '', close: '', value: g },
            C;
          for (; (C = d()); ) {
            if (C === '}') {
              x() === '}' && (C += d()), (v.value += C), (v.close = C);
              break;
            }
            C === ':' ? ((v.initial = ''), (v.key = v.inner)) : v.initial !== void 0 && (v.initial += C),
              (v.value += C),
              (v.inner += C);
          }
          (v.template = v.open + (v.initial || v.inner) + v.close),
            (v.key = v.key || v.inner),
            hasOwnProperty.call(e, v.key) && (v.initial = e[v.key]),
            (v = i(v)),
            b(v),
            u.push(v.key),
            n.add(v.key);
          let _ = c.find((m) => m.name === v.key);
          (v.field = r.find((m) => m.name === v.key)), _ || ((_ = new I_(v)), c.push(_)), _.lines.push(v.line - 1);
          continue;
        }
        let y = o[o.length - 1];
        y.type === 'text' && y.line === l ? (y.value += g) : b({ type: 'text', value: g });
      }
      return b({ type: 'eos', value: '' }), { input: s, tabstops: o, unique: n, keys: u, items: c };
    };
  aq.exports = async (t) => {
    let e = t.options,
      i = new Set(e.required === !0 ? [] : e.required || []),
      n = { ...e.values, ...e.initial },
      { tabstops: r, items: s, keys: o } = await _ne(e, n),
      c = A_('result', t, e),
      u = A_('format', t, e),
      l = A_('validate', t, e, !0),
      p = t.isValue.bind(t);
    return async (d = {}, x = !1) => {
      let b = 0;
      (d.required = i), (d.items = s), (d.keys = o), (d.output = '');
      let g = async (C, _, m, O) => {
        let N = await l(C, _, m, O);
        return N === !1 ? 'Invalid field ' + m.name : N;
      };
      for (let C of r) {
        let _ = C.value,
          m = C.key;
        if (C.type !== 'template') {
          _ && (d.output += _);
          continue;
        }
        if (C.type === 'template') {
          let O = s.find((F) => F.name === m);
          e.required === !0 && d.required.add(O.name);
          let N = [O.input, d.values[O.value], O.value, _].find(p),
            z = (O.field || {}).message || C.inner;
          if (x) {
            let F = await g(d.values[m], d, O, b);
            if ((F && typeof F == 'string') || F === !1) {
              d.invalid.set(m, F);
              continue;
            }
            d.invalid.delete(m);
            let ne = await c(d.values[m], d, O, b);
            d.output += oq(ne);
            continue;
          }
          O.placeholder = !1;
          let H = _;
          (_ = await u(_, d, O, b)),
            N !== _
              ? ((d.values[m] = N), (_ = t.styles.typing(N)), d.missing.delete(z))
              : ((d.values[m] = void 0),
                (N = `<${z}>`),
                (_ = t.styles.primary(N)),
                (O.placeholder = !0),
                d.required.has(m) && d.missing.add(z)),
            d.missing.has(z) && d.validating && (_ = t.styles.warning(N)),
            d.invalid.has(m) && d.validating && (_ = t.styles.danger(N)),
            b === d.index && (H !== _ ? (_ = t.styles.underline(_)) : (_ = t.styles.heading(oq(_)))),
            b++;
        }
        _ && (d.output += _);
      }
      let y = d.output
          .split(
            `
`
          )
          .map((C) => ' ' + C),
        h = s.length,
        v = 0;
      for (let C of s)
        d.invalid.has(C.name) &&
          C.lines.forEach((_) => {
            y[_][0] === ' ' && (y[_] = d.styles.danger(d.symbols.bullet) + y[_].slice(1));
          }),
          t.isValue(d.values[C.name]) && v++;
      return (
        (d.completed = ((v / h) * 100).toFixed(0)),
        (d.output = y.join(`
`)),
        d.output
      );
    };
  };
  function A_(t, e, i, n) {
    return (r, s, o, c) =>
      typeof o.field[t] == 'function' ? o.field[t].call(e, r, s, o, c) : [n, r].find((u) => e.isValue(u));
  }
});
var lq = P((bxe, uq) => {
  'use strict';
  var Sne = Ls(),
    Cne = cq(),
    Rne = kc(),
    N_ = class extends Rne {
      constructor(e) {
        super(e), this.cursorHide(), this.reset(!0);
      }
      async initialize() {
        (this.interpolate = await Cne(this)), await super.initialize();
      }
      async reset(e) {
        (this.state.keys = []),
          (this.state.invalid = new Map()),
          (this.state.missing = new Set()),
          (this.state.completed = 0),
          (this.state.values = {}),
          e !== !0 && (await this.initialize(), await this.render());
      }
      moveCursor(e) {
        let i = this.getItem();
        (this.cursor += e), (i.cursor += e);
      }
      dispatch(e, i) {
        if (!i.code && !i.ctrl && e != null && this.getItem()) {
          this.append(e, i);
          return;
        }
        this.alert();
      }
      append(e, i) {
        let n = this.getItem(),
          r = n.input.slice(0, this.cursor),
          s = n.input.slice(this.cursor);
        (this.input = n.input = `${r}${e}${s}`), this.moveCursor(1), this.render();
      }
      delete() {
        let e = this.getItem();
        if (this.cursor <= 0 || !e.input) return this.alert();
        let i = e.input.slice(this.cursor),
          n = e.input.slice(0, this.cursor - 1);
        (this.input = e.input = `${n}${i}`), this.moveCursor(-1), this.render();
      }
      increment(e) {
        return e >= this.state.keys.length - 1 ? 0 : e + 1;
      }
      decrement(e) {
        return e <= 0 ? this.state.keys.length - 1 : e - 1;
      }
      first() {
        (this.state.index = 0), this.render();
      }
      last() {
        (this.state.index = this.state.keys.length - 1), this.render();
      }
      right() {
        if (this.cursor >= this.input.length) return this.alert();
        this.moveCursor(1), this.render();
      }
      left() {
        if (this.cursor <= 0) return this.alert();
        this.moveCursor(-1), this.render();
      }
      prev() {
        (this.state.index = this.decrement(this.state.index)), this.getItem(), this.render();
      }
      next() {
        (this.state.index = this.increment(this.state.index)), this.getItem(), this.render();
      }
      up() {
        this.prev();
      }
      down() {
        this.next();
      }
      format(e) {
        let i = this.state.completed < 100 ? this.styles.warning : this.styles.success;
        return (
          this.state.submitted === !0 && this.state.completed !== 100 && (i = this.styles.danger),
          i(`${this.state.completed}% completed`)
        );
      }
      async render() {
        let { index: e, keys: i = [], submitted: n, size: r } = this.state,
          s = [
            this.options.newline,
            `
`,
          ].find((C) => C != null),
          o = await this.prefix(),
          c = await this.separator(),
          u = await this.message(),
          l = [o, u, c].filter(Boolean).join(' ');
        this.state.prompt = l;
        let p = await this.header(),
          d = (await this.error()) || '',
          x = (await this.hint()) || '',
          b = n ? '' : await this.interpolate(this.state),
          g = (this.state.key = i[e] || ''),
          y = await this.format(g),
          h = await this.footer();
        y && (l += ' ' + y), x && !y && this.state.completed === 0 && (l += ' ' + x), this.clear(r);
        let v = [p, l, b, h, d.trim()];
        this.write(v.filter(Boolean).join(s)), this.restore();
      }
      getItem(e) {
        let { items: i, keys: n, index: r } = this.state,
          s = i.find((o) => o.name === n[r]);
        return s && s.input != null && ((this.input = s.input), (this.cursor = s.cursor)), s;
      }
      async submit() {
        typeof this.interpolate != 'function' && (await this.initialize()), await this.interpolate(this.state, !0);
        let { invalid: e, missing: i, output: n, values: r } = this.state;
        if (e.size) {
          let c = '';
          for (let [u, l] of e)
            c += `Invalid ${u}: ${l}
`;
          return (this.state.error = c), super.submit();
        }
        if (i.size) return (this.state.error = 'Required: ' + [...i.keys()].join(', ')), super.submit();
        let o = Sne(n)
          .split(
            `
`
          )
          .map((c) => c.slice(1)).join(`
`);
        return (this.value = { values: r, result: o }), super.submit();
      }
    };
  uq.exports = N_;
});
var fq = P((vxe, pq) => {
  'use strict';
  var Tne = '(Use <shift>+<up/down> to sort)',
    One = Fs(),
    P_ = class extends One {
      constructor(e) {
        super({ ...e, reorder: !1, sort: !0, multiple: !0 }),
          (this.state.hint = [this.options.hint, Tne].find(this.isValue.bind(this)));
      }
      indicator() {
        return '';
      }
      async renderChoice(e, i) {
        let n = await super.renderChoice(e, i),
          r = this.symbols.identicalTo + ' ',
          s = this.index === i && this.sorting ? this.styles.muted(r) : '  ';
        return this.options.drag === !1 && (s = ''), this.options.numbered === !0 ? s + `${i + 1} - ` + n : s + n;
      }
      get selected() {
        return this.choices;
      }
      submit() {
        return (this.value = this.choices.map((e) => e.value)), super.submit();
      }
    };
  pq.exports = P_;
});
var hq = P((wxe, dq) => {
  'use strict';
  var kne = zl(),
    L_ = class extends kne {
      constructor(e = {}) {
        if (
          (super(e),
          (this.emptyError = e.emptyError || 'No items were selected'),
          (this.term = process.env.TERM_PROGRAM),
          !this.options.header)
        ) {
          let i = ['', '4 - Strongly Agree', '3 - Agree', '2 - Neutral', '1 - Disagree', '0 - Strongly Disagree', ''];
          (i = i.map((n) => this.styles.muted(n))),
            (this.state.header = i.join(`
   `));
        }
      }
      async toChoices(...e) {
        if (this.createdScales) return !1;
        this.createdScales = !0;
        let i = await super.toChoices(...e);
        for (let n of i) (n.scale = Ane(5, this.options)), (n.scaleIdx = 2);
        return i;
      }
      dispatch() {
        this.alert();
      }
      space() {
        let e = this.focused,
          i = e.scale[e.scaleIdx],
          n = i.selected;
        return e.scale.forEach((r) => (r.selected = !1)), (i.selected = !n), this.render();
      }
      indicator() {
        return '';
      }
      pointer() {
        return '';
      }
      separator() {
        return this.styles.muted(this.symbols.ellipsis);
      }
      right() {
        let e = this.focused;
        return e.scaleIdx >= e.scale.length - 1 ? this.alert() : (e.scaleIdx++, this.render());
      }
      left() {
        let e = this.focused;
        return e.scaleIdx <= 0 ? this.alert() : (e.scaleIdx--, this.render());
      }
      indent() {
        return '   ';
      }
      async renderChoice(e, i) {
        await this.onChoice(e, i);
        let n = this.index === i,
          r = this.term === 'Hyper',
          s = r ? 9 : 8,
          o = r ? '' : ' ',
          c = this.symbols.line.repeat(s),
          u = ' '.repeat(s + (r ? 0 : 1)),
          l = (_) => (_ ? this.styles.success('\u25C9') : '\u25EF') + o,
          p = i + 1 + '.',
          d = n ? this.styles.heading : this.styles.noop,
          x = await this.resolve(e.message, this.state, e, i),
          b = this.indent(e),
          g = b + e.scale.map((_, m) => l(m === e.scaleIdx)).join(c),
          y = (_) => (_ === e.scaleIdx ? d(_) : _),
          h = b + e.scale.map((_, m) => y(m)).join(u),
          v = () => [p, x].filter(Boolean).join(' '),
          C = () =>
            [v(), g, h, ' '].filter(Boolean).join(`
`);
        return n && ((g = this.styles.cyan(g)), (h = this.styles.cyan(h))), C();
      }
      async renderChoices() {
        if (this.state.submitted) return '';
        let e = this.visible.map(async (n, r) => await this.renderChoice(n, r)),
          i = await Promise.all(e);
        return (
          i.length || i.push(this.styles.danger('No matching choices')),
          i.join(`
`)
        );
      }
      format() {
        return this.state.submitted ? this.choices.map((i) => this.styles.info(i.scaleIdx)).join(', ') : '';
      }
      async render() {
        let { submitted: e, size: i } = this.state,
          n = await this.prefix(),
          r = await this.separator(),
          s = await this.message(),
          o = [n, s, r].filter(Boolean).join(' ');
        this.state.prompt = o;
        let c = await this.header(),
          u = await this.format(),
          l = (await this.error()) || (await this.hint()),
          p = await this.renderChoices(),
          d = await this.footer();
        (u || !l) && (o += ' ' + u),
          l && !o.includes(l) && (o += ' ' + l),
          e && !u && !p && this.multiple && this.type !== 'form' && (o += this.styles.danger(this.emptyError)),
          this.clear(i),
          this.write(
            [o, c, p, d].filter(Boolean).join(`
`)
          ),
          this.restore();
      }
      submit() {
        this.value = {};
        for (let e of this.choices) this.value[e.name] = e.scaleIdx;
        return this.base.submit.call(this);
      }
    };
  function Ane(t, e = {}) {
    if (Array.isArray(e.scale)) return e.scale.map((n) => ({ ...n }));
    let i = [];
    for (let n = 1; n < t + 1; n++) i.push({ i: n, selected: !1 });
    return i;
  }
  dq.exports = L_;
});
var gq = P((Exe, mq) => {
  'use strict';
  mq.exports = E_();
});
var yq = P((_xe, xq) => {
  'use strict';
  var Ine = Sm(),
    D_ = class extends Ine {
      async initialize() {
        await super.initialize(),
          (this.value = this.initial = this.resolve(this.options.initial)),
          (this.disabled = this.options.disabled || 'no'),
          (this.enabled = this.options.enabled || 'yes'),
          await this.render();
      }
      reset() {
        (this.value = this.initial), this.render();
      }
      delete() {
        this.alert();
      }
      toggle() {
        (this.value = !this.value), this.render();
      }
      enable() {
        if (this.value === !0) return this.alert();
        (this.value = !0), this.render();
      }
      disable() {
        if (this.value === !1) return this.alert();
        (this.value = !1), this.render();
      }
      up() {
        this.toggle();
      }
      down() {
        this.toggle();
      }
      right() {
        this.toggle();
      }
      left() {
        this.toggle();
      }
      next() {
        this.toggle();
      }
      prev() {
        this.toggle();
      }
      dispatch(e = '', i) {
        switch (e.toLowerCase()) {
          case ' ':
            return this.toggle();
          case '1':
          case 'y':
          case 't':
            return this.enable();
          case '0':
          case 'n':
          case 'f':
            return this.disable();
          default:
            return this.alert();
        }
      }
      format() {
        let e = (n) => this.styles.primary.underline(n);
        return [this.value ? this.disabled : e(this.disabled), this.value ? e(this.enabled) : this.enabled].join(
          this.styles.muted(' / ')
        );
      }
      async render() {
        let { size: e } = this.state,
          i = await this.header(),
          n = await this.prefix(),
          r = await this.separator(),
          s = await this.message(),
          o = await this.format(),
          c = (await this.error()) || (await this.hint()),
          u = await this.footer(),
          l = [n, s, r, o].join(' ');
        (this.state.prompt = l),
          c && !l.includes(c) && (l += ' ' + c),
          this.clear(e),
          this.write(
            [i, l, u].filter(Boolean).join(`
`)
          ),
          this.write(this.margin[2]),
          this.restore();
      }
    };
  xq.exports = D_;
});
var vq = P((Sxe, bq) => {
  'use strict';
  var Nne = Fs(),
    F_ = class extends Nne {
      constructor(e) {
        if ((super(e), typeof this.options.correctChoice != 'number' || this.options.correctChoice < 0))
          throw new Error('Please specify the index of the correct answer from the list of choices');
      }
      async toChoices(e, i) {
        let n = await super.toChoices(e, i);
        if (n.length < 2) throw new Error('Please give at least two choices to the user');
        if (this.options.correctChoice > n.length)
          throw new Error('Please specify the index of the correct answer from the list of choices');
        return n;
      }
      check(e) {
        return e.index === this.options.correctChoice;
      }
      async result(e) {
        return {
          selectedAnswer: e,
          correctAnswer: this.options.choices[this.options.correctChoice].value,
          correct: await this.check(this.state),
        };
      }
    };
  bq.exports = F_;
});
var Eq = P((j_) => {
  'use strict';
  var wq = hi(),
    Bt = (t, e) => {
      wq.defineExport(j_, t, e), wq.defineExport(j_, t.toLowerCase(), e);
    };
  Bt('AutoComplete', () => OU());
  Bt('BasicAuth', () => DU());
  Bt('Confirm', () => MU());
  Bt('Editable', () => qU());
  Bt('Form', () => _m());
  Bt('Input', () => E_());
  Bt('Invisible', () => WU());
  Bt('List', () => XU());
  Bt('MultiSelect', () => JU());
  Bt('Numeral', () => eq());
  Bt('Password', () => iq());
  Bt('Scale', () => sq());
  Bt('Select', () => Fs());
  Bt('Snippet', () => lq());
  Bt('Sort', () => fq());
  Bt('Survey', () => hq());
  Bt('Text', () => gq());
  Bt('Toggle', () => yq());
  Bt('Quiz', () => vq());
});
var Sq = P((Rxe, _q) => {
  'use strict';
  _q.exports = { ArrayPrompt: zl(), AuthPrompt: g_(), BooleanPrompt: Sm(), NumberPrompt: T_(), StringPrompt: Ho() };
});
var Tq = P((Txe, Rq) => {
  'use strict';
  var Cq = require('assert'),
    U_ = require('events'),
    js = hi(),
    kn = class extends U_ {
      constructor(e, i) {
        super(), (this.options = js.merge({}, e)), (this.answers = { ...i });
      }
      register(e, i) {
        if (js.isObject(e)) {
          for (let r of Object.keys(e)) this.register(r, e[r]);
          return this;
        }
        Cq.equal(typeof i, 'function', 'expected a function');
        let n = e.toLowerCase();
        return (
          i.prototype instanceof this.Prompt ? (this.prompts[n] = i) : (this.prompts[n] = i(this.Prompt, this)), this
        );
      }
      async prompt(e = []) {
        for (let i of [].concat(e))
          try {
            typeof i == 'function' && (i = await i.call(this)), await this.ask(js.merge({}, this.options, i));
          } catch (n) {
            return Promise.reject(n);
          }
        return this.answers;
      }
      async ask(e) {
        typeof e == 'function' && (e = await e.call(this));
        let i = js.merge({}, this.options, e),
          { type: n, name: r } = e,
          { set: s, get: o } = js;
        if ((typeof n == 'function' && (n = await n.call(this, e, this.answers)), !n)) return this.answers[r];
        n === 'number' && (n = 'numeral'), Cq(this.prompts[n], `Prompt "${n}" is not registered`);
        let c = new this.prompts[n](i),
          u = o(this.answers, r);
        (c.state.answers = this.answers),
          (c.enquirer = this),
          r &&
            c.on('submit', (p) => {
              this.emit('answer', r, p, c), s(this.answers, r, p);
            });
        let l = c.emit.bind(c);
        return (
          (c.emit = (...p) => (this.emit.call(this, ...p), l(...p))),
          this.emit('prompt', c, this),
          i.autofill && u != null
            ? ((c.value = c.input = u), i.autofill === 'show' && (await c.submit()))
            : (u = c.value = await c.run()),
          u
        );
      }
      use(e) {
        return e.call(this, this), this;
      }
      set Prompt(e) {
        this._Prompt = e;
      }
      get Prompt() {
        return this._Prompt || this.constructor.Prompt;
      }
      get prompts() {
        return this.constructor.prompts;
      }
      static set Prompt(e) {
        this._Prompt = e;
      }
      static get Prompt() {
        return this._Prompt || kc();
      }
      static get prompts() {
        return Eq();
      }
      static get types() {
        return Sq();
      }
      static get prompt() {
        let e = (i, ...n) => {
          let r = new this(...n),
            s = r.emit.bind(r);
          return (r.emit = (...o) => (e.emit(...o), s(...o))), r.prompt(i);
        };
        return js.mixinEmitter(e, new U_()), e;
      }
    };
  js.mixinEmitter(kn, new U_());
  var M_ = kn.prompts;
  for (let t of Object.keys(M_)) {
    let e = t.toLowerCase(),
      i = (n) => new M_[t](n).run();
    (kn.prompt[e] = i), (kn[e] = i), kn[t] || Reflect.defineProperty(kn, t, { get: () => M_[t] });
  }
  var Vl = (t) => {
    js.defineExport(kn, t, () => kn.types[t]);
  };
  Vl('ArrayPrompt');
  Vl('AuthPrompt');
  Vl('BooleanPrompt');
  Vl('NumberPrompt');
  Vl('StringPrompt');
  Rq.exports = kn;
});
var q_ = {};
Ft(q_, { logout: () => Pne });
async function Pne() {
  let t = new In(),
    e = t.getAllSectionNxCloudUrls();
  e.length === 0
    ? (Rm.note({ title: 'No Nx Cloud instances found to logout from. Exiting as there is nothing to be done.' }),
      process.exit(0))
    : Rm.note({
        title: 'Logging out of Nx Cloud',
        bodyLines: [
          'Your personal access token will be revoked and you will be logged out of Nx Cloud.',
          'You will need to log in again to your workspace to access Nx Cloud.',
        ],
      });
  let i = e.length == 1 ? [...e] : [...e, Oq],
    n = await kq.prompt({
      type: 'select',
      name: 'nxCloudUrl',
      message: 'Select the Nx Cloud instance to logout from',
      choices: i,
      initial: 0,
    }),
    r = n.nxCloudUrl === Oq ? e : [n.nxCloudUrl],
    s = [];
  r.forEach((o) => {
    let c = t.getPersonalAccessTokenFromNxCloudUrl(o);
    c && s.push({ personalAccessToken: c, nxCloudUrl: o });
  }),
    s && (await Lne(s), s.forEach((o) => t.deletePersonalAccessTokenFromNxCloudUrl(o.nxCloudUrl)));
}
async function Lne(t) {
  try {
    let e = null;
    for (let i of t) {
      let n = { personalAccessToken: i.personalAccessToken };
      e = await xm.post(`${i.nxCloudUrl}/nx-cloud/logout`, n);
    }
    e &&
      e.status === 200 &&
      Rm.success({
        title: 'Successfully logged out of Nx Cloud',
        bodyLines: [
          'Revoked access tokens and logged out from the following Nx Cloud instances:',
          ...t.map((i) => `- ${i.nxCloudUrl}`),
        ],
      });
  } catch {
    Rm.error({
      title: 'Encountered an error while logging out of Nx Cloud',
      bodyLines: ['You can still revoke the access token manually from your profile settings.'],
    });
  }
}
var kq,
  Rm,
  Oq,
  B_ = te(() => {
    'use strict';
    UM();
    kq = je(Tq());
    Mc();
    ({ output: Rm } = Ae()), (Oq = 'Logout from all Nx Cloud instances');
  });
var H_ = {};
Ft(H_, { cleanup: () => Fne });
async function Fne() {
  Dne.note({ title: 'Cleaning up temporary files created by Nx Cloud.' }),
    (0, Tm.existsSync)(il) && (0, Tm.unlinkSync)(il);
}
var Tm,
  Dne,
  G_ = te(() => {
    'use strict';
    Tm = require('fs');
    Cd();
    ({ output: Dne } = Ae());
  });
var Aq = {};
Ft(Aq, { validate: () => Mne });
async function Mne() {
  let { stepFile: t, workflowFile: e, runner: i } = jne;
  e || (Om.error({ title: 'missing --workflow-file argument' }), Yn.exit(1));
  let n = i ?? Yn.env.NX_TASKS_RUNNER ?? Yn.env.NX_RUNNER ?? 'default',
    { nxCloudOptions: r } = vt(n),
    s = Qt(),
    o = zt(r);
  try {
    let l = (
      await tt(() =>
        o.post('/nx-cloud/workflows/validate', { workflowFile: e, stepFile: t ?? !1, commitSha: s ?? 'HEAD' })
      )
    ).data.filter((p) => p.errors.length > 0);
    l.length > 0
      ? (Om.error({
          title: t ? 'Workflow Launch Template Step is invalid' : 'Workflow Launch Template is invalid',
          bodyLines: l.map((p) =>
            p.launchTemplateName
              ? `${p.launchTemplateName}:
	${p.errors.join(`
	`)}`.trim()
              : p.errors.join(`
`)
          ),
        }),
        Yn.exit(1))
      : (Om.success({ title: t ? 'Workflow Launch Template Step is valid' : 'Workflow Launch Template is valid' }),
        Yn.exit(0));
  } catch (c) {
    Om.error({ title: c.message, bodyLines: c.bodyLines ?? [] }), Yn.exit(1);
  }
}
var Yn,
  Om,
  jne,
  Iq = te(() => {
    'use strict';
    Yn = je(require('process'));
    pl();
    mn();
    Le();
    $i();
    ({ output: Om } = Ae()), (jne = vs(Yn.argv, { boolean: ['step-file'], string: ['workflow-file', 'runner'] }));
  });
exports.nxCloudTasksRunner = (...t) => (WP(), Ke($P)).default(...t);
exports.getRemoteCache = () => (zb(), Ke(rN)).default;
exports.configureLightClientRequire = () => (Pc(), Ke(gS)).configureLightClientRequire;
var Une = {
  'clean-up-agents': () => (u0(), Ke(c0)).cleanUpAgents(),
  record: () => (p0(), Ke(l0)).runCommandAndStoreInCloud(),
  'start-agent': () =>
    process.env.NX_CLOUD_DTE_V1 === 'true' ? ($w(), Ke(Vw)).startAgent() : (A2(), Ke(k2)).startAgent(),
  'start-ci-run': () => (Yw(), Ke(Xw)).startCiRun(),
  'stop-all-agents': () => ($h(), Ke(Vh)).stopAllAgents(),
  'complete-ci-run': () => ($h(), Ke(Vh)).stopAllAgents(),
  'upload-and-show-run-details': () => (oE(), Ke(sE)).uploadAndShowRunDetails(),
  login: async () => await (uE(), Ke(cE)).login(),
  configure: () => (pE(), Ke(lE)).configure(),
  'convert-to-nx-cloud-id': async () => await (hE(), Ke(dE)).convertToNxCloudId(),
  logout: async () => await (B_(), Ke(q_)).logout(),
  cleanup: () => (G_(), Ke(H_)).cleanup(),
  validate: () => (Iq(), Ke(Aq)).validate(),
};
exports.commands = Une;
exports.cleanUpAgents = () => (u0(), Ke(c0)).cleanUpAgents();
exports.runCommandAndStoreInCloud = () => (p0(), Ke(l0)).runCommandAndStoreInCloud();
exports.startAgent = () => ($w(), Ke(Vw)).startAgent();
exports.startCiRun = () => (Yw(), Ke(Xw)).startCiRun();
exports.stopAllAgents = () => ($h(), Ke(Vh)).stopAllAgents();
exports.uploadAndShowRunDetails = () => (oE(), Ke(sE)).uploadAndShowRunDetails();
exports.cleanup = () => (G_(), Ke(H_)).cleanup();
exports.login = () => (uE(), Ke(cE)).login();
exports.logout = () => (B_(), Ke(q_)).logout();
exports.configure = () => (pE(), Ke(lE)).configure();
exports.convertToNxCloudId = () => (hE(), Ke(dE)).convertToNxCloudId();
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

yargs-parser/build/lib/string-utils.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/tokenize-arg-string.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/yargs-parser-types.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/yargs-parser.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/index.js:
  (**
   * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
   * CJS and ESM environments.
   *
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)
*/
